<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Research Feed -- 20 September 2025</title>
    
    <!-- Favicon and Apple Touch Icons -->
    <link rel="icon" type="image/png" href="/favicon.png">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <link rel="apple-touch-icon-precomposed" href="/apple-touch-icon-precomposed.png">
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;700&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- KaTeX CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous">
    
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Custom Tailwind Configuration -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        'heading': ['Space Grotesk', 'Inter', 'system-ui', 'sans-serif'],
                        'body': ['Space Mono', 'Fira Code', 'Consolas', 'monospace'],
                    },
                    
                    fontSize: {
                            // 4px increments with responsive scaling
                            'xs': 'clamp(0.5rem, 1vw, 0.625rem)',     // 8-10px
                            'sm': 'clamp(0.625rem, 1.2vw, 0.75rem)',  // 10-12px
                            'md': 'clamp(0.75rem, 1.4vw, 0.875rem)',  // 12-14px
                            'lg': 'clamp(0.875rem, 1.6vw, 1rem)',     // 14-16px
                            'xl': 'clamp(1rem, 1.8vw, 1.125rem)',     // 16-18px
                            '2xl': 'clamp(1.125rem, 2vw, 1.25rem)',   // 18-20px
                            '3xl': 'clamp(1.25rem, 2.2vw, 1.375rem)', // 20-22px
                            '4xl': 'clamp(1.375rem, 2.4vw, 1.5rem)',  // 22-24px
                            '5xl': 'clamp(1.5rem, 2.6vw, 1.625rem)',  // 24-26px
                            '6xl': 'clamp(1.625rem, 2.8vw, 1.75rem)', // 26-28px
                            '7xl': 'clamp(1.75rem, 3vw, 1.875rem)',   // 28-30px
                            '8xl': 'clamp(1.875rem, 3.2vw, 2rem)',    // 30-32px
                            '9xl': 'clamp(2rem, 3.4vw, 2.125rem)',    // 32-34px
                        },

                    colors: {
                        neutral: {
                            10: '#f5f2e7',
                            20: '#e5e5e5',
                            40: '#a3a3a3',
                            60: '#525252',
                            70: '#404040',
                            90: '#171717',
                            100: '#f5f2e7',
                            200: '#dad7cd',
                            300: '#bebcb3',
                            400: '#a2a199',
                            500: '#86857f',
                            600: '#6b6a65',
                            700: '#4f4e4b',
                            900: '#171717',
                        },
                        // Status colors with 70% opacity
                        status: {
                            green: 'rgba(22, 104, 52, 0.7)',     // #166834 with 70% opacity
                            blue: 'rgba(40, 100, 156, 0.7)',     // #28649C with 70% opacity
                            orange: 'rgba(234, 147, 0, 0.7)',    // #EA9300 with 70% opacity
                            red: 'rgba(129, 12, 12, 0.7)',       // #810C0C with 70% opacity
                        },
                        bar: {
                            raw: 'rgba(107, 106, 101, 0.7)',       // #6B6A65 with 70% opacity
                            normalized: 'rgba(107, 106, 101, 0.7)' // #6B6A65 with 70% opacity
                        }
                    },
                    
                    spacing: {
                        '2xs': 'clamp(0.125rem, 0.5vw, 0.25rem)', // 2-4px
                        'xs': 'clamp(0.25rem, 1vw, 0.5rem)',    // 4-8px
                        'sm': 'clamp(0.5rem, 1.5vw, 0.75rem)',  // 8-12px
                        'md': 'clamp(0.75rem, 2vw, 1rem)',      // 12-16px
                        'lg': 'clamp(1rem, 2.5vw, 1.5rem)',     // 16-24px
                        'xl': 'clamp(1.5rem, 3vw, 2rem)',       // 24-32px
                        '2xl': 'clamp(2rem, 4vw, 3rem)',        // 32-48px
                        '3xl': 'clamp(3rem, 6vw, 4rem)',        // 48-64px
                        '4xl': 'clamp(4rem, 8vw, 5rem)',        // 64-80px
                        '5xl': 'clamp(5rem, 10vw, 6rem)',       // 80-96px
                        '6xl': 'clamp(6rem, 12vw, 7rem)',       // 96-112px
                        
                        // Mobile-specific spacing
                        'mobile-header': '5px',                  // 5px for mobile header padding
                        
                        // Card-specific spacing
                        'card-gap': '20px',                      // 20px gap for card info grid
                        
                        // Tag-specific spacing
                        'tag-x': '8px',                          // 8px horizontal padding for tags
                        'tag-y': '4px',                          // 4px vertical padding for tags
                    },
                    
                    screens: {
                        'mobile': '480px',
                        'tablet': '768px',
                        'desktop': '1024px',
                        'wide': '1440px',
                    },
                }
            }
        }
    </script>
    
    <!-- Custom CSS for additional styles -->
    <style>
        /* Focus states */
        .nav-button:focus-visible {
            outline: 2px solid #86857f;
            outline-offset: 2px;
        }
        
        .pagination-square:focus-visible {
            outline: 2px solid #86857f;
            outline-offset: 2px;
        }
        
        .pagination-arrow:focus-visible {
            outline: 2px solid #86857f;
            outline-offset: 2px;
        }
        
        .pagination-arrow {
            transition: background-color 0.2s ease, opacity 0.2s ease;
        }
        
        .pagination-arrow.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .pagination-arrow.disabled:hover {
            background-color: transparent;
        }
        
        /* Fix for multiline text padding in author and category spans */
        .metadata-tag {
            box-decoration-break: clone;
            -webkit-box-decoration-break: clone;
        }
        
        /* Sidebar styling */
        #mobile-sidebar {
            backdrop-filter: blur(4px);
            /* Move scrollbar to left side */
            direction: rtl;
        }
        
        #mobile-sidebar > div {
            /* Reset text direction inside sidebar */
            direction: ltr;
        }
        
        #desktop-sidebar {
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            /* Move scrollbar to left side */
            direction: rtl;
        }
        
        #desktop-sidebar > div {
            /* Reset text direction inside sidebar */
            direction: ltr;
        }
        
        /* Mobile main container transition */
        #mobile-main-container {
            transition: transform 300ms ease-in-out;
        }
        
        /* Prevent scrolling when any sidebar is open */
        body.no-scroll {
            overflow: hidden;
        }
        
        /* Dropdown positioning */
        .dropdown-up {
            bottom: 100% !important;
            top: auto !important;
        }
        
        .dropdown-down {
            top: 100% !important;
            bottom: auto !important;
        }
        
        /* Mobile active states */
        @media (hover: none) {
            /* Remove button animation */
        }
        
        /* Font fallbacks */
        .font-mono {
            font-family: 'Space Mono', 'Fira Code', 'Consolas', monospace;
        }
        
        /* Paper title link styling */
        .paper-title-link {
            color: inherit;
            text-decoration: none;
            transition: text-decoration 0.2s ease;
        }
        
        .paper-title-link:hover {
            text-decoration: underline;
        }
        
        /* Abstract text styling */
        .abstract-text {
            transition: all 0.3s ease-in-out;
        }

        /* KaTeX styling customization */
        .katex {
            font-size: 1em !important;
            line-height: inherit !important;
        }
        
        /* Inline math styling */
        .katex-display {
            margin: 0.5em 0 !important;
            text-align: left !important;
        }
        
        /* Make KaTeX blend with our color scheme */
        .katex .base {
            color: inherit;
        }
        
        /* Ensure KaTeX math doesn't break responsive design */
        .katex-display > .katex {
            max-width: 100%;
            overflow-x: auto;
            overflow-y: hidden;
        }
        
        /* Prevent double tap to zoom on mobile - Global */
        * {
            touch-action: manipulation;
        }
        
        /* Prevent double tap to zoom on mobile - Specific elements (keeping for compatibility) */
        .button, .interactive-element {
            touch-action: manipulation;
        }
        
        /* Research Feed button hover effect */
        .research-feed-button:hover {
            background-color: #4f4e4b !important; /* bg-neutral-700 */
            color: #f5f2e7 !important; /* text-neutral-10 */
        }
        
        /* Custom checkbox styling */
        .custom-checkbox {
            position: relative;
            display: inline-flex;
            align-items: center;
        }
        
        .custom-checkbox input[type="checkbox"] {
            opacity: 0;
            position: absolute;
            width: 0;
            height: 0;
        }
        
        .custom-checkbox label {
            display: inline-block;
            width: 20px;
            height: 20px;
            background-color: #86857f; /* bg-neutral-500 */
            border: 2px solid #f5f2e7; /* border-neutral-100 */
            border-radius: 4px; /* rounded corners */
            cursor: pointer;
            transition: background-color 0.2s ease, border-color 0.2s ease;
            flex-shrink: 0;
        }
        
        .custom-checkbox input[type="checkbox"]:checked + label {
            background-color: #f5f2e7; /* bg-neutral-100 */
            border-color: #f5f2e7;
        }
        
        .custom-checkbox input[type="checkbox"]:checked + label::after {
            content: '';
            position: absolute;
            left: 6px;
            top: 2px;
            width: 6px;
            height: 10px;
            border: solid #86857f;
            border-width: 0 2px 2px 0;
            transform: rotate(45deg);
        }
        
        /* H-Index range section styling */
        .hindex-range-section {
            transition: opacity 0.2s ease;
        }
        
        .hindex-range-section.disabled {
            opacity: 0.5;
        }
        
        .hindex-range-section.disabled input {
            cursor: not-allowed !important;
        }
        
        .hindex-range-section.disabled input:hover {
            background-color: #6b6a65 !important; /* Keep original bg when disabled */
        }
        
        /* Override any Tailwind hover effects on disabled inputs */
        .hindex-range-section.disabled input.bg-neutral-600:hover {
            background-color: #6b6a65 !important;
        }
        
        /* Advanced filter dropdowns disabled state */
        .opacity-50 {
            opacity: 0.5 !important;
        }
        
        .cursor-not-allowed {
            cursor: not-allowed !important;
        }
    </style>
</head>

<body class="bg-neutral-100 min-h-screen">
    <!-- Mobile Layout (visible < 768px) -->
    <div class="flex flex-col tablet:hidden" id="mobile-main-container">
        <!-- Mobile Header -->
        <header class="bg-neutral-100 w-full flex items-center px-xs pt-xl pb-md relative">
            <!-- Menu Button - Positioned absolutely within header -->
            <button id="mobile-menu-btn" class="absolute top-1/4 left-xs transform -translate-y-1/2 z-10 nav-button w-12 h-12 bg-transparent flex items-center justify-center button" aria-label="Open Menu" onclick="toggleMobileMenu()">
                <svg width="24" height="18" viewBox="0 0 24 18" xmlns="http://www.w3.org/2000/svg">
                    <rect x="0" y="0" width="24" height="5" fill="#4F4E4B"/>
                    <rect x="0" y="6.5" width="24" height="5" fill="#4F4E4B"/>
                    <rect x="0" y="13" width="24" height="5" fill="#4F4E4B"/>
                </svg>
            </button>
            
            <!-- Center: Page info (full width since menu button is positioned absolutely) -->
            <div class="w-full flex flex-col items-center justify-center text-center">
                <h1 class="text-neutral-70 font-heading font-bold text-lg mb-md" id="page-title-mobile">
                    Papers Published on 20 September 2025
                </h1>
                
                <!-- Mobile Pagination -->
                <div class="flex items-center gap-sm mb-md">
                    <!-- Previous Arrow -->
                    <button id="mobile-prev-btn" class="pagination-arrow w-8 h-8 bg-transparent text-neutral-70 flex items-center justify-center hover:bg-neutral-300 cursor-pointer" onclick="goToPage(currentPage - 1)">
                        <span class="font-heading font-bold text-sm">‹</span>
                    </button>
                    
                    <!-- Page Numbers Container -->
                    <div class="flex gap-sm" id="mobile-pagination-numbers">
                        <!-- Page numbers will be populated by JavaScript -->
                    </div>
                    
                    <!-- Next Arrow -->
                    <button id="mobile-next-btn" class="pagination-arrow w-8 h-8 bg-transparent text-neutral-70 flex items-center justify-center hover:bg-neutral-300 cursor-pointer" onclick="goToPage(currentPage + 1)">
                        <span class="font-heading font-bold text-sm">›</span>
                    </button>
                </div>
                
                <!-- Mobile Paper Count -->
                <p id="mobile-main-paper-count" class="text-neutral-60 font-heading font-bold text-lg">
                    Showing 0 / 0 papers
                </p>
            </div>
        </header>
        
        <!-- Mobile Content Area -->
        <main class="bg-neutral-100 min-h-screen">
            <div class="max-w-[500px] mx-auto">
                <!-- Mobile Papers Grid -->
                <div class="flex flex-col gap-3xl" id="mobile-papers">
                    <!-- Paper cards will be populated by JavaScript -->
                </div>
            </div>
        </main>
        
        <!-- Mobile Footer -->
        <footer class="py-xl px-lg bg-neutral-200">
            <div class="flex flex-col items-center justify-center text-center">
                <!-- Mobile Footer Pagination -->
                <div class="flex items-center gap-sm">
                    <!-- Previous Arrow -->
                    <button id="mobile-footer-prev-btn" class="pagination-arrow w-8 h-8 bg-transparent text-neutral-70 flex items-center justify-center hover:bg-neutral-300 cursor-pointer" onclick="goToPage(currentPage - 1)">
                        <span class="font-heading font-bold text-sm">‹</span>
                    </button>
                    
                    <!-- Page Numbers Container -->
                    <div class="flex gap-sm" id="mobile-footer-pagination-numbers">
                        <!-- Page numbers will be populated by JavaScript -->
                    </div>
                    
                    <!-- Next Arrow -->
                    <button id="mobile-footer-next-btn" class="pagination-arrow w-8 h-8 bg-transparent text-neutral-70 flex items-center justify-center hover:bg-neutral-300 cursor-pointer" onclick="goToPage(currentPage + 1)">
                        <span class="font-heading font-bold text-sm">›</span>
                    </button>
                </div>
            </div>
        </footer>
    </div>
    
    <!-- Mobile Sidebar -->
    <div id="mobile-sidebar" class="fixed inset-y-0 left-0 z-50 tablet:hidden bg-neutral-100 transition-transform duration-300 ease-in-out overflow-y-auto" style="width: 100vw; transform: translateX(-100%);">
        <div class="w-full h-full flex flex-col">
            <!-- Mobile Sidebar Header -->
            <div class="flex items-center justify-between pt-lg pr-lg pb-sm pl-lg">
                <!-- Left: Research Feed Home Button -->
                <div>
                    <a href="index.html" class="research-feed-button text-center px-tag-x py-sm bg-neutral-600 transition-colors duration-200">
                        <span class="text-neutral-10 font-heading font-bold text-2xl">Research Feed</span>
                    </a>
                </div>
                
                <!-- Right: Menu Button -->
                <button id="mobile-close-btn" class="nav-button w-12 h-12 bg-transparent flex items-center justify-center button" aria-label="Close Menu" onclick="closeMobileMenu()">
                    <svg width="24" height="18" viewBox="0 0 24 18" xmlns="http://www.w3.org/2000/svg">
                        <rect x="0" y="0" width="24" height="5" fill="#4F4E4B"/>
                        <rect x="0" y="6.5" width="24" height="5" fill="#4F4E4B"/>
                        <rect x="0" y="13" width="24" height="5" fill="#4F4E4B"/>
                    </svg>
                </button>
            </div>
            
            <!-- Mobile Sidebar Content -->
            <div class="flex-1 pt-sm px-lg pb-6xl">
                <div class="flex flex-col gap-lg gap-lg">
                    <!-- Section 1: Paper Count -->
                    <div class="bg-transparent text-left">
                        <span class="text-neutral-70 font-heading font-bold text-2xl" id="mobile-paper-count">
                            Showing: 0/0 Papers
                        </span>
                    </div>
                    
                    <!-- Section 2: Quick Filters -->
                    <div class="flex flex-col gap-sm">
                        <h3 class="text-neutral-60 font-heading font-bold text-2xl text-left bg-transparent">Quick Filters</h3>
                        <button id="mobile-quick-must-read" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('must-read')">Must Read</button>
                        <button id="mobile-quick-should-read" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('should-read')">Should Read</button>
                        <button id="mobile-quick-rlhf" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('rlhf')">RLHF</button>
                        <button id="mobile-quick-weak-supervision" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('weak-supervision')">Weak Supervision</button>
                        <button id="mobile-quick-diffusion-reasoning" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('diffusion-reasoning')">Diffusion Reasoning</button>
                        <button id="mobile-quick-distributed-training" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('distributed-training')">Distributed Training</button>
                        <button id="mobile-quick-datasets" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('datasets')">Datasets</button>
                        <button id="mobile-quick-reset" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('reset')">Reset To Default</button>
                    </div>
                    
                    <!-- Section 3: Advanced Filters -->
                    <div class="flex flex-col gap-sm">
                        <h3 class="text-neutral-60 font-heading font-bold text-2xl text-left bg-transparent">Advanced Filters</h3>
                        <!-- Scoring Filter Dropdown -->
                        <div class="relative">
                            <button id="mobile-scoring-btn" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleMobileScoringDropdown()">
                                <span class="font-bold">Scoring:</span> <span class="font-normal">All Selected</span> <span class="text-base">▼</span>
                            </button>
                            <div id="mobile-scoring-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-md">
                                    <!-- Section 1: Has Scoring and Summary Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-scoring-has" checked>
                                            <label for="mobile-scoring-has"></label>
                                        </div>
                                        <label for="mobile-scoring-has" class="text-neutral-10 text-xl font-heading cursor-pointer">Completed</label>
                                    </div>
                                    
                                    <!-- Section 2: Does not have Scoring and Summary Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-scoring-no" checked>
                                            <label for="mobile-scoring-no"></label>
                                        </div>
                                        <label for="mobile-scoring-no" class="text-neutral-10 text-xl font-heading cursor-pointer">Not relevant enough</label>
                                    </div>
                                    
                                    <!-- Section 3: Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyScoringFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        <!-- Recommendation Filter Dropdown -->
                        <div class="relative">
                            <button id="mobile-recommendation-btn" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleMobileRecommendationDropdown()">
                                <span class="font-bold">Recommendation:</span> <span class="font-normal">All Selected</span> <span class="text-base">▼</span>
                            </button>
                            <div id="mobile-recommendation-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-md">
                                    <!-- Must Read Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-recommendation-must" checked>
                                            <label for="mobile-recommendation-must"></label>
                                        </div>
                                        <label for="mobile-recommendation-must" class="text-neutral-10 text-xl font-heading cursor-pointer">Must Read</label>
                                    </div>
                                    
                                    <!-- Should Read Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-recommendation-should" checked>
                                            <label for="mobile-recommendation-should"></label>
                                        </div>
                                        <label for="mobile-recommendation-should" class="text-neutral-10 text-xl font-heading cursor-pointer">Should Read</label>
                                    </div>
                                    
                                    <!-- Can Skip Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-recommendation-skip" checked>
                                            <label for="mobile-recommendation-skip"></label>
                                        </div>
                                        <label for="mobile-recommendation-skip" class="text-neutral-10 text-xl font-heading cursor-pointer">Can Skip</label>
                                    </div>
                                    
                                    <!-- Ignore Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-recommendation-ignore" checked>
                                            <label for="mobile-recommendation-ignore"></label>
                                        </div>
                                        <label for="mobile-recommendation-ignore" class="text-neutral-10 text-xl font-heading cursor-pointer">Ignore</label>
                                    </div>
                                    
                                    <!-- Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyRecommendationFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        <!-- Novelty Filter Dropdown -->
                        <div class="relative">
                            <button id="mobile-novelty-btn" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleMobileNoveltyDropdown()">
                                <span class="font-bold">Novelty:</span> <span class="font-normal">All Selected</span> <span class="text-base">▼</span>
                            </button>
                            <div id="mobile-novelty-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-md">
                                    <!-- High Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-novelty-high" checked>
                                            <label for="mobile-novelty-high"></label>
                                        </div>
                                        <label for="mobile-novelty-high" class="text-neutral-10 text-xl font-heading cursor-pointer">High</label>
                                    </div>
                                    
                                    <!-- Moderate Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-novelty-moderate" checked>
                                            <label for="mobile-novelty-moderate"></label>
                                        </div>
                                        <label for="mobile-novelty-moderate" class="text-neutral-10 text-xl font-heading cursor-pointer">Moderate</label>
                                    </div>
                                    
                                    <!-- Low Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-novelty-low" checked>
                                            <label for="mobile-novelty-low"></label>
                                        </div>
                                        <label for="mobile-novelty-low" class="text-neutral-10 text-xl font-heading cursor-pointer">Low</label>
                                    </div>
                                    
                                    <!-- None Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-novelty-none" checked>
                                            <label for="mobile-novelty-none"></label>
                                        </div>
                                        <label for="mobile-novelty-none" class="text-neutral-10 text-xl font-heading cursor-pointer">None</label>
                                    </div>
                                    
                                    <!-- Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyNoveltyFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        <!-- Potential Impact Filter Dropdown -->
                        <div class="relative">
                            <button id="mobile-impact-btn" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleMobileImpactDropdown()">
                                <span class="font-bold">Potential Impact:</span> <span class="font-normal">All Selected</span> <span class="text-base">▼</span>
                            </button>
                            <div id="mobile-impact-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-md">
                                    <!-- High Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-impact-high" checked>
                                            <label for="mobile-impact-high"></label>
                                        </div>
                                        <label for="mobile-impact-high" class="text-neutral-10 text-xl font-heading cursor-pointer">High</label>
                                    </div>
                                    
                                    <!-- Moderate Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-impact-moderate" checked>
                                            <label for="mobile-impact-moderate"></label>
                                        </div>
                                        <label for="mobile-impact-moderate" class="text-neutral-10 text-xl font-heading cursor-pointer">Moderate</label>
                                    </div>
                                    
                                    <!-- Low Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-impact-low" checked>
                                            <label for="mobile-impact-low"></label>
                                        </div>
                                        <label for="mobile-impact-low" class="text-neutral-10 text-lg font-heading cursor-pointer">Low</label>
                                    </div>
                                    
                                    <!-- Negligible Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-impact-negligible" checked>
                                            <label for="mobile-impact-negligible"></label>
                                        </div>
                                        <label for="mobile-impact-negligible" class="text-neutral-10 text-xl font-heading cursor-pointer">Negligible</label>
                                    </div>
                                    
                                    <!-- Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyImpactFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        <!-- Relevance Filter Dropdown -->
                        <div class="relative">
                            <button id="mobile-relevance-btn" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleMobileRelevanceDropdown()">
                                <span class="font-bold">Relevance:</span> <span class="font-normal">All Selected</span> <span class="text-base">▼</span>
                            </button>
                            <div id="mobile-relevance-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-md">
                                    <!-- Highly Relevant Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-relevance-highly" checked>
                                            <label for="mobile-relevance-highly"></label>
                                        </div>
                                        <label for="mobile-relevance-highly" class="text-neutral-10 text-xl font-heading cursor-pointer">Highly Relevant</label>
                                    </div>
                                    
                                    <!-- Moderately Relevant Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-relevance-moderately" checked>
                                            <label for="mobile-relevance-moderately"></label>
                                        </div>
                                        <label for="mobile-relevance-moderately" class="text-neutral-10 text-xl font-heading cursor-pointer">Moderately Relevant</label>
                                    </div>
                                    
                                    <!-- Tangentially Relevant Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-relevance-tangentially" checked>
                                            <label for="mobile-relevance-tangentially"></label>
                                        </div>
                                        <label for="mobile-relevance-tangentially" class="text-neutral-10 text-xl font-heading cursor-pointer">Tangentially Relevant</label>
                                    </div>
                                    
                                    <!-- Not Relevant Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-relevance-not" checked>
                                            <label for="mobile-relevance-not"></label>
                                        </div>
                                        <label for="mobile-relevance-not" class="text-neutral-10 text-xl font-heading cursor-pointer">Not Relevant</label>
                                    </div>
                                    
                                    <!-- Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyRelevanceFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Topic Filter Dropdown -->
                        <div class="relative">
                            <button id="mobile-topic-btn" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleMobileTopicDropdown()">
                                <span class="font-bold">Topics:</span> <span class="font-normal">All Selected</span> <span class="text-base">▼</span>
                            </button>
                            <div id="mobile-topic-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-md">
                                    <!-- RLHF Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-topic-rlhf" checked>
                                            <label for="mobile-topic-rlhf"></label>
                                        </div>
                                        <label for="mobile-topic-rlhf" class="text-neutral-10 text-xl font-heading cursor-pointer">RLHF</label>
                                    </div>
                                    
                                    <!-- Weak Supervision Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-topic-weak-supervision" checked>
                                            <label for="mobile-topic-weak-supervision"></label>
                                        </div>
                                        <label for="mobile-topic-weak-supervision" class="text-neutral-10 text-xl font-heading cursor-pointer">Weak Supervision</label>
                                    </div>
                                    
                                    <!-- Diffusion Reasoning Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-topic-diffusion-reasoning" checked>
                                            <label for="mobile-topic-diffusion-reasoning"></label>
                                        </div>
                                        <label for="mobile-topic-diffusion-reasoning" class="text-neutral-10 text-xl font-heading cursor-pointer">Diffusion Reasoning</label>
                                    </div>
                                    
                                    <!-- Distributed Training Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-topic-distributed-training" checked>
                                            <label for="mobile-topic-distributed-training"></label>
                                        </div>
                                        <label for="mobile-topic-distributed-training" class="text-neutral-10 text-xl font-heading cursor-pointer">Distributed Training</label>
                                    </div>
                                    
                                    <!-- Datasets Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-topic-datasets" checked>
                                            <label for="mobile-topic-datasets"></label>
                                        </div>
                                        <label for="mobile-topic-datasets" class="text-neutral-10 text-xl font-heading cursor-pointer">Datasets</label>
                                    </div>
                                    
                                    <!-- Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyTopicFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- H-Index Filter Dropdown -->
                        <div class="relative">
                            <button id="mobile-hindex-btn" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleMobileHIndexDropdown()">
                                H-index: All Selected <span class="text-lg">▼</span>
                            </button>
                            <div id="mobile-hindex-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-lg">
                                    <!-- Section 1: H-Index Found Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-hindex-found" checked onchange="toggleHIndexRanges()">
                                            <label for="mobile-hindex-found"></label>
                                        </div>
                                        <label for="mobile-hindex-found" class="text-neutral-10 text-xl font-heading cursor-pointer">H-Index Found</label>
                                    </div>
                                    
                                    <!-- Section 2: H-Index Not Found Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-hindex-not-found" checked>
                                            <label for="mobile-hindex-not-found"></label>
                                        </div>
                                        <label for="mobile-hindex-not-found" class="text-neutral-10 text-xl font-heading cursor-pointer">H-Index Not Found</label>
                                    </div>
                                    
                                    <!-- Section 3: Highest H-Index Range -->
                                    <div id="mobile-highest-range" class="hindex-range-section">
                                        <div class="text-neutral-10 text-lg font-heading mb-2xs">Highest H-Index Range:</div>
                                        <div class="flex items-center gap-xs">
                                            <span class="text-neutral-10 text-lg font-heading">Min:</span>
                                            <input type="number" id="mobile-highest-min" min="0" max="1000" value="0" class="bg-neutral-600 text-neutral-10 px-2xs py-2xs text-lg font-heading w-16 rounded">
                                            <span class="text-neutral-10 text-lg font-heading">-</span>
                                            <span class="text-neutral-10 text-lg font-heading">Max:</span>
                                            <input type="number" id="mobile-highest-max" min="0" max="1000" value="1000" class="bg-neutral-600 text-neutral-10 px-2xs py-2xs text-lg font-heading w-16 rounded">
                                        </div>
                                    </div>
                                    
                                    <!-- Section 4: Average H-Index Range -->
                                    <div id="mobile-average-range" class="hindex-range-section">
                                        <div class="text-neutral-10 text-lg font-heading mb-2xs">Average H-Index Range:</div>
                                        <div class="flex items-center gap-xs">
                                            <span class="text-neutral-10 text-lg font-heading">Min:</span>
                                            <input type="number" id="mobile-average-min" min="0" max="1000" value="0" class="bg-neutral-600 text-neutral-10 px-2xs py-2xs text-lg font-heading w-16 rounded">
                                            <span class="text-neutral-10 text-lg font-heading">-</span>
                                            <span class="text-neutral-10 text-lg font-heading">Max:</span>
                                            <input type="number" id="mobile-average-max" min="0" max="1000" value="1000" class="bg-neutral-600 text-neutral-10 px-2xs py-2xs text-lg font-heading w-16 rounded">
                                        </div>
                                    </div>
                                    
                                    <!-- Section 5: Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyHIndexFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Sort By Dropdown -->
                        <div class="relative">
                            <button id="mobile-sort-btn" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleMobileSortDropdown()">
                                <span class="font-bold">Sort By:</span> <span id="mobile-sort-text" class="font-normal">Recommendation (Best First)</span> <span class="text-base">▼</span>
                            </button>
                            <div id="mobile-sort-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 py-xs">
                                <div class="flex flex-col gap-xs">
                                    <button class="w-full py-tag-y font-heading text-xl text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('recommend_best')">Recommendation (Best First)</button>
                                    <button class="w-full py-tag-y font-heading text-xl text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('recommend_worst')">Recommendation (Worst First)</button>
                                    <button class="w-full py-tag-y font-heading text-xl text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('relevance_high')">Relevance (Highest to Lowest)</button>
                                    <button class="w-full py-tag-y font-heading text-xl text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('relevance_low')">Relevance (Lowest to Highest)</button>
                                    <button class="w-full py-tag-y font-heading text-xl text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('highest_hindex_asc')">Highest H-Index (Ascending)</button>
                                    <button class="w-full py-tag-y font-heading text-xl text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('highest_hindex_desc')">Highest H-Index (Descending)</button>
                                    <button class="w-full py-tag-y font-heading text-xl text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('average_hindex_asc')">Average H-Index (Ascending)</button>
                                    <button class="w-full py-tag-y font-heading text-xl text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('average_hindex_desc')">Average H-Index (Descending)</button>
                                    <button class="w-full py-tag-y font-heading text-xl text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('id_asc')">arXiv ID (Ascending)</button>
                                    <button class="w-full py-tag-y font-heading text-xl text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('id_desc')">arXiv ID (Descending)</button>
                                    <button class="w-full py-tag-y font-heading text-xl text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('title_az')">Title (A-Z)</button>
                                    <button class="w-full py-tag-y font-heading text-xl text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('title_za')">Title (Z-A)</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Desktop Sidebar Overlay -->
    <div id="desktop-sidebar-overlay" class="hidden tablet:block fixed inset-0 bg-black bg-opacity-50 z-30 opacity-0 pointer-events-none transition-opacity duration-300 ease-in-out" onclick="closeDesktopMenu()"></div>
    
    <!-- Desktop Sidebar -->
    <div id="desktop-sidebar" class="hidden tablet:block fixed inset-y-0 left-0 z-40 bg-neutral-200 transition-transform duration-300 ease-in-out overflow-y-auto" style="width: 500px; transform: translateX(-100%);">
        <div class="w-full h-full flex flex-col">
            <!-- Desktop Sidebar Header -->
            <div class="flex items-center justify-between pt-lg pr-lg pb-sm pl-lg">
                <!-- Left: Research Feed Home Button -->
                <div>
                    <a href="index.html" class="research-feed-button text-center px-tag-x py-sm bg-neutral-600 transition-colors duration-200">
                        <span class="text-neutral-10 font-heading font-bold text-2xl">Research Feed</span>
                    </a>
                </div>
                
                <!-- Right: Menu Button -->
                <button id="desktop-close-btn" class="nav-button bg-transparent flex items-center justify-center button" 
                        style="width: clamp(3rem, 6vw, 3.125rem); height: clamp(3rem, 6vw, 3.125rem);" 
                        aria-label="Close Menu" onclick="closeDesktopMenu()">
                    <svg width="24" height="18" viewBox="0 0 24 18" xmlns="http://www.w3.org/2000/svg">
                        <rect x="0" y="0" width="24" height="5" fill="#4F4E4B"/>
                        <rect x="0" y="6.5" width="24" height="5" fill="#4F4E4B"/>
                        <rect x="0" y="13" width="24" height="5" fill="#4F4E4B"/>
                    </svg>
                </button>
            </div>
            
            <!-- Desktop Sidebar Content -->
            <div class="flex-1 px-lg pt-lg pb-6xl">
                <div class="flex flex-col gap-lg">
                    <!-- Section 1: Paper Count -->
                    <div class="bg-transparent">
                        <span class="text-neutral-70 font-heading text-xl font-bold" id="desktop-paper-count">
                            Showing: 0/0 Papers
                        </span>
                    </div>
                    
                    <!-- Section 2: Quick Filters -->
                    <div class="flex flex-col gap-xs">
                        <h3 class="text-neutral-60 font-heading font-bold text-2xl text-left bg-transparent">Quick Filters</h3>
                        <button id="desktop-quick-must-read" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('must-read')">Must Read</button>
                        <button id="desktop-quick-should-read" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('should-read')">Should Read</button>
                        <button id="desktop-quick-rlhf" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('rlhf')">RLHF</button>
                        <button id="desktop-quick-weak-supervision" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('weak-supervision')">Weak Supervision</button>
                        <button id="desktop-quick-diffusion-reasoning" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('diffusion-reasoning')">Diffusion Reasoning</button>
                        <button id="desktop-quick-distributed-training" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('distributed-training')">Distributed Training</button>
                        <button id="desktop-quick-datasets" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('datasets')">Datasets</button>
                        <button id="desktop-quick-reset" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('reset')">Reset To Default</button>
                    </div>
                    
                    <!-- Section 3: Advanced Filters -->
                    <div class="flex flex-col gap-xs">
                        <h3 class="text-neutral-60 font-heading font-bold text-2xl text-left bg-transparent">Advanced Filters</h3>
                        <!-- Scoring Filter Dropdown -->
                        <div class="relative">
                            <button id="desktop-scoring-btn" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleDesktopScoringDropdown()">
                                <span class="font-bold">Scoring:</span> <span class="font-normal">All Selected</span> <span class="text-sm">▼</span>
                            </button>
                            <div id="desktop-scoring-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-xs">
                                    <!-- Section 1: Has Scoring and Summary Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-scoring-has" checked>
                                            <label for="desktop-scoring-has"></label>
                                        </div>
                                        <label for="desktop-scoring-has" class="text-neutral-10 text-lg font-heading cursor-pointer">Completed</label>
                                    </div>
                                    
                                    <!-- Section 2: Does not have Scoring and Summary Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-scoring-no" checked>
                                            <label for="desktop-scoring-no"></label>
                                        </div>
                                        <label for="desktop-scoring-no" class="text-neutral-10 text-lg font-heading cursor-pointer">Not relevant enough</label>
                                    </div>
                                    
                                    <!-- Section 3: Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyScoringFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        <!-- Recommendation Filter Dropdown -->
                        <div class="relative">
                            <button id="desktop-recommendation-btn" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleDesktopRecommendationDropdown()">
                                <span class="font-bold">Recommendation:</span> <span class="font-normal">All Selected</span> <span class="text-sm">▼</span>
                            </button>
                            <div id="desktop-recommendation-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-xs">
                                    <!-- Must Read Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-recommendation-must" checked>
                                            <label for="desktop-recommendation-must"></label>
                                        </div>
                                        <label for="desktop-recommendation-must" class="text-neutral-10 text-lg font-heading cursor-pointer">Must Read</label>
                                    </div>
                                    
                                    <!-- Should Read Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-recommendation-should" checked>
                                            <label for="desktop-recommendation-should"></label>
                                        </div>
                                        <label for="desktop-recommendation-should" class="text-neutral-10 text-lg font-heading cursor-pointer">Should Read</label>
                                    </div>
                                    
                                    <!-- Can Skip Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-recommendation-skip" checked>
                                            <label for="desktop-recommendation-skip"></label>
                                        </div>
                                        <label for="desktop-recommendation-skip" class="text-neutral-10 text-lg font-heading cursor-pointer">Can Skip</label>
                                    </div>
                                    
                                    <!-- Ignore Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-recommendation-ignore" checked>
                                            <label for="desktop-recommendation-ignore"></label>
                                        </div>
                                        <label for="desktop-recommendation-ignore" class="text-neutral-10 text-lg font-heading cursor-pointer">Ignore</label>
                                    </div>
                                    
                                    <!-- Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyRecommendationFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        <!-- Novelty Filter Dropdown -->
                        <div class="relative">
                            <button id="desktop-novelty-btn" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleDesktopNoveltyDropdown()">
                                <span class="font-bold">Novelty:</span> <span class="font-normal">All Selected</span> <span class="text-sm">▼</span>
                            </button>
                            <div id="desktop-novelty-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-xs">
                                    <!-- High Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-novelty-high" checked>
                                            <label for="desktop-novelty-high"></label>
                                        </div>
                                        <label for="desktop-novelty-high" class="text-neutral-10 text-lg font-heading cursor-pointer">High</label>
                                    </div>
                                    
                                    <!-- Moderate Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-novelty-moderate" checked>
                                            <label for="desktop-novelty-moderate"></label>
                                        </div>
                                        <label for="desktop-novelty-moderate" class="text-neutral-10 text-lg font-heading cursor-pointer">Moderate</label>
                                    </div>
                                    
                                    <!-- Low Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-novelty-low" checked>
                                            <label for="desktop-novelty-low"></label>
                                        </div>
                                        <label for="desktop-novelty-low" class="text-neutral-10 text-lg font-heading cursor-pointer">Low</label>
                                    </div>
                                    
                                    <!-- None Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-novelty-none" checked>
                                            <label for="desktop-novelty-none"></label>
                                        </div>
                                        <label for="desktop-novelty-none" class="text-neutral-10 text-lg font-heading cursor-pointer">None</label>
                                    </div>
                                    
                                    <!-- Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyNoveltyFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        <!-- Potential Impact Filter Dropdown -->
                        <div class="relative">
                            <button id="desktop-impact-btn" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleDesktopImpactDropdown()">
                                <span class="font-bold">Potential Impact:</span> <span class="font-normal">All Selected</span> <span class="text-sm">▼</span>
                            </button>
                            <div id="desktop-impact-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-xs">
                                    <!-- High Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-impact-high" checked>
                                            <label for="desktop-impact-high"></label>
                                        </div>
                                        <label for="desktop-impact-high" class="text-neutral-10 text-lg font-heading cursor-pointer">High</label>
                                    </div>
                                    
                                    <!-- Moderate Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-impact-moderate" checked>
                                            <label for="desktop-impact-moderate"></label>
                                        </div>
                                        <label for="desktop-impact-moderate" class="text-neutral-10 text-lg font-heading cursor-pointer">Moderate</label>
                                    </div>
                                    
                                    <!-- Low Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-impact-low" checked>
                                            <label for="desktop-impact-low"></label>
                                        </div>
                                        <label for="desktop-impact-low" class="text-neutral-10 text-lg font-heading cursor-pointer">Low</label>
                                    </div>
                                    
                                    <!-- Negligible Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-impact-negligible" checked>
                                            <label for="desktop-impact-negligible"></label>
                                        </div>
                                        <label for="desktop-impact-negligible" class="text-neutral-10 text-lg font-heading cursor-pointer">Negligible</label>
                                    </div>
                                    
                                    <!-- Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyImpactFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        <!-- Relevance Filter Dropdown -->
                        <div class="relative">
                            <button id="desktop-relevance-btn" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleDesktopRelevanceDropdown()">
                                <span class="font-bold">Relevance:</span> <span class="font-normal">All Selected</span> <span class="text-sm">▼</span>
                            </button>
                            <div id="desktop-relevance-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-xs">
                                    <!-- Highly Relevant Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-relevance-highly" checked>
                                            <label for="desktop-relevance-highly"></label>
                                        </div>
                                        <label for="desktop-relevance-highly" class="text-neutral-10 text-lg font-heading cursor-pointer">Highly Relevant</label>
                                    </div>
                                    
                                    <!-- Moderately Relevant Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-relevance-moderately" checked>
                                            <label for="desktop-relevance-moderately"></label>
                                        </div>
                                        <label for="desktop-relevance-moderately" class="text-neutral-10 text-lg font-heading cursor-pointer">Moderately Relevant</label>
                                    </div>
                                    
                                    <!-- Tangentially Relevant Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-relevance-tangentially" checked>
                                            <label for="desktop-relevance-tangentially"></label>
                                        </div>
                                        <label for="desktop-relevance-tangentially" class="text-neutral-10 text-lg font-heading cursor-pointer">Tangentially Relevant</label>
                                    </div>
                                    
                                    <!-- Not Relevant Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-relevance-not" checked>
                                            <label for="desktop-relevance-not"></label>
                                        </div>
                                        <label for="desktop-relevance-not" class="text-neutral-10 text-lg font-heading cursor-pointer">Not Relevant</label>
                                    </div>
                                    
                                    <!-- Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyRelevanceFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Topic Filter Dropdown -->
                        <div class="relative">
                            <button id="desktop-topic-btn" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleDesktopTopicDropdown()">
                                <span class="font-bold">Topics:</span> <span class="font-normal">All Selected</span> <span class="text-sm">▼</span>
                            </button>
                            <div id="desktop-topic-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-xs">
                                    <!-- RLHF Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-topic-rlhf" checked>
                                            <label for="desktop-topic-rlhf"></label>
                                        </div>
                                        <label for="desktop-topic-rlhf" class="text-neutral-10 text-lg font-heading cursor-pointer">RLHF</label>
                                    </div>
                                    
                                    <!-- Weak Supervision Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-topic-weak-supervision" checked>
                                            <label for="desktop-topic-weak-supervision"></label>
                                        </div>
                                        <label for="desktop-topic-weak-supervision" class="text-neutral-10 text-lg font-heading cursor-pointer">Weak Supervision</label>
                                    </div>
                                    
                                    <!-- Diffusion Reasoning Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-topic-diffusion-reasoning" checked>
                                            <label for="desktop-topic-diffusion-reasoning"></label>
                                        </div>
                                        <label for="desktop-topic-diffusion-reasoning" class="text-neutral-10 text-lg font-heading cursor-pointer">Diffusion Reasoning</label>
                                    </div>
                                    
                                    <!-- Distributed Training Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-topic-distributed-training" checked>
                                            <label for="desktop-topic-distributed-training"></label>
                                        </div>
                                        <label for="desktop-topic-distributed-training" class="text-neutral-10 text-lg font-heading cursor-pointer">Distributed Training</label>
                                    </div>
                                    
                                    <!-- Datasets Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-topic-datasets" checked>
                                            <label for="desktop-topic-datasets"></label>
                                        </div>
                                        <label for="desktop-topic-datasets" class="text-neutral-10 text-lg font-heading cursor-pointer">Datasets</label>
                                    </div>
                                    
                                    <!-- Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyTopicFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- H-Index Filter Dropdown -->
                        <div class="relative">
                            <button id="desktop-hindex-btn" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleDesktopHIndexDropdown()">
                                H-index: All Selected <span class="text-md">▼</span>
                            </button>
                            <div id="desktop-hindex-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-lg">
                                    <!-- Section 1: H-Index Found Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-hindex-found" checked onchange="toggleHIndexRanges()">
                                            <label for="desktop-hindex-found"></label>
                                        </div>
                                        <label for="desktop-hindex-found" class="text-neutral-10 text-lg font-heading cursor-pointer">H-Index Found</label>
                                    </div>
                                    
                                    <!-- Section 2: H-Index Not Found Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-hindex-not-found" checked>
                                            <label for="desktop-hindex-not-found"></label>
                                        </div>
                                        <label for="desktop-hindex-not-found" class="text-neutral-10 text-lg font-heading cursor-pointer">H-Index Not Found</label>
                                    </div>
                                    
                                    <!-- Section 3: Highest H-Index Range -->
                                    <div id="desktop-highest-range" class="hindex-range-section">
                                        <div class="text-neutral-10 text-lg font-heading mb-2xs">Highest H-Index Range:</div>
                                        <div class="flex items-center gap-xs">
                                            <span class="text-neutral-10 text-lg font-heading">Min:</span>
                                            <input type="number" id="desktop-highest-min" min="0" max="1000" value="0" class="bg-neutral-600 text-neutral-10 px-2xs py-2xs text-lg font-heading w-16 rounded">
                                            <span class="text-neutral-10 text-lg font-heading">-</span>
                                            <span class="text-neutral-10 text-lg font-heading">Max:</span>
                                            <input type="number" id="desktop-highest-max" min="0" max="1000" value="1000" class="bg-neutral-600 text-neutral-10 px-2xs py-2xs text-lg font-heading w-16 rounded">
                                        </div>
                                    </div>
                                    
                                    <!-- Section 4: Average H-Index Range -->
                                    <div id="desktop-average-range" class="hindex-range-section">
                                        <div class="text-neutral-10 text-lg font-heading mb-2xs">Average H-Index Range:</div>
                                        <div class="flex items-center gap-xs">
                                            <span class="text-neutral-10 text-lg font-heading">Min:</span>
                                            <input type="number" id="desktop-average-min" min="0" max="1000" value="0" class="bg-neutral-600 text-neutral-10 px-2xs py-2xs text-lg font-heading w-16 rounded">
                                            <span class="text-neutral-10 text-lg font-heading">-</span>
                                            <span class="text-neutral-10 text-lg font-heading">Max:</span>
                                            <input type="number" id="desktop-average-max" min="0" max="1000" value="1000" class="bg-neutral-600 text-neutral-10 px-2xs py-2xs text-lg font-heading w-16 rounded">
                                        </div>
                                    </div>
                                    
                                    <!-- Section 5: Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyHIndexFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Sort By Dropdown -->
                        <div class="relative">
                            <button id="desktop-sort-btn" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleDesktopSortDropdown()">
                                <span class="font-bold">Sort By:</span> <span id="desktop-sort-text" class="font-normal">Recommendation (Best First)</span> <span class="text-sm">▼</span>
                            </button>
                            <div id="desktop-sort-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50">
                                <div class="flex flex-col gap-xs">
                                    <button class="w-full py-tag-y font-heading text-lg text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('recommend_best')">Recommendation (Best First)</button>
                                    <button class="w-full py-tag-y font-heading text-lg text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('recommend_worst')">Recommendation (Worst First)</button>
                                    <button class="w-full py-tag-y font-heading text-lg text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('relevance_high')">Relevance (Highest to Lowest)</button>
                                    <button class="w-full py-tag-y font-heading text-lg text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('relevance_low')">Relevance (Lowest to Highest)</button>
                                    <button class="w-full py-tag-y font-heading text-lg text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('highest_hindex_asc')">Highest H-Index (Ascending)</button>
                                    <button class="w-full py-tag-y font-heading text-lg text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('highest_hindex_desc')">Highest H-Index (Descending)</button>
                                    <button class="w-full py-tag-y font-heading text-lg text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('average_hindex_asc')">Average H-Index (Ascending)</button>
                                    <button class="w-full py-tag-y font-heading text-lg text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('average_hindex_desc')">Average H-Index (Descending)</button>
                                    <button class="w-full py-tag-y font-heading text-lg text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('id_asc')">arXiv ID (Ascending)</button>
                                    <button class="w-full py-tag-y font-heading text-lg text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('id_desc')">arXiv ID (Descending)</button>
                                    <button class="w-full py-tag-y font-heading text-lg text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('title_az')">Title (A-Z)</button>
                                    <button class="w-full py-tag-y font-heading text-lg text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('title_za')">Title (Z-A)</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Desktop Layout (visible ≥ 768px) -->
    <div class="hidden tablet:block">
        <!-- Desktop Header -->
        <header class="bg-neutral-200 w-full flex items-center px-lg pt-xl pb-md relative">
            <!-- Menu Button - Positioned absolutely within header -->
            <button id="desktop-menu-btn" class="absolute top-1/2 left-lg transform -translate-y-1/2 z-10 nav-button bg-transparent flex items-center justify-center button" 
                    style="width: clamp(3rem, 6vw, 3.125rem); height: clamp(3rem, 6vw, 3.125rem);" 
                    aria-label="Open Menu" onclick="toggleDesktopMenu()">
                <svg width="24" height="18" viewBox="0 0 24 18" xmlns="http://www.w3.org/2000/svg">
                    <rect x="0" y="0" width="24" height="5" fill="#4F4E4B"/>
                    <rect x="0" y="6.5" width="24" height="5" fill="#4F4E4B"/>
                    <rect x="0" y="13" width="24" height="5" fill="#4F4E4B"/>
                </svg>
            </button>
            
            <!-- Center: Page info (full width since menu button is positioned absolutely) -->
            <div class="w-full flex flex-col items-center justify-center text-center">
                <h1 class="text-neutral-70 font-heading font-bold text-4xl mb-md" id="page-title-desktop">
                    Papers Published on 20 September 2025
                </h1>
                
                <!-- Desktop Pagination -->
                <div class="flex items-center mb-md" style="gap: clamp(0.5rem, 1vw, 0.75rem);">
                    <!-- Previous Arrow -->
                    <button id="desktop-prev-btn" class="pagination-arrow bg-transparent text-neutral-70 flex items-center justify-center hover:bg-neutral-300 cursor-pointer" 
                            style="width: clamp(1.5rem, 3vw, 1.875rem); height: clamp(1.5rem, 3vw, 1.875rem);" onclick="goToPage(currentPage - 1)">
                        <span class="font-heading font-bold text-md">‹</span>
                    </button>
                    
                    <!-- Page Numbers Container -->
                    <div class="flex" style="gap: clamp(0.5rem, 1vw, 0.75rem);" id="desktop-pagination-numbers">
                        <!-- Page numbers will be populated by JavaScript -->
                    </div>
                    
                    <!-- Next Arrow -->
                    <button id="desktop-next-btn" class="pagination-arrow bg-transparent text-neutral-70 flex items-center justify-center hover:bg-neutral-300 cursor-pointer" 
                            style="width: clamp(1.5rem, 3vw, 1.875rem); height: clamp(1.5rem, 3vw, 1.875rem);" onclick="goToPage(currentPage + 1)">
                        <span class="font-heading font-bold text-md">›</span>
                    </button>
                </div>
                
                <!-- Desktop Paper Count -->
                <p id="desktop-main-paper-count" class="text-neutral-60 font-heading font-bold text-xl">
                    Showing 0 / 0 papers
                </p>
            </div>
        </header>
        
        <!-- Desktop Content Area -->
        <main class="px-xl py-2xl min-h-screen">
            <div class="max-w-[1400px] mx-auto">
                <!-- Desktop Papers Grid -->
                <div class="flex flex-col gap-3xl" id="desktop-papers">
                    <!-- Paper cards will be populated by JavaScript -->
                </div>
            </div>
        </main>
        
        <!-- Desktop Footer -->
        <footer class="py-xl bg-neutral-200">
            <div class="flex flex-col items-center justify-center text-center">
                <!-- Desktop Footer Pagination -->
                <div class="flex items-center" style="gap: clamp(0.5rem, 1vw, 0.75rem);">
                    <!-- Previous Arrow -->
                    <button id="desktop-footer-prev-btn" class="pagination-arrow bg-transparent text-neutral-70 flex items-center justify-center hover:bg-neutral-300 cursor-pointer" 
                            style="width: clamp(1.5rem, 3vw, 1.875rem); height: clamp(1.5rem, 3vw, 1.875rem);" onclick="goToPage(currentPage - 1)">
                        <span class="font-heading font-bold text-md">‹</span>
                    </button>
                    
                    <!-- Page Numbers Container -->
                    <div class="flex" style="gap: clamp(0.5rem, 1vw, 0.75rem);" id="desktop-footer-pagination-numbers">
                        <!-- Page numbers will be populated by JavaScript -->
                    </div>
                    
                    <!-- Next Arrow -->
                    <button id="desktop-footer-next-btn" class="pagination-arrow bg-transparent text-neutral-70 flex items-center justify-center hover:bg-neutral-300 cursor-pointer" 
                            style="width: clamp(1.5rem, 3vw, 1.875rem); height: clamp(1.5rem, 3vw, 1.875rem);" onclick="goToPage(currentPage + 1)">
                        <span class="font-heading font-bold text-md">›</span>
                    </button>
                </div>
            </div>
        </footer>
    </div>

    <!-- Embedded Paper Data - This will be populated by the builder script -->
    <script>
        // This JSON structure will be injected by the builder script
        // Expected structure:
        // {
        //   "papers": [
        //     {
        //       "id": "2407.xxxxx",
        //       "title": "Paper title with possible LaTeX: $\\alpha$ notation",
        //       "authors": ["Author 1", "Author 2"],
        //       "categories": ["cs.LG", "cs.AI"],
        //       "abstract": "Abstract text with possible LaTeX notation",
        //       "published_date": "2025-07-15",
        //       "arxiv_url": "https://arxiv.org/abs/2407.xxxxx",
        //       "pdf_url": "https://arxiv.org/pdf/2407.xxxxx.pdf",
        //       "summary": "AI generated summary",
        //       "recommendation_score": "Must Read",
        //       "recommendation_justification": "Justification text",
        //       "novelty_score": "High",
        //       "novelty_justification": "Novelty justification",
        //       "impact_score": "High", 
        //       "impact_justification": "Impact justification",
        //       "rlhf_score": 0.85,
        //       "weak_supervision_score": 0.72,
        //       "diffusion_reasoning_score": 0.15,
        //       "distributed_training_score": 0.05,
        //       "datasets_score": 0.92,
        //       "rlhf_relevance": "Highly Relevant",
        //       "weak_supervision_relevance": "Moderately Relevant", 
        //       "diffusion_reasoning_relevance": "Not Relevant",
        //       "distributed_training_relevance": "Not Relevant",
        //       "datasets_relevance": "Highly Relevant",
        //       "rlhf_justification": "Relevance justification text",
        //       "weak_supervision_justification": "Relevance justification text",
        //       "diffusion_reasoning_justification": "below_threshold",
        //       "distributed_training_justification": "below_threshold", 
        //       "datasets_justification": "Relevance justification text",
        //       "h_index_status": "completed",
        //       "semantic_scholar_url": "https://www.semanticscholar.org/...",
        //       "total_authors": 3,
        //       "authors_found": 2,
        //       "highest_h_index": 45,
        //       "average_h_index": 28.5,
        //       "notable_authors_count": 2,
        //       "author_h_indexes": [
        //         {"name": "Author 1", "h_index": 45, "profile_url": "https://..."},
        //         {"name": "Author 2", "h_index": 12, "profile_url": "https://..."}
        //       ],
        //       "llm_score_status": "completed" // or "not_relevant_enough"
        //     }
        //   ],
        //   "total_papers": 25,
        //   "date": "2025-07-15"
        // }
        const PAPER_DATA = {
  "papers": [
    {
      "id": "2509.16474",
      "title": "Cross-Corpus and Cross-domain Handwriting Assessment of\n  NeuroDegenerative Diseases via Time-Series-to-Image Conversion",
      "authors": [
        "Gabrielle Chavez",
        "Laureano Moro-Velazquez",
        "Ankur Butala",
        "Najim Dehak",
        "Thomas Thebaud"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Handwriting is significantly affected by neurological disorders (ND) such as\nParkinson's disease (PD) and Alzheimer's disease (AD). Prior works have\nanalyzed handwriting tasks using feature-based approaches or computer-vision\ntechniques, but these methods have struggled to generalize across multiple\ndatasets, particularly between temporal features represented as time-series and\nimages. We propose a framework that leverages both time-series and images of\nhandwriting through a joint classifier, based on a ResNet50 pretrained on\nImageNet-1k. Binary classification experiments demonstrate state-of-the-art\nperformances on existing time-series and image datasets, with significant\nimprovement on specific drawing and writing tasks from the NeuroLogical Signals\n(NLS) dataset. In particular, the proposed model demonstrates improved\nperformance on Draw Clock and Spiral tasks. Additionally, cross-dataset and\nmulti-dataset experiments were consistently able to achieve high F1 scores, up\nto 98 for PD detection, highlighting the potential of the proposed model to\ngeneralize over different forms of handwriting signals, and enhance the\ndetection of motor deficits in ND.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16474v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16474v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.309,
      "weak_supervision_score": 0.323,
      "diffusion_reasoning_score": 0.377,
      "distributed_training_score": 0.349,
      "datasets_score": 0.374,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16476",
      "title": "Eye Gaze Tells You Where to Compute: Gaze-Driven Efficient VLMs",
      "authors": [
        "Qinyu Chen",
        "Jiawen Qi"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Vision-Language Models (VLMs) deliver impressive performance in understanding\nvisual content with language instructions. However, redundancy in vision tokens\nresults in the degenerated inference efficiency of VLMs, which hinders\nreal-time use on edge consumer devices such as AR/VR devices. Existing\nefficiency methods commonly prune visual tokens using learned saliency, sparse\nattention schedules, or controller policies, but they often require\narchitectural modification or access to intermediate activations. These\npipelines add inference-time modules that increase compute and memory and often\nlead to an accuracy trade-off. Moreover, they also suffer from misalignment\nbetween the prompts and the region of interest in the images. Without human\nguidance, the model may focus on the wrong regions and miss small,\nhigh-frequency details when prompts or scenes change. In this paper, we propose\nGazeVLM, a training-free framework that uses the human eye gaze as a natural\nsupervisory signal to allocate computation where it matters. By extracting\ngaze-driven regions of interest (ROIs) and optionally combining them with a\nlow-resolution global view, GazeVLM mimics fovea-periphery perception to cut\nredundant visual tokens while preserving task-relevant details. We evaluate the\nvisual question answering tasks on Qwen2.5-VL-3B/7B on the VOILA-COCO benchmark\nwith human gaze. Quality of the answer is assessed by GPT-4o pairwise judging\nand a weighted score over coverage, accuracy, details, and fluency. Efficiency\nis measured by token counts and FLOPs. GazeVLM reduces visual tokens by up to\n93.1%, total tokens by up to 59.6%, and FLOPs by 50%, while keeping better\nanswer quality relative to full-resolution baselines. Our results show that\naligning model computation with human gaze offers a simple, plug-and-play path\ntoward efficient VLM inference on consumer devices.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16476v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16476v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.396,
      "weak_supervision_score": 0.356,
      "diffusion_reasoning_score": 0.41,
      "distributed_training_score": 0.381,
      "datasets_score": 0.3,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper's main contribution is a gaze-driven framework for efficient Vision-Language Models (VLMs), focusing on reducing visual tokens using human eye gaze to optimize computation on edge devices. It does not involve diffusion models, iterative refinement processes, or multi-step logical reasoning for complex tasks. There is no mention of adapting diffusion techniques for reasoning, making the paper unrelated to this topic.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16479",
      "title": "Thermal Imaging-based Real-time Fall Detection using Motion Flow and\n  Attention-enhanced Convolutional Recurrent Architecture",
      "authors": [
        "Christopher Silver",
        "Thangarajah Akilan"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Falls among seniors are a major public health issue. Existing solutions using\nwearable sensors, ambient sensors, and RGB-based vision systems face challenges\nin reliability, user compliance, and practicality. Studies indicate that\nstakeholders, such as older adults and eldercare facilities, prefer\nnon-wearable, passive, privacy-preserving, and real-time fall detection systems\nthat require no user interaction. This study proposes an advanced thermal fall\ndetection method using a Bidirectional Convolutional Long Short-Term Memory\n(BiConvLSTM) model, enhanced with spatial, temporal, feature, self, and general\nattention mechanisms. Through systematic experimentation across hundreds of\nmodel variations exploring the integration of attention mechanisms, recurrent\nmodules, and motion flow, we identified top-performing architectures. Among\nthem, BiConvLSTM achieved state-of-the-art performance with a ROC-AUC of\n$99.7\\%$ on the TSF dataset and demonstrated robust results on TF-66, a newly\nemerged, diverse, and privacy-preserving benchmark. These results highlight the\ngeneralizability and practicality of the proposed model, setting new standards\nfor thermal fall detection and paving the way toward deployable,\nhigh-performance solutions.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16479v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16479v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.348,
      "weak_supervision_score": 0.325,
      "diffusion_reasoning_score": 0.373,
      "distributed_training_score": 0.328,
      "datasets_score": 0.365,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16483",
      "title": "Octree Latent Diffusion for Semantic 3D Scene Generation and Completion",
      "authors": [
        "Xujia Zhang",
        "Brendan Crowe",
        "Christoffer Heckman"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "The completion, extension, and generation of 3D semantic scenes are an\ninterrelated set of capabilities that are useful for robotic navigation and\nexploration. Existing approaches seek to decouple these problems and solve them\noneoff. Additionally, these approaches are often domain-specific, requiring\nseparate models for different data distributions, e.g. indoor vs. outdoor\nscenes. To unify these techniques and provide cross-domain compatibility, we\ndevelop a single framework that can perform scene completion, extension, and\ngeneration in both indoor and outdoor scenes, which we term Octree Latent\nSemantic Diffusion. Our approach operates directly on an efficient dual octree\ngraph latent representation: a hierarchical, sparse, and memory-efficient\noccupancy structure. This technique disentangles synthesis into two stages: (i)\nstructure diffusion, which predicts binary split signals to construct a coarse\noccupancy octree, and (ii) latent semantic diffusion, which generates semantic\nembeddings decoded by a graph VAE into voxellevel semantic labels. To perform\nsemantic scene completion or extension, our model leverages inference-time\nlatent inpainting, or outpainting respectively. These inference-time methods\nuse partial LiDAR scans or maps to condition generation, without the need for\nretraining or finetuning. We demonstrate highquality structure, coherent\nsemantics, and robust completion from single LiDAR scans, as well as zero-shot\ngeneralization to out-of-distribution LiDAR data. These results indicate that\ncompletion-through-generation in a dual octree graph latent space is a\npractical and scalable alternative to regression-based pipelines for real-world\nrobotic perception tasks.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16483v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16483v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.306,
      "weak_supervision_score": 0.339,
      "diffusion_reasoning_score": 0.542,
      "distributed_training_score": 0.339,
      "datasets_score": 0.335,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on using diffusion models for 3D scene generation, completion, and extension, specifically through structure and semantic diffusion on octree representations. While it involves iterative refinement, it does not adapt diffusion for complex logical tasks, multi-step reasoning, or treating a 'Chain-of-Thought' as an entity. Thus, it lacks the core elements of diffusion-based reasoning as defined.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16487",
      "title": "The Oracle Has Spoken: A Multi-Aspect Evaluation of Dialogue in Pythia",
      "authors": [
        "Zixun Chen",
        "Petr Babkin",
        "Akshat Gupta",
        "Gopala Anumanchipalli",
        "Xiaomo Liu"
      ],
      "categories": [
        "cs.CL (Computation and Language)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Dialogue is one of the landmark abilities of large language models (LLMs).\nDespite its ubiquity, few studies actually distinguish specific ingredients\nunderpinning dialogue behavior emerging during post-training. We employ a\ncomprehensive suite of model-based metrics, each targeting a distinct\nfine-grained aspect of dialogue, motivated by linguistic theory. We evaluate\nhow the performance of pre-trained Pythia models changes with respect to each\nof those dimensions, depending on model size and as a result of supervised\nfine-tuning on conversational datasets. We observe only a mild impact of raw\nmodel size on most metrics, whereas fine-tuning quickly saturates the scores\nfor all but the smallest models tested. Somewhat contrary to our expectations,\nmany metrics show very similar trends, especially if they are all rooted in the\nsame evaluator model, which raises the question of their reliability in\nmeasuring a specific dimension. To that end, we conduct additional analyses of\nscore distributions, metric correlations, and term frequencies in generated\nresponses to help explain our observations.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16487v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16487v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.4,
      "weak_supervision_score": 0.335,
      "diffusion_reasoning_score": 0.402,
      "distributed_training_score": 0.349,
      "datasets_score": 0.359,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Tangentially Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper discusses supervised fine-tuning on human-annotated conversational datasets to align models with user preferences, which indirectly relates to human feedback in AI alignment. However, it does not involve training a reward model or using reinforcement learning, as required for RLHF, making it only tangentially relevant.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on evaluating dialogue abilities in LLMs through fine-tuning and metrics, with no mention of diffusion models, iterative refinement processes, or multi-step logical reasoning as described in the topic.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16494",
      "title": "Can an Individual Manipulate the Collective Decisions of Multi-Agents?",
      "authors": [
        "Fengyuan Liu",
        "Rui Zhao",
        "Shuo Chen",
        "Guohao Li",
        "Philip Torr",
        "Lei Han",
        "Jindong Gu"
      ],
      "categories": [
        "cs.CL (Computation and Language)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Individual Large Language Models (LLMs) have demonstrated significant\ncapabilities across various domains, such as healthcare and law. Recent studies\nalso show that coordinated multi-agent systems exhibit enhanced decision-making\nand reasoning abilities through collaboration. However, due to the\nvulnerabilities of individual LLMs and the difficulty of accessing all agents\nin a multi-agent system, a key question arises: If attackers only know one\nagent, could they still generate adversarial samples capable of misleading the\ncollective decision? To explore this question, we formulate it as a game with\nincomplete information, where attackers know only one target agent and lack\nknowledge of the other agents in the system. With this formulation, we propose\nM-Spoiler, a framework that simulates agent interactions within a multi-agent\nsystem to generate adversarial samples. These samples are then used to\nmanipulate the target agent in the target system, misleading the system's\ncollaborative decision-making process. More specifically, M-Spoiler introduces\na stubborn agent that actively aids in optimizing adversarial samples by\nsimulating potential stubborn responses from agents in the target system. This\nenhances the effectiveness of the generated adversarial samples in misleading\nthe system. Through extensive experiments across various tasks, our findings\nconfirm the risks posed by the knowledge of an individual agent in multi-agent\nsystems and demonstrate the effectiveness of our framework. We also explore\nseveral defense mechanisms, showing that our proposed attack framework remains\nmore potent than baselines, underscoring the need for further research into\ndefensive strategies.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16494v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16494v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.418,
      "weak_supervision_score": 0.398,
      "diffusion_reasoning_score": 0.404,
      "distributed_training_score": 0.367,
      "datasets_score": 0.306,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper focuses on adversarial attacks in multi-agent systems using LLMs, specifically generating samples to manipulate collective decisions. It does not involve reinforcement learning, human feedback, reward models, or any alignment of AI models with human preferences, which are core to RLHF.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper addresses simulating agent interactions and generating adversarial samples in multi-agent systems, but it does not incorporate diffusion models, iterative refinement processes, or multi-step logical reasoning as defined. There is no mention of treating Chain-of-Thought as a single entity for holistic correction.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16496",
      "title": "Synergies between Federated Foundation Models and Smart Power Grids",
      "authors": [
        "Seyyedali Hosseinalipour",
        "Shimiao Li",
        "Adedoyin Inaolaji",
        "Filippo Malandra",
        "Luis Herrera",
        "Nicholas Mastronarde"
      ],
      "categories": [
        "eess.SY (Systems and Control)",
        "cs.AI (Artificial Intelligence)",
        "cs.LG (Machine Learning)",
        "cs.SY (Systems and Control)"
      ],
      "abstract": "The recent emergence of large language models (LLMs) such as GPT-3 has marked\na significant paradigm shift in machine learning. Trained on massive corpora of\ndata, these models demonstrate remarkable capabilities in language\nunderstanding, generation, summarization, and reasoning, transforming how\nintelligent systems process and interact with human language. Although LLMs may\nstill seem like a recent breakthrough, the field is already witnessing the rise\nof a new and more general category: multi-modal, multi-task foundation models\n(M3T FMs). These models go beyond language and can process heterogeneous data\ntypes/modalities, such as time-series measurements, audio, imagery, tabular\nrecords, and unstructured logs, while supporting a broad range of downstream\ntasks spanning forecasting, classification, control, and retrieval. When\ncombined with federated learning (FL), they give rise to M3T Federated\nFoundation Models (FedFMs): a highly recent and largely unexplored class of\nmodels that enable scalable, privacy-preserving model training/fine-tuning\nacross distributed data sources. In this paper, we take one of the first steps\ntoward introducing these models to the power systems research community by\noffering a bidirectional perspective: (i) M3T FedFMs for smart grids and (ii)\nsmart grids for FedFMs. In the former, we explore how M3T FedFMs can enhance\nkey grid functions, such as load/demand forecasting and fault detection, by\nlearning from distributed, heterogeneous data available at the grid edge in a\nprivacy-preserving manner. In the latter, we investigate how the constraints\nand structure of smart grids, spanning energy, communication, and regulatory\ndimensions, shape the design, training, and deployment of M3T FedFMs.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16496v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16496v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "extraction_failed",
      "embedding_status": "completed",
      "rlhf_score": 0.424,
      "weak_supervision_score": 0.343,
      "diffusion_reasoning_score": 0.38,
      "distributed_training_score": 0.43,
      "datasets_score": 0.36,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "Highly Relevant",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper focuses on federated learning and foundation models for smart power grids, emphasizing privacy-preserving training on distributed data. It does not mention reinforcement learning, human feedback, reward models, or any mechanism for aligning models with human preferences.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "The paper discusses Federated Learning (FL) as a core component for training and fine-tuning foundation models across distributed, heterogeneous data sources in a scalable and privacy-preserving manner. This directly aligns with distributed training techniques, including parallel computing and multi-node machine learning for accelerating model development.",
      "datasets_justification": "below_threshold",
      "llm_score_status": "completed",
      "summary": "The paper introduces multi-modal, multi-task foundation models (M3T FMs) combined with federated learning (FedFMs) to the power systems community, exploring their potential to enhance smart grid functions such as load forecasting and fault detection using distributed, heterogeneous data in a privacy-preserving manner. It also examines how the constraints of smart grids, including energy, communication, and regulatory aspects, influence the design, training, and deployment of FedFMs, providing a bidirectional perspective on this emerging intersection of AI and power systems.",
      "novelty_score": "Moderate",
      "novelty_justification": "The paper presents a notable improvement by applying federated foundation models to smart grids, combining existing AI techniques in a new context for privacy-preserving data analysis, though it does not introduce entirely novel architectures or problems.",
      "impact_score": "Moderate",
      "impact_justification": "The work is likely to influence research in AI applications for power systems by highlighting privacy-preserving methods, potentially leading to citations and developments in subfields like smart grid optimization.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "This paper offers a valuable introduction to an emerging area at the intersection of AI and smart grids, providing insights that could guide future research, making it essential for specialists in these fields.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/effb8d3ae6e1a68d0a281a18d349a1de3fa98556",
      "total_authors": 6,
      "authors_found": 6,
      "highest_h_index": 20,
      "average_h_index": 5.166666666666667,
      "notable_authors_count": 2,
      "author_h_indexes": [
        {
          "name": "Seyyedali Hosseinalipour",
          "h_index": 20,
          "profile_url": "https://www.semanticscholar.org/author/2911998"
        },
        {
          "name": "Shimiao Li",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2381454057"
        },
        {
          "name": "Adedoyin Inaolaji",
          "h_index": 9,
          "profile_url": "https://www.semanticscholar.org/author/2038525866"
        },
        {
          "name": "Filippo Malandra",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2261549572"
        },
        {
          "name": "Luis Herrera",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2381377749"
        },
        {
          "name": "Nicholas Mastronarde",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2319333567"
        }
      ]
    },
    {
      "id": "2509.16500",
      "title": "RLGF: Reinforcement Learning with Geometric Feedback for Autonomous\n  Driving Video Generation",
      "authors": [
        "Tianyi Yan",
        "Wencheng Han",
        "Xia Zhou",
        "Xueyang Zhang",
        "Kun Zhan",
        "Cheng-zhong Xu",
        "Jianbing Shen"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Synthetic data is crucial for advancing autonomous driving (AD) systems, yet\ncurrent state-of-the-art video generation models, despite their visual realism,\nsuffer from subtle geometric distortions that limit their utility for\ndownstream perception tasks. We identify and quantify this critical issue,\ndemonstrating a significant performance gap in 3D object detection when using\nsynthetic versus real data. To address this, we introduce Reinforcement\nLearning with Geometric Feedback (RLGF), RLGF uniquely refines video diffusion\nmodels by incorporating rewards from specialized latent-space AD perception\nmodels. Its core components include an efficient Latent-Space Windowing\nOptimization technique for targeted feedback during diffusion, and a\nHierarchical Geometric Reward (HGR) system providing multi-level rewards for\npoint-line-plane alignment, and scene occupancy coherence. To quantify these\ndistortions, we propose GeoScores. Applied to models like DiVE on nuScenes,\nRLGF substantially reduces geometric errors (e.g., VP error by 21\\%, Depth\nerror by 57\\%) and dramatically improves 3D object detection mAP by 12.7\\%,\nnarrowing the gap to real-data performance. RLGF offers a plug-and-play\nsolution for generating geometrically sound and reliable synthetic videos for\nAD development.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16500v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16500v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.476,
      "weak_supervision_score": 0.366,
      "diffusion_reasoning_score": 0.5,
      "distributed_training_score": 0.355,
      "datasets_score": 0.322,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper introduces RLGF, which uses reinforcement learning with rewards from AI-based perception models for geometric feedback, not from human-ranked data or preferences. Since RLHF specifically requires human feedback to train a reward model and fine-tune the main model, this paper does not align with that definition.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper applies diffusion models to video generation for autonomous driving, focusing on refining geometric accuracy through RL, but it does not involve adapting diffusion for multi-step logical reasoning or treating a Chain-of-Thought as an entity for correction. The core contribution is generation-based, not reasoning-oriented.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16506",
      "title": "CommonForms: A Large, Diverse Dataset for Form Field Detection",
      "authors": [
        "Joe Barrow"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.LG (Machine Learning)"
      ],
      "abstract": "This paper introduces CommonForms, a web-scale dataset for form field\ndetection. It casts the problem of form field detection as object detection:\ngiven an image of a page, predict the location and type (Text Input, Choice\nButton, Signature) of form fields. The dataset is constructed by filtering\nCommon Crawl to find PDFs that have fillable elements. Starting with 8 million\ndocuments, the filtering process is used to arrive at a final dataset of\nroughly 55k documents that have over 450k pages. Analysis shows that the\ndataset contains a diverse mixture of languages and domains; one third of the\npages are non-English, and among the 14 classified domains, no domain makes up\nmore than 25% of the dataset.\n  In addition, this paper presents a family of form field detectors,\nFFDNet-Small and FFDNet-Large, which attain a very high average precision on\nthe CommonForms test set. Each model cost less than $500 to train. Ablation\nresults show that high-resolution inputs are crucial for high-quality form\nfield detection, and that the cleaning process improves data efficiency over\nusing all PDFs that have fillable fields in Common Crawl. A qualitative\nanalysis shows that they outperform a popular, commercially available PDF\nreader that can prepare forms. Unlike the most popular commercially available\nsolutions, FFDNet can predict checkboxes in addition to text and signature\nfields. This is, to our knowledge, the first large scale dataset released for\nform field detection, as well as the first open source models. The dataset,\nmodels, and code will be released at https://github.com/jbarrow/commonforms",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16506v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16506v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.354,
      "weak_supervision_score": 0.407,
      "diffusion_reasoning_score": 0.327,
      "distributed_training_score": 0.356,
      "datasets_score": 0.456,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "Moderately Relevant",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "Highly Relevant",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "The paper employs a weak supervision approach by programmatically filtering and cleaning Common Crawl data to generate labels from existing fillable PDFs, rather than relying on hand-labeled data. This aligns with weak supervision principles, as it uses noisy or high-level sources for training signals. However, weak supervision is not the primary focus; it is a methodological step to create the dataset, making the paper moderately relevant rather than central to the topic.",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "The paper's main contribution is the introduction, creation, and analysis of the CommonForms dataset, including its curation from Common Crawl, diversity analysis (e.g., languages and domains), and benchmarking with models. This directly matches research on dataset creation, analysis, and evaluation for AI applications, making it highly relevant.",
      "llm_score_status": "completed",
      "summary": "This paper introduces CommonForms, a large-scale dataset derived from Common Crawl comprising over 450,000 pages from approximately 55,000 documents, designed to facilitate form field detection by treating it as an object detection problem to identify locations and types of fields like text inputs, choice buttons, and signatures. The authors develop and release two YOLO11-based models, FFDNet-Small and FFDNet-Large, trained on this diverse dataset, which achieve over 80% average precision, outperform commercial tools like Adobe Acrobat in qualitative analysis, and highlight the benefits of high-resolution inputs and data cleaning for enhanced performance and efficiency.",
      "novelty_score": "High",
      "novelty_justification": "The paper introduces the first large-scale, open-source dataset and models specifically for form field detection, significantly advancing the state-of-the-art by addressing a gap in resources for this application. This represents a truly new contribution, as it provides a novel dataset and models that extend beyond existing commercial solutions.",
      "impact_score": "High",
      "impact_justification": "The work is likely to influence future research in computer vision and machine learning for document processing, given the open-source release of the dataset and models, which can enable broader applications in accessibility and digital form handling. Its potential for citation and adaptation in subfields like form automation suggests wide-reaching effects.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "This paper offers a strong, valuable contribution with practical tools and insights for researchers in document analysis, making it important for those in relevant fields to be aware of. While essential for specialists, it may not be universally critical for all readers.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/c26d7865f23523a6b6cac7b6062e436a4847c5b1",
      "total_authors": 1,
      "authors_found": 1,
      "highest_h_index": 12,
      "average_h_index": 12.0,
      "notable_authors_count": 1,
      "author_h_indexes": [
        {
          "name": "Joe Barrow",
          "h_index": 12,
          "profile_url": "https://www.semanticscholar.org/author/40080808"
        }
      ]
    },
    {
      "id": "2509.16507",
      "title": "OS-DiffVSR: Towards One-step Latent Diffusion Model for High-detailed\n  Real-world Video Super-Resolution",
      "authors": [
        "Hanting Li",
        "Huaao Tang",
        "Jianhong Han",
        "Tianxiong Zhou",
        "Jiulong Cui",
        "Haizhen Xie",
        "Yan Chen",
        "Jie Hu"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Recently, latent diffusion models has demonstrated promising performance in\nreal-world video super-resolution (VSR) task, which can reconstruct\nhigh-quality videos from distorted low-resolution input through multiple\ndiffusion steps. Compared to image super-resolution (ISR), VSR methods needs to\nprocess each frame in a video, which poses challenges to its inference\nefficiency. However, video quality and inference efficiency have always been a\ntrade-off for the diffusion-based VSR methods. In this work, we propose\nOne-Step Diffusion model for real-world Video Super-Resolution, namely\nOS-DiffVSR. Specifically, we devise a novel adjacent frame adversarial training\nparadigm, which can significantly improve the quality of synthetic videos.\nBesides, we devise a multi-frame fusion mechanism to maintain inter-frame\ntemporal consistency and reduce the flicker in video. Extensive experiments on\nseveral popular VSR benchmarks demonstrate that OS-DiffVSR can even achieve\nbetter quality than existing diffusion-based VSR methods that require dozens of\nsampling steps.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16507v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16507v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.318,
      "weak_supervision_score": 0.326,
      "diffusion_reasoning_score": 0.514,
      "distributed_training_score": 0.352,
      "datasets_score": 0.289,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper's main contribution is a one-step diffusion model for video super-resolution, focusing on improving video quality, efficiency, and temporal consistency through techniques like adversarial training and frame fusion. This is a generative task for visual enhancement, not an adaptation of diffusion models for solving complex logical tasks or multi-step reasoning paths, such as Chain-of-Thought processes. Therefore, it does not align with the topic.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16509",
      "title": "SlowFast-SCI: Slow-Fast Deep Unfolding Learning for Spectral Compressive\n  Imaging",
      "authors": [
        "Haijin Zeng",
        "Xuan Lu",
        "Yurong Zhang",
        "Yongyong Chen",
        "Jingyong Su",
        "Jie Liu"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Humans learn in two complementary ways: a slow, cumulative process that\nbuilds broad, general knowledge, and a fast, on-the-fly process that captures\nspecific experiences. Existing deep-unfolding methods for spectral compressive\nimaging (SCI) mirror only the slow component-relying on heavy pre-training with\nmany unfolding stages-yet they lack the rapid adaptation needed to handle new\noptical configurations. As a result, they falter on out-of-distribution\ncameras, especially in bespoke spectral setups unseen during training. This\ndepth also incurs heavy computation and slow inference. To bridge this gap, we\nintroduce SlowFast-SCI, a dual-speed framework seamlessly integrated into any\ndeep unfolding network beyond SCI systems. During slow learning, we pre-train\nor reuse a priors-based backbone and distill it via imaging guidance into a\ncompact fast-unfolding model. In the fast learning stage, lightweight\nadaptation modules are embedded within each block and trained self-supervised\nat test time via a dual-domain loss-without retraining the backbone. To the\nbest of our knowledge, SlowFast-SCI is the first test-time adaptation-driven\ndeep unfolding framework for efficient, self-adaptive spectral reconstruction.\nIts dual-stage design unites offline robustness with on-the-fly per-sample\ncalibration-yielding over 70% reduction in parameters and FLOPs, up to 5.79 dB\nPSNR improvement on out-of-distribution data, preserved cross-domain\nadaptability, and a 4x faster adaptation speed. In addition, its modularity\nintegrates with any deep-unfolding network, paving the way for self-adaptive,\nfield-deployable imaging and expanded computational imaging modalities. Code\nand models are available at https://github.com/XuanLu11/SlowFast-SCI.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16509v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16509v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.337,
      "weak_supervision_score": 0.388,
      "diffusion_reasoning_score": 0.385,
      "distributed_training_score": 0.407,
      "datasets_score": 0.308,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "Not Relevant",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "The paper introduces SlowFast-SCI, a framework for spectral compressive imaging that focuses on dual-speed learning, test-time adaptation, and model distillation to improve reconstruction efficiency. It does not discuss distributed training, parallel computing, multi-node setups, or strategies for partitioning data/computation across processors, as its contributions are centered on single-model adaptations for imaging tasks.",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16517",
      "title": "Seeing Culture: A Benchmark for Visual Reasoning and Grounding",
      "authors": [
        "Burak Satar",
        "Zhixin Ma",
        "Patrick A. Irawan",
        "Wilfried A. Mulyawan",
        "Jing Jiang",
        "Ee-Peng Lim",
        "Chong-Wah Ngo"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.AI (Artificial Intelligence)",
        "cs.CL (Computation and Language)",
        "cs.MM (Multimedia)"
      ],
      "abstract": "Multimodal vision-language models (VLMs) have made substantial progress in\nvarious tasks that require a combined understanding of visual and textual\ncontent, particularly in cultural understanding tasks, with the emergence of\nnew cultural datasets. However, these datasets frequently fall short of\nproviding cultural reasoning while underrepresenting many cultures. In this\npaper, we introduce the Seeing Culture Benchmark (SCB), focusing on cultural\nreasoning with a novel approach that requires VLMs to reason on culturally rich\nimages in two stages: i) selecting the correct visual option with\nmultiple-choice visual question answering (VQA), and ii) segmenting the\nrelevant cultural artifact as evidence of reasoning. Visual options in the\nfirst stage are systematically organized into three types: those originating\nfrom the same country, those from different countries, or a mixed group.\nNotably, all options are derived from a singular category for each type.\nProgression to the second stage occurs only after a correct visual option is\nchosen. The SCB benchmark comprises 1,065 images that capture 138 cultural\nartifacts across five categories from seven Southeast Asia countries, whose\ndiverse cultures are often overlooked, accompanied by 3,178 questions, of which\n1,093 are unique and meticulously curated by human annotators. Our evaluation\nof various VLMs reveals the complexities involved in cross-modal cultural\nreasoning and highlights the disparity between visual reasoning and spatial\ngrounding in culturally nuanced scenarios. The SCB serves as a crucial\nbenchmark for identifying these shortcomings, thereby guiding future\ndevelopments in the field of cultural reasoning.\nhttps://github.com/buraksatar/SeeingCulture",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16517v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16517v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.342,
      "weak_supervision_score": 0.338,
      "diffusion_reasoning_score": 0.373,
      "distributed_training_score": 0.292,
      "datasets_score": 0.427,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "Highly Relevant",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "The paper's main contribution is the introduction of the Seeing Culture Benchmark (SCB), a new dataset comprising 1,065 images and 3,178 questions focused on cultural reasoning for multimodal vision-language models. It details dataset creation, including curation methodologies (e.g., human annotators and verification by native speakers), benchmarking of VLMs on this dataset, and comparative analysis with existing datasets, directly aligning with research on creating, analyzing, benchmarking, and evaluating datasets for AI applications.",
      "llm_score_status": "completed",
      "summary": "The Seeing Culture Benchmark (SCB) is a novel dataset introduced to evaluate multimodal vision-language models (VLMs) on cultural reasoning tasks, specifically for underrepresented Southeast Asian cultures, through a two-stage process: first, multiple-choice visual question answering (VQA) to select the correct image from options categorized by country origins, and second, segmenting the relevant cultural artifact as evidence. Comprising 1,065 images, 138 cultural artifacts across five categories from seven countries, and 3,178 human-curated questions, the benchmark reveals disparities in VLM performance across question types and between visual reasoning and spatial grounding, highlighting the need for more culturally sensitive AI advancements.",
      "novelty_score": "Moderate",
      "novelty_justification": "The paper presents a clever combination of existing VQA and segmentation techniques into a new two-stage benchmark for cultural reasoning, particularly for underrepresented regions like Southeast Asia, advancing the state-of-the-art in a meaningful but not entirely groundbreaking way.",
      "impact_score": "Moderate",
      "impact_justification": "The work is likely to be cited and built upon in subfields of AI and computer vision focused on cultural understanding, as it addresses gaps in diverse cultural datasets and could guide improvements in VLMs, though its influence may remain niche.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "This paper offers a valuable and timely contribution by introducing a benchmark for cultural reasoning in AI, making it essential for researchers working on multimodal models and cultural inclusivity to be aware of its insights and methodologies.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/b0c446041b282bfefae50f73be4d0bb6f81bf164",
      "total_authors": 7,
      "authors_found": 7,
      "highest_h_index": 4,
      "average_h_index": 1.5714285714285714,
      "notable_authors_count": 0,
      "author_h_indexes": [
        {
          "name": "Burak Satar",
          "h_index": 4,
          "profile_url": "https://www.semanticscholar.org/author/51431460"
        },
        {
          "name": "Zhixin Ma",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2381722029"
        },
        {
          "name": "Patrick Amadeus Irawan",
          "h_index": 3,
          "profile_url": "https://www.semanticscholar.org/author/2306258046"
        },
        {
          "name": "Wilfried A. Mulyawan",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2381377477"
        },
        {
          "name": "Jing Jiang",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2381482088"
        },
        {
          "name": "Ee-Peng Lim",
          "h_index": 2,
          "profile_url": "https://www.semanticscholar.org/author/2294572540"
        },
        {
          "name": "C. Ngo",
          "h_index": 2,
          "profile_url": "https://www.semanticscholar.org/author/2283854158"
        }
      ]
    },
    {
      "id": "2509.16518",
      "title": "FG-Attn: Leveraging Fine-Grained Sparsity In Diffusion Transformers",
      "authors": [
        "Sankeerth Durvasula",
        "Kavya Sreedhar",
        "Zain Moustafa",
        "Suraj Kothawade",
        "Ashish Gondimalla",
        "Suvinay Subramanian",
        "Narges Shahidi",
        "Nandita Vijaykumar"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.AR (Hardware Architecture)"
      ],
      "abstract": "Generating realistic videos with diffusion transformers demands significant\ncomputation, with attention layers the central bottleneck; even producing a\nshort clip requires running a transformer over a very long sequence of\nembeddings, e.g., more than 30K embeddings for a 5-second video, incurring\nsignificant latency. Prior work aims to mitigate this bottleneck by exploiting\nsparsity in the attention layers to reduce computation. However, these works\ntypically rely on block-sparse attention, which skips score computation only\nwhen all entries in a block of attention scores (corresponding to M queries and\nM keys, with M = 64 typically) are zero. This coarse-granular skipping of\nattention scores does not fully exploit sparsity in the attention map and\nleaves room for improvement. In this work, we propose FG-Attn, a sparse\nattention mechanism for long-context diffusion transformers that leverages\nsparsity at a fine granularity. Unlike block-sparse attention, which skips\nentire MxM blocks, our approach skips computations at the granularity of Mx1\nslices of the attention map. Each slice is produced by query-key dot products\nbetween a block of query vectors and a single key. To implement our proposed\nsparse attention mechanism, we develop a new efficient bulk-load operation\ncalled asynchronous-gather load. This load operation gathers a sparse set of\nrelevant key-value vectors from memory and arranges them into packed tiles in\nthe GPU's shared memory. Only a sparse set of keys relevant to those queries\nare loaded into shared memory when computing attention for a block of queries,\nin contrast to loading full blocks of key tokens in block-sparse attention. Our\nfine-grained sparse attention, applied to video diffusion models, achieves an\naverage 1.55X (up to 1.65X) speedup for 5 second, 480p videos, and an average\n1.41X (up to 1.49X) for 5 second, 720p videos on a single H100 GPU.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16518v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16518v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.32,
      "weak_supervision_score": 0.348,
      "diffusion_reasoning_score": 0.481,
      "distributed_training_score": 0.421,
      "datasets_score": 0.299,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "Not Relevant",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on optimizing attention mechanisms in diffusion transformers for video generation, emphasizing computational efficiency in generative tasks. It does not involve adapting diffusion models for multi-step logical reasoning, Chain-of-Thought processes, or iterative refinement for complex logical tasks.",
      "distributed_training_justification": "The paper discusses techniques for accelerating inference on a single GPU by leveraging fine-grained sparsity in attention layers, without addressing distributed training, parallel computing across multiple nodes, or strategies for partitioning data/computation in multi-processor environments.",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16519",
      "title": "PM25Vision: A Large-Scale Benchmark Dataset for Visual Estimation of Air\n  Quality",
      "authors": [
        "Yang Han"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "We introduce PM25Vision (PM25V), the largest and most comprehensive dataset\nto date for estimating air quality - specifically PM2.5 concentrations - from\nstreet-level images. The dataset contains over 11,114 images matched with\ntimestamped and geolocated PM2.5 readings across 3,261 AQI monitoring stations\nand 11 years, significantly exceeding the scale of previous benchmarks. The\nspatial accuracy of this dataset has reached 5 kilometers, far exceeding the\ncity-level accuracy of many datasets. We describe the data collection,\nsynchronization, and cleaning pipelines, and provide baseline model\nperformances using CNN and transformer architectures. Our dataset is publicly\navailable.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16519v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16519v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.307,
      "weak_supervision_score": 0.365,
      "diffusion_reasoning_score": 0.305,
      "distributed_training_score": 0.32,
      "datasets_score": 0.458,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "Highly Relevant",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "The paper's main contribution is the introduction of a new large-scale dataset, PM25Vision, for estimating PM2.5 concentrations using computer vision. It details dataset creation, including data collection from sources like WAQI and Mapillary, synchronization, cleaning pipelines, and benchmarking with CNN and transformer models. This directly aligns with research on creating, analyzing, benchmarking, and evaluating datasets for AI applications, making it highly relevant to the topic.",
      "llm_score_status": "completed",
      "summary": "PM25Vision introduces a large-scale benchmark dataset comprising over 11,114 street-level images paired with geolocated and timestamped PM2.5 readings from 3,261 monitoring stations across 11 years, aiming to enhance the visual estimation of air quality. The methodology involves collecting data from the World Air Quality Index Project and Mapillary, synchronizing and cleaning it to achieve high spatial accuracy, and providing baseline performances using CNN and transformer models, positioning the dataset as a comprehensive resource for advancing computer vision applications in environmental monitoring.",
      "novelty_score": "Moderate",
      "novelty_justification": "The paper presents a notable improvement by creating the largest and most spatially accurate dataset for PM2.5 estimation from images, combining existing data sources in a clever way, though it builds on known techniques rather than introducing a entirely new problem or architecture.",
      "impact_score": "Moderate",
      "impact_justification": "The work is likely to be cited and built upon in computer vision and environmental science subfields, as it provides a valuable benchmark dataset for air quality estimation, potentially influencing research in urban monitoring and model development.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "This paper offers a high-quality, significant contribution by establishing a comprehensive benchmark dataset, making it essential for researchers in computer vision and air quality fields to be aware of for advancing their work.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/98e503cdb05ed4a4b53aa2572aadcc1689d0fee7",
      "total_authors": 1,
      "authors_found": 1,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": [
        {
          "name": "Yang Han",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2383103938"
        }
      ]
    },
    {
      "id": "2509.16525",
      "title": "Causal Fuzzing for Verifying Machine Unlearning",
      "authors": [
        "Anna Mazhar",
        "Sainyam Galhotra"
      ],
      "categories": [
        "cs.SE (Software Engineering)",
        "cs.AI (Artificial Intelligence)",
        "cs.LG (Machine Learning)"
      ],
      "abstract": "As machine learning models become increasingly embedded in decision-making\nsystems, the ability to \"unlearn\" targeted data or features is crucial for\nenhancing model adaptability, fairness, and privacy in models which involves\nexpensive training. To effectively guide machine unlearning, a thorough testing\nis essential. Existing methods for verification of machine unlearning provide\nlimited insights, often failing in scenarios where the influence is indirect.\nIn this work, we propose CAF\\'E, a new causality based framework that unifies\ndatapoint- and feature-level unlearning for verification of black-box ML\nmodels. CAF\\'E evaluates both direct and indirect effects of unlearning targets\nthrough causal dependencies, providing actionable insights with fine-grained\nanalysis. Our evaluation across five datasets and three model architectures\ndemonstrates that CAF\\'E successfully detects residual influence missed by\nbaselines while maintaining computational efficiency.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16525v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16525v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.405,
      "weak_supervision_score": 0.429,
      "diffusion_reasoning_score": 0.378,
      "distributed_training_score": 0.33,
      "datasets_score": 0.359,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "Not Relevant",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper's main contribution is a causality-based framework for verifying machine unlearning in ML models, focusing on detecting residual influences through causal dependencies. It does not involve reinforcement learning, human feedback, reward models, or aligning AI with human preferences.",
      "weak_supervision_justification": "The paper addresses verification of machine unlearning in trained models, emphasizing causal analysis to ensure features or data points are removed. It does not discuss training models with programmatically generated, noisy, or imprecise labels, which is the core of weak supervision.",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16527",
      "title": "Lattice Boltzmann Model for Learning Real-World Pixel Dynamicity",
      "authors": [
        "Guangze Zheng",
        "Shijie Lin",
        "Haobo Zuo",
        "Si Si",
        "Ming-Shan Wang",
        "Changhong Fu",
        "Jia Pan"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "This work proposes the Lattice Boltzmann Model (LBM) to learn real-world\npixel dynamicity for visual tracking. LBM decomposes visual representations\ninto dynamic pixel lattices and solves pixel motion states through\ncollision-streaming processes. Specifically, the high-dimensional distribution\nof the target pixels is acquired through a multilayer predict-update network to\nestimate the pixel positions and visibility. The predict stage formulates\nlattice collisions among the spatial neighborhood of target pixels and develops\nlattice streaming within the temporal visual context. The update stage\nrectifies the pixel distributions with online visual representations. Compared\nwith existing methods, LBM demonstrates practical applicability in an online\nand real-time manner, which can efficiently adapt to real-world visual tracking\ntasks. Comprehensive evaluations of real-world point tracking benchmarks such\nas TAP-Vid and RoboTAP validate LBM's efficiency. A general evaluation of\nlarge-scale open-world object tracking benchmarks such as TAO, BFT, and OVT-B\nfurther demonstrates LBM's real-world practicality.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16527v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16527v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.349,
      "weak_supervision_score": 0.325,
      "diffusion_reasoning_score": 0.397,
      "distributed_training_score": 0.372,
      "datasets_score": 0.298,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16530",
      "title": "AIPsychoBench: Understanding the Psychometric Differences between LLMs\n  and Humans",
      "authors": [
        "Wei Xie",
        "Shuoyoucheng Ma",
        "Zhenhua Wang",
        "Enze Wang",
        "Kai Chen",
        "Xiaobing Sun",
        "Baosheng Wang"
      ],
      "categories": [
        "cs.CL (Computation and Language)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Large Language Models (LLMs) with hundreds of billions of parameters have\nexhibited human-like intelligence by learning from vast amounts of\ninternet-scale data. However, the uninterpretability of large-scale neural\nnetworks raises concerns about the reliability of LLM. Studies have attempted\nto assess the psychometric properties of LLMs by borrowing concepts from human\npsychology to enhance their interpretability, but they fail to account for the\nfundamental differences between LLMs and humans. This results in high rejection\nrates when human scales are reused directly. Furthermore, these scales do not\nsupport the measurement of LLM psychological property variations in different\nlanguages. This paper introduces AIPsychoBench, a specialized benchmark\ntailored to assess the psychological properties of LLM. It uses a lightweight\nrole-playing prompt to bypass LLM alignment, improving the average effective\nresponse rate from 70.12% to 90.40%. Meanwhile, the average biases are only\n3.3% (positive) and 2.1% (negative), which are significantly lower than the\nbiases of 9.8% and 6.9%, respectively, caused by traditional jailbreak prompts.\nFurthermore, among the total of 112 psychometric subcategories, the score\ndeviations for seven languages compared to English ranged from 5% to 20.2% in\n43 subcategories, providing the first comprehensive evidence of the linguistic\nimpact on the psychometrics of LLM.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16530v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16530v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.487,
      "weak_supervision_score": 0.366,
      "diffusion_reasoning_score": 0.438,
      "distributed_training_score": 0.354,
      "datasets_score": 0.417,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "Highly Relevant",
      "rlhf_justification": "The paper focuses on introducing a benchmark for LLM psychometrics and using prompts to bypass alignment, but it does not involve training models with human feedback, reward models, or reinforcement learning techniques. While it mentions LLM alignment in general, this is not the same as RLHF.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper deals with psychometric evaluation of LLMs using prompts and benchmarks, with no mention of diffusion models, iterative refinement processes, or multi-step logical reasoning as described. It is solely about psychological assessments, not reasoning mechanisms.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "The paper's main contribution is the introduction and evaluation of AIPsychoBench, a new benchmark dataset for assessing LLM psychometrics, including its creation, adaptation for multiple languages, and experimental analysis. This directly aligns with research on creating, benchmarking, and evaluating datasets for AI applications.",
      "llm_score_status": "completed",
      "summary": "This paper introduces AIPsychoBench, a specialized benchmark for evaluating the psychological properties of Large Language Models (LLMs), addressing the shortcomings of directly applying human psychometric scales by using a lightweight role-playing prompt to improve response rates and reduce biases. The methodology involves testing LLMs across eight languages, revealing key findings such as an increased effective response rate from 70.12% to 90.40%, minimal biases compared to traditional methods, and significant score deviations in 43 out of 112 subcategories (ranging from 5% to 20.2%), highlighting the impact of language on LLM psychometrics.",
      "novelty_score": "High",
      "novelty_justification": "The paper introduces a novel benchmark and prompting technique specifically tailored for LLMs, significantly advancing the state-of-the-art in machine psychology by addressing fundamental differences between LLMs and humans.",
      "impact_score": "High",
      "impact_justification": "The work provides a comprehensive tool that could influence future research in AI interpretability, multilingual evaluations, and machine psychology, potentially leading to broader applications in reliable AI deployment.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "This paper offers a strong, valuable contribution to AI research with practical insights and a new benchmark, making it essential for those in computational psychology and LLM development, though not universally critical.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/edf965e63d0990c8c7493a798f1f59d914682bc0",
      "total_authors": 7,
      "authors_found": 6,
      "highest_h_index": 7,
      "average_h_index": 4.166666666666667,
      "notable_authors_count": 3,
      "author_h_indexes": [
        {
          "name": "Wei Xie",
          "h_index": null,
          "profile_url": null
        },
        {
          "name": "Shuoyoucheng Ma",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2287248650"
        },
        {
          "name": "Zhenhua Wang",
          "h_index": 6,
          "profile_url": "https://www.semanticscholar.org/author/2108330405"
        },
        {
          "name": "Enze Wang",
          "h_index": 7,
          "profile_url": "https://www.semanticscholar.org/author/152482017"
        },
        {
          "name": "Kai Chen",
          "h_index": 3,
          "profile_url": "https://www.semanticscholar.org/author/2208124975"
        },
        {
          "name": "Xiaobing Sun",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2330761106"
        },
        {
          "name": "Baosheng Wang",
          "h_index": 7,
          "profile_url": "https://www.semanticscholar.org/author/2118640332"
        }
      ]
    },
    {
      "id": "2509.16532",
      "title": "No Need for Real 3D: Fusing 2D Vision with Pseudo 3D Representations for\n  Robotic Manipulation Learning",
      "authors": [
        "Run Yu",
        "Yangdi Liu",
        "Wen-Da Wei",
        "Chen Li"
      ],
      "categories": [
        "cs.RO (Robotics)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Recently,vision-based robotic manipulation has garnered significant attention\nand witnessed substantial advancements. 2D image-based and 3D point cloud-based\npolicy learning represent two predominant paradigms in the field, with recent\nstudies showing that the latter consistently outperforms the former in terms of\nboth policy performance and generalization, thereby underscoring the value and\nsignificance of 3D information. However, 3D point cloud-based approaches face\nthe significant challenge of high data acquisition costs, limiting their\nscalability and real-world deployment. To address this issue, we propose a\nnovel framework NoReal3D: which introduces the 3DStructureFormer, a learnable\n3D perception module capable of transforming monocular images into\ngeometrically meaningful pseudo-point cloud features, effectively fused with\nthe 2D encoder output features. Specially, the generated pseudo-point clouds\nretain geometric and topological structures so we design a pseudo-point cloud\nencoder to preserve these properties, making it well-suited for our framework.\nWe also investigate the effectiveness of different feature fusion\nstrategies.Our framework enhances the robot's understanding of 3D spatial\nstructures while completely eliminating the substantial costs associated with\n3D point cloud acquisition.Extensive experiments across various tasks validate\nthat our framework can achieve performance comparable to 3D point cloud-based\nmethods, without the actual point cloud data.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16532v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16532v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.376,
      "weak_supervision_score": 0.404,
      "diffusion_reasoning_score": 0.379,
      "distributed_training_score": 0.333,
      "datasets_score": 0.313,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "Not Relevant",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "The paper's main contribution is a framework for generating and fusing pseudo-3D representations from 2D images to enhance robotic manipulation, without relying on programmatically generated labels or weak supervision techniques. It uses pre-trained models like monocular depth estimation to create features, but does not address training with noisy or imprecise labels, which is central to weak supervision.",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16534",
      "title": "InteGround: On the Evaluation of Verification and Retrieval Planning in\n  Integrative Grounding",
      "authors": [
        "Cheng Jiayang",
        "Qianqian Zhuang",
        "Haoran Li",
        "Chunkit Chan",
        "Xin Liu",
        "Lin Qiu",
        "Yangqiu Song"
      ],
      "categories": [
        "cs.CL (Computation and Language)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Grounding large language models (LLMs) in external knowledge sources is a\npromising method for faithful prediction. While existing grounding approaches\nwork well for simple queries, many real-world information needs require\nsynthesizing multiple pieces of evidence. We introduce \"integrative grounding\"\n-- the challenge of retrieving and verifying multiple inter-dependent pieces of\nevidence to support a hypothesis query. To systematically study this problem,\nwe repurpose data from four domains for evaluating integrative grounding\ncapabilities. Our investigation reveals two critical findings: First, in\ngroundedness verification, while LLMs are robust to redundant evidence, they\ntend to rationalize using internal knowledge when information is incomplete.\nSecond, in examining retrieval planning strategies, we find that undirected\nplanning can degrade performance through noise introduction, while premise\nabduction emerges as a promising approach due to its logical constraints.\nAdditionally, LLMs' zero-shot self-reflection capabilities consistently improve\ngrounding quality. These insights provide valuable direction for developing\nmore effective integrative grounding systems.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16534v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16534v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.407,
      "weak_supervision_score": 0.394,
      "diffusion_reasoning_score": 0.487,
      "distributed_training_score": 0.334,
      "datasets_score": 0.363,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper focuses on integrative grounding for LLMs, involving retrieval and verification of evidence, but does not mention reinforcement learning, human feedback, reward models, or any alignment with human preferences.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper discusses iterative refinement through self-reflection and planning strategies for LLMs, but it does not involve diffusion models or adapt the diffusion process for multi-step logical reasoning tasks.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16538",
      "title": "Advancing Reference-free Evaluation of Video Captions with Factual\n  Analysis",
      "authors": [
        "Shubhashis Roy Dipta",
        "Tz-Ying Wu",
        "Subarna Tripathi"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.CL (Computation and Language)"
      ],
      "abstract": "Video captions offer concise snapshots of actors, objects, and actions within\na video, serving as valuable assets for applications such as question answering\nand event localization. However, acquiring human annotations for video captions\nis costly or even impractical, especially when dealing with diverse video\ndomains. Existing models trained on supervised datasets face challenges in\nevaluating performance across different domains due to the reliance on\nreference-based evaluation protocols, which necessitate ground truth captions.\nThis assumption is unrealistic for evaluating videos in the wild. To address\nthese limitations, we propose a reference-free evaluation framework that does\nnot require ground truth captions, focusing on factual grounding to ensure\naccurate assessment of caption quality. We introduce VC-Inspector, a novel\ncaption quality evaluator that is both reference-free and factually grounded.\nUtilizing large language models, we generate pseudo captions of varying quality\nbased on supervised data, which are subsequently used to train a multimodal\nmodel (i.e., Qwen2.5-VL) as the evaluator. Our approach demonstrates superior\nalignment with human judgments on the VATEX-Eval dataset, outperforming\nexisting methods. The performance also generalizes to image caption datasets,\nFlickr8K-Expert and Flickr8K-CF, when viewing images as 1-frame videos.\nOverall, VC-Inspector offers a scalable and generalizable solution for\nevaluating the factual accuracy of video captions, paving the way for more\neffective and objective assessment methodologies in diverse video domains.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16538v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16538v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.337,
      "weak_supervision_score": 0.386,
      "diffusion_reasoning_score": 0.364,
      "distributed_training_score": 0.288,
      "datasets_score": 0.381,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16546",
      "title": "Train to Defend: First Defense Against Cryptanalytic Neural Network\n  Parameter Extraction Attacks",
      "authors": [
        "Ashley Kurian",
        "Aydin Aysu"
      ],
      "categories": [
        "cs.CR (Cryptography and Security)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Neural networks are valuable intellectual property due to the significant\ncomputational cost, expert labor, and proprietary data involved in their\ndevelopment. Consequently, protecting their parameters is critical not only for\nmaintaining a competitive advantage but also for enhancing the model's security\nand privacy. Prior works have demonstrated the growing capability of\ncryptanalytic attacks to scale to deeper models. In this paper, we present the\nfirst defense mechanism against cryptanalytic parameter extraction attacks. Our\nkey insight is to eliminate the neuron uniqueness necessary for these attacks\nto succeed. We achieve this by a novel, extraction-aware training method.\nSpecifically, we augment the standard loss function with an additional\nregularization term that minimizes the distance between neuron weights within a\nlayer. Therefore, the proposed defense has zero area-delay overhead during\ninference. We evaluate the effectiveness of our approach in mitigating\nextraction attacks while analyzing the model accuracy across different\narchitectures and datasets. When re-trained with the same model architecture,\nthe results show that our defense incurs a marginal accuracy change of less\nthan 1% with the modified loss function. Moreover, we present a theoretical\nframework to quantify the success probability of the attack. When tested\ncomprehensively with prior attack settings, our defense demonstrated empirical\nsuccess for sustained periods of extraction, whereas unprotected networks are\nextracted between 14 minutes to 4 hours.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16546v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16546v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.327,
      "weak_supervision_score": 0.326,
      "diffusion_reasoning_score": 0.329,
      "distributed_training_score": 0.409,
      "datasets_score": 0.286,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "Not Relevant",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "The paper's main contribution focuses on developing a defense mechanism against cryptanalytic parameter extraction attacks by modifying the neural network training process with a regularization term to enforce weight similarity among neurons. It addresses model security, privacy, and training modifications for attack resistance, but does not involve distributed training, parallel computing, multi-node machine learning, or strategies for partitioning data/computation across processors. There is no discussion of accelerating training through distributed systems, making it unrelated to this topic.",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16547",
      "title": "Checking extracted rules in Neural Networks",
      "authors": [
        "Adrian Wurm"
      ],
      "categories": [
        "cs.AI (Artificial Intelligence)",
        "cs.LG (Machine Learning)"
      ],
      "abstract": "In this paper we investigate formal verification of extracted rules for\nNeural Networks under a complexity theoretic point of view. A rule is a global\nproperty or a pattern concerning a large portion of the input space of a\nnetwork. These rules are algorithmically extracted from networks in an effort\nto better understand their inner way of working. Here, three problems will be\nin the focus: Does a given set of rules apply to a given network? Is a given\nset of rules consistent or do the rules contradict themselves? Is a given set\nof rules exhaustive in the sense that for every input the output is determined?\nFinding algorithms that extract such rules out of networks has been\ninvestigated over the last 30 years, however, to the author's current\nknowledge, no attempt in verification was made until now. A lot of attempts of\nextracting rules use heuristics involving randomness and over-approximation, so\nit might be beneficial to know whether knowledge obtained in that way can\nactually be trusted.\n  We investigate the above questions for neural networks with ReLU-activation\nas well as for Boolean networks, each for several types of rules. We\ndemonstrate how these problems can be reduced to each other and show that most\nof them are co-NP-complete.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16547v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16547v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.354,
      "weak_supervision_score": 0.317,
      "diffusion_reasoning_score": 0.371,
      "distributed_training_score": 0.299,
      "datasets_score": 0.297,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16549",
      "title": "Efficient Rectified Flow for Image Fusion",
      "authors": [
        "Zirui Wang",
        "Jiayi Zhang",
        "Tianwei Guan",
        "Yuhan Zhou",
        "Xingyuan Li",
        "Minjing Dong",
        "Jinyuan Liu"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Image fusion is a fundamental and important task in computer vision, aiming\nto combine complementary information from different modalities to fuse images.\nIn recent years, diffusion models have made significant developments in the\nfield of image fusion. However, diffusion models often require complex\ncomputations and redundant inference time, which reduces the applicability of\nthese methods. To address this issue, we propose RFfusion, an efficient\none-step diffusion model for image fusion based on Rectified Flow. We\nincorporate Rectified Flow into the image fusion task to straighten the\nsampling path in the diffusion model, achieving one-step sampling without the\nneed for additional training, while still maintaining high-quality fusion\nresults. Furthermore, we propose a task-specific variational autoencoder (VAE)\narchitecture tailored for image fusion, where the fusion operation is embedded\nwithin the latent space to further reduce computational complexity. To address\nthe inherent discrepancy between conventional reconstruction-oriented VAE\nobjectives and the requirements of image fusion, we introduce a two-stage\ntraining strategy. This approach facilitates the effective learning and\nintegration of complementary information from multi-modal source images,\nthereby enabling the model to retain fine-grained structural details while\nsignificantly enhancing inference efficiency. Extensive experiments demonstrate\nthat our method outperforms other state-of-the-art methods in terms of both\ninference speed and fusion quality. Code is available at\nhttps://github.com/zirui0625/RFfusion.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16549v2",
      "pdf_url": "http://arxiv.org/pdf/2509.16549v2",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.336,
      "weak_supervision_score": 0.287,
      "diffusion_reasoning_score": 0.511,
      "distributed_training_score": 0.335,
      "datasets_score": 0.273,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper's main contribution is the development of an efficient diffusion model for image fusion, specifically using Rectified Flow to accelerate sampling in visual tasks. It does not involve adapting diffusion models for complex logical tasks, multi-step reasoning, or treating a chain-of-thought as an entity. Instead, it focuses on generative image processing, which lacks any component of logical reasoning as defined in the topic.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16550",
      "title": "TranTac: Leveraging Transient Tactile Signals for Contact-Rich Robotic\n  Manipulation",
      "authors": [
        "Yinghao Wu",
        "Shuhong Hou",
        "Haowen Zheng",
        "Yichen Li",
        "Weiyi Lu",
        "Xun Zhou",
        "Yitian Shao"
      ],
      "categories": [
        "cs.RO (Robotics)",
        "cs.AI (Artificial Intelligence)",
        "cs.SY (Systems and Control)",
        "eess.SY (Systems and Control)"
      ],
      "abstract": "Robotic manipulation tasks such as inserting a key into a lock or plugging a\nUSB device into a port can fail when visual perception is insufficient to\ndetect misalignment. In these situations, touch sensing is crucial for the\nrobot to monitor the task's states and make precise, timely adjustments.\nCurrent touch sensing solutions are either insensitive to detect subtle changes\nor demand excessive sensor data. Here, we introduce TranTac, a data-efficient\nand low-cost tactile sensing and control framework that integrates a single\ncontact-sensitive 6-axis inertial measurement unit within the elastomeric tips\nof a robotic gripper for completing fine insertion tasks. Our customized\nsensing system can detect dynamic translational and torsional deformations at\nthe micrometer scale, enabling the tracking of visually imperceptible pose\nchanges of the grasped object. By leveraging transformer-based encoders and\ndiffusion policy, TranTac can imitate human insertion behaviors using transient\ntactile cues detected at the gripper's tip during insertion processes. These\ncues enable the robot to dynamically control and correct the 6-DoF pose of the\ngrasped object. When combined with vision, TranTac achieves an average success\nrate of 79% on object grasping and insertion tasks, outperforming both\nvision-only policy and the one augmented with end-effector 6D force/torque\nsensing. Contact localization performance is also validated through\ntactile-only misaligned insertion tasks, achieving an average success rate of\n88%. We assess the generalizability by training TranTac on a single prism-slot\npair and testing it on unseen data, including a USB plug and a metal key, and\nfind that the insertion tasks can still be completed with an average success\nrate of nearly 70%. The proposed framework may inspire new robotic tactile\nsensing systems for delicate manipulation tasks.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16550v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16550v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.341,
      "weak_supervision_score": 0.336,
      "diffusion_reasoning_score": 0.349,
      "distributed_training_score": 0.295,
      "datasets_score": 0.268,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16551",
      "title": "Rethinking the Role of Text Complexity in Language Model Pretraining",
      "authors": [
        "Dan John Velasco",
        "Matthew Theodore Roque"
      ],
      "categories": [
        "cs.CL (Computation and Language)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Improving pretraining data quality and size is known to boost downstream\nperformance, but the role of text complexity--how hard a text is to\nread--remains less explored. We reduce surface-level complexity (shorter\nsentences, simpler words, simpler structure) while keeping core content\napproximately constant and ask: (i) How does complexity affect language\nmodeling across model sizes? (ii) Can useful representations be learned from\nsimpler text alone? (iii) How does pretraining text complexity influence\ndownstream language understanding? We simplify human-written texts using a\nlarge language model, pretrain causal models (28M-500M) from scratch on\noriginal vs. simplified data, and evaluate them in fine-tuning and zero-shot\nsetups. We find that perplexity is sensitive to the interaction between model\ncapacity and text complexity--smaller models degrade far less on simpler\ntexts--while text complexity has little impact on fine-tuning evaluations, with\nzero-shot evaluations indicating that simpler texts benefit performance on\nlinguistic knowledge tasks, whereas more complex texts favor tasks requiring\nworld knowledge and entity tracking. Our findings suggest that different types\nof data diversity affect transfer and zero-shot performance differently,\nproviding insight into tailoring data curation to specific goals.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16551v2",
      "pdf_url": "http://arxiv.org/pdf/2509.16551v2",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.375,
      "weak_supervision_score": 0.4,
      "diffusion_reasoning_score": 0.466,
      "distributed_training_score": 0.367,
      "datasets_score": 0.352,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "Tangentially Relevant",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "The paper involves using a Large Language Model to programmatically generate simplified texts, which could be seen as a form of weak supervision through noisy or imprecise data augmentation. However, the primary focus is on evaluating text complexity in pretraining, not on training models with weakly labeled data as defined.",
      "diffusion_reasoning_justification": "The paper does not mention or utilize diffusion models, iterative refinement processes, or multi-step logical reasoning; it centers on language model pretraining with simplified texts, with no connection to diffusion-based approaches.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16552",
      "title": "ST-GS: Vision-Based 3D Semantic Occupancy Prediction with\n  Spatial-Temporal Gaussian Splatting",
      "authors": [
        "Xiaoyang Yan",
        "Muleilan Pei",
        "Shaojie Shen"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.RO (Robotics)"
      ],
      "abstract": "3D occupancy prediction is critical for comprehensive scene understanding in\nvision-centric autonomous driving. Recent advances have explored utilizing 3D\nsemantic Gaussians to model occupancy while reducing computational overhead,\nbut they remain constrained by insufficient multi-view spatial interaction and\nlimited multi-frame temporal consistency. To overcome these issues, in this\npaper, we propose a novel Spatial-Temporal Gaussian Splatting (ST-GS) framework\nto enhance both spatial and temporal modeling in existing Gaussian-based\npipelines. Specifically, we develop a guidance-informed spatial aggregation\nstrategy within a dual-mode attention mechanism to strengthen spatial\ninteraction in Gaussian representations. Furthermore, we introduce a\ngeometry-aware temporal fusion scheme that effectively leverages historical\ncontext to improve temporal continuity in scene completion. Extensive\nexperiments on the large-scale nuScenes occupancy prediction benchmark showcase\nthat our proposed approach not only achieves state-of-the-art performance but\nalso delivers markedly better temporal consistency compared to existing\nGaussian-based methods.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16552v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16552v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.264,
      "weak_supervision_score": 0.32,
      "diffusion_reasoning_score": 0.394,
      "distributed_training_score": 0.304,
      "datasets_score": 0.285,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16554",
      "title": "ViTCAE: ViT-based Class-conditioned Autoencoder",
      "authors": [
        "Vahid Jebraeeli",
        "Hamid Krim",
        "Derya Cansever"
      ],
      "categories": [
        "cs.LG (Machine Learning)",
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Vision Transformer (ViT) based autoencoders often underutilize the global\nClass token and employ static attention mechanisms, limiting both generative\ncontrol and optimization efficiency. This paper introduces ViTCAE, a framework\nthat addresses these issues by re-purposing the Class token into a generative\nlinchpin. In our architecture, the encoder maps the Class token to a global\nlatent variable that dictates the prior distribution for local, patch-level\nlatent variables, establishing a robust dependency where global semantics\ndirectly inform the synthesis of local details. Drawing inspiration from\nopinion dynamics, we treat each attention head as a dynamical system of\ninteracting tokens seeking consensus. This perspective motivates a\nconvergence-aware temperature scheduler that adaptively anneals each head's\ninfluence function based on its distributional stability. This process enables\na principled head-freezing mechanism, guided by theoretically-grounded\ndiagnostics like an attention evolution distance and a consensus/cluster\nfunctional. This technique prunes converged heads during training to\nsignificantly improve computational efficiency without sacrificing fidelity. By\nunifying a generative Class token with an adaptive attention mechanism rooted\nin multi-agent consensus theory, ViTCAE offers a more efficient and\ncontrollable approach to transformer-based generation.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16554v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16554v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.309,
      "weak_supervision_score": 0.313,
      "diffusion_reasoning_score": 0.406,
      "distributed_training_score": 0.344,
      "datasets_score": 0.325,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on improving Vision Transformer-based autoencoders for image generation and reconstruction, emphasizing the Class token and adaptive attention mechanisms inspired by opinion dynamics. It does not involve diffusion models, iterative refinement for logical tasks, or multi-step reasoning processes like Chain-of-Thought. Therefore, there is no connection to diffusion-based reasoning.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16557",
      "title": "Person Identification from Egocentric Human-Object Interactions using 3D\n  Hand Pose",
      "authors": [
        "Muhammad Hamza",
        "Danish Hamid",
        "Muhammad Tahir Akram"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.ET (Emerging Technologies)",
        "cs.HC (Human-Computer Interaction)",
        "cs.LG (Machine Learning)"
      ],
      "abstract": "Human-Object Interaction Recognition (HOIR) and user identification play a\ncrucial role in advancing augmented reality (AR)-based personalized assistive\ntechnologies. These systems are increasingly being deployed in high-stakes,\nhuman-centric environments such as aircraft cockpits, aerospace maintenance,\nand surgical procedures. This research introduces I2S (Interact2Sign), a multi\nstage framework designed for unobtrusive user identification through human\nobject interaction recognition, leveraging 3D hand pose analysis in egocentric\nvideos. I2S utilizes handcrafted features extracted from 3D hand poses and per\nforms sequential feature augmentation: first identifying the object class,\nfollowed by HOI recognition, and ultimately, user identification. A\ncomprehensive feature extraction and description process was carried out for 3D\nhand poses, organizing the extracted features into semantically meaningful\ncategories: Spatial, Frequency, Kinematic, Orientation, and a novel descriptor\nintroduced in this work, the Inter-Hand Spatial Envelope (IHSE). Extensive\nablation studies were conducted to determine the most effective combination of\nfeatures. The optimal configuration achieved an impressive average F1-score of\n97.52% for user identification, evaluated on a bimanual object manipulation\ndataset derived from the ARCTIC and H2O datasets. I2S demonstrates\nstate-of-the-art performance while maintaining a lightweight model size of\nunder 4 MB and a fast inference time of 0.1 seconds. These characteristics make\nthe proposed framework highly suitable for real-time, on-device authentication\nin security-critical, AR-based systems.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16557v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16557v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.371,
      "weak_supervision_score": 0.277,
      "diffusion_reasoning_score": 0.277,
      "distributed_training_score": 0.266,
      "datasets_score": 0.308,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16560",
      "title": "Captioning for Text-Video Retrieval via Dual-Group Direct Preference\n  Optimization",
      "authors": [
        "Ji Soo Lee",
        "Byungoh Ko",
        "Jaewon Cho",
        "Howoong Lee",
        "Jaewoon Byun",
        "Hyunwoo J. Kim"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "In text-video retrieval, auxiliary captions are often used to enhance video\nunderstanding, bridging the gap between the modalities. While recent advances\nin multi-modal large language models (MLLMs) have enabled strong zero-shot\ncaption generation, we observe that such captions tend to be generic and\nindistinguishable across visually similar videos, limiting their utility for\nfine-grained retrieval. Moreover, conventional captioning approaches are\ntypically evaluated using language generation metrics, such as BLEU, which are\nnot typically tailored for retrieval tasks that require making discriminative\ndistinctions between candidates. To address this, we propose\n$\\textbf{CaRe-DPO}$, a retrieval framework that directly optimizes caption\ngeneration using retrieval relevance scores. At its core is Dual-Group Direct\nPreference Optimization (DG-DPO), a novel learning strategy that supervises\ncaptioning by modeling preferences across groups of distinct video and caption\npairs. In addition, we present an MLLM-based retrieval model that incorporates\nrole-embeddings to better distinguish between textual inputs with different\nfunctional roles, such as an auxiliary caption and a text query. Through\nextensive experiments, we demonstrate that CaRe-DPO significantly enhances\nretrieval performance by effectively leveraging auxiliary knowledge to generate\nfine-grained captions for retrieval. Code is available at\nhttps://github.com/mlvlab/CaReDPO.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16560v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16560v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.415,
      "weak_supervision_score": 0.379,
      "diffusion_reasoning_score": 0.437,
      "distributed_training_score": 0.34,
      "datasets_score": 0.377,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper proposes DG-DPO, a preference optimization method using retrieval relevance scores, but it does not involve human feedback, a reward model trained on human-ranked data, or reinforcement learning based on human preferences. Instead, it focuses on model-based optimization for captioning in text-video retrieval, which does not align with the core elements of RLHF.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper addresses caption generation and optimization for text-video retrieval using preference-based methods, with no mention of diffusion models, iterative refinement processes, or multi-step logical reasoning for complex tasks. It lacks any components related to treating Chain-of-Thought as an entity for holistic correction.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16561",
      "title": "SalaMAnder: Shapley-based Mathematical Expression Attribution and Metric\n  for Chain-of-Thought Reasoning",
      "authors": [
        "Yue Xin",
        "Chen Shen",
        "Shaotian Yan",
        "Xiaosong Yuan",
        "Yaoming Wang",
        "Xiaofeng Zhang",
        "Chenxi Huang",
        "Jieping Ye"
      ],
      "categories": [
        "cs.AI (Artificial Intelligence)",
        "cs.CL (Computation and Language)"
      ],
      "abstract": "Chain-of-Thought (CoT) prompting enhances the math reasoning capability of\nlarge language models (LLMs) to a large margin. However, the mechanism\nunderlying such improvements remains unexplored. In this paper, we present\n\\textbf{SalaMAnder} (\\textbf{S}h\\textbf{a}p\\textbf{l}ey-b\\textbf{a}sed\n\\textbf{M}athematical Expression \\textbf{A}ttribution a\\textbf{nd}\nM\\textbf{e}t\\textbf{r}ic), a theoretically grounded methodology as well as a\nmathematically rigorous evaluation metric for quantifying component-level\ncontributions in few-shot CoT reasoning. Concretely, we leverage the Shapley\nvalue for mathematical expression attribution and develop an efficient\nstratified sampling algorithm that significantly reduces the computational\ncomplexity. Besides, we develop the \\textbf{CoSP} (\\textbf{C}ardinality\n\\textbf{o}f \\textbf{S}hapley \\textbf{P}ositives) metric through covariance\nanalysis. Comprehensive validation across popular LLM models and diverse\nmathematical benchmarks demonstrates that the CoSP metric within our SalaMAnder\nframework exhibits a robust monotonic correlation with model performance, not\nonly providing theoretical explanations for the empirical success of existing\nfew-shot CoT but also establishing mathematically rigorous principles for\nprompt construction optimization. Furthermore, we verify the reliability of the\nexplanation, based on which we unify the insights of previous work.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16561v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16561v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.333,
      "weak_supervision_score": 0.293,
      "diffusion_reasoning_score": 0.476,
      "distributed_training_score": 0.318,
      "datasets_score": 0.318,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on Shapley-based attribution and metrics for Chain-of-Thought reasoning in LLMs, specifically for mathematical expressions. It does not involve diffusion models, iterative refinement processes, or any adaptation of diffusion for logical tasks. Therefore, it lacks any connection to diffusion-based reasoning.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16567",
      "title": "V-CECE: Visual Counterfactual Explanations via Conceptual Edits",
      "authors": [
        "Nikolaos Spanos",
        "Maria Lymperaiou",
        "Giorgos Filandrianos",
        "Konstantinos Thomas",
        "Athanasios Voulodimos",
        "Giorgos Stamou"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Recent black-box counterfactual generation frameworks fail to take into\naccount the semantic content of the proposed edits, while relying heavily on\ntraining to guide the generation process. We propose a novel, plug-and-play\nblack-box counterfactual generation framework, which suggests step-by-step\nedits based on theoretical guarantees of optimal edits to produce human-level\ncounterfactual explanations with zero training. Our framework utilizes a\npre-trained image editing diffusion model, and operates without access to the\ninternals of the classifier, leading to an explainable counterfactual\ngeneration process. Throughout our experimentation, we showcase the explanatory\ngap between human reasoning and neural model behavior by utilizing both\nConvolutional Neural Network (CNN), Vision Transformer (ViT) and Large Vision\nLanguage Model (LVLM) classifiers, substantiated through a comprehensive human\nevaluation.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16567v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16567v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.375,
      "weak_supervision_score": 0.323,
      "diffusion_reasoning_score": 0.494,
      "distributed_training_score": 0.274,
      "datasets_score": 0.327,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Tangentially Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper utilizes a pre-trained image editing diffusion model for generating counterfactual explanations through conceptual edits, leveraging the iterative refinement process of diffusion for image modifications. However, it does not adapt diffusion for multi-step logical reasoning or treat a 'Chain-of-Thought' as a holistic entity to solve complex logical tasks. Instead, the focus is on visual edits for explainability, lacking the core elements of diffusion-based reasoning as defined.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16578",
      "title": "Zero-Shot Human Mobility Forecasting via Large Language Model with\n  Hierarchical Reasoning",
      "authors": [
        "Wenyao Li",
        "Ran Zhang",
        "Pengyang Wang",
        "Yuanchun Zhou",
        "Pengfei Wang"
      ],
      "categories": [
        "cs.AI (Artificial Intelligence)",
        "cs.IR (Information Retrieval)"
      ],
      "abstract": "Human mobility forecasting is important for applications such as\ntransportation planning, urban management, and personalized recommendations.\nHowever, existing methods often fail to generalize to unseen users or locations\nand struggle to capture dynamic intent due to limited labeled data and the\ncomplexity of mobility patterns. We propose ZHMF, a framework for zero-shot\nhuman mobility forecasting that combines a semantic enhanced retrieval and\nreflection mechanism with a hierarchical language model based reasoning system.\nThe task is reformulated as a natural language question answering paradigm.\nLeveraging LLMs semantic understanding of user histories and context, our\napproach handles previously unseen prediction scenarios. We further introduce a\nhierarchical reflection mechanism for iterative reasoning and refinement by\ndecomposing forecasting into an activity level planner and a location level\nselector, enabling collaborative modeling of long term user intentions and\nshort term contextual preferences. Experiments on standard human mobility\ndatasets show that our approach outperforms existing models. Ablation studies\nreveal the contribution of each module, and case studies illustrate how the\nmethod captures user intentions and adapts to diverse contextual scenarios.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16578v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16578v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.457,
      "weak_supervision_score": 0.374,
      "diffusion_reasoning_score": 0.472,
      "distributed_training_score": 0.374,
      "datasets_score": 0.349,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper focuses on using LLMs with hierarchical reasoning for zero-shot human mobility forecasting via prompt engineering, without any mention of human feedback, reward models, or reinforcement learning techniques to align models with preferences.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper describes a hierarchical reflection mechanism for iterative reasoning in mobility forecasting, but it does not involve diffusion models or adapt the iterative refinement process of diffusion for logical tasks; instead, it relies on LLMs and prompt-based reasoning.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16580",
      "title": "Fusing Spectral Correlation Density Imaging with Deep Learning for\n  Intelligent Fault Diagnosis in Rotating Machinery",
      "authors": [
        "Dilshara Herath",
        "Chinthaka Abeyrathne",
        "Chamindu Adithya",
        "Chathura Seneviratne"
      ],
      "categories": [
        "eess.SP (Signal Processing)",
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Bearing fault diagnosis in rotating machinery is critical for ensuring\noperational reliability, therefore early fault detection is essential to avoid\ncatastrophic failures and expensive emergency repairs. Traditional methods like\nFast Fourier Transform (FFT) often fail to capture the complex, non-stationary\nnature of vibration signals. This study leverages the cyclostationary\nproperties of vibration data through Spectral Correlation Density (SCD) images\nto enhance fault detection and apply deep learning for classification. Using a\npublicly available dataset with bearing faults seeded in two distinct housings\n(A and B) under varying load conditions (0 Nm, 2 Nm, 4 Nm), we processed\nvibration signals into 2D SCD images to reveal fault-specific periodicities,\nsuch as broadband spectra (2000--8000 Hz) for larger faults. Three\nconvolutional neural network (CNN) models, Custom CNN, ResNet152V2, and\nEfficientNetB0, were developed to classify seven bearing conditions. The custom\nCNN achieved the highest accuracies of 96.58\\% and 94.95\\% on Housing A and B,\nrespectively, followed by ResNet152V2 at 96.49\\% and 95.35\\%, and\nEfficientNetB0 at 94.16\\% and 91.65\\%, respectively. The models' high\naccuracies across different housings demonstrate a robust solution suitable for\ncost-effective condition monitoring deployable near sensing platforms,\ncontributing to applied machine learning for edge intelligence and showcasing\neffective signal processing strategies for handling complex, potentially\nlarge-scale vibration data.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16580v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16580v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.328,
      "weak_supervision_score": 0.371,
      "diffusion_reasoning_score": 0.346,
      "distributed_training_score": 0.376,
      "datasets_score": 0.382,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16582",
      "title": "A Novel Metric for Detecting Memorization in Generative Models for Brain\n  MRI Synthesis",
      "authors": [
        "Antonio Scardace",
        "Lemuel Puglisi",
        "Francesco Guarnera",
        "Sebastiano Battiato",
        "Daniele Ravì"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.LG (Machine Learning)"
      ],
      "abstract": "Deep generative models have emerged as a transformative tool in medical\nimaging, offering substantial potential for synthetic data generation. However,\nrecent empirical studies highlight a critical vulnerability: these models can\nmemorize sensitive training data, posing significant risks of unauthorized\npatient information disclosure. Detecting memorization in generative models\nremains particularly challenging, necessitating scalable methods capable of\nidentifying training data leakage across large sets of generated samples. In\nthis work, we propose DeepSSIM, a novel self-supervised metric for quantifying\nmemorization in generative models. DeepSSIM is trained to: i) project images\ninto a learned embedding space and ii) force the cosine similarity between\nembeddings to match the ground-truth SSIM (Structural Similarity Index) scores\ncomputed in the image space. To capture domain-specific anatomical features,\ntraining incorporates structure-preserving augmentations, allowing DeepSSIM to\nestimate similarity reliably without requiring precise spatial alignment. We\nevaluate DeepSSIM in a case study involving synthetic brain MRI data generated\nby a Latent Diffusion Model (LDM) trained under memorization-prone conditions,\nusing 2,195 MRI scans from two publicly available datasets (IXI and CoRR).\nCompared to state-of-the-art memorization metrics, DeepSSIM achieves superior\nperformance, improving F1 scores by an average of +52.03% over the best\nexisting method. Code and data of our approach are publicly available at the\nfollowing link: https://github.com/brAIn-science/DeepSSIM.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16582v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16582v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.343,
      "weak_supervision_score": 0.374,
      "diffusion_reasoning_score": 0.457,
      "distributed_training_score": 0.355,
      "datasets_score": 0.388,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper's main contribution is a novel metric (DeepSSIM) for detecting memorization in generative models used for brain MRI synthesis, including a Latent Diffusion Model (LDM). While it mentions diffusion models for image generation, it does not adapt the iterative refinement process of diffusion for solving complex logical tasks, multi-step reasoning, or Chain-of-Thought processes. The focus is on privacy and similarity metrics in medical imaging, not on reasoning applications.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16584",
      "title": "From Scores to Steps: Diagnosing and Improving LLM Performance in\n  Evidence-Based Medical Calculations",
      "authors": [
        "Benlu Wang",
        "Iris Xia",
        "Yifan Zhang",
        "Junda Wang",
        "Feiyun Ouyang",
        "Shuo Han",
        "Arman Cohan",
        "Hong Yu",
        "Zonghai Yao"
      ],
      "categories": [
        "cs.CL (Computation and Language)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Large language models (LLMs) have demonstrated promising performance on\nmedical benchmarks; however, their ability to perform medical calculations, a\ncrucial aspect of clinical decision-making, remains underexplored and poorly\nevaluated. Existing benchmarks often assess only the final answer with a wide\nnumerical tolerance, overlooking systematic reasoning failures and potentially\ncausing serious clinical misjudgments. In this work, we revisit medical\ncalculation evaluation with a stronger focus on clinical trustworthiness.\nFirst, we clean and restructure the MedCalc-Bench dataset and propose a new\nstep-by-step evaluation pipeline that independently assesses formula selection,\nentity extraction, and arithmetic computation. Under this granular framework,\nthe accuracy of GPT-4o drops from 62.7% to 43.6%, revealing errors masked by\nprior evaluations. Second, we introduce an automatic error analysis framework\nthat generates structured attribution for each failure mode. Human evaluation\nconfirms its alignment with expert judgment, enabling scalable and explainable\ndiagnostics. Finally, we propose a modular agentic pipeline, MedRaC, that\ncombines retrieval-augmented generation and Python-based code execution.\nWithout any fine-tuning, MedRaC improves the accuracy of different LLMs from\n16.35% up to 53.19%. Our work highlights the limitations of current benchmark\npractices and proposes a more clinically faithful methodology. By enabling\ntransparent and transferable reasoning evaluation, we move closer to making\nLLM-based systems trustworthy for real-world medical applications.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16584v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16584v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.386,
      "weak_supervision_score": 0.371,
      "diffusion_reasoning_score": 0.452,
      "distributed_training_score": 0.35,
      "datasets_score": 0.357,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on evaluating and improving LLMs for medical calculations through step-by-step pipelines, error analysis, and a modular agentic method (MedRaC). It does not involve diffusion-based models, iterative refinement processes, or any adaptation of diffusion for reasoning tasks. Thus, there is no connection to the topic.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16588",
      "title": "SQS: Enhancing Sparse Perception Models via Query-based Splatting in\n  Autonomous Driving",
      "authors": [
        "Haiming Zhang",
        "Yiyao Zhu",
        "Wending Zhou",
        "Xu Yan",
        "Yingjie Cai",
        "Bingbing Liu",
        "Shuguang Cui",
        "Zhen Li"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.AI (Artificial Intelligence)",
        "cs.RO (Robotics)"
      ],
      "abstract": "Sparse Perception Models (SPMs) adopt a query-driven paradigm that forgoes\nexplicit dense BEV or volumetric construction, enabling highly efficient\ncomputation and accelerated inference. In this paper, we introduce SQS, a novel\nquery-based splatting pre-training specifically designed to advance SPMs in\nautonomous driving. SQS introduces a plug-in module that predicts 3D Gaussian\nrepresentations from sparse queries during pre-training, leveraging\nself-supervised splatting to learn fine-grained contextual features through the\nreconstruction of multi-view images and depth maps. During fine-tuning, the\npre-trained Gaussian queries are seamlessly integrated into downstream networks\nvia query interaction mechanisms that explicitly connect pre-trained queries\nwith task-specific queries, effectively accommodating the diverse requirements\nof occupancy prediction and 3D object detection. Extensive experiments on\nautonomous driving benchmarks demonstrate that SQS delivers considerable\nperformance gains across multiple query-based 3D perception tasks, notably in\noccupancy prediction and 3D object detection, outperforming prior\nstate-of-the-art pre-training approaches by a significant margin (i.e., +1.3\nmIoU on occupancy prediction and +1.0 NDS on 3D detection).",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16588v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16588v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.335,
      "weak_supervision_score": 0.42,
      "diffusion_reasoning_score": 0.421,
      "distributed_training_score": 0.41,
      "datasets_score": 0.336,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "Highly Relevant",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "Not Relevant",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "The paper's main contribution involves self-supervised pre-training using reconstruction of multi-view images and depth maps from unlabeled data, which aligns with weak supervision by generating training signals programmatically without relying on precise, hand-labeled annotations. This approach reduces the need for costly labels, fitting the definition of weak supervision.",
      "diffusion_reasoning_justification": "The paper focuses on query-based splatting and Gaussian representations for 3D perception in autonomous driving, with no mention of diffusion models, iterative refinement processes, or multi-step logical reasoning. There is no component involving diffusion for holistic correction of reasoning paths.",
      "distributed_training_justification": "The paper does not address distributed training, parallel computing, or strategies for partitioning data/computation across multiple nodes. Its contributions are centered on model architecture and self-supervised pre-training, without any discussion of acceleration via multi-processor systems.",
      "datasets_justification": "below_threshold",
      "llm_score_status": "completed",
      "summary": "The paper introduces SQS, a novel pre-training framework designed to enhance Sparse Perception Models (SPMs) for autonomous driving by employing query-based splatting to predict 3D Gaussian representations from sparse queries, enabling self-supervised learning through the reconstruction of multi-view images and depth maps. This approach allows the pre-trained Gaussian queries to integrate seamlessly with task-specific queries during fine-tuning, leading to significant performance improvements in downstream tasks such as occupancy prediction and 3D object detection, with gains of +1.3 mIoU and +1.0 NDS over state-of-the-art methods.",
      "novelty_score": "High",
      "novelty_justification": "The paper introduces a truly new pre-training technique using query-based splatting for Sparse Perception Models, which significantly advances the state-of-the-art by adapting splatting to sparse queries in a way not previously explored.",
      "impact_score": "Moderate",
      "impact_justification": "The work is likely to be cited and built upon in the subfield of autonomous driving perception, as it demonstrates practical improvements in efficiency and accuracy for query-based models, though its influence may be limited to specific applications.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "This paper represents a strong and valuable contribution to computer vision and autonomous driving research, offering innovative methods and empirical evidence that are important for specialists in the field.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/28dcafc85f21ac3a434e3ff6818850fe4ac6ac43",
      "total_authors": 8,
      "authors_found": 8,
      "highest_h_index": 6,
      "average_h_index": 3.125,
      "notable_authors_count": 1,
      "author_h_indexes": [
        {
          "name": "Haiming Zhang",
          "h_index": 6,
          "profile_url": "https://www.semanticscholar.org/author/2261887052"
        },
        {
          "name": "Yiyao Zhu",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2332963014"
        },
        {
          "name": "Wending Zhou",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2332043727"
        },
        {
          "name": "Xu Yan",
          "h_index": 4,
          "profile_url": "https://www.semanticscholar.org/author/2279659190"
        },
        {
          "name": "Yingjie Cai",
          "h_index": 3,
          "profile_url": "https://www.semanticscholar.org/author/2323851085"
        },
        {
          "name": "Bingbing Liu",
          "h_index": 2,
          "profile_url": "https://www.semanticscholar.org/author/2323042847"
        },
        {
          "name": "Shuguang Cui",
          "h_index": 5,
          "profile_url": "https://www.semanticscholar.org/author/2267443266"
        },
        {
          "name": "Zhen Li",
          "h_index": 3,
          "profile_url": "https://www.semanticscholar.org/author/2273909904"
        }
      ]
    },
    {
      "id": "2509.16589",
      "title": "Benchmarking Contextual and Paralinguistic Reasoning in Speech-LLMs: A\n  Case Study with In-the-Wild Data",
      "authors": [
        "Qiongqiong Wang",
        "Hardik Bhupendra Sailor",
        "Tianchi Liu",
        "Wenyu Zhang",
        "Muhammad Huzaifah",
        "Nattadaporn Lertcheva",
        "Shuo Sun",
        "Nancy F. Chen",
        "Jinyang Wu",
        "AiTi Aw"
      ],
      "categories": [
        "cs.CL (Computation and Language)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Recent speech-LLMs have shown impressive performance in tasks like\ntranscription and translation, yet they remain limited in understanding the\nparalinguistic aspects of speech crucial for social and emotional intelligence.\nWe propose CP-Bench, a benchmark for evaluating speech-LLMs on contextual\nparalinguistic reasoning the integration of verbal content with non-verbal cues\nlike emotion and prosody. The benchmark includes two curated question answering\n(QA) datasets requiring both linguistic and empathetic understanding. We\nevaluate state-of-the-art speech-LLMs from both open and closed-source models\nand perform a comprehensive analysis across different question types. The top\ntwo models were further analyzed under temperature tuning to understand its\neffect on this task. Our benchmark reveals a key gap in existing evaluations\nand offers insights into building more context-aware and emotionally\nintelligent speech-capable LLMs.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16589v2",
      "pdf_url": "http://arxiv.org/pdf/2509.16589v2",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.411,
      "weak_supervision_score": 0.397,
      "diffusion_reasoning_score": 0.447,
      "distributed_training_score": 0.352,
      "datasets_score": 0.42,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "Highly Relevant",
      "rlhf_justification": "The paper focuses on benchmarking speech-LLMs for contextual paralinguistic reasoning and evaluating existing models, but it does not involve training models with human feedback, reward models, or reinforcement learning techniques. There is no mention of aligning AI with human preferences through RLHF.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper discusses evaluation of speech-LLMs and temperature tuning for output generation, but it does not involve diffusion models, iterative refinement processes, or multi-step logical reasoning as described. There is no component adapting diffusion for reasoning tasks.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "The paper's main contribution is the creation and evaluation of CP-Bench, including two curated QA datasets for speech-LLMs, along with methodologies for dataset curation, benchmarking, and analysis. This directly aligns with research on datasets for AI applications.",
      "llm_score_status": "completed",
      "summary": "This paper introduces CP-Bench, a novel benchmark designed to evaluate speech-LLMs' ability to perform contextual paralinguistic reasoning by integrating verbal content with non-verbal cues such as emotion and prosody, using two curated question-answering datasets derived from real-world speech data. The authors assess state-of-the-art open and closed-source models, analyze the impact of temperature tuning on performance, and reveal significant limitations in current speech-LLMs, providing insights for developing more empathetic and context-aware systems.",
      "novelty_score": "High",
      "novelty_justification": "The paper introduces a truly new benchmark, CP-Bench, specifically for evaluating contextual paralinguistic reasoning in speech-LLMs, which addresses a gap in existing evaluations and advances the state-of-the-art in multimodal AI.",
      "impact_score": "Moderate",
      "impact_justification": "The work is likely to be cited and built upon within the subfield of speech processing and AI, as it provides a new tool for improving empathetic speech-LLMs, though its influence may be limited to specialized applications.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "This paper offers a high-quality contribution by highlighting critical gaps in speech-LLMs and introducing a useful benchmark, making it valuable for researchers in AI and computational linguistics focused on multimodal understanding.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/7d67ef761639366c7c0112b8daad892953b26958",
      "total_authors": 10,
      "authors_found": 9,
      "highest_h_index": 13,
      "average_h_index": 4.444444444444445,
      "notable_authors_count": 2,
      "author_h_indexes": [
        {
          "name": "Qiongqiong Wang",
          "h_index": 3,
          "profile_url": "https://www.semanticscholar.org/author/2307022655"
        },
        {
          "name": "Hardik B. Sailor",
          "h_index": 13,
          "profile_url": "https://www.semanticscholar.org/author/1916219"
        },
        {
          "name": "Tianchi Liu",
          "h_index": 10,
          "profile_url": "https://www.semanticscholar.org/author/2254792816"
        },
        {
          "name": "Wenyu Zhang",
          "h_index": 4,
          "profile_url": "https://www.semanticscholar.org/author/2306875069"
        },
        {
          "name": "Muhammad Huzaifah",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2381372804"
        },
        {
          "name": "Nattadaporn Lertcheva",
          "h_index": 2,
          "profile_url": "https://www.semanticscholar.org/author/2287315"
        },
        {
          "name": "Shuo Sun",
          "h_index": 4,
          "profile_url": "https://www.semanticscholar.org/author/2307389481"
        },
        {
          "name": "Nancy F. Chen",
          "h_index": null,
          "profile_url": null
        },
        {
          "name": "Jinyang Wu",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2381634990"
        },
        {
          "name": "AiTi Aw",
          "h_index": 3,
          "profile_url": "https://www.semanticscholar.org/author/2308032939"
        }
      ]
    },
    {
      "id": "2509.16590",
      "title": "Question Answering with LLMs and Learning from Answer Sets",
      "authors": [
        "Manuel Borroto",
        "Katie Gallagher",
        "Antonio Ielo",
        "Irfan Kareem",
        "Francesco Ricca",
        "Alessandra Russo"
      ],
      "categories": [
        "cs.AI (Artificial Intelligence)",
        "cs.CL (Computation and Language)",
        "cs.LO (Logic in Computer Science)"
      ],
      "abstract": "Large Language Models (LLMs) excel at understanding natural language but\nstruggle with explicit commonsense reasoning. A recent trend of research\nsuggests that the combination of LLM with robust symbolic reasoning systems can\novercome this problem on story-based question answering tasks. In this setting,\nexisting approaches typically depend on human expertise to manually craft the\nsymbolic component. We argue, however, that this component can also be\nautomatically learned from examples. In this work, we introduce LLM2LAS, a\nhybrid system that effectively combines the natural language understanding\ncapabilities of LLMs, the rule induction power of the Learning from Answer Sets\n(LAS) system ILASP, and the formal reasoning strengths of Answer Set\nProgramming (ASP). LLMs are used to extract semantic structures from text,\nwhich ILASP then transforms into interpretable logic rules. These rules allow\nan ASP solver to perform precise and consistent reasoning, enabling correct\nanswers to previously unseen questions. Empirical results outline the strengths\nand weaknesses of our automatic approach for learning and reasoning in a\nstory-based question answering benchmark.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16590v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16590v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.415,
      "weak_supervision_score": 0.413,
      "diffusion_reasoning_score": 0.503,
      "distributed_training_score": 0.308,
      "datasets_score": 0.366,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "Moderately Relevant",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper focuses on combining LLMs with symbolic reasoning systems like ASP and ILASP to learn logic rules from examples, without any mention of human feedback, reward models, or reinforcement learning for model alignment.",
      "weak_supervision_justification": "The paper involves learning symbolic rules from examples (e.g., stories with questions and answers) using ILASP, which implies limited supervision that could be noisy or programmatically derived, aligning somewhat with weak supervision concepts, though it does not explicitly rely on high-level or imprecise label generation.",
      "diffusion_reasoning_justification": "The paper describes a neuro-symbolic approach using LLMs, ILASP, and ASP for reasoning, with no reference to diffusion models, iterative refinement processes, or treating reasoning paths as entities for multi-step correction.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "completed",
      "summary": "This paper introduces LLM2LAS, a hybrid neuro-symbolic system that combines Large Language Models (LLMs) for natural language understanding, the ILASP system for inductive learning of logic rules from answer sets, and Answer Set Programming (ASP) for formal reasoning to enhance question answering tasks. The core objective is to automate the learning of symbolic rules from examples, eliminating the need for manual crafting, and the methodology involves using LLMs to extract semantic structures from text, which ILASP then transforms into interpretable logic rules for ASP-based reasoning; empirical evaluations on a story-based question answering benchmark demonstrate the approach's strengths in learning and reasoning while revealing its limitations.",
      "novelty_score": "Moderate",
      "novelty_justification": "The paper presents a notable improvement by automating the learning of symbolic rules in neuro-symbolic systems, combining existing technologies like LLMs and ILASP in a clever way to address the limitations of manual knowledge crafting in question answering. However, it builds on prior work in neuro-symbolic AI rather than introducing a entirely new problem or technique.",
      "impact_score": "Moderate",
      "impact_justification": "The work is likely to be cited and built upon in the subfield of neuro-symbolic AI and question answering, as it demonstrates a practical method for automating symbolic learning, potentially improving the scalability of such systems. Nonetheless, its influence may remain confined to specific areas like commonsense reasoning and not extend broadly to general AI applications.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "This paper provides a valuable contribution to hybrid AI approaches for question answering, offering insights into automated symbolic learning that are relevant for researchers in AI reasoning and natural language processing. While not essential for all, it is significant for those working in neuro-symbolic systems.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/d2d5597a0ac7d57b388e15006626000c23817f49",
      "total_authors": 6,
      "authors_found": 6,
      "highest_h_index": 2,
      "average_h_index": 1.5,
      "notable_authors_count": 0,
      "author_h_indexes": [
        {
          "name": "Manuel Borroto",
          "h_index": 2,
          "profile_url": "https://www.semanticscholar.org/author/2122949640"
        },
        {
          "name": "Katie Gallagher",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2328405297"
        },
        {
          "name": "Antonio Ielo",
          "h_index": 2,
          "profile_url": "https://www.semanticscholar.org/author/102919472"
        },
        {
          "name": "Irfan Kareem",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2290180895"
        },
        {
          "name": "Francesco Ricca",
          "h_index": 2,
          "profile_url": "https://www.semanticscholar.org/author/2276961023"
        },
        {
          "name": "Alessandra Russo",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2328561649"
        }
      ]
    },
    {
      "id": "2509.16596",
      "title": "Analyzing the Effects of Supervised Fine-Tuning on Model Knowledge from\n  Token and Parameter Levels",
      "authors": [
        "Junjie Ye",
        "Yuming Yang",
        "Yang Nan",
        "Shuo Li",
        "Qi Zhang",
        "Tao Gui",
        "Xuanjing Huang",
        "Peng Wang",
        "Zhongchao Shi",
        "Jianping Fan"
      ],
      "categories": [
        "cs.CL (Computation and Language)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Large language models (LLMs) acquire substantial world knowledge during\npre-training, which is further shaped by post-training techniques such as\nsupervised fine-tuning (SFT). However, the impact of SFT on a model's knowledge\nremains underexplored, limiting our ability to control knowledge change\nbehavior in fine-tuned models. To address this gap, we evaluate closed-book\nquestion answering (CBQA) performance across five LLMs from the LLaMA-2 and\nLLaMA-3 families. Surprisingly, models fine-tuned on 1,920 samples perform up\nto 14% worse than those fine-tuned on only 240 samples. Furthermore, varying\nthe level of knowledge mastery in the fine-tuning data leads to performance\nfluctuations of over 12%. To investigate these effects, we analyze model\nbehavior at both the token and parameter levels. Our analysis reveals that up\nto 90% of parameter updates during SFT do not contribute to knowledge\nenhancement. Restoring these updates can improve performance on the CBQA task,\ndepending on the characteristics of the fine-tuning data. These insights offer\npractical guidance for developing fine-tuning strategies that more effectively\nstrengthen model knowledge.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16596v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16596v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.407,
      "weak_supervision_score": 0.42,
      "diffusion_reasoning_score": 0.389,
      "distributed_training_score": 0.378,
      "datasets_score": 0.344,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "Not Relevant",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper primarily investigates supervised fine-tuning (SFT) on large language models and its effects on knowledge, with only a brief mention of reinforcement learning in the introduction. It does not involve training a reward model on human-ranked data or using reinforcement learning for alignment, which are core to RLHF.",
      "weak_supervision_justification": "The paper evaluates SFT using categorized fine-tuning data based on knowledge mastery levels but does not involve programmatically generating labels from noisy or imprecise sources, which is the essence of weak supervision. It relies on standard supervised data without addressing weak labeling techniques.",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16598",
      "title": "PruneCD: Contrasting Pruned Self Model to Improve Decoding Factuality",
      "authors": [
        "Byeongho Yu",
        "Changhun Lee",
        "Jungyu Jin",
        "Eunhyeok Park"
      ],
      "categories": [
        "cs.CL (Computation and Language)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "To mitigate the hallucination problem in large language models, DoLa exploits\nearly exit logits from the same model as a contrastive prior. However, we found\nthat these early exit logits tend to be flat, low in magnitude, and fail to\nreflect meaningful contrasts. To address this, we propose PruneCD, a novel\ncontrastive decoding method that constructs the amateur model via layer pruning\nrather than early exit. This design leads to more informative and well-aligned\nlogits, enabling more effective contrastive decoding. Through qualitative and\nquantitative analyses, we demonstrate that PruneCD consistently improves\nfactuality with minimal inference overhead, offering a robust and practical\napproach to mitigating hallucinations in LLMs.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16598v2",
      "pdf_url": "http://arxiv.org/pdf/2509.16598v2",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.379,
      "weak_supervision_score": 0.355,
      "diffusion_reasoning_score": 0.443,
      "distributed_training_score": 0.334,
      "datasets_score": 0.289,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper's main contribution is a contrastive decoding method using layer pruning to improve factuality in large language models by mitigating hallucinations. It does not involve diffusion models, iterative refinement processes, or multi-step logical reasoning for complex tasks, as it focuses solely on decoding techniques within LLMs.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16602",
      "title": "FakeChain: Exposing Shallow Cues in Multi-Step Deepfake Detection",
      "authors": [
        "Minji Heo",
        "Simon S. Woo"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Multi-step or hybrid deepfakes, created by sequentially applying different\ndeepfake creation methods such as Face-Swapping, GAN-based generation, and\nDiffusion methods, can pose an emerging and unforseen technical challenge for\ndetection models trained on single-step forgeries. While prior studies have\nmainly focused on detecting isolated single manipulation, little is known about\nthe detection model behavior under such compositional, hybrid, and complex\nmanipulation pipelines. In this work, we introduce \\textbf{FakeChain}, a\nlarge-scale benchmark comprising 1-, 2-, and 3-Step forgeries synthesized using\nfive state-of-the-art representative generators. Using this approach, we\nanalyze detection performance and spectral properties across hybrid\nmanipulation at different step, along with varying generator combinations and\nquality settings. Surprisingly, our findings reveal that detection performance\nhighly depends on the final manipulation type, with F1-score dropping by up to\n\\textbf{58.83\\%} when it differs from training distribution. This clearly\ndemonstrates that detectors rely on last-stage artifacts rather than cumulative\nmanipulation traces, limiting generalization. Such findings highlight the need\nfor detection models to explicitly consider manipulation history and sequences.\nOur results highlight the importance of benchmarks such as FakeChain,\nreflecting growing synthesis complexity and diversity in real-world scenarios.\nOur sample code is available\nhere\\footnote{https://github.com/minjihh/FakeChain}.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16602v2",
      "pdf_url": "http://arxiv.org/pdf/2509.16602v2",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.357,
      "weak_supervision_score": 0.364,
      "diffusion_reasoning_score": 0.424,
      "distributed_training_score": 0.369,
      "datasets_score": 0.377,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper introduces a benchmark for detecting multi-step deepfakes, which includes diffusion models as part of the generation pipeline for creating synthetic images. However, it does not adapt the iterative refinement process of diffusion models for solving complex logical tasks or treat a 'Chain-of-Thought' as an entity for holistic correction. The focus is solely on image manipulation and detection, with no component for multi-step logical reasoning, making it unrelated to the specified topic.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16609",
      "title": "Describe-to-Score: Text-Guided Efficient Image Complexity Assessment",
      "authors": [
        "Shipeng Liu",
        "Zhonglin Zhang",
        "Dengfeng Chen",
        "Liang Zhao"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Accurately assessing image complexity (IC) is critical for computer vision,\nyet most existing methods rely solely on visual features and often neglect\nhigh-level semantic information, limiting their accuracy and generalization. We\nintroduce vision-text fusion for IC modeling. This approach integrates visual\nand textual semantic features, increasing representational diversity. It also\nreduces the complexity of the hypothesis space, which enhances both accuracy\nand generalization in complexity assessment. We propose the D2S\n(Describe-to-Score) framework, which generates image captions with a\npre-trained vision-language model. We propose the feature alignment and entropy\ndistribution alignment mechanisms, D2S guides semantic information to inform\ncomplexity assessment while bridging the gap between vision and text\nmodalities. D2S utilizes multi-modal information during training but requires\nonly the vision branch during inference, thereby avoiding multi-modal\ncomputational overhead and enabling efficient assessment. Experimental results\ndemonstrate that D2S outperforms existing methods on the IC9600 dataset and\nmaintains competitiveness on no-reference image quality assessment (NR-IQA)\nbenchmark, validating the effectiveness and efficiency of multi-modal fusion in\ncomplexity-related tasks. Code is available at:\nhttps://github.com/xauat-liushipeng/D2S",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16609v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16609v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.364,
      "weak_supervision_score": 0.372,
      "diffusion_reasoning_score": 0.477,
      "distributed_training_score": 0.333,
      "datasets_score": 0.382,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper's main contribution is a vision-text fusion framework for image complexity assessment, using pre-trained vision-language models to generate captions and align features. It does not involve diffusion models, iterative refinement processes, or multi-step logical reasoning for tasks like Chain-of-Thought. Therefore, it lacks any connection to diffusion-based reasoning.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16617",
      "title": "Detection and Simulation of Urban Heat Islands Using a Fine-Tuned\n  Geospatial Foundation Model",
      "authors": [
        "David Kreismann"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "As urbanization and climate change progress, urban heat island effects are\nbecoming more frequent and severe. To formulate effective mitigation plans,\ncities require detailed air temperature data. However, predictive analytics\nmethods based on conventional machine learning models and limited data\ninfrastructure often provide inaccurate predictions, especially in underserved\nareas. In this context, geospatial foundation models trained on unstructured\nglobal data demonstrate strong generalization and require minimal fine-tuning,\noffering an alternative for predictions where traditional approaches are\nlimited. This study fine-tunes a geospatial foundation model to predict urban\nland surface temperatures under future climate scenarios and explores its\nresponse to land cover changes using simulated vegetation strategies. The\nfine-tuned model achieved pixel-wise downscaling errors below 1.74 {\\deg}C and\naligned with ground truth patterns, demonstrating an extrapolation capacity up\nto 3.62 {\\deg}C.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16617v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16617v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.335,
      "weak_supervision_score": 0.327,
      "diffusion_reasoning_score": 0.354,
      "distributed_training_score": 0.338,
      "datasets_score": 0.359,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16618",
      "title": "Surgical-MambaLLM: Mamba2-enhanced Multimodal Large Language Model for\n  VQLA in Robotic Surgery",
      "authors": [
        "Pengfei Hao",
        "Hongqiu Wang",
        "Shuaibo Li",
        "Zhaohu Xing",
        "Guang Yang",
        "Kaishun Wu",
        "Lei Zhu"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "In recent years, Visual Question Localized-Answering in robotic surgery\n(Surgical-VQLA) has gained significant attention for its potential to assist\nmedical students and junior doctors in understanding surgical scenes. Recently,\nthe rapid development of Large Language Models (LLMs) has provided more\npromising solutions for this task. However, current methods struggle to\nestablish complex dependencies between text and visual details, and have\ndifficulty perceiving the spatial information of surgical scenes. To address\nthese challenges, we propose a novel method, Surgical-MambaLLM, which is the\nfirst to combine Mamba2 with LLM in the surgical domain, that leverages\nMamba2's ability to effectively capture cross-modal dependencies and perceive\nspatial information in surgical scenes, thereby enhancing the LLMs'\nunderstanding of surgical images. Specifically, we propose the Cross-modal\nBidirectional Mamba2 Integration (CBMI) module to leverage Mamba2 for effective\nmultimodal fusion, with its cross-modal integration capabilities. Additionally,\ntailored to the geometric characteristics of surgical scenes, we design the\nSurgical Instrument Perception (SIP) scanning mode for Mamba2 to scan the\nsurgical images, enhancing the model's spatial understanding of the surgical\nscene. Extensive experiments demonstrate that our Surgical-MambaLLM model\noutperforms the state-of-the-art methods on the EndoVis17-VQLA and\nEndoVis18-VQLA datasets, significantly improving the performance of the\nSurgical-VQLA task.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16618v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16618v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.353,
      "weak_supervision_score": 0.375,
      "diffusion_reasoning_score": 0.415,
      "distributed_training_score": 0.333,
      "datasets_score": 0.295,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on integrating Mamba2 with Large Language Models for Visual Question Localized-Answering in robotic surgery, emphasizing cross-modal fusion and spatial perception. It does not involve diffusion models, iterative refinement processes, or multi-step logical reasoning as described in the topic. Therefore, there is no connection to diffusion-based reasoning.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16622",
      "title": "Audio-Conditioned Diffusion LLMs for ASR and Deliberation Processing",
      "authors": [
        "Mengqi Wang",
        "Zhan Liu",
        "Zengrui Jin",
        "Guangzhi Sun",
        "Chao Zhang",
        "Philip C. Woodland"
      ],
      "categories": [
        "eess.AS (Audio and Speech Processing)",
        "cs.AI (Artificial Intelligence)",
        "cs.SD (Sound)"
      ],
      "abstract": "Diffusion-based large language models (DLLMs) have recently attracted growing\ninterest as an alternative to autoregressive decoders. In this work, we present\nan empirical study on using the diffusion-based large language model LLaDA for\nautomatic speech recognition (ASR). We first investigate its use as an external\ndeliberation-based processing module for Whisper-LLaMA transcripts. By\nleveraging the bidirectional attention and denoising capabilities of LLaDA, we\nexplore random masking, low-confidence masking, and semi-autoregressive\nstrategies, showing that Whisper-LLaDA substantially reduces WER compared with\nthe baseline. On LibriSpeech, the best cascade system achieves 2.25%/4.94% WER\non test-clean/test-other, representing a 12.3% relative improvement over the\nWhisper-LLaMA baseline on the test-other split. In contrast, a plain-text LLaDA\nwithout acoustic features fails to improve accuracy, highlighting the\nimportance of audio-conditioned embeddings. We further evaluate Whisper-LLaDA\nas a standalone decoder for ASR with diffusion-based and semi-autoregressive\ndecoding. Most experimental configurations achieve faster inference than the\nWhisper-LLaMA baseline, although recognition accuracy is slightly lower. These\nfindings offer an empirical view of diffusion-based LLMs for ASR and point to\npromising directions for improvements.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16622v2",
      "pdf_url": "http://arxiv.org/pdf/2509.16622v2",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.384,
      "weak_supervision_score": 0.4,
      "diffusion_reasoning_score": 0.585,
      "distributed_training_score": 0.371,
      "datasets_score": 0.299,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "Not Relevant",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "The paper focuses on applying diffusion-based language models to ASR tasks, such as refining transcripts and decoding, without any discussion of training models using programmatically generated, noisy, or imprecise labels. It relies on pre-trained models like LLaDA and Whisper-LLaMA, emphasizing inference strategies rather than weak supervision techniques.",
      "diffusion_reasoning_justification": "The paper uses diffusion models for iterative refinement in ASR, such as denoising transcripts, but does not adapt this process to solve complex logical tasks or treat a chain-of-thought as a single entity for holistic correction. The application is limited to speech recognition, lacking any clear component for multi-step logical reasoning.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16623",
      "title": "CGTGait: Collaborative Graph and Transformer for Gait Emotion\n  Recognition",
      "authors": [
        "Junjie Zhou",
        "Haijun Xiong",
        "Junhao Lu",
        "Ziyu Lin",
        "Bin Feng"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Skeleton-based gait emotion recognition has received significant attention\ndue to its wide-ranging applications. However, existing methods primarily focus\non extracting spatial and local temporal motion information, failing to capture\nlong-range temporal representations. In this paper, we propose\n\\textbf{CGTGait}, a novel framework that collaboratively integrates graph\nconvolution and transformers to extract discriminative spatiotemporal features\nfor gait emotion recognition. Specifically, CGTGait consists of multiple CGT\nblocks, where each block employs graph convolution to capture frame-level\nspatial topology and the transformer to model global temporal dependencies.\nAdditionally, we introduce a Bidirectional Cross-Stream Fusion (BCSF) module to\neffectively aggregate posture and motion spatiotemporal features, facilitating\nthe exchange of complementary information between the two streams. We evaluate\nour method on two widely used datasets, Emotion-Gait and ELMD, demonstrating\nthat our CGTGait achieves state-of-the-art or at least competitive performance\nwhile reducing computational complexity by approximately \\textbf{82.2\\%} (only\nrequiring 0.34G FLOPs) during testing. Code is available at\n\\small{https://github.com/githubzjj1/CGTGait.}",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16623v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16623v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.297,
      "weak_supervision_score": 0.257,
      "diffusion_reasoning_score": 0.389,
      "distributed_training_score": 0.314,
      "datasets_score": 0.304,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16628",
      "title": "Enhancing Scientific Visual Question Answering via Vision-Caption aware\n  Supervised Fine-Tuning",
      "authors": [
        "Janak Kapuriya",
        "Anwar Shaikh",
        "Arnav Goel",
        "Medha Hira",
        "Apoorv Singh",
        "Jay Saraf",
        "Sanjana",
        "Vaibhav Nauriyal",
        "Avinash Anand",
        "Zhengkui Wang",
        "Rajiv Ratn Shah"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "In this study, we introduce Vision-Caption aware Supervised FineTuning\n(VCASFT), a novel learning paradigm designed to enhance the performance of\nsmaller Vision Language Models(VLMs) on scientific visual question\nanswering(VQA) tasks. VCASFT leverages image captions as zero-shot prompts\nalongside question-answer pairs and instruction-tunes models to yield\nsignificant performance improvements. To comprehensively evaluate VCASFT, we\nbenchmark it on ScienceQA, which consists of questions across diverse\nlanguages, subjects, and fields, demonstrating its adaptability and\neffectiveness in a variety of educational contexts. Additionally, to further\ndemonstrate the effectiveness of this technique on lowresource languages, we\ndeveloped HiSciVQA, a dataset comprising 2,245 high-quality, hand-annotated\nHindi multimodal Q&A pairs. This dataset addresses the critical need for\nlow-resource language Q&A datasets and serves as a foundation for testing\nVCASFT. Additionally, we introduce a novel LLM-based evaluation scheme to\nevaluate VLMs on HiSciVQA which offers deeper insights into model effectiveness\nsurpassing traditional n-gram matching accuracy metrics. We are committed to\nadvancing the field by open-sourcing all code files and the HiSciVQA dataset\nfor the research community.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16628v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16628v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.369,
      "weak_supervision_score": 0.4,
      "diffusion_reasoning_score": 0.423,
      "distributed_training_score": 0.35,
      "datasets_score": 0.381,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "Moderately Relevant",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "The paper introduces VCASFT, which uses generated image captions as zero-shot prompts for fine-tuning Vision Language Models. This aligns with weak supervision as the captions are likely programmatically generated and potentially noisy, serving as imprecise labels alongside question-answer pairs, though the core method is not explicitly framed as weak supervision.",
      "diffusion_reasoning_justification": "The paper focuses on supervised fine-tuning with image captions for Vision Language Models and does not mention or involve diffusion models, iterative refinement processes, or any multi-step logical reasoning via diffusion techniques.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "completed",
      "summary": "This paper introduces Vision-Caption aware Supervised Fine-Tuning (VCASFT), a novel method that enhances smaller Vision Language Models (VLMs) for scientific visual question answering by incorporating image captions as zero-shot prompts during fine-tuning, evaluated on the ScienceQA dataset where it achieves significant performance gains, such as an 8% improvement on 7-billion parameter models. The authors also create HiSciVQA, a new dataset of 2,245 hand-annotated Hindi multimodal Q&A pairs, and propose an LLM-based evaluation scheme for deeper insights, demonstrating VCASFT's effectiveness in low-resource languages with up to a 15% performance boost on a 1.7-billion parameter model, while open-sourcing the code and dataset for broader research accessibility.",
      "novelty_score": "Moderate",
      "novelty_justification": "The paper presents a clever combination of existing fine-tuning techniques with image captions for scientific VQA, introducing a new method and dataset that notably improves model performance in a specific context, though it doesn't introduce a entirely new problem or architecture.",
      "impact_score": "Moderate",
      "impact_justification": "The work is likely to influence research in multilingual and scientific VQA by providing a new dataset and method, potentially leading to citations and builds in subfields, especially for low-resource languages, due to its open-sourcing.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "This paper offers a valuable contribution with practical innovations like VCASFT and HiSciVQA, making it important for researchers in computer vision and multilingual AI, though it's not essential for all audiences.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/5ae5b7a4cdabb43afbe050b71b388e4edaafb744",
      "total_authors": 11,
      "authors_found": 11,
      "highest_h_index": 42,
      "average_h_index": 6.909090909090909,
      "notable_authors_count": 4,
      "author_h_indexes": [
        {
          "name": "Janak Kapuriya",
          "h_index": 3,
          "profile_url": "https://www.semanticscholar.org/author/2287841157"
        },
        {
          "name": "A. Shaikh",
          "h_index": 6,
          "profile_url": "https://www.semanticscholar.org/author/3022676"
        },
        {
          "name": "Arnav Goel",
          "h_index": 6,
          "profile_url": "https://www.semanticscholar.org/author/2240490"
        },
        {
          "name": "Medha Hira",
          "h_index": 4,
          "profile_url": "https://www.semanticscholar.org/author/2223137354"
        },
        {
          "name": "Apoorv Singh",
          "h_index": 3,
          "profile_url": "https://www.semanticscholar.org/author/2296730605"
        },
        {
          "name": "Jay Saraf",
          "h_index": 2,
          "profile_url": "https://www.semanticscholar.org/author/2296711567"
        },
        {
          "name": "Sanjana",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2381375361"
        },
        {
          "name": "Vaibhav Nauriyal",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2381375208"
        },
        {
          "name": "Avinash Anand",
          "h_index": 9,
          "profile_url": "https://www.semanticscholar.org/author/2223123570"
        },
        {
          "name": "Zheng Wang",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2323979762"
        },
        {
          "name": "R. Shah",
          "h_index": 42,
          "profile_url": "https://www.semanticscholar.org/author/1753278"
        }
      ]
    },
    {
      "id": "2509.16630",
      "title": "Follow-Your-Emoji-Faster: Towards Efficient, Fine-Controllable, and\n  Expressive Freestyle Portrait Animation",
      "authors": [
        "Yue Ma",
        "Zexuan Yan",
        "Hongyu Liu",
        "Hongfa Wang",
        "Heng Pan",
        "Yingqing He",
        "Junkun Yuan",
        "Ailing Zeng",
        "Chengfei Cai",
        "Heung-Yeung Shum",
        "Zhifeng Li",
        "Wei Liu",
        "Linfeng Zhang",
        "Qifeng Chen"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "We present Follow-Your-Emoji-Faster, an efficient diffusion-based framework\nfor freestyle portrait animation driven by facial landmarks. The main\nchallenges in this task are preserving the identity of the reference portrait,\naccurately transferring target expressions, and maintaining long-term temporal\nconsistency while ensuring generation efficiency. To address identity\npreservation and accurate expression retargeting, we enhance Stable Diffusion\nwith two key components: a expression-aware landmarks as explicit motion\nsignals, which improve motion alignment, support exaggerated expressions, and\nreduce identity leakage; and a fine-grained facial loss that leverages both\nexpression and facial masks to better capture subtle expressions and faithfully\npreserve the reference appearance. With these components, our model supports\ncontrollable and expressive animation across diverse portrait types, including\nreal faces, cartoons, sculptures, and animals. However, diffusion-based\nframeworks typically struggle to efficiently generate long-term stable\nanimation results, which remains a core challenge in this task. To address\nthis, we propose a progressive generation strategy for stable long-term\nanimation, and introduce a Taylor-interpolated cache, achieving a 2.6X lossless\nacceleration. These two strategies ensure that our method produces high-quality\nresults efficiently, making it user-friendly and accessible. Finally, we\nintroduce EmojiBench++, a more comprehensive benchmark comprising diverse\nportraits, driving videos, and landmark sequences. Extensive evaluations on\nEmojiBench++ demonstrate that Follow-Your-Emoji-Faster achieves superior\nperformance in both animation quality and controllability. The code, training\ndataset and benchmark will be found in https://follow-your-emoji.github.io/.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16630v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16630v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.344,
      "weak_supervision_score": 0.305,
      "diffusion_reasoning_score": 0.433,
      "distributed_training_score": 0.338,
      "datasets_score": 0.29,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on using diffusion models for portrait animation, specifically enhancing Stable Diffusion for generating expressive and efficient video sequences from facial landmarks. While it employs the iterative refinement process of diffusion for image generation, it does not adapt this process for complex logical tasks, such as treating a 'Chain-of-Thought' as a single entity for holistic correction in reasoning. There is no component for multi-step logical reasoning, making the paper unrelated to this topic.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16632",
      "title": "DA-Font: Few-Shot Font Generation via Dual-Attention Hybrid Integration",
      "authors": [
        "Weiran Chen",
        "Guiqian Zhu",
        "Ying Li",
        "Yi Ji",
        "Chunping Liu"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Few-shot font generation aims to create new fonts with a limited number of\nglyph references. It can be used to significantly reduce the labor cost of\nmanual font design. However, due to the variety and complexity of font styles,\nthe results generated by existing methods often suffer from visible defects,\nsuch as stroke errors, artifacts and blurriness. To address these issues, we\npropose DA-Font, a novel framework which integrates a Dual-Attention Hybrid\nModule (DAHM). Specifically, we introduce two synergistic attention blocks: the\ncomponent attention block that leverages component information from content\nimages to guide the style transfer process, and the relation attention block\nthat further refines spatial relationships through interacting the content\nfeature with both original and stylized component-wise representations. These\ntwo blocks collaborate to preserve accurate character shapes and stylistic\ntextures. Moreover, we also design a corner consistency loss and an elastic\nmesh feature loss to better improve geometric alignment. Extensive experiments\nshow that our DA-Font outperforms the state-of-the-art methods across diverse\nfont styles and characters, demonstrating its effectiveness in enhancing\nstructural integrity and local fidelity. The source code can be found at\n\\href{https://github.com/wrchen2001/DA-Font}{\\textit{https://github.com/wrchen2001/DA-Font}}.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16632v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16632v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.348,
      "weak_supervision_score": 0.31,
      "diffusion_reasoning_score": 0.423,
      "distributed_training_score": 0.341,
      "datasets_score": 0.335,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on few-shot font generation using a Dual-Attention Hybrid Module and attention mechanisms, with mentions of diffusion models only in the general context of deep learning techniques. However, it does not involve adapting diffusion for iterative refinement in solving complex logical tasks or multi-step reasoning. The core contributions are in font style transfer and geometric alignment, not diffusion-based reasoning.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16633",
      "title": "When Big Models Train Small Ones: Label-Free Model Parity Alignment for\n  Efficient Visual Question Answering using Small VLMs",
      "authors": [
        "Abhirama Subramanyam Penamakuri",
        "Navlika Singh",
        "Piyush Arora",
        "Anand Mishra"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.AI (Artificial Intelligence)",
        "cs.CL (Computation and Language)"
      ],
      "abstract": "Large Vision-Language Models (L-VLMs) have demonstrated remarkable\nperformance in various vision and language tasks, including visual question\nanswering (VQA). However, their high computational cost makes them impractical\nfor resource-constrained settings and inference-heavy applications. In\ncontrast, Small Vision-Language Models (S-VLMs) offer efficiency but suffer\nfrom a significant performance gap compared to their larger counterparts. In\nthis work, we introduce the Model Parity Aligner (MPA), a novel framework\ndesigned to systematically improve S-VLMs by leveraging unlabeled images and\neffective knowledge transfer from L-VLMs. Instead of traditional knowledge\ndistillation methods that rely on labeled training data, MPA employs a\nstrategic parity-based approach that precisely identifies the knowledge\ndisparities between S-VLMs and L-VLMs, and optimizes training by targeting only\nthese disparities. We conduct extensive experiments on four diverse VQA\nbenchmarks, namely TextVQA, ST-VQA, ChartQA, and OKVQA, each of which requires\nspecialized reasoning capabilities such as text recognition, chart\ninterpretation, and commonsense and factual understanding. Our results\ndemonstrate that MPA consistently enhances the performance of S-VLMs on all\nbenchmarks, reducing the performance gap while maintaining computational\nefficiency. We make our code publicly available.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16633v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16633v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.402,
      "weak_supervision_score": 0.467,
      "diffusion_reasoning_score": 0.416,
      "distributed_training_score": 0.431,
      "datasets_score": 0.369,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "Highly Relevant",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "Not Relevant",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper focuses on knowledge transfer from large to small VLMs using pseudo-labels on unlabeled images, without any involvement of human feedback, reward models, or reinforcement learning techniques.",
      "weak_supervision_justification": "The paper's MPA framework uses pseudo-labels generated programmatically from L-VLMs on unlabeled images, which aligns directly with weak supervision by relying on noisy, high-level sources for training labels instead of hand-annotated data.",
      "diffusion_reasoning_justification": "The paper does not involve diffusion models, iterative refinement processes, or multi-step logical reasoning; it centers on knowledge alignment and pseudo-labeling for VQA, without any components related to diffusion-based approaches.",
      "distributed_training_justification": "The paper does not address distributed training, parallel computing, or multi-node systems; it focuses solely on the MPA framework for knowledge transfer, with no mention of computational partitioning or acceleration techniques.",
      "datasets_justification": "below_threshold",
      "llm_score_status": "completed",
      "summary": "This paper introduces the Model Parity Aligner (MPA), a novel framework designed to enhance the performance of small vision-language models (S-VLMs) for visual question answering (VQA) by transferring knowledge from large VLMs (L-VLMs) using only unlabeled images. The methodology involves identifying knowledge disparities between S-VLMs and L-VLMs, generating high-quality pseudo-labels through parity-based alignment, and optimizing training to target these gaps, resulting in consistent performance improvements across four diverse VQA benchmarks like TextVQA and ChartQA, while maintaining computational efficiency and reducing the performance gap without requiring labeled data.",
      "novelty_score": "Moderate",
      "novelty_justification": "The paper presents a notable improvement by combining existing techniques like knowledge distillation and pseudo-labeling into a new parity-based framework for efficient knowledge transfer in VQA, though it does not introduce an entirely new problem or architecture. This approach effectively addresses a known challenge in resource-constrained settings but builds on prior ideas rather than creating a groundbreaking innovation.",
      "impact_score": "Moderate",
      "impact_justification": "The work is likely to influence research in efficient AI models and VQA within subfields like computer vision and artificial intelligence, as it demonstrates practical ways to improve smaller models using unlabeled data. However, its applicability may be limited to specific domains and not broadly transformative across all AI applications.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "This paper offers a valuable contribution to knowledge transfer in vision-language models, making it relevant for researchers in efficient AI and VQA who can benefit from its practical insights and experimental results. While not essential for all, it represents a strong advancement worth considering for those focused on resource-efficient machine learning.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/c6e3d1b8ce67a96025fe4526a11ba66ef747e33a",
      "total_authors": 4,
      "authors_found": 3,
      "highest_h_index": 10,
      "average_h_index": 4.0,
      "notable_authors_count": 1,
      "author_h_indexes": [
        {
          "name": "A. S. Penamakuri",
          "h_index": 2,
          "profile_url": "https://www.semanticscholar.org/author/2187933424"
        },
        {
          "name": "Navlika Singh",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2381817450"
        },
        {
          "name": "Piyush Arora",
          "h_index": 10,
          "profile_url": "https://www.semanticscholar.org/author/50128338"
        },
        {
          "name": "Anand Mishra",
          "h_index": null,
          "profile_url": null
        }
      ]
    },
    {
      "id": "2509.16635",
      "title": "Towards Anytime Retrieval: A Benchmark for Anytime Person\n  Re-Identification",
      "authors": [
        "Xulin Li",
        "Yan Lu",
        "Bin Liu",
        "Jiaze Li",
        "Qinhong Yang",
        "Tao Gong",
        "Qi Chu",
        "Mang Ye",
        "Nenghai Yu"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "In real applications, person re-identification (ReID) is expected to retrieve\nthe target person at any time, including both daytime and nighttime, ranging\nfrom short-term to long-term. However, existing ReID tasks and datasets can not\nmeet this requirement, as they are constrained by available time and only\nprovide training and evaluation for specific scenarios. Therefore, we\ninvestigate a new task called Anytime Person Re-identification (AT-ReID), which\naims to achieve effective retrieval in multiple scenarios based on variations\nin time. To address the AT-ReID problem, we collect the first large-scale\ndataset, AT-USTC, which contains 403k images of individuals wearing multiple\nclothes captured by RGB and IR cameras. Our data collection spans 21 months,\nand 270 volunteers were photographed on average 29.1 times across different\ndates or scenes, 4-15 times more than current datasets, providing conditions\nfor follow-up investigations in AT-ReID. Further, to tackle the new challenge\nof multi-scenario retrieval, we propose a unified model named Uni-AT, which\ncomprises a multi-scenario ReID (MS-ReID) framework for scenario-specific\nfeatures learning, a Mixture-of-Attribute-Experts (MoAE) module to alleviate\ninter-scenario interference, and a Hierarchical Dynamic Weighting (HDW)\nstrategy to ensure balanced training across all scenarios. Extensive\nexperiments show that our model leads to satisfactory results and exhibits\nexcellent generalization to all scenarios.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16635v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16635v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.312,
      "weak_supervision_score": 0.301,
      "diffusion_reasoning_score": 0.311,
      "distributed_training_score": 0.313,
      "datasets_score": 0.374,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16638",
      "title": "KungfuBot2: Learning Versatile Motion Skills for Humanoid Whole-Body\n  Control",
      "authors": [
        "Jinrui Han",
        "Weiji Xie",
        "Jiakun Zheng",
        "Jiyuan Shi",
        "Weinan Zhang",
        "Ting Xiao",
        "Chenjia Bai"
      ],
      "categories": [
        "cs.RO (Robotics)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Learning versatile whole-body skills by tracking various human motions is a\nfundamental step toward general-purpose humanoid robots. This task is\nparticularly challenging because a single policy must master a broad repertoire\nof motion skills while ensuring stability over long-horizon sequences. To this\nend, we present VMS, a unified whole-body controller that enables humanoid\nrobots to learn diverse and dynamic behaviors within a single policy. Our\nframework integrates a hybrid tracking objective that balances local motion\nfidelity with global trajectory consistency, and an Orthogonal\nMixture-of-Experts (OMoE) architecture that encourages skill specialization\nwhile enhancing generalization across motions. A segment-level tracking reward\nis further introduced to relax rigid step-wise matching, enhancing robustness\nwhen handling global displacements and transient inaccuracies. We validate VMS\nextensively in both simulation and real-world experiments, demonstrating\naccurate imitation of dynamic skills, stable performance over minute-long\nsequences, and strong generalization to unseen motions. These results highlight\nthe potential of VMS as a scalable foundation for versatile humanoid whole-body\ncontrol. The project page is available at\nhttps://kungfubot2-humanoid.github.io.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16638v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16638v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.371,
      "weak_supervision_score": 0.312,
      "diffusion_reasoning_score": 0.326,
      "distributed_training_score": 0.332,
      "datasets_score": 0.281,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16639",
      "title": "Unlocking Hidden Potential in Point Cloud Networks with Attention-Guided\n  Grouping-Feature Coordination",
      "authors": [
        "Shangzhuo Xie",
        "Qianqian Yang"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Point cloud analysis has evolved with diverse network architectures, while\nexisting works predominantly focus on introducing novel structural designs.\nHowever, conventional point-based architectures - processing raw points through\nsequential sampling, grouping, and feature extraction layers - demonstrate\nunderutilized potential. We notice that substantial performance gains can be\nunlocked through strategic module integration rather than structural\nmodifications. In this paper, we propose the Grouping-Feature Coordination\nModule (GF-Core), a lightweight separable component that simultaneously\nregulates both grouping layer and feature extraction layer to enable more\nnuanced feature aggregation. Besides, we introduce a self-supervised\npretraining strategy specifically tailored for point-based inputs to enhance\nmodel robustness in complex point cloud analysis scenarios. On ModelNet40\ndataset, our method elevates baseline networks to 94.0% accuracy, matching\nadvanced frameworks' performance while preserving architectural simplicity. On\nthree variants of the ScanObjectNN dataset, we obtain improvements of 2.96%,\n6.34%, and 6.32% respectively.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16639v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16639v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.345,
      "weak_supervision_score": 0.358,
      "diffusion_reasoning_score": 0.386,
      "distributed_training_score": 0.428,
      "datasets_score": 0.334,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "Not Relevant",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "The paper focuses on enhancing point cloud network architectures through the introduction of the Grouping-Feature Coordination Module (GF-Core) and a self-supervised pretraining strategy, aiming to improve feature aggregation and model robustness. It does not address distributed training, parallel computing, multi-node machine learning, or any methods for partitioning data or computation across processors or nodes.",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16645",
      "title": "ADVEDM:Fine-grained Adversarial Attack against VLM-based Embodied Agents",
      "authors": [
        "Yichen Wang",
        "Hangtao Zhang",
        "Hewen Pan",
        "Ziqi Zhou",
        "Xianlong Wang",
        "Peijin Guo",
        "Lulu Xue",
        "Shengshan Hu",
        "Minghui Li",
        "Leo Yu Zhang"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Vision-Language Models (VLMs), with their strong reasoning and planning\ncapabilities, are widely used in embodied decision-making (EDM) tasks in\nembodied agents, such as autonomous driving and robotic manipulation. Recent\nresearch has increasingly explored adversarial attacks on VLMs to reveal their\nvulnerabilities. However, these attacks either rely on overly strong\nassumptions, requiring full knowledge of the victim VLM, which is impractical\nfor attacking VLM-based agents, or exhibit limited effectiveness. The latter\nstems from disrupting most semantic information in the image, which leads to a\nmisalignment between the perception and the task context defined by system\nprompts. This inconsistency interrupts the VLM's reasoning process, resulting\nin invalid outputs that fail to affect interactions in the physical world. To\nthis end, we propose a fine-grained adversarial attack framework, ADVEDM, which\nmodifies the VLM's perception of only a few key objects while preserving the\nsemantics of the remaining regions. This attack effectively reduces conflicts\nwith the task context, making VLMs output valid but incorrect decisions and\naffecting the actions of agents, thus posing a more substantial safety threat\nin the physical world. We design two variants of based on this framework,\nADVEDM-R and ADVEDM-A, which respectively remove the semantics of a specific\nobject from the image and add the semantics of a new object into the image. The\nexperimental results in both general scenarios and EDM tasks demonstrate\nfine-grained control and excellent attack performance.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16645v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16645v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.411,
      "weak_supervision_score": 0.357,
      "diffusion_reasoning_score": 0.446,
      "distributed_training_score": 0.316,
      "datasets_score": 0.309,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper focuses on adversarial attacks against Vision-Language Models in embodied decision-making tasks, with no mention of reinforcement learning, human feedback, reward models, or fine-tuning based on human preferences.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper addresses adversarial attacks that disrupt Chain-of-Thought reasoning in VLMs, but it does not involve diffusion models, iterative refinement processes, or any adaptation of diffusion for multi-step logical reasoning.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16648",
      "title": "FESTA: Functionally Equivalent Sampling for Trust Assessment of\n  Multimodal LLMs",
      "authors": [
        "Debarpan Bhattacharya",
        "Apoorva Kulkarni",
        "Sriram Ganapathy"
      ],
      "categories": [
        "cs.AI (Artificial Intelligence)",
        "cs.CL (Computation and Language)",
        "cs.LG (Machine Learning)"
      ],
      "abstract": "The accurate trust assessment of multimodal large language models (MLLMs)\ngenerated predictions, which can enable selective prediction and improve user\nconfidence, is challenging due to the diverse multi-modal input paradigms. We\npropose Functionally Equivalent Sampling for Trust Assessment (FESTA), a\nmultimodal input sampling technique for MLLMs, that generates an uncertainty\nmeasure based on the equivalent and complementary input samplings. The proposed\ntask-preserving sampling approach for uncertainty quantification expands the\ninput space to probe the consistency (through equivalent samples) and\nsensitivity (through complementary samples) of the model. FESTA uses only\ninput-output access of the model (black-box), and does not require ground truth\n(unsupervised). The experiments are conducted with various off-the-shelf\nmulti-modal LLMs, on both visual and audio reasoning tasks. The proposed FESTA\nuncertainty estimate achieves significant improvement (33.3% relative\nimprovement for vision-LLMs and 29.6% relative improvement for audio-LLMs) in\nselective prediction performance, based on\narea-under-receiver-operating-characteristic curve (AUROC) metric in detecting\nmispredictions. The code implementation is open-sourced.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16648v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16648v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.396,
      "weak_supervision_score": 0.382,
      "diffusion_reasoning_score": 0.429,
      "distributed_training_score": 0.327,
      "datasets_score": 0.346,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper's main contribution is a sampling technique (FESTA) for uncertainty quantification in multimodal LLMs, focusing on equivalent and complementary input samples to assess model consistency and sensitivity. It does not involve diffusion models, iterative refinement processes, or treating Chain-of-Thought as a holistic entity for logical tasks. Thus, there is no connection to diffusion-based reasoning.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16649",
      "title": "AISTAT lab system for DCASE2025 Task6: Language-based audio retrieval",
      "authors": [
        "Hyun Jun Kim",
        "Hyeong Yong Choi",
        "Changwon Lim"
      ],
      "categories": [
        "cs.SD (Sound)",
        "cs.AI (Artificial Intelligence)",
        "eess.AS (Audio and Speech Processing)"
      ],
      "abstract": "This report presents the AISTAT team's submission to the language-based audio\nretrieval task in DCASE 2025 Task 6. Our proposed system employs dual encoder\narchitecture, where audio and text modalities are encoded separately, and their\nrepresentations are aligned using contrastive learning. Drawing inspiration\nfrom methodologies of the previous year's challenge, we implemented a\ndistillation approach and leveraged large language models (LLMs) for effective\ndata augmentation techniques, including back-translation and LLM mix.\nAdditionally, we incorporated clustering to introduce an auxiliary\nclassification task for further finetuning. Our best single system achieved a\nmAP@16 of 46.62, while an ensemble of four systems reached a mAP@16 of 48.83 on\nthe Clotho development test split.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16649v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16649v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.33,
      "weak_supervision_score": 0.295,
      "diffusion_reasoning_score": 0.366,
      "distributed_training_score": 0.299,
      "datasets_score": 0.369,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16654",
      "title": "Are VLMs Ready for Lane Topology Awareness in Autonomous Driving?",
      "authors": [
        "Xin Chen",
        "Jia He",
        "Maozheng Li",
        "Dongliang Xu",
        "Tianyu Wang",
        "Yixiao Chen",
        "Zhixin Lin",
        "Yue Yao"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Vision-Language Models (VLMs) have recently shown remarkable progress in\nmultimodal reasoning, yet their applications in autonomous driving remain\nlimited. In particular, the ability to understand road topology, a key\nrequirement for safe navigation, has received relatively little attention.\nWhile some recent works have begun to explore VLMs in driving contexts, their\nperformance on topology reasoning is far from satisfactory. In this work, we\nsystematically evaluate VLMs' capabilities in road topology understanding.\nSpecifically, multi-view images are projected into unified ground-plane\ncoordinate system and fused into bird's-eye-view (BEV) lanes. Based on these\nBEV lanes, we formulate four topology-related diagnostic VQA tasks, which\ntogether capture essential components of spatial topology reasoning. Through\nextensive evaluation, we find that while frontier closed-source models (e.g.,\nGPT-4o) achieve relatively high accuracy in some tasks, they still fail in some\ntemporal questions that humans can answer (e.g., GPT-4o achieve only 67.8% in\nvector, a two-class classification problem). Furthermore, we find open-source\nVLMs, even at 30B scale, struggle significantly. These results indicate that\nspatial reasoning remains a fundamental bottleneck for current VLMs. We also\nfind that the model's capability is positively correlated with model size,\nlength of reasoning tokens and shots provided as examples, showing direction\nfor future research.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16654v2",
      "pdf_url": "http://arxiv.org/pdf/2509.16654v2",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.372,
      "weak_supervision_score": 0.344,
      "diffusion_reasoning_score": 0.433,
      "distributed_training_score": 0.355,
      "datasets_score": 0.322,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper evaluates Vision-Language Models (VLMs) for lane topology awareness in autonomous driving, focusing on benchmarks, VQA tasks, and inference strategies like few-shot learning. It does not involve diffusion models, iterative refinement processes, or multi-step logical reasoning adapted from diffusion techniques.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16656",
      "title": "NUMINA: A Natural Understanding Benchmark for Multi-dimensional\n  Intelligence and Numerical Reasoning Abilities",
      "authors": [
        "Changyu Zeng",
        "Yifan Wang",
        "Zimu Wang",
        "Wei Wang",
        "Zhengni Yang",
        "Muyi Bao",
        "Jiming Xiao",
        "Anh Nguyen",
        "Yutao Yue"
      ],
      "categories": [
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Recent advancements in 2D multimodal large language models (MLLMs) have\nsignificantly improved performance in vision-language tasks. However, extending\nthese capabilities to 3D environments remains a distinct challenge due to the\ncomplexity of spatial reasoning. Nevertheless, existing 3D benchmarks often\nlack fine-grained numerical reasoning task annotations, limiting MLLMs' ability\nto perform precise spatial measurements and complex numerical reasoning. To\naddress this gap, we introduce NUMINA, the first Natural Understanding\nbenchmark for Multi-dimensional Intelligence and Numerical reasoning Abilities\nto enhance multimodal indoor perceptual understanding. NUMINA features\nmulti-scale annotations and various question-answer pairs, generated using\nNUMINA-Flow, an automated annotation pipeline that integrates LLM rewriting and\nrule-based self-verification. We evaluate the performance of various\nstate-of-the-art LLMs on NUMINA following the Chat-Scene framework,\ndemonstrating that current LLMs struggle with multimodal numerical reasoning,\nparticularly in performing precise computations such as distance and volume\nestimation, highlighting the need for further advancements in 3D models. The\ndataset and source codes can be obtained from\nhttps://github.com/fengshun124/NUMINA.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16656v2",
      "pdf_url": "http://arxiv.org/pdf/2509.16656v2",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.319,
      "weak_supervision_score": 0.359,
      "diffusion_reasoning_score": 0.404,
      "distributed_training_score": 0.312,
      "datasets_score": 0.406,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "Highly Relevant",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on introducing a benchmark for 3D multimodal numerical reasoning and evaluating LLMs, but it does not mention or utilize diffusion models, iterative refinement processes, or any adaptation of diffusion for logical reasoning tasks.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "The paper's main contribution is the creation and introduction of the NUMINA dataset, including its annotation pipeline (NUMINA-Flow), benchmarking of LLMs, and analysis of existing datasets, which directly aligns with research on dataset creation, curation, and evaluation for AI applications.",
      "llm_score_status": "completed",
      "summary": "The paper introduces NUMINA, a pioneering benchmark for evaluating multimodal large language models (MLLMs) on 3D spatial and numerical reasoning tasks, addressing the shortcomings of existing datasets by providing fine-grained annotations for object coordinates, sizes, and distances. Utilizing an automated pipeline called NUMINA-Flow, which integrates large language model rewriting and rule-based verification, the authors generate 74,526 question-answer pairs across various formats and difficulty levels; evaluations of state-of-the-art LLMs using the Chat-Scene framework reveal significant weaknesses in numerical inference tasks, such as distance and volume estimation, highlighting the need for further advancements in 3D multimodal intelligence.",
      "novelty_score": "High",
      "novelty_justification": "The paper introduces a truly new benchmark with fine-grained numerical annotations for 3D spatial reasoning, significantly advancing the state-of-the-art by addressing gaps in existing datasets and enabling more precise evaluations of MLLMs.",
      "impact_score": "Moderate",
      "impact_justification": "The work is likely to be cited and built upon within the subfield of 3D vision-language models, as it provides a new benchmark for numerical reasoning that could improve model development for applications like indoor navigation. However, its influence may be limited to specialized research areas rather than broader commercial applications.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "This paper represents a strong and valuable contribution by introducing a much-needed benchmark for 3D numerical reasoning, making it essential for researchers in AI and multimodal perception to be aware of for advancing model capabilities.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/de26669bc40d467ef698cde947724351ddfa966d",
      "total_authors": 9,
      "authors_found": 9,
      "highest_h_index": 8,
      "average_h_index": 1.2222222222222223,
      "notable_authors_count": 1,
      "author_h_indexes": [
        {
          "name": "Changyu Zeng",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2351995689"
        },
        {
          "name": "Yifan Wang",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2374189250"
        },
        {
          "name": "Zimu Wang",
          "h_index": 8,
          "profile_url": "https://www.semanticscholar.org/author/2200687506"
        },
        {
          "name": "Wei Wang",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2372626339"
        },
        {
          "name": "Zhengni Yang",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2372802869"
        },
        {
          "name": "Muyi Bao",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2351926175"
        },
        {
          "name": "Jiming Xiao",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2382404366"
        },
        {
          "name": "Ahn Nguyen",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2382464730"
        },
        {
          "name": "Yutao Yue",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2381823990"
        }
      ]
    },
    {
      "id": "2509.16662",
      "title": "On the de-duplication of the Lakh MIDI dataset",
      "authors": [
        "Eunjin Choi",
        "Hyerin Kim",
        "Jiwoo Ryu",
        "Juhan Nam",
        "Dasaem Jeong"
      ],
      "categories": [
        "cs.SD (Sound)",
        "cs.AI (Artificial Intelligence)",
        "cs.LG (Machine Learning)",
        "cs.MM (Multimedia)",
        "eess.AS (Audio and Speech Processing)"
      ],
      "abstract": "A large-scale dataset is essential for training a well-generalized\ndeep-learning model. Most such datasets are collected via scraping from various\ninternet sources, inevitably introducing duplicated data. In the symbolic music\ndomain, these duplicates often come from multiple user arrangements and\nmetadata changes after simple editing. However, despite critical issues such as\nunreliable training evaluation from data leakage during random splitting,\ndataset duplication has not been extensively addressed in the MIR community.\nThis study investigates the dataset duplication issues regarding Lakh MIDI\nDataset (LMD), one of the largest publicly available sources in the symbolic\nmusic domain. To find and evaluate the best retrieval method for duplicated\ndata, we employed the Clean MIDI subset of the LMD as a benchmark test set, in\nwhich different versions of the same songs are grouped together. We first\nevaluated rule-based approaches and previous symbolic music retrieval models\nfor de-duplication and also investigated with a contrastive learning-based BERT\nmodel with various augmentations to find duplicate files. As a result, we\npropose three different versions of the filtered list of LMD, which filters out\nat least 38,134 samples in the most conservative settings among 178,561 files.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16662v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16662v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.307,
      "weak_supervision_score": 0.321,
      "diffusion_reasoning_score": 0.32,
      "distributed_training_score": 0.332,
      "datasets_score": 0.433,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "Highly Relevant",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "The paper's main contribution involves analyzing and curating the Lakh MIDI Dataset (LMD) by addressing duplication issues, which directly aligns with dataset analysis and curation methodologies. It evaluates various methods for detecting duplicates, proposes filtered versions of the dataset, and uses benchmarks like the Clean MIDI subset for evaluation. This fits squarely within research on analyzing, benchmarking, and evaluating datasets for AI applications in machine learning, particularly in the music domain.",
      "llm_score_status": "completed",
      "summary": "This paper addresses the issue of data duplication in the Lakh MIDI Dataset (LMD), a key resource in music information retrieval (MIR), by highlighting how duplicates lead to unreliable model evaluations due to data leakage during random splits. The authors evaluate various methods, including rule-based approaches, existing symbolic music retrieval models, and a contrastive learning-based BERT model with augmentations, using the Clean MIDI subset as a benchmark to detect duplicates, ultimately proposing three filtered versions of LMD that remove at least 38,134 files in the most conservative setting to improve dataset quality and reliability.",
      "novelty_score": "Moderate",
      "novelty_justification": "The paper presents a notable improvement by applying existing techniques like contrastive learning to the under-addressed problem of dataset duplication in MIR, offering a clever combination for detecting duplicates in symbolic music data. While not introducing a entirely new architecture, it advances the state-of-the-art in this specific domain by providing practical methods and filtered datasets.",
      "impact_score": "Moderate",
      "impact_justification": "The work is likely to be cited and built upon in the MIR community, as it provides tools and filtered datasets that enhance the reliability of future research on LMD. However, its influence is primarily confined to this subfield and may not extend to broader commercial applications.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "This paper offers a valuable contribution by tackling an overlooked issue in MIR datasets, making it essential for researchers working with LMD to ensure accurate evaluations. It is a high-quality work but not transformative enough to be considered must-read for those outside the field.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/39dc5e1f1e58beb4ed15a57a569fcc742fc7a822",
      "total_authors": 5,
      "authors_found": 5,
      "highest_h_index": 10,
      "average_h_index": 2.8,
      "notable_authors_count": 1,
      "author_h_indexes": [
        {
          "name": "Eunjin Choi",
          "h_index": 2,
          "profile_url": "https://www.semanticscholar.org/author/2146892830"
        },
        {
          "name": "Hyerin Kim",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2381407870"
        },
        {
          "name": "Jiwoo Ryu",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2314781760"
        },
        {
          "name": "Juhan Nam",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2278114494"
        },
        {
          "name": "Dasaem Jeong",
          "h_index": 10,
          "profile_url": "https://www.semanticscholar.org/author/20609447"
        }
      ]
    },
    {
      "id": "2509.16673",
      "title": "MedCutMix: A Data-Centric Approach to Improve Radiology Vision-Language\n  Pre-training with Disease Awareness",
      "authors": [
        "Sinuo Wang",
        "Yutong Xie",
        "Yuyuan Liu",
        "Qi Wu"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Vision-Language Pre-training (VLP) is drawing increasing interest for its\nability to minimize manual annotation requirements while enhancing semantic\nunderstanding in downstream tasks. However, its reliance on image-text datasets\nposes challenges due to privacy concerns and the high cost of obtaining paired\nannotations. Data augmentation emerges as a viable strategy to address this\nissue, yet existing methods often fall short of capturing the subtle and\ncomplex variations in medical data due to limited diversity. To this end, we\npropose MedCutMix, a novel multi-modal disease-centric data augmentation\nmethod. MedCutMix performs diagnostic sentence CutMix within medical reports\nand establishes the cross-attention between the diagnostic sentence and medical\nimage to guide attentive manifold mix within the imaging modality. Our approach\nsurpasses previous methods across four downstream radiology diagnosis datasets,\nhighlighting its effectiveness in enhancing performance and generalizability in\nradiology VLP.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16673v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16673v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.321,
      "weak_supervision_score": 0.397,
      "diffusion_reasoning_score": 0.423,
      "distributed_training_score": 0.344,
      "datasets_score": 0.389,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper introduces MedCutMix, a data augmentation method for enhancing Vision-Language Pre-training in radiology by mixing diagnostic sentences and image features. It does not involve diffusion models, iterative refinement processes, or any multi-step logical reasoning as described in the topic. The core contributions are centered on data augmentation and cross-modal alignment, with no reference to treating a 'Chain-of-Thought' or similar diffusion-based mechanisms.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16674",
      "title": "FitPro: A Zero-Shot Framework for Interactive Text-based Pedestrian\n  Retrieval in Open World",
      "authors": [
        "Zengli Luo",
        "Canlong Zhang",
        "Xiaochun Lu",
        "Zhixin Li"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Text-based Pedestrian Retrieval (TPR) aims to retrieve specific target\npedestrians in visual scenes according to natural language descriptions.\nAlthough existing methods have achieved progress under constrained settings,\ninteractive retrieval in the open-world scenario still suffers from limited\nmodel generalization and insufficient semantic understanding. To address these\nchallenges, we propose FitPro, an open-world interactive zero-shot TPR\nframework with enhanced semantic comprehension and cross-scene adaptability.\nFitPro has three innovative components: Feature Contrastive Decoding (FCD),\nIncremental Semantic Mining (ISM), and Query-aware Hierarchical Retrieval\n(QHR). The FCD integrates prompt-guided contrastive decoding to generate\nhigh-quality structured pedestrian descriptions from denoised images,\neffectively alleviating semantic drift in zero-shot scenarios. The ISM\nconstructs holistic pedestrian representations from multi-view observations to\nachieve global semantic modeling in multi-turn interactions,thereby improving\nrobustness against viewpoint shifts and fine-grained variations in\ndescriptions. The QHR dynamically optimizes the retrieval pipeline according to\nquery types, enabling efficient adaptation to multi-modal and multi-view\ninputs. Extensive experiments on five public datasets and two evaluation\nprotocols demonstrate that FitPro significantly overcomes the generalization\nlimitations and semantic modeling constraints of existing methods in\ninteractive retrieval, paving the way for practical deployment. The code and\ndata will be released at https://github.com/\nlilo4096/FitPro-Interactive-Person-Retrieval.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16674v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16674v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.387,
      "weak_supervision_score": 0.337,
      "diffusion_reasoning_score": 0.365,
      "distributed_training_score": 0.364,
      "datasets_score": 0.322,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16676",
      "title": "Governed By Agents: A Survey On The Role Of Agentic AI In Future\n  Computing Environments",
      "authors": [
        "Nauman Ali Murad",
        "Safia Baloch"
      ],
      "categories": [
        "cs.ET (Emerging Technologies)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "The emergence of agentic Artificial Intelligence (AI), which can operate\nautonomously, demonstrate goal-directed behavior, and adaptively learn,\nindicates the onset of a massive change in today's computing infrastructure.\nThis study investigates how agentic AI models' multiple characteristics may\nimpact the architecture, governance, and operation under which computing\nenvironments function. Agentic AI has the potential to reduce reliance on\nextremely large (public) cloud environments due to resource efficiency,\nespecially with processing and/or storage. The aforementioned characteristics\nprovide us with an opportunity to canvas the likelihood of strategic migration\nin computing infrastructures away from massive public cloud services, towards\nmore locally distributed architectures: edge computing and on-premises\ncomputing infrastructures. Many of these likely migrations will be spurred by\nfactors like on-premises processing needs, diminished data consumption\nfootprints, and cost savings. This study examines how a solution for\nimplementing AI's autonomy could result in a re-architecture of the systems and\nmodel a departure from today's governance models to help us manage these\nincreasingly autonomous agents, and an operational overhaul of processes over a\nvery diverse computing systems landscape that bring together computing via\ncloud, edge, and on-premises computing solutions. To enable us to explore these\nintertwined decisions, it will be fundamentally important to understand how to\nbest position agentic AI, and to navigate the future state of computing\ninfrastructures.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16676v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16676v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.41,
      "weak_supervision_score": 0.355,
      "diffusion_reasoning_score": 0.37,
      "distributed_training_score": 0.367,
      "datasets_score": 0.365,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper surveys the role of agentic AI in computing environments, focusing on autonomy, learning cycles, and infrastructure shifts, but does not mention or discuss Reinforcement Learning from Human Feedback (RLHF) specifically. RLHF involves training AI models using human-ranked data to create a reward model for fine-tuning, which is not addressed in the paper's content on general AI learning and efficiency. Thus, there is no direct or indirect relevance to RLHF.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16677",
      "title": "Segment-to-Act: Label-Noise-Robust Action-Prompted Video Segmentation\n  Towards Embodied Intelligence",
      "authors": [
        "Wenxin Li",
        "Kunyu Peng",
        "Di Wen",
        "Ruiping Liu",
        "Mengfei Duan",
        "Kai Luo",
        "Kailun Yang"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.LG (Machine Learning)",
        "cs.RO (Robotics)",
        "eess.IV (Image and Video Processing)"
      ],
      "abstract": "Embodied intelligence relies on accurately segmenting objects actively\ninvolved in interactions. Action-based video object segmentation addresses this\nby linking segmentation with action semantics, but it depends on large-scale\nannotations and prompts that are costly, inconsistent, and prone to multimodal\nnoise such as imprecise masks and referential ambiguity. To date, this\nchallenge remains unexplored. In this work, we take the first step by studying\naction-based video object segmentation under label noise, focusing on two\nsources: textual prompt noise (category flips and within-category noun\nsubstitutions) and mask annotation noise (perturbed object boundaries to mimic\nimprecise supervision). Our contributions are threefold. First, we introduce\ntwo types of label noises for the action-based video object segmentation task.\nSecond, we build up the first action-based video object segmentation under a\nlabel noise benchmark ActiSeg-NL and adapt six label-noise learning strategies\nto this setting, and establish protocols for evaluating them under textual,\nboundary, and mixed noise. Third, we provide a comprehensive analysis linking\nnoise types to failure modes and robustness gains, and we introduce a Parallel\nMask Head Mechanism (PMHM) to address mask annotation noise. Qualitative\nevaluations further reveal characteristic failure modes, including boundary\nleakage and mislocalization under boundary perturbations, as well as occasional\nidentity substitutions under textual flips. Our comparative analysis reveals\nthat different learning strategies exhibit distinct robustness profiles,\ngoverned by a foreground-background trade-off where some achieve balanced\nperformance while others prioritize foreground accuracy at the cost of\nbackground precision. The established benchmark and source code will be made\npublicly available at https://github.com/mylwx/ActiSeg-NL.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16677v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16677v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.391,
      "weak_supervision_score": 0.472,
      "diffusion_reasoning_score": 0.369,
      "distributed_training_score": 0.335,
      "datasets_score": 0.35,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "Highly Relevant",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "The paper's main contribution involves handling label noise in action-based video object segmentation by introducing synthetic noise (e.g., textual prompt noise and mask annotation noise) and adapting noise-robust learning strategies, which aligns directly with weak supervision. It trains models using programmatically generated noisy labels instead of perfect annotations, as seen in the creation of the ActiSeg-NL benchmark and the evaluation of methods like Co-teaching and GCE to mitigate such noise.",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "completed",
      "summary": "This paper tackles the challenges of label noise in action-based video object segmentation for embodied intelligence by introducing two types of noise—textual prompt noise (e.g., category flips) and mask annotation noise (e.g., perturbed boundaries)—and establishing a new benchmark called ActiSeg-NL using the VISOR dataset. The authors adapt six noise-robust learning strategies, evaluate their performance under various noise scenarios, analyze failure modes and robustness trade-offs, and propose a Parallel Mask Head Mechanism (PMHM) to specifically address mask noise, ultimately revealing that different strategies balance foreground and background accuracy differently and highlighting the need for tailored solutions in this domain.",
      "novelty_score": "High",
      "novelty_justification": "The paper introduces a novel benchmark (ActiSeg-NL) and new types of label noise for action-based video object segmentation, which is a previously underexplored area, significantly advancing the state-of-the-art by providing a framework for robust embodied perception.",
      "impact_score": "Moderate",
      "impact_justification": "The work is likely to be cited and built upon in subfields like computer vision and robotics, as it offers a new benchmark and strategies that could enhance the robustness of video segmentation models in real-world applications.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "This paper provides a valuable contribution by addressing a critical gap in noisy label handling for video segmentation, making it essential for researchers in embodied AI and robotics to understand and potentially adopt its findings and tools.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/142aee3b1df92d7db28a057568fcc473f409eac0",
      "total_authors": 7,
      "authors_found": 7,
      "highest_h_index": 38,
      "average_h_index": 9.428571428571429,
      "notable_authors_count": 2,
      "author_h_indexes": [
        {
          "name": "Wenxin Li",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2381467461"
        },
        {
          "name": "Kunyu Peng",
          "h_index": 17,
          "profile_url": "https://www.semanticscholar.org/author/91549683"
        },
        {
          "name": "Di Wen",
          "h_index": 4,
          "profile_url": "https://www.semanticscholar.org/author/2288587946"
        },
        {
          "name": "Ruiping Liu",
          "h_index": 5,
          "profile_url": "https://www.semanticscholar.org/author/2273522374"
        },
        {
          "name": "Mengfei Duan",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2348254443"
        },
        {
          "name": "Kai Luo",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2348254368"
        },
        {
          "name": "Kailun Yang",
          "h_index": 38,
          "profile_url": "https://www.semanticscholar.org/author/8689702"
        }
      ]
    },
    {
      "id": "2509.16678",
      "title": "IPF-RDA: An Information-Preserving Framework for Robust Data\n  Augmentation",
      "authors": [
        "Suorong Yang",
        "Hongchao Yang",
        "Suhan Guo",
        "Furao Shen",
        "Jian Zhao"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Data augmentation is widely utilized as an effective technique to enhance the\ngeneralization performance of deep models. However, data augmentation may\ninevitably introduce distribution shifts and noises, which significantly\nconstrain the potential and deteriorate the performance of deep networks. To\nthis end, we propose a novel information-preserving framework, namely IPF-RDA,\nto enhance the robustness of data augmentations in this paper. IPF-RDA combines\nthe proposal of (i) a new class-discriminative information estimation algorithm\nthat identifies the points most vulnerable to data augmentation operations and\ncorresponding importance scores; And (ii) a new information-preserving scheme\nthat preserves the critical information in the augmented samples and ensures\nthe diversity of augmented data adaptively. We divide data augmentation methods\ninto three categories according to the operation types and integrate these\napproaches into our framework accordingly. After being integrated into our\nframework, the robustness of data augmentation methods can be enhanced and\ntheir full potential can be unleashed. Extensive experiments demonstrate that\nalthough being simple, IPF-RDA consistently improves the performance of\nnumerous commonly used state-of-the-art data augmentation methods with popular\ndeep models on a variety of datasets, including CIFAR-10, CIFAR-100,\nTiny-ImageNet, CUHK03, Market1501, Oxford Flower, and MNIST, where its\nperformance and scalability are stressed. The implementation is available at\nhttps://github.com/Jackbrocp/IPF-RDA.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16678v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16678v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.398,
      "weak_supervision_score": 0.422,
      "diffusion_reasoning_score": 0.398,
      "distributed_training_score": 0.413,
      "datasets_score": 0.407,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "Not Relevant",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "Not Relevant",
      "datasets_relevance": "Tangentially Relevant",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "The paper focuses on improving data augmentation techniques for deep learning models by preserving critical information, without any discussion of generating labels from noisy or imprecise sources. It assumes standard labeled data and does not address weak supervision concepts.",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "The paper does not involve parallel computing, multi-node setups, or strategies for distributing data or computation across processors. It discusses computational overhead in augmentation but remains centered on single-process training enhancements.",
      "datasets_justification": "The paper evaluates its framework on various standard datasets like CIFAR-10 and Tiny-ImageNet to demonstrate performance, which touches on benchmarking, but its primary contribution is methodological (improving data augmentation), not creating, analyzing, or curating datasets.",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16680",
      "title": "ProtoVQA: An Adaptable Prototypical Framework for Explainable\n  Fine-Grained Visual Question Answering",
      "authors": [
        "Xingjian Diao",
        "Weiyi Wu",
        "Keyi Kong",
        "Peijun Qing",
        "Xinwen Xu",
        "Ming Cheng",
        "Soroush Vosoughi",
        "Jiang Gui"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.AI (Artificial Intelligence)",
        "cs.LG (Machine Learning)"
      ],
      "abstract": "Visual Question Answering (VQA) is increasingly used in diverse applications\nranging from general visual reasoning to safety-critical domains such as\nmedical imaging and autonomous systems, where models must provide not only\naccurate answers but also explanations that humans can easily understand and\nverify. Prototype-based modeling has shown promise for interpretability by\ngrounding predictions in semantically meaningful regions for purely visual\nreasoning tasks, yet remains underexplored in the context of VQA. We present\nProtoVQA, a unified prototypical framework that (i) learns question-aware\nprototypes that serve as reasoning anchors, connecting answers to\ndiscriminative image regions, (ii) applies spatially constrained matching to\nensure that the selected evidence is coherent and semantically relevant, and\n(iii) supports both answering and grounding tasks through a shared prototype\nbackbone. To assess explanation quality, we propose the Visual-Linguistic\nAlignment Score (VLAS), which measures how well the model's attended regions\nalign with ground-truth evidence. Experiments on Visual7W show that ProtoVQA\nyields faithful, fine-grained explanations while maintaining competitive\naccuracy, advancing the development of transparent and trustworthy VQA systems.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16680v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16680v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.351,
      "weak_supervision_score": 0.35,
      "diffusion_reasoning_score": 0.448,
      "distributed_training_score": 0.313,
      "datasets_score": 0.33,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper introduces ProtoVQA, a framework for explainable Visual Question Answering using prototype-based learning, which focuses on learning question-aware prototypes and spatial matching for interpretability. It does not involve diffusion models, iterative refinement processes, or multi-step logical reasoning as described in the topic. Therefore, there is no connection to diffusion-based approaches.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16682",
      "title": "Design and Development of an Intelligent LLM-based LDAP Honeypot",
      "authors": [
        "Javier Jiménez-Román",
        "Florina Almenares-Mendoza",
        "Alfonso Sánchez-Macián"
      ],
      "categories": [
        "cs.CR (Cryptography and Security)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Cybersecurity threats continue to increase, with a growing number of\npreviously unknown attacks each year targeting both large corporations and\nsmaller entities. This scenario demands the implementation of advanced security\nmeasures, not only to mitigate damage but also to anticipate emerging attack\ntrends. In this context, deception tools have become a key strategy, enabling\nthe detection, deterrence, and deception of potential attackers while\nfacilitating the collection of information about their tactics and methods.\nAmong these tools, honeypots have proven their value, although they have\ntraditionally been limited by rigidity and configuration complexity, hindering\ntheir adaptability to dynamic scenarios. The rise of artificial intelligence,\nand particularly general-purpose Large Language Models (LLMs), is driving the\ndevelopment of new deception solutions capable of offering greater adaptability\nand ease of use. This work proposes the design and implementation of an\nLLM-based honeypot to simulate an LDAP server, a critical protocol present in\nmost organizations due to its central role in identity and access management.\nThe proposed solution aims to provide a flexible and realistic tool capable of\nconvincingly interacting with attackers, thereby contributing to early\ndetection and threat analysis while enhancing the defensive capabilities of\ninfrastructures against intrusions targeting this service.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16682v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16682v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.406,
      "weak_supervision_score": 0.362,
      "diffusion_reasoning_score": 0.338,
      "distributed_training_score": 0.34,
      "datasets_score": 0.36,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper's main contribution is the design and implementation of an LLM-based honeypot for simulating an LDAP server, focusing on cybersecurity applications, adaptability, and threat detection. It does not involve training or fine-tuning AI models using human feedback, reward models, or reinforcement learning techniques. Therefore, it has no connection to Reinforcement Learning from Human Feedback.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16684",
      "title": "Active View Selection for Scene-level Multi-view Crowd Counting and\n  Localization with Limited Labels",
      "authors": [
        "Qi Zhang",
        "Bin Li",
        "Antoni B. Chan",
        "Hui Huang"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Multi-view crowd counting and localization fuse the input multi-views for\nestimating the crowd number or locations on the ground. Existing methods mainly\nfocus on accurately predicting on the crowd shown in the input views, which\nneglects the problem of choosing the `best' camera views to perceive all crowds\nwell in the scene. Besides, existing view selection methods require massive\nlabeled views and images, and lack the ability for cross-scene settings,\nreducing their application scenarios. Thus, in this paper, we study the view\nselection issue for better scene-level multi-view crowd counting and\nlocalization results with cross-scene ability and limited label demand, instead\nof input-view-level results. We first propose an independent view selection\nmethod (IVS) that considers view and scene geometries in the view selection\nstrategy and conducts the view selection, labeling, and downstream tasks\nindependently. Based on IVS, we also put forward an active view selection\nmethod (AVS) that jointly optimizes the view selection, labeling, and\ndownstream tasks. In AVS, we actively select the labeled views and consider\nboth the view/scene geometries and the predictions of the downstream task\nmodels in the view selection process. Experiments on multi-view counting and\nlocalization tasks demonstrate the cross-scene and the limited label demand\nadvantages of the proposed active view selection method (AVS), outperforming\nexisting methods and with wider application scenarios.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16684v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16684v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.299,
      "weak_supervision_score": 0.329,
      "diffusion_reasoning_score": 0.312,
      "distributed_training_score": 0.326,
      "datasets_score": 0.289,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16685",
      "title": "Towards a Transparent and Interpretable AI Model for Medical Image\n  Classifications",
      "authors": [
        "Binbin Wen",
        "Yihang Wu",
        "Tareef Daqqaq",
        "Ahmad Chaddad"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.LG (Machine Learning)"
      ],
      "abstract": "The integration of artificial intelligence (AI) into medicine is remarkable,\noffering advanced diagnostic and therapeutic possibilities. However, the\ninherent opacity of complex AI models presents significant challenges to their\nclinical practicality. This paper focuses primarily on investigating the\napplication of explainable artificial intelligence (XAI) methods, with the aim\nof making AI decisions transparent and interpretable. Our research focuses on\nimplementing simulations using various medical datasets to elucidate the\ninternal workings of the XAI model. These dataset-driven simulations\ndemonstrate how XAI effectively interprets AI predictions, thus improving the\ndecision-making process for healthcare professionals. In addition to a survey\nof the main XAI methods and simulations, ongoing challenges in the XAI field\nare discussed. The study highlights the need for the continuous development and\nexploration of XAI, particularly from the perspective of diverse medical\ndatasets, to promote its adoption and effectiveness in the healthcare domain.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16685v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16685v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.383,
      "weak_supervision_score": 0.348,
      "diffusion_reasoning_score": 0.393,
      "distributed_training_score": 0.333,
      "datasets_score": 0.384,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16690",
      "title": "Spectral Compressive Imaging via Chromaticity-Intensity Decomposition",
      "authors": [
        "Xiaodong Wang",
        "Zijun He",
        "Ping Wang",
        "Lishun Wang",
        "Yanan Hu",
        "Xin Yuan"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "In coded aperture snapshot spectral imaging (CASSI), the captured measurement\nentangles spatial and spectral information, posing a severely ill-posed inverse\nproblem for hyperspectral images (HSIs) reconstruction. Moreover, the captured\nradiance inherently depends on scene illumination, making it difficult to\nrecover the intrinsic spectral reflectance that remains invariant to lighting\nconditions. To address these challenges, we propose a chromaticity-intensity\ndecomposition framework, which disentangles an HSI into a spatially smooth\nintensity map and a spectrally variant chromaticity cube. The chromaticity\nencodes lighting-invariant reflectance, enriched with high-frequency spatial\ndetails and local spectral sparsity. Building on this decomposition, we develop\nCIDNet, a Chromaticity-Intensity Decomposition unfolding network within a\ndual-camera CASSI system. CIDNet integrates a hybrid spatial-spectral\nTransformer tailored to reconstruct fine-grained and sparse spectral\nchromaticity and a degradation-aware, spatially-adaptive noise estimation\nmodule that captures anisotropic noise across iterative stages. Extensive\nexperiments on both synthetic and real-world CASSI datasets demonstrate that\nour method achieves superior performance in both spectral and chromaticity\nfidelity. Code and models will be publicly available.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16690v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16690v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.259,
      "weak_supervision_score": 0.284,
      "diffusion_reasoning_score": 0.335,
      "distributed_training_score": 0.322,
      "datasets_score": 0.288,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16691",
      "title": "InstanceAssemble: Layout-Aware Image Generation via Instance Assembling\n  Attention",
      "authors": [
        "Qiang Xiang",
        "Shuang Sun",
        "Binglei Li",
        "Dejia Song",
        "Huaxia Li",
        "Nemo Chen",
        "Xu Tang",
        "Yao Hu",
        "Junping Zhang"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Diffusion models have demonstrated remarkable capabilities in generating\nhigh-quality images. Recent advancements in Layout-to-Image (L2I) generation\nhave leveraged positional conditions and textual descriptions to facilitate\nprecise and controllable image synthesis. Despite overall progress, current L2I\nmethods still exhibit suboptimal performance. Therefore, we propose\nInstanceAssemble, a novel architecture that incorporates layout conditions via\ninstance-assembling attention, enabling position control with bounding boxes\n(bbox) and multimodal content control including texts and additional visual\ncontent. Our method achieves flexible adaption to existing DiT-based T2I models\nthrough light-weighted LoRA modules. Additionally, we propose a Layout-to-Image\nbenchmark, Denselayout, a comprehensive benchmark for layout-to-image\ngeneration, containing 5k images with 90k instances in total. We further\nintroduce Layout Grounding Score (LGS), an interpretable evaluation metric to\nmore precisely assess the accuracy of L2I generation. Experiments demonstrate\nthat our InstanceAssemble method achieves state-of-the-art performance under\ncomplex layout conditions, while exhibiting strong compatibility with diverse\nstyle LoRA modules.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16691v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16691v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.328,
      "weak_supervision_score": 0.351,
      "diffusion_reasoning_score": 0.498,
      "distributed_training_score": 0.321,
      "datasets_score": 0.339,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper's main contribution is a novel architecture for layout-aware image generation using diffusion models, specifically focusing on improving spatial and content control in image synthesis. It does not involve adapting the diffusion process for multi-step logical reasoning, chain-of-thought processing, or solving complex logical tasks. Instead, it applies diffusion models to visual generation tasks, which lacks the required components for diffusion-based reasoning as defined.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16702",
      "title": "Animalbooth: multimodal feature enhancement for animal subject\n  personalization",
      "authors": [
        "Chen Liu",
        "Haitao Wu",
        "Kafeng Wang",
        "Xiaowang Zhang"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Personalized animal image generation is challenging due to rich appearance\ncues and large morphological variability. Existing approaches often exhibit\nfeature misalignment across domains, which leads to identity drift. We present\nAnimalBooth, a framework that strengthens identity preservation with an Animal\nNet and an adaptive attention module, mitigating cross domain alignment errors.\nWe further introduce a frequency controlled feature integration module that\napplies Discrete Cosine Transform filtering in the latent space to guide the\ndiffusion process, enabling a coarse to fine progression from global structure\nto detailed texture. To advance research in this area, we curate AnimalBench, a\nhigh resolution dataset for animal personalization. Extensive experiments show\nthat AnimalBooth consistently outperforms strong baselines on multiple\nbenchmarks and improves both identity fidelity and perceptual quality.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16702v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16702v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.364,
      "weak_supervision_score": 0.352,
      "diffusion_reasoning_score": 0.35,
      "distributed_training_score": 0.307,
      "datasets_score": 0.368,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16704",
      "title": "When Confidence Fails: Revisiting Pseudo-Label Selection in\n  Semi-supervised Semantic Segmentation",
      "authors": [
        "Pan Liu",
        "Jinshi Liu"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "While significant advances exist in pseudo-label generation for\nsemi-supervised semantic segmentation, pseudo-label selection remains\nunderstudied. Existing methods typically use fixed confidence thresholds to\nretain high-confidence predictions as pseudo-labels. However, these methods\ncannot cope with network overconfidence tendency, where correct and incorrect\npredictions overlap significantly in high-confidence regions, making separation\nchallenging and amplifying model cognitive bias. Meanwhile, the direct\ndiscarding of low-confidence predictions disrupts spatial-semantic continuity,\ncausing critical context loss. We propose Confidence Separable Learning (CSL)\nto address these limitations. CSL formulates pseudo-label selection as a convex\noptimization problem within the confidence distribution feature space,\nestablishing sample-specific decision boundaries to distinguish reliable from\nunreliable predictions. Additionally, CSL introduces random masking of reliable\npixels to guide the network in learning contextual relationships from\nlow-reliability regions, thereby mitigating the adverse effects of discarding\nuncertain predictions. Extensive experimental results on the Pascal,\nCityscapes, and COCO benchmarks show that CSL performs favorably against\nstate-of-the-art methods. Code and model weights are available at\nhttps://github.com/PanLiuCSU/CSL.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16704v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16704v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.361,
      "weak_supervision_score": 0.493,
      "diffusion_reasoning_score": 0.325,
      "distributed_training_score": 0.35,
      "datasets_score": 0.341,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "Highly Relevant",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "The paper's main contribution involves enhancing pseudo-label generation and selection in semi-supervised semantic segmentation, where labels are programmatically derived from model predictions on unlabeled data. This directly aligns with weak supervision, as it relies on noisy or imprecise sources (e.g., overconfident predictions) to create training labels without perfect hand-labeling, thereby improving model training efficiency.",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "completed",
      "summary": "This paper addresses the limitations of existing pseudo-label selection methods in semi-supervised semantic segmentation, which rely on fixed confidence thresholds and struggle with network overconfidence. It introduces Confidence Separable Learning (CSL), a framework that formulates pseudo-label selection as a convex optimization problem in a confidence distribution feature space to better separate reliable from unreliable predictions, and incorporates random masking of reliable pixels to enhance learning from uncertain regions, demonstrating superior performance on benchmarks like Pascal, Cityscapes, and COCO.",
      "novelty_score": "High",
      "novelty_justification": "The paper introduces a truly new technique by formulating pseudo-label selection as a convex optimization problem in a confidence distribution feature space, significantly advancing the handling of network overconfidence in semi-supervised semantic segmentation.",
      "impact_score": "Moderate",
      "impact_justification": "The work is likely to be cited and built upon in the subfield of semi-supervised learning for semantic segmentation, as it improves pseudo-label quality and could extend to related computer vision applications. However, its influence may be limited to specific domains rather than broadly transformative.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "This paper represents a strong, valuable contribution by innovating on a key challenge in semi-supervised semantic segmentation, making it essential for researchers in computer vision to be aware of for advancing their work.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/99fb11fbeaaed340108752976ad6e4a5c5eb5cc0",
      "total_authors": 2,
      "authors_found": 2,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": [
        {
          "name": "Pan Liu",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2381700004"
        },
        {
          "name": "Jinshi Liu",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2381389456"
        }
      ]
    },
    {
      "id": "2509.16721",
      "title": "Text-Scene: A Scene-to-Language Parsing Framework for 3D Scene\n  Understanding",
      "authors": [
        "Haoyuan Li",
        "Rui Liu",
        "Hehe Fan",
        "Yi Yang"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.AI (Artificial Intelligence)",
        "cs.RO (Robotics)"
      ],
      "abstract": "Enabling agents to understand and interact with complex 3D scenes is a\nfundamental challenge for embodied artificial intelligence systems. While\nMultimodal Large Language Models (MLLMs) have achieved significant progress in\n2D image understanding, extending such capabilities to 3D scenes remains\ndifficult: 1) 3D environment involves richer concepts such as spatial\nrelationships, affordances, physics, layout, and so on, 2) the absence of\nlarge-scale 3D vision-language datasets has posed a significant obstacle. In\nthis paper, we introduce Text-Scene, a framework that automatically parses 3D\nscenes into textual descriptions for scene understanding. Given a 3D scene, our\nmodel identifies object attributes and spatial relationships, and then\ngenerates a coherent summary of the whole scene, bridging the gap between 3D\nobservation and language without requiring human-in-the-loop intervention. By\nleveraging both geometric analysis and MLLMs, Text-Scene produces descriptions\nthat are accurate, detailed, and human-interpretable, capturing object-level\ndetails and global-level context. Experimental results on benchmarks\ndemonstrate that our textual parses can faithfully represent 3D scenes and\nbenefit downstream tasks. To evaluate the reasoning capability of MLLMs, we\npresent InPlan3D, a comprehensive benchmark for 3D task planning, consisting of\n3174 long-term planning tasks across 636 indoor scenes. We emphasize clarity\nand accessibility in our approach, aiming to make 3D scene content\nunderstandable through language. Code and datasets will be released.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16721v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16721v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.358,
      "weak_supervision_score": 0.338,
      "diffusion_reasoning_score": 0.461,
      "distributed_training_score": 0.318,
      "datasets_score": 0.365,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper introduces the Text-Scene framework for parsing 3D scenes into textual descriptions using geometric analysis and Multimodal Large Language Models (MLLMs). It focuses on object identification, spatial relationships, and fine-tuning MLLMs for scene understanding, with no mention of diffusion models, iterative refinement processes, or multi-step logical reasoning as defined. Thus, the paper does not align with diffusion-based reasoning concepts.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16724",
      "title": "Exploring AI Capabilities in Participatory Budgeting within Smart\n  Cities: The Case of Sao Paulo",
      "authors": [
        "Italo Alberto Sousa",
        "Mariana Carvalho da Silva",
        "Jorge Machado",
        "José Carlos Vaz"
      ],
      "categories": [
        "cs.CY (Computers and Society)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "This research examines how Artificial Intelligence (AI) can improve\nparticipatory budgeting processes within smart cities. In response to\nchallenges like declining civic participation and resource allocation\nconflicts, the study explores how online political participation can be\nimproved by AI. It investigates the state capacity governments need to\nimplement AI-enhanced participatory tools, considering technological\ndependencies and vulnerabilities. It analyzes technological and administrative\nstructures, actors, interests, and strategies to understand the dynamics of\nonline political participation technologies in the case of Sao Paulo, Brazil.\nThe study contributes to understanding how technological advancements can\nreshape participatory budgeting processes. In a broader sense, the research\nhighlights how AI can transform participatory institutions by offering new\ntools for citizens and also for government officials in charge of participatory\nprocesses within smart cities.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16724v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16724v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "extraction_failed",
      "embedding_status": "completed",
      "rlhf_score": 0.355,
      "weak_supervision_score": 0.335,
      "diffusion_reasoning_score": 0.263,
      "distributed_training_score": 0.269,
      "datasets_score": 0.376,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16727",
      "title": "Pain in 3D: Generating Controllable Synthetic Faces for Automated Pain\n  Assessment",
      "authors": [
        "Xin Lei Lin",
        "Soroush Mehraban",
        "Abhishek Moturu",
        "Babak Taati"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.LG (Machine Learning)"
      ],
      "abstract": "Automated pain assessment from facial expressions is crucial for\nnon-communicative patients, such as those with dementia. Progress has been\nlimited by two challenges: (i) existing datasets exhibit severe demographic and\nlabel imbalance due to ethical constraints, and (ii) current generative models\ncannot precisely control facial action units (AUs), facial structure, or\nclinically validated pain levels.\n  We present 3DPain, a large-scale synthetic dataset specifically designed for\nautomated pain assessment, featuring unprecedented annotation richness and\ndemographic diversity. Our three-stage framework generates diverse 3D meshes,\ntextures them with diffusion models, and applies AU-driven face rigging to\nsynthesize multi-view faces with paired neutral and pain images, AU\nconfigurations, PSPI scores, and the first dataset-level annotations of\npain-region heatmaps. The dataset comprises 82,500 samples across 25,000 pain\nexpression heatmaps and 2,500 synthetic identities balanced by age, gender, and\nethnicity.\n  We further introduce ViTPain, a Vision Transformer based cross-modal\ndistillation framework in which a heatmap-trained teacher guides a student\ntrained on RGB images, enhancing accuracy, interpretability, and clinical\nreliability. Together, 3DPain and ViTPain establish a controllable, diverse,\nand clinically grounded foundation for generalizable automated pain assessment.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16727v2",
      "pdf_url": "http://arxiv.org/pdf/2509.16727v2",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.381,
      "weak_supervision_score": 0.359,
      "diffusion_reasoning_score": 0.431,
      "distributed_training_score": 0.355,
      "datasets_score": 0.403,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "Highly Relevant",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper utilizes diffusion models primarily for generating synthetic facial images and textures, such as in texture synthesis with Hunyuan3D. However, it does not involve adapting diffusion for multi-step logical reasoning, Chain-of-Thought processes, or iterative correction of reasoning paths. The focus is on generative tasks for data creation, not on solving complex logical tasks.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "The paper's main contribution includes the introduction of a new synthetic dataset, 3DPain, which comprises 82,500 samples with detailed annotations. It describes the dataset's creation methodology, including a three-stage generation pipeline, and addresses aspects like demographic diversity and benchmarking for automated pain assessment, directly aligning with research on creating and evaluating datasets for AI applications.",
      "llm_score_status": "completed",
      "summary": "The paper addresses challenges in automated pain assessment by introducing 3DPain, a large-scale synthetic dataset generated through a three-stage framework that creates diverse 3D facial meshes, applies diffusion-based texturing, and uses action unit-driven rigging to produce photorealistic faces with annotations for pain expressions, including neutral-pain pairs, AU configurations, PSPI scores, and pain-region heatmaps across 2,500 balanced synthetic identities. Additionally, it presents ViTPain, a Vision Transformer-based model that employs cross-modal distillation from heatmap-trained teachers to student models on RGB images, enhancing the accuracy, interpretability, and clinical reliability of pain detection systems.",
      "novelty_score": "High",
      "novelty_justification": "The paper introduces a novel synthetic dataset and generation pipeline that precisely controls facial action units and pain levels, significantly advancing automated pain assessment by addressing key limitations in existing datasets and models. This represents a truly new technique tailored to a critical healthcare application, pushing the state-of-the-art in generative AI for medical use.",
      "impact_score": "High",
      "impact_justification": "The work has the potential to broadly influence future research in healthcare AI by providing a diverse, controllable dataset that could improve pain assessment for vulnerable populations, leading to more equitable and generalizable commercial applications. Its introduction of ViTPain further enhances clinical reliability, making it likely to be widely cited and adopted in the subfield of computer vision for medicine.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "This paper offers a high-quality contribution that advances a specialized area with real-world implications, making it valuable for researchers in computer vision and healthcare AI to be aware of for potential applications. While essential for those directly in the field, it may not be universally critical for all audiences.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/7137e66e532b60395765cfd14c199510fd288517",
      "total_authors": 4,
      "authors_found": 4,
      "highest_h_index": 3,
      "average_h_index": 1.5,
      "notable_authors_count": 0,
      "author_h_indexes": [
        {
          "name": "Xin Lei Lin",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2381938452"
        },
        {
          "name": "Soroush Mehraban",
          "h_index": 3,
          "profile_url": "https://www.semanticscholar.org/author/2192282860"
        },
        {
          "name": "Abhishek Moturu",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2339997870"
        },
        {
          "name": "Babak Taati",
          "h_index": 2,
          "profile_url": "https://www.semanticscholar.org/author/2261673551"
        }
      ]
    },
    {
      "id": "2509.16738",
      "title": "Mixture of Noise for Pre-Trained Model-Based Class-Incremental Learning",
      "authors": [
        "Kai Jiang",
        "Zhengyan Shi",
        "Dell Zhang",
        "Hongyuan Zhang",
        "Xuelong Li"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.LG (Machine Learning)"
      ],
      "abstract": "Class Incremental Learning (CIL) aims to continuously learn new categories\nwhile retaining the knowledge of old ones. Pre-trained models (PTMs) show\npromising capabilities in CIL. However, existing approaches that apply\nlightweight fine-tuning to backbones still induce parameter drift, thereby\ncompromising the generalization capability of pre-trained models. Parameter\ndrift can be conceptualized as a form of noise that obscures critical patterns\nlearned for previous tasks. However, recent researches have shown that noise is\nnot always harmful. For example, the large number of visual patterns learned\nfrom pre-training can be easily abused by a single task, and introducing\nappropriate noise can suppress some low-correlation features, thus leaving a\nmargin for future tasks. To this end, we propose learning beneficial noise for\nCIL guided by information theory and propose Mixture of Noise (Min), aiming to\nmitigate the degradation of backbone generalization from adapting new tasks.\nSpecifically, task-specific noise is learned from high-dimension features of\nnew tasks. Then, a set of weights is adjusted dynamically for optimal mixture\nof different task noise. Finally, Min embeds the beneficial noise into the\nintermediate features to mask the response of inefficient patterns. Extensive\nexperiments on six benchmark datasets demonstrate that Min achieves\nstate-of-the-art performance in most incremental settings, with particularly\noutstanding results in 50-steps incremental settings. This shows the\nsignificant potential for beneficial noise in continual learning. Code is\navailable at https://github.com/ASCIIJK/MiN-NeurIPS2025.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16738v3",
      "pdf_url": "http://arxiv.org/pdf/2509.16738v3",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.348,
      "weak_supervision_score": 0.401,
      "diffusion_reasoning_score": 0.378,
      "distributed_training_score": 0.359,
      "datasets_score": 0.288,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "Tangentially Relevant",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "The paper focuses on using noise in features for Class-Incremental Learning to mitigate parameter drift and improve generalization, which involves the concept of noise in machine learning. However, it does not address training models with programmatically generated, noisy labels or weak supervision sources; instead, it deals with internal noise manipulation for feature adaptation, making the connection indirect.",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16742",
      "title": "Sycophancy Mitigation Through Reinforcement Learning with\n  Uncertainty-Aware Adaptive Reasoning Trajectories",
      "authors": [
        "Mohammad Beigi",
        "Ying Shen",
        "Parshin Shojaee",
        "Qifan Wang",
        "Zichao Wang",
        "Chandan Reddy",
        "Ming Jin",
        "Lifu Huang"
      ],
      "categories": [
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Despite the remarkable capabilities of large language models, current\ntraining paradigms inadvertently foster \\textit{sycophancy}, i.e., the tendency\nof a model to agree with or reinforce user-provided information even when it's\nfactually incorrect. To address this challenge, we introduce \\textbf{SMART}\n(Sycophancy Mitigation through Adaptive Reasoning Trajectories), which reframes\nsycophancy as a \\textit{reasoning optimization problem} rather than an output\nalignment issue. SMART is a two-stage framework comprising: (1)\nUncertainty-Aware Adaptive Monte Carlo Tree Search (UA-MCTS), which dynamically\nadjusts model exploration based on state-level uncertainty to collect\nhigh-quality, diverse reasoning trajectories alongside both stepwise progress\nand final outcome rewards; and (2) progress-based reinforcement learning, which\nfine-tunes the model using the collected trajectories and reward signals to\nreinforce effective reasoning patterns. Through extensive experiments, we show\nthat SMART significantly reduces sycophantic behavior while preserving strong\nperformance on out-of-distribution inputs and maintaining general capabilities.\nThese results underscore the importance of optimizing internal reasoning\nmechanisms to build more truthful and aligned AI assistants.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16742v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16742v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.518,
      "weak_supervision_score": 0.446,
      "diffusion_reasoning_score": 0.506,
      "distributed_training_score": 0.38,
      "datasets_score": 0.359,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "Moderately Relevant",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper uses reinforcement learning in its second stage to fine-tune the model based on rewards from UA-MCTS trajectories, which are derived from uncertainty and progress metrics, not from a reward model trained on human-ranked data. Since no human feedback is involved, this does not align with RLHF.",
      "weak_supervision_justification": "The paper employs programmatically generated reasoning trajectories and rewards via UA-MCTS, which can be seen as weak supervision since it relies on automated, noisy sources rather than precise hand-labeled data. However, it is not the primary focus, as the method emphasizes optimization over broad weak supervision techniques.",
      "diffusion_reasoning_justification": "The paper focuses on UA-MCTS for generating and optimizing reasoning trajectories, with no mention or use of diffusion models or iterative refinement processes for logical tasks. Thus, it does not involve diffusion-based reasoning.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "completed",
      "summary": "This paper introduces SMART, a two-stage framework designed to mitigate sycophancy in large language models by reframing it as a reasoning optimization problem rather than an output alignment issue. The framework employs Uncertainty-Aware Adaptive Monte Carlo Tree Search (UA-MCTS) in the first stage to generate diverse, high-quality reasoning trajectories with uncertainty-based rewards, followed by progress-based reinforcement learning in the second stage to fine-tune the model using these trajectories and reward signals. Experimental results demonstrate that SMART significantly reduces sycophantic behavior by 31.9% to 46.4% across various models, enhances generalization on out-of-distribution inputs, and achieves more efficient policy improvements compared to baselines, highlighting the benefits of optimizing internal reasoning mechanisms for more truthful AI assistants.",
      "novelty_score": "High",
      "novelty_justification": "The paper introduces a novel framework, SMART, that reframes sycophancy as a reasoning trajectory optimization problem and proposes UA-MCTS, a new technique that significantly advances state-of-the-art methods for exploring and optimizing LLM reasoning paths.",
      "impact_score": "High",
      "impact_justification": "The work addresses a critical issue in LLMs like sycophancy, potentially influencing widespread research in AI alignment, model safety, and commercial applications by promoting more truthful and robust AI systems.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "This paper offers a high-quality, innovative contribution to mitigating biases in LLMs, making it essential for researchers focused on AI ethics and reinforcement learning to understand and build upon.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/55ca8913b2d324d41d83ad7235dea2b409459399",
      "total_authors": 8,
      "authors_found": 7,
      "highest_h_index": 10,
      "average_h_index": 4.285714285714286,
      "notable_authors_count": 3,
      "author_h_indexes": [
        {
          "name": "Mohammad Beigi",
          "h_index": 3,
          "profile_url": "https://www.semanticscholar.org/author/2284682293"
        },
        {
          "name": "Ying Shen",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2328004098"
        },
        {
          "name": "Parshin Shojaee",
          "h_index": 8,
          "profile_url": "https://www.semanticscholar.org/author/2037848556"
        },
        {
          "name": "Qifan Wang",
          "h_index": 10,
          "profile_url": "https://www.semanticscholar.org/author/2266712798"
        },
        {
          "name": "Zichao Wang",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2374483090"
        },
        {
          "name": "Chandan Reddy",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2381379689"
        },
        {
          "name": "Ming Jin",
          "h_index": null,
          "profile_url": null
        },
        {
          "name": "Lifu Huang",
          "h_index": 8,
          "profile_url": "https://www.semanticscholar.org/author/2273197501"
        }
      ]
    },
    {
      "id": "2509.16743",
      "title": "A Hybrid PCA-PR-Seq2Seq-Adam-LSTM Framework for Time-Series Power Outage\n  Prediction",
      "authors": [
        "Subhabrata Das",
        "Bodruzzaman Khan",
        "Xiao-Yang Liu"
      ],
      "categories": [
        "cs.LG (Machine Learning)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Accurately forecasting power outages is a complex task influenced by diverse\nfactors such as weather conditions [1], vegetation, wildlife, and load\nfluctuations. These factors introduce substantial variability and noise into\noutage data, making reliable prediction challenging. Long Short-Term Memory\n(LSTM) networks, a type of Recurrent Neural Network (RNN), are particularly\neffective for modeling nonlinear and dynamic time-series data, with proven\napplications in stock price forecasting [2], energy demand prediction, demand\nresponse [3], and traffic flow management [4]. This paper introduces a hybrid\ndeep learning framework, termed PCA-PR-Seq2Seq-Adam-LSTM, that integrates\nPrincipal Component Analysis (PCA), Poisson Regression (PR), a\nSequence-to-Sequence (Seq2Seq) architecture, and an Adam-optimized LSTM. PCA is\nemployed to reduce dimensionality and stabilize data variance, while Poisson\nRegression effectively models discrete outage events. The Seq2Seq-Adam-LSTM\ncomponent enhances temporal feature learning through efficient gradient\noptimization and long-term dependency capture. The framework is evaluated using\nreal-world outage records from Michigan, and results indicate that the proposed\napproach significantly improves forecasting accuracy and robustness compared to\nexisting methods.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16743v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16743v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.337,
      "weak_supervision_score": 0.338,
      "diffusion_reasoning_score": 0.346,
      "distributed_training_score": 0.328,
      "datasets_score": 0.317,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16745",
      "title": "CAMBench-QR : A Structure-Aware Benchmark for Post-Hoc Explanations with\n  QR Understanding",
      "authors": [
        "Ritabrata Chakraborty",
        "Avijit Dasgupta",
        "Sandeep Chaurasia"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Visual explanations are often plausible but not structurally faithful. We\nintroduce CAMBench-QR, a structure-aware benchmark that leverages the canonical\ngeometry of QR codes (finder patterns, timing lines, module grid) to test\nwhether CAM methods place saliency on requisite substructures while avoiding\nbackground. CAMBench-QR synthesizes QR/non-QR data with exact masks and\ncontrolled distortions, and reports structure-aware metrics (Finder/Timing Mass\nRatios, Background Leakage, coverage AUCs, Distance-to-Structure) alongside\ncausal occlusion, insertion/deletion faithfulness, robustness, and latency. We\nbenchmark representative, efficient CAMs (LayerCAM, EigenGrad-CAM, XGrad-CAM)\nunder two practical regimes of zero-shot and last-block fine-tuning. The\nbenchmark, metrics, and training recipes provide a simple, reproducible\nyardstick for structure-aware evaluation of visual explanations. Hence we\npropose that CAMBENCH-QR can be used as a litmus test of whether visual\nexplanations are truly structure-aware.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16745v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16745v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.326,
      "weak_supervision_score": 0.32,
      "diffusion_reasoning_score": 0.413,
      "distributed_training_score": 0.294,
      "datasets_score": 0.363,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper introduces CAMBench-QR, a benchmark for evaluating the structural faithfulness of visual saliency methods in computer vision, specifically using QR codes. It does not involve diffusion models, iterative refinement processes, or any adaptation for solving logical tasks or chain-of-thought reasoning. Therefore, there is no connection to diffusion-based reasoning.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16748",
      "title": "HyPlaneHead: Rethinking Tri-plane-like Representations in Full-Head\n  Image Synthesis",
      "authors": [
        "Heyuan Li",
        "Kenkun Liu",
        "Lingteng Qiu",
        "Qi Zuo",
        "Keru Zheng",
        "Zilong Dong",
        "Xiaoguang Han"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Tri-plane-like representations have been widely adopted in 3D-aware GANs for\nhead image synthesis and other 3D object/scene modeling tasks due to their\nefficiency. However, querying features via Cartesian coordinate projection\noften leads to feature entanglement, which results in mirroring artifacts. A\nrecent work, SphereHead, attempted to address this issue by introducing\nspherical tri-planes based on a spherical coordinate system. While it\nsuccessfully mitigates feature entanglement, SphereHead suffers from uneven\nmapping between the square feature maps and the spherical planes, leading to\ninefficient feature map utilization during rendering and difficulties in\ngenerating fine image details. Moreover, both tri-plane and spherical tri-plane\nrepresentations share a subtle yet persistent issue: feature penetration across\nconvolutional channels can cause interference between planes, particularly when\none plane dominates the others. These challenges collectively prevent\ntri-plane-based methods from reaching their full potential. In this paper, we\nsystematically analyze these problems for the first time and propose innovative\nsolutions to address them. Specifically, we introduce a novel hybrid-plane\n(hy-plane for short) representation that combines the strengths of both planar\nand spherical planes while avoiding their respective drawbacks. We further\nenhance the spherical plane by replacing the conventional theta-phi warping\nwith a novel near-equal-area warping strategy, which maximizes the effective\nutilization of the square feature map. In addition, our generator synthesizes a\nsingle-channel unified feature map instead of multiple feature maps in separate\nchannels, thereby effectively eliminating feature penetration. With a series of\ntechnical improvements, our hy-plane representation enables our method,\nHyPlaneHead, to achieve state-of-the-art performance in full-head image\nsynthesis.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16748v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16748v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.341,
      "weak_supervision_score": 0.285,
      "diffusion_reasoning_score": 0.355,
      "distributed_training_score": 0.336,
      "datasets_score": 0.264,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16765",
      "title": "The Sound of Syntax: Finetuning and Comprehensive Evaluation of Language\n  Models for Speech Pathology",
      "authors": [
        "Fagun Patel",
        "Duc Q. Nguyen",
        "Sang T. Truong",
        "Jody Vaynshtok",
        "Sanmi Koyejo",
        "Nick Haber"
      ],
      "categories": [
        "cs.CL (Computation and Language)",
        "cs.AI (Artificial Intelligence)",
        "cs.SD (Sound)",
        "eess.AS (Audio and Speech Processing)"
      ],
      "abstract": "According to the U.S. National Institutes of Health, more than 3.4 million\nchildren experience speech disorders that require clinical intervention. The\nnumber of speech-language pathologists (SLPs) is roughly 20 times fewer than\nthe number of affected children, highlighting a significant gap in children's\ncare and a pressing need for technological support that improves the\nproductivity of SLPs. State-of-the-art multimodal language models (MLMs) show\npromise for supporting SLPs, but their use remains underexplored largely due to\na limited understanding of their performance in high-stakes clinical settings.\nTo address this gap, we collaborate with domain experts to develop a taxonomy\nof real-world use cases of MLMs in speech-language pathologies. Building on\nthis taxonomy, we introduce the first comprehensive benchmark for evaluating\nMLM across five core use cases, each containing 1,000 manually annotated data\npoints. This benchmark includes robustness and sensitivity tests under various\nsettings, including background noise, speaker gender, and accent. Our\nevaluation of 15 state-of-the-art MLMs reveals that no single model\nconsistently outperforms others across all tasks. Notably, we find systematic\ndisparities, with models performing better on male speakers, and observe that\nchain-of-thought prompting can degrade performance on classification tasks with\nlarge label spaces and narrow decision boundaries. Furthermore, we study\nfine-tuning MLMs on domain-specific data, achieving improvements of over 10\\%\ncompared to base models. These findings highlight both the potential and\nlimitations of current MLMs for speech-language pathology applications,\nunderscoring the need for further research and targeted development.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16765v2",
      "pdf_url": "http://arxiv.org/pdf/2509.16765v2",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.42,
      "weak_supervision_score": 0.421,
      "diffusion_reasoning_score": 0.433,
      "distributed_training_score": 0.373,
      "datasets_score": 0.414,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "Not Relevant",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "Highly Relevant",
      "rlhf_justification": "The paper focuses on fine-tuning language models with domain-specific data and manual annotations but does not mention using reinforcement learning, a reward model, or human feedback for alignment, which are core to RLHF.",
      "weak_supervision_justification": "The paper relies on manually annotated data points for its benchmark and datasets, rather than programmatically generating labels from noisy or imprecise sources, which defines weak supervision.",
      "diffusion_reasoning_justification": "The paper evaluates chain-of-thought prompting for reasoning but does not involve diffusion models or iterative refinement processes for multi-step logical tasks, as required for diffusion-based reasoning.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "The paper's main contributions include creating, curating, and releasing four pediatric speech datasets, developing annotation methodologies, and using them for benchmarking and evaluation, directly aligning with research on datasets.",
      "llm_score_status": "completed",
      "summary": "This paper addresses the critical shortage of speech-language pathologists for children with speech disorders by developing a taxonomy of real-world use cases for multimodal language models (MLMs) and introducing the first comprehensive benchmark with over 1,000 annotated data points per task. The methodology involves evaluating 15 state-of-the-art MLMs across five clinical tasks, testing robustness under various conditions, and fine-tuning models on domain-specific data, revealing performance disparities (e.g., better on male speakers), the potential drawbacks of chain-of-thought prompting, and significant improvements of over 10% in model performance, while emphasizing the need for further research to enhance MLMs for high-stakes clinical applications.",
      "novelty_score": "High",
      "novelty_justification": "The paper introduces a truly new benchmark, datasets, and evaluation framework for MLMs in speech pathology, significantly advancing the state-of-the-art by addressing a previously underexplored area with practical resources for clinical applications.",
      "impact_score": "Moderate",
      "impact_justification": "The work is likely to be cited and built upon within the subfield of AI for speech pathology, as it provides essential datasets and benchmarks that could improve technological support for clinicians, though its influence may be limited to specialized healthcare applications.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "This paper represents a strong, valuable contribution by offering new tools and insights for AI in healthcare, making it essential for researchers in computation and language or speech processing to be aware of its findings and resources.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/5a0ee7fb7aa16615242d923ace51118fe9ecc8c4",
      "total_authors": 6,
      "authors_found": 6,
      "highest_h_index": 17,
      "average_h_index": 3.6666666666666665,
      "notable_authors_count": 1,
      "author_h_indexes": [
        {
          "name": "Fagun Patel",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2381366159"
        },
        {
          "name": "Duc Q. Nguyen",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2345690815"
        },
        {
          "name": "Sang T. Truong",
          "h_index": 2,
          "profile_url": "https://www.semanticscholar.org/author/2290018091"
        },
        {
          "name": "Jody Vaynshtok",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2381364579"
        },
        {
          "name": "Sanmi Koyejo",
          "h_index": 17,
          "profile_url": "https://www.semanticscholar.org/author/123593472"
        },
        {
          "name": "Nick Haber",
          "h_index": 2,
          "profile_url": "https://www.semanticscholar.org/author/2314823386"
        }
      ]
    },
    {
      "id": "2509.16767",
      "title": "DiffEye: Diffusion-Based Continuous Eye-Tracking Data Generation\n  Conditioned on Natural Images",
      "authors": [
        "Ozgur Kara",
        "Harris Nisar",
        "James M. Rehg"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Numerous models have been developed for scanpath and saliency prediction,\nwhich are typically trained on scanpaths, which model eye movement as a\nsequence of discrete fixation points connected by saccades, while the rich\ninformation contained in the raw trajectories is often discarded. Moreover,\nmost existing approaches fail to capture the variability observed among human\nsubjects viewing the same image. They generally predict a single scanpath of\nfixed, pre-defined length, which conflicts with the inherent diversity and\nstochastic nature of real-world visual attention. To address these challenges,\nwe propose DiffEye, a diffusion-based training framework designed to model\ncontinuous and diverse eye movement trajectories during free viewing of natural\nimages. Our method builds on a diffusion model conditioned on visual stimuli\nand introduces a novel component, namely Corresponding Positional Embedding\n(CPE), which aligns spatial gaze information with the patch-based semantic\nfeatures of the visual input. By leveraging raw eye-tracking trajectories\nrather than relying on scanpaths, DiffEye captures the inherent variability in\nhuman gaze behavior and generates high-quality, realistic eye movement\npatterns, despite being trained on a comparatively small dataset. The generated\ntrajectories can also be converted into scanpaths and saliency maps, resulting\nin outputs that more accurately reflect the distribution of human visual\nattention. DiffEye is the first method to tackle this task on natural images\nusing a diffusion model while fully leveraging the richness of raw eye-tracking\ndata. Our extensive evaluation shows that DiffEye not only achieves\nstate-of-the-art performance in scanpath generation but also enables, for the\nfirst time, the generation of continuous eye movement trajectories. Project\nwebpage: https://diff-eye.github.io/",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16767v2",
      "pdf_url": "http://arxiv.org/pdf/2509.16767v2",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.337,
      "weak_supervision_score": 0.356,
      "diffusion_reasoning_score": 0.547,
      "distributed_training_score": 0.338,
      "datasets_score": 0.356,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper's main contribution is a diffusion-based framework for generating eye-tracking data from natural images, focusing on modeling continuous trajectories and capturing variability in human gaze. This is a generative task in computer vision, involving iterative refinement for data synthesis, but it does not adapt diffusion models to solve complex logical tasks, handle multi-step reasoning chains, or holistically correct reasoning paths as defined in the topic. Therefore, there is no clear component for diffusion-based reasoning.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16768",
      "title": "MMPart: Harnessing Multi-Modal Large Language Models for Part-Aware 3D\n  Generation",
      "authors": [
        "Omid Bonakdar",
        "Nasser Mozayani"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Generative 3D modeling has advanced rapidly, driven by applications in VR/AR,\nmetaverse, and robotics. However, most methods represent the target object as a\nclosed mesh devoid of any structural information, limiting editing, animation,\nand semantic understanding. Part-aware 3D generation addresses this problem by\ndecomposing objects into meaningful components, but existing pipelines face\nchallenges: in existing methods, the user has no control over which objects are\nseparated and how model imagine the occluded parts in isolation phase. In this\npaper, we introduce MMPart, an innovative framework for generating part-aware\n3D models from a single image. We first use a VLM to generate a set of prompts\nbased on the input image and user descriptions. In the next step, a generative\nmodel generates isolated images of each object based on the initial image and\nthe previous step's prompts as supervisor (which control the pose and guide\nmodel how imagine previously occluded areas). Each of those images then enters\nthe multi-view generation stage, where a number of consistent images from\ndifferent views are generated. Finally, a reconstruction model converts each of\nthese multi-view images into a 3D model.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16768v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16768v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.338,
      "weak_supervision_score": 0.344,
      "diffusion_reasoning_score": 0.424,
      "distributed_training_score": 0.349,
      "datasets_score": 0.321,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper introduces MMPart, a framework for part-aware 3D generation using VLMs and generative models, but it does not involve adapting diffusion models for multi-step logical reasoning or treating a Chain-of-Thought as a holistic entity. While generative models might implicitly use diffusion for image generation, there is no clear component dedicated to iterative refinement of logical tasks, making the paper unrelated to this topic.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16769",
      "title": "Geometric Mixture Classifier (GMC): A Discriminative Per-Class Mixture\n  of Hyperplanes",
      "authors": [
        "Prasanth K K",
        "Shubham Sharma"
      ],
      "categories": [
        "cs.LG (Machine Learning)",
        "cs.AI (Artificial Intelligence)",
        "cs.CL (Computation and Language)"
      ],
      "abstract": "Many real world categories are multimodal, with single classes occupying\ndisjoint regions in feature space. Classical linear models (logistic\nregression, linear SVM) use a single global hyperplane and perform poorly on\nsuch data, while high-capacity methods (kernel SVMs, deep nets) fit multimodal\nstructure but at the expense of interpretability, heavier tuning, and higher\ncomputational cost. We propose the Geometric Mixture Classifier (GMC), a\ndiscriminative model that represents each class as a mixture of hyperplanes.\nWithin each class, GMC combines plane scores via a temperature-controlled\nsoft-OR (log-sum-exp), smoothly approximating the max; across classes, standard\nsoftmax yields probabilistic posteriors. GMC optionally uses Random Fourier\nFeatures (RFF) for nonlinear mappings while keeping inference linear in the\nnumber of planes and features. Our practical training recipe: geometry-aware\nk-means initialization, silhouette-based plane budgeting, alpha annealing,\nusage-aware L2 regularization, label smoothing, and early stopping, makes GMC\nplug-and-play. Across synthetic multimodal datasets (moons, circles, blobs,\nspirals) and tabular/image benchmarks (iris, wine, WDBC, digits), GMC\nconsistently outperforms linear baselines and k-NN, is competitive with\nRBF-SVM, Random Forests, and small MLPs, and provides geometric introspection\nvia per-plane and class responsibility visualizations. Inference scales\nlinearly in planes and features, making GMC CPU-friendly, with single-digit\nmicrosecond latency per example, often faster than RBF-SVM and compact MLPs.\nPost-hoc temperature scaling reduces ECE from about 0.06 to 0.02. GMC thus\nstrikes a favorable balance of accuracy, interpretability, and efficiency: it\nis more expressive than linear models and lighter, more transparent, and faster\nthan kernel or deep models.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16769v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16769v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.312,
      "weak_supervision_score": 0.361,
      "diffusion_reasoning_score": 0.357,
      "distributed_training_score": 0.337,
      "datasets_score": 0.314,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16771",
      "title": "Artificial Satellite Trails Detection Using U-Net Deep Neural Network\n  and Line Segment Detector Algorithm",
      "authors": [
        "Xiaohan Chen",
        "Hongrui Gu",
        "Cunshi Wang",
        "Haiyang Mu",
        "Jie Zheng",
        "Junju Du",
        "Jing Ren",
        "Zhou Fan",
        "Jing Li"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "astro-ph.IM (Instrumentation and Methods for Astrophysics)"
      ],
      "abstract": "With the rapid increase in the number of artificial satellites, astronomical\nimaging is experiencing growing interference. When these satellites reflect\nsunlight, they produce streak-like artifacts in photometry images. Such\nsatellite trails can introduce false sources and cause significant photometric\nerrors. As a result, accurately identifying the positions of satellite trails\nin observational data has become essential. In this work, we propose a\nsatellite trail detection model that combines the U-Net deep neural network for\nimage segmentation with the Line Segment Detector (LSD) algorithm. The model is\ntrained on 375 simulated images of satellite trails, generated using data from\nthe Mini-SiTian Array. Experimental results show that for trails with a\nsignal-to-noise ratio (SNR) greater than 3, the detection rate exceeds 99.\nAdditionally, when applied to real observational data from the Mini-SiTian\nArray, the model achieves a recall of 79.57 and a precision of 74.56.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16771v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16771v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.296,
      "weak_supervision_score": 0.352,
      "diffusion_reasoning_score": 0.328,
      "distributed_training_score": 0.359,
      "datasets_score": 0.346,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16780",
      "title": "Comparing RAG and GraphRAG for Page-Level Retrieval Question Answering\n  on Math Textbook",
      "authors": [
        "Eason Chen",
        "Chuangji Li",
        "Shizhuo Li",
        "Zimo Xiao",
        "Jionghao Lin",
        "Kenneth R. Koedinger"
      ],
      "categories": [
        "cs.IR (Information Retrieval)",
        "cs.AI (Artificial Intelligence)",
        "cs.HC (Human-Computer Interaction)"
      ],
      "abstract": "Technology-enhanced learning environments often help students retrieve\nrelevant learning content for questions arising during self-paced study. Large\nlanguage models (LLMs) have emerged as novel aids for information retrieval\nduring learning. While LLMs are effective for general-purpose\nquestion-answering, they typically lack alignment with the domain knowledge of\nspecific course materials such as textbooks and slides. We investigate\nRetrieval-Augmented Generation (RAG) and GraphRAG, a knowledge graph-enhanced\nRAG approach, for page-level question answering in an undergraduate mathematics\ntextbook. While RAG has been effective for retrieving discrete, contextually\nrelevant passages, GraphRAG may excel in modeling interconnected concepts and\nhierarchical knowledge structures. We curate a dataset of 477 question-answer\npairs, each tied to a distinct textbook page. We then compare the standard\nembedding-based RAG methods to GraphRAG for evaluating both retrieval\naccuracy-whether the correct page is retrieved-and generated answer quality via\nF1 scores. Our findings show that embedding-based RAG achieves higher retrieval\naccuracy and better F1 scores compared to GraphRAG, which tends to retrieve\nexcessive and sometimes irrelevant content due to its entity-based structure.\nWe also explored re-ranking the retrieved pages with LLM and observed mixed\nresults, including performance drop and hallucinations when dealing with larger\ncontext windows. Overall, this study highlights both the promises and\nchallenges of page-level retrieval systems in educational contexts, emphasizing\nthe need for more refined retrieval methods to build reliable AI tutoring\nsolutions in providing reference page numbers.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16780v2",
      "pdf_url": "http://arxiv.org/pdf/2509.16780v2",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.383,
      "weak_supervision_score": 0.337,
      "diffusion_reasoning_score": 0.459,
      "distributed_training_score": 0.317,
      "datasets_score": 0.35,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper's main contribution is a comparison of RAG and GraphRAG methods for retrieval and question answering in a math textbook context, focusing on retrieval accuracy and answer quality. It does not involve diffusion models, iterative refinement processes, or any adaptation of diffusion for multi-step logical reasoning tasks. Therefore, there is no connection to diffusion-based reasoning.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16788",
      "title": "Domain-Adaptive Pre-Training for Arabic Aspect-Based Sentiment Analysis:\n  A Comparative Study of Domain Adaptation and Fine-Tuning Strategies",
      "authors": [
        "Salha Alyami",
        "Amani Jamal",
        "Areej Alhothali"
      ],
      "categories": [
        "cs.CL (Computation and Language)",
        "cs.AI (Artificial Intelligence)",
        "cs.LG (Machine Learning)"
      ],
      "abstract": "Aspect-based sentiment analysis (ABSA) in natural language processing enables\norganizations to understand customer opinions on specific product aspects.\nWhile deep learning models are widely used for English ABSA, their application\nin Arabic is limited due to the scarcity of labeled data. Researchers have\nattempted to tackle this issue by using pre-trained contextualized language\nmodels such as BERT. However, these models are often based on fact-based data,\nwhich can introduce bias in domain-specific tasks like ABSA. To our knowledge,\nno studies have applied adaptive pre-training with Arabic contextualized models\nfor ABSA. This research proposes a novel approach using domain-adaptive\npre-training for aspect-sentiment classification (ASC) and opinion target\nexpression (OTE) extraction. We examine fine-tuning strategies - feature\nextraction, full fine-tuning, and adapter-based methods - to enhance\nperformance and efficiency, utilizing multiple adaptation corpora and\ncontextualized models. Our results show that in-domain adaptive pre-training\nyields modest improvements. Adapter-based fine-tuning is a computationally\nefficient method that achieves competitive results. However, error analyses\nreveal issues with model predictions and dataset labeling. In ASC, common\nproblems include incorrect sentiment labeling, misinterpretation of contrastive\nmarkers, positivity bias for early terms, and challenges with conflicting\nopinions and subword tokenization. For OTE, issues involve mislabeling targets,\nconfusion over syntactic roles, difficulty with multi-word expressions, and\nreliance on shallow heuristics. These findings underscore the need for syntax-\nand semantics-aware models, such as graph convolutional networks, to more\neffectively capture long-distance relations and complex aspect-based opinion\nalignments.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16788v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16788v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.39,
      "weak_supervision_score": 0.361,
      "diffusion_reasoning_score": 0.387,
      "distributed_training_score": 0.343,
      "datasets_score": 0.396,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16804",
      "title": "KuBERT: Central Kurdish BERT Model and Its Application for Sentiment\n  Analysis",
      "authors": [
        "Kozhin muhealddin Awlla",
        "Hadi Veisi",
        "Abdulhady Abas Abdullah"
      ],
      "categories": [
        "cs.CL (Computation and Language)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "This paper enhances the study of sentiment analysis for the Central Kurdish\nlanguage by integrating the Bidirectional Encoder Representations from\nTransformers (BERT) into Natural Language Processing techniques. Kurdish is a\nlow-resourced language, having a high level of linguistic diversity with\nminimal computational resources, making sentiment analysis somewhat\nchallenging. Earlier, this was done using a traditional word embedding model,\nsuch as Word2Vec, but with the emergence of new language models, specifically\nBERT, there is hope for improvements. The better word embedding capabilities of\nBERT lend to this study, aiding in the capturing of the nuanced semantic pool\nand the contextual intricacies of the language under study, the Kurdish\nlanguage, thus setting a new benchmark for sentiment analysis in low-resource\nlanguages.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16804v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16804v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "extraction_failed",
      "embedding_status": "completed",
      "rlhf_score": 0.299,
      "weak_supervision_score": 0.316,
      "diffusion_reasoning_score": 0.303,
      "distributed_training_score": 0.263,
      "datasets_score": 0.328,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16805",
      "title": "Benchmarking and Mitigating MCQA Selection Bias of Large Vision-Language\n  Models",
      "authors": [
        "Md. Atabuzzaman",
        "Ali Asgarov",
        "Chris Thomas"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Large Vision-Language Models (LVLMs) have achieved strong performance on\nvision-language tasks, particularly Visual Question Answering (VQA). While\nprior work has explored unimodal biases in VQA, the problem of selection bias\nin Multiple-Choice Question Answering (MCQA), where models may favor specific\noption tokens (e.g., \"A\") or positions, remains underexplored. In this paper,\nwe investigate both the presence and nature of selection bias in LVLMs through\nfine-grained MCQA benchmarks spanning easy, medium, and hard difficulty levels,\ndefined by the semantic similarity of the options. We further propose an\ninference-time logit-level debiasing method that estimates an ensemble bias\nvector from general and contextual prompts and applies confidence-adaptive\ncorrections to the model's output. Our method mitigates bias without retraining\nand is compatible with frozen LVLMs. Extensive experiments across several\nstate-of-the-art models reveal consistent selection biases that intensify with\ntask difficulty, and show that our mitigation approach significantly reduces\nbias while improving accuracy in challenging settings. This work offers new\ninsights into the limitations of LVLMs in MCQA and presents a practical\napproach to improve their robustness in fine-grained visual reasoning. Datasets\nand code are available at:\nhttps://github.com/Atabuzzaman/Selection-Bias-of-LVLMs",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16805v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16805v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.413,
      "weak_supervision_score": 0.409,
      "diffusion_reasoning_score": 0.435,
      "distributed_training_score": 0.344,
      "datasets_score": 0.4,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "Not Relevant",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "Highly Relevant",
      "rlhf_justification": "The paper focuses on benchmarking and mitigating selection bias in LVLMs through datasets and inference-time methods, with no mention of human feedback, reward models, or reinforcement learning for model alignment.",
      "weak_supervision_justification": "The paper introduces benchmark datasets for evaluating LVLMs but does not involve training models using programmatically generated labels or noisy sources, which is the core of weak supervision.",
      "diffusion_reasoning_justification": "The paper addresses selection bias in LVLMs and proposes a debiasing method, but it does not incorporate diffusion models, iterative refinement, or multi-step logical reasoning as described in diffusion-based approaches.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "The paper's main contributions include creating, analyzing, and benchmarking new datasets for evaluating selection bias in LVLMs, with variations across difficulty levels, directly aligning with research on dataset introduction and evaluation.",
      "llm_score_status": "completed",
      "summary": "This paper investigates selection biases in Large Vision-Language Models (LVLMs) for Multiple-Choice Question Answering (MCQA), where models exhibit preferences for specific options based on position or tokens, and proposes new benchmarks with easy, medium, and hard difficulty levels based on semantic similarity. The authors introduce an inference-time logit debiasing method that estimates an ensemble bias vector from prompts and applies confidence-adaptive corrections, demonstrating through experiments that it significantly reduces bias and improves accuracy in state-of-the-art LVLMs, particularly in challenging scenarios.",
      "novelty_score": "Moderate",
      "novelty_justification": "The paper presents a notable improvement by adapting known biases from LLMs to LVLMs and introducing new benchmarks, offering a clever combination of existing ideas to address an underexplored problem in MCQA. However, it does not introduce a entirely new problem or technique, as it builds on prior work in bias detection.",
      "impact_score": "Moderate",
      "impact_justification": "The work is likely to be cited and built upon in the subfield of vision-language models, as it provides practical benchmarks and a debiasing method that enhance model robustness and fairness. While its influence may be confined to specific AI research areas like bias mitigation, it addresses a relevant issue that could improve real-world applications of LVLMs.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "This paper delivers a high-quality contribution with practical insights and methods for addressing biases in LVLMs, making it valuable for researchers in computer vision and AI ethics. It is significant but not essential for all readers, as its focus is on a specific subproblem within the broader field.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/97ab9af9fae303418a5d94f0d061667f57db00b2",
      "total_authors": 3,
      "authors_found": 3,
      "highest_h_index": 2,
      "average_h_index": 1.3333333333333333,
      "notable_authors_count": 0,
      "author_h_indexes": [
        {
          "name": "Md. Atabuzzaman",
          "h_index": 2,
          "profile_url": "https://www.semanticscholar.org/author/2321868747"
        },
        {
          "name": "Ali Asgarov",
          "h_index": 2,
          "profile_url": "https://www.semanticscholar.org/author/2237423681"
        },
        {
          "name": "Chris Thomas",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2382957398"
        }
      ]
    },
    {
      "id": "2509.16806",
      "title": "MedGS: Gaussian Splatting for Multi-Modal 3D Medical Imaging",
      "authors": [
        "Kacper Marzol",
        "Ignacy Kolton",
        "Weronika Smolak-Dyżewska",
        "Joanna Kaleta",
        "Marcin Mazur",
        "Przemysław Spurek"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Multi-modal three-dimensional (3D) medical imaging data, derived from\nultrasound, magnetic resonance imaging (MRI), and potentially computed\ntomography (CT), provide a widely adopted approach for non-invasive anatomical\nvisualization. Accurate modeling, registration, and visualization in this\nsetting depend on surface reconstruction and frame-to-frame interpolation.\nTraditional methods often face limitations due to image noise and incomplete\ninformation between frames. To address these challenges, we present MedGS, a\nsemi-supervised neural implicit surface reconstruction framework that employs a\nGaussian Splatting (GS)-based interpolation mechanism. In this framework,\nmedical imaging data are represented as consecutive two-dimensional (2D) frames\nembedded in 3D space and modeled using Gaussian-based distributions. This\nrepresentation enables robust frame interpolation and high-fidelity surface\nreconstruction across imaging modalities. As a result, MedGS offers more\nefficient training than traditional neural implicit methods. Its explicit\nGS-based representation enhances noise robustness, allows flexible editing, and\nsupports precise modeling of complex anatomical structures with fewer\nartifacts. These features make MedGS highly suitable for scalable and practical\napplications in medical imaging.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16806v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16806v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.246,
      "weak_supervision_score": 0.328,
      "diffusion_reasoning_score": 0.372,
      "distributed_training_score": 0.324,
      "datasets_score": 0.293,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16810",
      "title": "Automated Procedural Analysis via Video-Language Models for AI-assisted\n  Nursing Skills Assessment",
      "authors": [
        "Shen Chang",
        "Dennis Liu",
        "Renran Tian",
        "Kristen L. Swartzell",
        "Stacie L. Klingler",
        "Amy M. Nagle",
        "Nan Kong"
      ],
      "categories": [
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Consistent high-quality nursing care is essential for patient safety, yet\ncurrent nursing education depends on subjective, time-intensive instructor\nfeedback in training future nurses, which limits scalability and efficiency in\ntheir training, and thus hampers nursing competency when they enter the\nworkforce. In this paper, we introduce a video-language model (VLM) based\nframework to develop the AI capability of automated procedural assessment and\nfeedback for nursing skills training, with the potential of being integrated\ninto existing training programs. Mimicking human skill acquisition, the\nframework follows a curriculum-inspired progression, advancing from high-level\naction recognition, fine-grained subaction decomposition, and ultimately to\nprocedural reasoning. This design supports scalable evaluation by reducing\ninstructor workload while preserving assessment quality. The system provides\nthree core capabilities: 1) diagnosing errors by identifying missing or\nincorrect subactions in nursing skill instruction videos, 2) generating\nexplainable feedback by clarifying why a step is out of order or omitted, and\n3) enabling objective, consistent formative evaluation of procedures.\nValidation on synthesized videos demonstrates reliable error detection and\ntemporal localization, confirming its potential to handle real-world training\nvariability. By addressing workflow bottlenecks and supporting large-scale,\nstandardized evaluation, this work advances AI applications in nursing\neducation, contributing to stronger workforce development and ultimately safer\npatient care.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16810v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16810v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.446,
      "weak_supervision_score": 0.42,
      "diffusion_reasoning_score": 0.415,
      "distributed_training_score": 0.368,
      "datasets_score": 0.377,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "Not Relevant",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper focuses on applying video-language models for nursing skills assessment, including error detection and feedback generation, but does not involve training a model using human-ranked data to create a reward model for reinforcement learning. There is no mention of RLHF or any similar alignment process.",
      "weak_supervision_justification": "The paper describes using video-language models for procedural analysis and validates on synthesized videos, but it does not discuss training models with programmatically generated, noisy, or imprecise labels. There is no evidence of weak supervision techniques being employed.",
      "diffusion_reasoning_justification": "The paper utilizes video-language models for hierarchical procedural reasoning and feedback, but it does not incorporate diffusion-based methods for multi-step logical reasoning or iterative refinement of a 'Chain-of-Thought'. The reasoning is described as curriculum-inspired but not diffusion-oriented.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16811",
      "title": "Prompt-Driven Agentic Video Editing System: Autonomous Comprehension of\n  Long-Form, Story-Driven Media",
      "authors": [
        "Zihan Ding",
        "Xinyi Wang",
        "Junlong Chen",
        "Per Ola Kristensson",
        "Junxiao Shen"
      ],
      "categories": [
        "cs.AI (Artificial Intelligence)",
        "cs.HC (Human-Computer Interaction)"
      ],
      "abstract": "Creators struggle to edit long-form, narrative-rich videos not because of UI\ncomplexity, but due to the cognitive demands of searching, storyboarding, and\nsequencing hours of footage. Existing transcript- or embedding-based methods\nfall short for creative workflows, as models struggle to track characters,\ninfer motivations, and connect dispersed events. We present a prompt-driven,\nmodular editing system that helps creators restructure multi-hour content\nthrough free-form prompts rather than timelines. At its core is a semantic\nindexing pipeline that builds a global narrative via temporal segmentation,\nguided memory compression, and cross-granularity fusion, producing\ninterpretable traces of plot, dialogue, emotion, and context. Users receive\ncinematic edits while optionally refining transparent intermediate outputs.\nEvaluated on 400+ videos with expert ratings, QA, and preference studies, our\nsystem scales prompt-driven editing, preserves narrative coherence, and\nbalances automation with creator control.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16811v2",
      "pdf_url": "http://arxiv.org/pdf/2509.16811v2",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.407,
      "weak_supervision_score": 0.359,
      "diffusion_reasoning_score": 0.447,
      "distributed_training_score": 0.32,
      "datasets_score": 0.348,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper presents a video editing system evaluated using human feedback, such as expert ratings and preference studies, but it does not involve training or fine-tuning models with a reward model based on human-ranked data via reinforcement learning. The core contribution focuses on prompt-driven editing and semantic indexing, not RLHF techniques.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper describes a system for video editing using temporal segmentation, memory compression, and agentic workflows, but it does not incorporate diffusion models or iterative refinement processes for multi-step logical reasoning. There is no mention of treating reasoning paths as entities for holistic correction.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16812",
      "title": "SMART-3D: Three-Dimensional Self-Morphing Adaptive Replanning Tree",
      "authors": [
        "Priyanshu Agrawal",
        "Shalabh Gupta",
        "Zongyuan Shen"
      ],
      "categories": [
        "cs.RO (Robotics)",
        "cs.AI (Artificial Intelligence)",
        "cs.SY (Systems and Control)",
        "eess.SY (Systems and Control)"
      ],
      "abstract": "This paper presents SMART-3D, an extension of the SMART algorithm to 3D\nenvironments. SMART-3D is a tree-based adaptive replanning algorithm for\ndynamic environments with fast moving obstacles. SMART-3D morphs the underlying\ntree to find a new path in real-time whenever the current path is blocked by\nobstacles. SMART-3D removed the grid decomposition requirement of the SMART\nalgorithm by replacing the concept of hot-spots with that of hot-nodes, thus\nmaking it computationally efficient and scalable to 3D environments. The\nhot-nodes are nodes which allow for efficient reconnections to morph the\nexisting tree to find a new safe and reliable path. The performance of SMART-3D\nis evaluated by extensive simulations in 2D and 3D environments populated with\nrandomly moving dynamic obstacles. The results show that SMART-3D achieves high\nsuccess rates and low replanning times, thus highlighting its suitability for\nreal-time onboard applications.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16812v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16812v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.285,
      "weak_supervision_score": 0.244,
      "diffusion_reasoning_score": 0.336,
      "distributed_training_score": 0.279,
      "datasets_score": 0.229,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16814",
      "title": "Development of a Mobile Application for at-Home Analysis of Retinal\n  Fundus Images",
      "authors": [
        "Mattea Reid",
        "Zuhairah Zainal",
        "Khaing Zin Than",
        "Danielle Chan",
        "Jonathan Chan"
      ],
      "categories": [
        "cs.HC (Human-Computer Interaction)",
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Machine learning is gaining significant attention as a diagnostic tool in\nmedical imaging, particularly in the analysis of retinal fundus images.\nHowever, this approach is not yet clinically applicable, as it still depends on\nhuman validation from a professional. Therefore, we present the design for a\nmobile application that monitors metrics related to retinal fundus images\ncorrelating to age-related conditions. The purpose of this platform is to\nobserve for a change in these metrics over time, offering early insights into\npotential ocular diseases without explicitly delivering diagnostics. Metrics\nanalysed include vessel tortuosity, as well as signs of glaucoma, retinopathy\nand macular edema. To evaluate retinopathy grade and risk of macular edema, a\nmodel was trained on the Messidor dataset and compared to a similar model\ntrained on the MAPLES-DR dataset. Information from the DeepSeeNet glaucoma\ndetection model, as well as tortuosity calculations, is additionally\nincorporated to ultimately present a retinal fundus image monitoring platform.\nAs a result, the mobile application permits monitoring of trends or changes in\nocular metrics correlated to age-related conditions with regularly uploaded\nphotographs.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16814v2",
      "pdf_url": "http://arxiv.org/pdf/2509.16814v2",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.292,
      "weak_supervision_score": 0.286,
      "diffusion_reasoning_score": 0.286,
      "distributed_training_score": 0.282,
      "datasets_score": 0.322,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16822",
      "title": "Looking in the mirror: A faithful counterfactual explanation method for\n  interpreting deep image classification models",
      "authors": [
        "Townim Faisal Chowdhury",
        "Vu Minh Hieu Phan",
        "Kewen Liao",
        "Nanyu Dong",
        "Minh-Son To",
        "Anton Hengel",
        "Johan Verjans",
        "Zhibin Liao"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Counterfactual explanations (CFE) for deep image classifiers aim to reveal\nhow minimal input changes lead to different model decisions, providing critical\ninsights for model interpretation and improvement. However, existing CFE\nmethods often rely on additional image encoders and generative models to create\nplausible images, neglecting the classifier's own feature space and decision\nboundaries. As such, they do not explain the intrinsic feature space and\ndecision boundaries learned by the classifier. To address this limitation, we\npropose Mirror-CFE, a novel method that generates faithful counterfactual\nexplanations by operating directly in the classifier's feature space, treating\ndecision boundaries as mirrors that ``reflect'' feature representations in the\nmirror. Mirror-CFE learns a mapping function from feature space to image space\nwhile preserving distance relationships, enabling smooth transitions between\nsource images and their counterfactuals. Through extensive experiments on four\nimage datasets, we demonstrate that Mirror-CFE achieves superior performance in\nvalidity while maintaining input resemblance compared to state-of-the-art\nexplanation methods. Finally, mirror-CFE provides interpretable visualization\nof the classifier's decision process by generating step-wise transitions that\nreveal how features evolve as classification confidence changes.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16822v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16822v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.343,
      "weak_supervision_score": 0.32,
      "diffusion_reasoning_score": 0.408,
      "distributed_training_score": 0.305,
      "datasets_score": 0.296,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper introduces Mirror-CFE, a method for generating counterfactual explanations in image classification by operating in the classifier's feature space and preserving distance relationships. It does not involve diffusion models, iterative refinement for logical tasks, or treating a 'Chain-of-Thought' as an entity for holistic correction. The focus is solely on visual explanations for AI models, with no components related to multi-step logical reasoning.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16825",
      "title": "KANO: Kolmogorov-Arnold Neural Operator",
      "authors": [
        "Jin Lee",
        "Ziming Liu",
        "Xinling Yu",
        "Yixuan Wang",
        "Haewon Jeong",
        "Murphy Yuezhen Niu",
        "Zheng Zhang"
      ],
      "categories": [
        "cs.LG (Machine Learning)",
        "cs.AI (Artificial Intelligence)",
        "cs.CE (Computational Engineering, Finance, and Science)"
      ],
      "abstract": "We introduce Kolmogorov--Arnold Neural Operator (KANO), a dual-domain neural\noperator jointly parameterized by both spectral and spatial bases with\nintrinsic symbolic interpretability. We theoretically demonstrate that KANO\novercomes the pure-spectral bottleneck of Fourier Neural Operator (FNO): KANO\nremains expressive over generic position-dependent dynamics (variable\ncoefficient PDEs) for any physical input, whereas FNO stays practical only for\nspectrally sparse operators and strictly imposes a fast-decaying input Fourier\ntail. We verify our claims empirically on position-dependent differential\noperators, for which KANO robustly generalizes but FNO fails to. In the quantum\nHamiltonian learning benchmark, KANO reconstructs ground-truth Hamiltonians in\nclosed-form symbolic representations accurate to the fourth decimal place in\ncoefficients and attains $\\approx 6\\times10^{-6}$ state infidelity from\nprojective measurement data, substantially outperforming that of the FNO\ntrained with ideal full wave function data, $\\approx 1.5\\times10^{-2}$, by\norders of magnitude.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16825v2",
      "pdf_url": "http://arxiv.org/pdf/2509.16825v2",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.301,
      "weak_supervision_score": 0.287,
      "diffusion_reasoning_score": 0.357,
      "distributed_training_score": 0.343,
      "datasets_score": 0.257,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16832",
      "title": "L2M-Reg: Building-level Uncertainty-aware Registration of Outdoor LiDAR\n  Point Clouds and Semantic 3D City Models",
      "authors": [
        "Ziyang Xu",
        "Benedikt Schwab",
        "Yihui Yang",
        "Thomas H. Kolbe",
        "Christoph Holst"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.RO (Robotics)",
        "eess.IV (Image and Video Processing)"
      ],
      "abstract": "Accurate registration between LiDAR (Light Detection and Ranging) point\nclouds and semantic 3D city models is a fundamental topic in urban digital\ntwinning and a prerequisite for downstream tasks, such as digital construction,\nchange detection and model refinement. However, achieving accurate\nLiDAR-to-Model registration at individual building level remains challenging,\nparticularly due to the generalization uncertainty in semantic 3D city models\nat the Level of Detail 2 (LoD2). This paper addresses this gap by proposing\nL2M-Reg, a plane-based fine registration method that explicitly accounts for\nmodel uncertainty. L2M-Reg consists of three key steps: establishing reliable\nplane correspondence, building a pseudo-plane-constrained Gauss-Helmert model,\nand adaptively estimating vertical translation. Experiments on three real-world\ndatasets demonstrate that L2M-Reg is both more accurate and computationally\nefficient than existing ICP-based and plane-based methods. Overall, L2M-Reg\nprovides a novel building-level solution regarding LiDAR-to-Model registration\nwhen model uncertainty is present.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16832v2",
      "pdf_url": "http://arxiv.org/pdf/2509.16832v2",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.319,
      "weak_supervision_score": 0.321,
      "diffusion_reasoning_score": 0.329,
      "distributed_training_score": 0.304,
      "datasets_score": 0.297,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16833",
      "title": "SOLAR: Switchable Output Layer for Accuracy and Robustness in\n  Once-for-All Training",
      "authors": [
        "Shaharyar Ahmed Khan Tareen",
        "Lei Fan",
        "Xiaojing Yuan",
        "Qin Lin",
        "Bin Hu"
      ],
      "categories": [
        "cs.LG (Machine Learning)",
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Once-for-All (OFA) training enables a single super-net to generate multiple\nsub-nets tailored to diverse deployment scenarios, supporting flexible\ntrade-offs among accuracy, robustness, and model-size without retraining.\nHowever, as the number of supported sub-nets increases, excessive parameter\nsharing in the backbone limits representational capacity, leading to degraded\ncalibration and reduced overall performance. To address this, we propose SOLAR\n(Switchable Output Layer for Accuracy and Robustness in Once-for-All Training),\na simple yet effective technique that assigns each sub-net a separate\nclassification head. By decoupling the logit learning process across sub-nets,\nthe Switchable Output Layer (SOL) reduces representational interference and\nimproves optimization, without altering the shared backbone. We evaluate SOLAR\non five datasets (SVHN, CIFAR-10, STL-10, CIFAR-100, and TinyImageNet) using\nfour super-net backbones (ResNet-34, WideResNet-16-8, WideResNet-40-2, and\nMobileNetV2) for two OFA training frameworks (OATS and SNNs). Experiments show\nthat SOLAR outperforms the baseline methods: compared to OATS, it improves\naccuracy of sub-nets up to 1.26 %, 4.71 %, 1.67 %, and 1.76 %, and robustness\nup to 9.01 %, 7.71 %, 2.72 %, and 1.26 % on SVHN, CIFAR-10, STL-10, and\nCIFAR-100, respectively. Compared to SNNs, it improves TinyImageNet accuracy by\nup to 2.93 %, 2.34 %, and 1.35 % using ResNet-34, WideResNet-16-8, and\nMobileNetV2 backbones (with 8 sub-nets), respectively.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16833v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16833v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.341,
      "weak_supervision_score": 0.357,
      "diffusion_reasoning_score": 0.338,
      "distributed_training_score": 0.448,
      "datasets_score": 0.289,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "Not Relevant",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "The paper focuses on improving Once-for-All (OFA) training by introducing separate classification heads for sub-nets to enhance accuracy and robustness, without any discussion of distributed training techniques, parallel computing, or partitioning data/computation across multiple processors or nodes. It deals solely with model architecture and optimization within a single training setup.",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16834",
      "title": "Robot Learning with Sparsity and Scarcity",
      "authors": [
        "Jingxi Xu"
      ],
      "categories": [
        "cs.RO (Robotics)",
        "cs.AI (Artificial Intelligence)",
        "cs.LG (Machine Learning)"
      ],
      "abstract": "Unlike in language or vision, one of the fundamental challenges in robot\nlearning is the lack of access to vast data resources. We can further break\ndown the problem into (1) data sparsity from the angle of data representation\nand (2) data scarcity from the angle of data quantity. In this thesis, I will\ndiscuss selected works on two domains: (1) tactile sensing and (2)\nrehabilitation robots, which are exemplars of data sparsity and scarcity,\nrespectively. Tactile sensing is an essential modality for robotics, but\ntactile data are often sparse, and for each interaction with the physical\nworld, tactile sensors can only obtain information about the local area of\ncontact. I will discuss my work on learning vision-free tactile-only\nexploration and manipulation policies through model-free reinforcement learning\nto make efficient use of sparse tactile information. On the other hand,\nrehabilitation robots are an example of data scarcity to the extreme due to the\nsignificant challenge of collecting biosignals from disabled-bodied subjects at\nscale for training. I will discuss my work in collaboration with the medical\nschool and clinicians on intent inferral for stroke survivors, where a hand\northosis developed in our lab collects a set of biosignals from the patient and\nuses them to infer the activity that the patient intends to perform, so the\northosis can provide the right type of physical assistance at the right moment.\nMy work develops machine learning algorithms that enable intent inferral with\nminimal data, including semi-supervised, meta-learning, and generative AI\nmethods.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16834v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16834v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.414,
      "weak_supervision_score": 0.479,
      "diffusion_reasoning_score": 0.351,
      "distributed_training_score": 0.393,
      "datasets_score": 0.399,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "Moderately Relevant",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper discusses model-free reinforcement learning for tactile manipulation and intent inference, but it does not involve human feedback, such as training a reward model on human-ranked data, to fine-tune models. The focus is on sparse and scarce data without any mention of human preferences or feedback mechanisms.",
      "weak_supervision_justification": "The paper addresses handling minimal data for intent inference in rehabilitation robots using semi-supervised and meta-learning methods, which can involve noisy or imprecise labels similar to weak supervision. However, it does not explicitly describe programmatically generating labels from high-level sources, limiting the direct relevance.",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "completed",
      "summary": "This thesis addresses the fundamental challenges of data sparsity and scarcity in robot learning, focusing on tactile sensing and rehabilitation robots as key examples. For tactile sensing, the author develops model-free reinforcement learning policies to enable efficient exploration and manipulation using sparse local contact data, while for rehabilitation robots, machine learning algorithms such as semi-supervised learning, meta-learning, and generative AI are employed to infer user intent from minimal biosignals, facilitating targeted assistance for stroke survivors. Overall, the work highlights innovative approaches to overcome data limitations in robotics, though it primarily synthesizes and applies existing techniques to specific domains.",
      "novelty_score": "Moderate",
      "novelty_justification": "The paper presents a notable improvement by combining existing machine learning techniques like reinforcement learning and meta-learning with specific robotics challenges, such as sparse tactile data and scarce biosignals, to address known problems in new contextual ways, though it does not introduce entirely novel architectures or problems.",
      "impact_score": "Moderate",
      "impact_justification": "The work is likely to influence future research in subfields like tactile manipulation and assistive rehabilitation robotics by providing practical methods for data-limited scenarios, potentially leading to citations and developments in specialized applications but with limited broader reach.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "This paper offers valuable contributions to handling data challenges in robotics, making it a significant and insightful read for researchers in AI and robotics who focus on real-world applications, though it may not be essential for a general audience.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/081ef66a38c4ebbadaf92a6d5730cfb89dfcf768",
      "total_authors": 1,
      "authors_found": 1,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": [
        {
          "name": "Jingxi Xu",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2381827894"
        }
      ]
    },
    {
      "id": "2509.16835",
      "title": "Semantic-Driven Topic Modeling for Analyzing Creativity in Virtual\n  Brainstorming",
      "authors": [
        "Melkamu Abay Mersha",
        "Jugal Kalita"
      ],
      "categories": [
        "cs.CL (Computation and Language)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Virtual brainstorming sessions have become a central component of\ncollaborative problem solving, yet the large volume and uneven distribution of\nideas often make it difficult to extract valuable insights efficiently. Manual\ncoding of ideas is time-consuming and subjective, underscoring the need for\nautomated approaches to support the evaluation of group creativity. In this\nstudy, we propose a semantic-driven topic modeling framework that integrates\nfour modular components: transformer-based embeddings (Sentence-BERT),\ndimensionality reduction (UMAP), clustering (HDBSCAN), and topic extraction\nwith refinement. The framework captures semantic similarity at the sentence\nlevel, enabling the discovery of coherent themes from brainstorming transcripts\nwhile filtering noise and identifying outliers. We evaluate our approach on\nstructured Zoom brainstorming sessions involving student groups tasked with\nimproving their university. Results demonstrate that our model achieves higher\ntopic coherence compared to established methods such as LDA, ETM, and BERTopic,\nwith an average coherence score of 0.687 (CV), outperforming baselines by a\nsignificant margin. Beyond improved performance, the model provides\ninterpretable insights into the depth and diversity of topics explored,\nsupporting both convergent and divergent dimensions of group creativity. This\nwork highlights the potential of embedding-based topic modeling for analyzing\ncollaborative ideation and contributes an efficient and scalable framework for\nstudying creativity in synchronous virtual meetings.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16835v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16835v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.379,
      "weak_supervision_score": 0.369,
      "diffusion_reasoning_score": 0.48,
      "distributed_training_score": 0.359,
      "datasets_score": 0.405,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "Not Relevant",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on a semantic-driven topic modeling framework using transformer-based embeddings, dimensionality reduction, clustering, and topic extraction for analyzing brainstorming sessions. It does not involve diffusion models, iterative refinement processes, or multi-step logical reasoning, making it unrelated to diffusion-based reasoning.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "The paper applies topic modeling to Zoom brainstorming transcripts for evaluating group creativity but does not primarily focus on creating, analyzing, benchmarking, or evaluating datasets. It uses a dataset as part of its experiments without contributing to dataset research.",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.16839",
      "title": "Roundtable Policy: Improving Scientific Reasoning and Narratives through\n  Confidence-Weighted Consensus of LLMs",
      "authors": [
        "Yu Yao",
        "Jiayi Dong",
        "Ju Li",
        "Yang Yang",
        "Yilun Du"
      ],
      "categories": [
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Large language models (LLMs) have demonstrated remarkable capabilities not\nonly in language generation but also in advancing scientific discovery. A\ngrowing body of work has explored ways to improve their reasoning, from\nself-consistency and chain-of-thought to multi-agent debate. Inspired by the\ndynamics of scientific committees and the \"Society of Mind,\" we introduce\nRoundtable Policy, a complementary inference-time reasoning framework that\nperforms inference through the weighted consensus of multiple LLMs. Our\nfindings indicate that this approach significantly enhances reasoning in\ncomplex heterogeneous scientific tasks and improves scientific narratives in\nterms of creativity, rigor, and logical coherence, while reducing\nhallucinations that single models are prone to. Our approach emphasizes\nstructured and interpretable consensus rather than opaque convergence, while\nrequiring only black-box access and uniform procedures, making it broadly\napplicable to multi-LLM reasoning.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.16839v1",
      "pdf_url": "http://arxiv.org/pdf/2509.16839v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.449,
      "weak_supervision_score": 0.396,
      "diffusion_reasoning_score": 0.536,
      "distributed_training_score": 0.392,
      "datasets_score": 0.37,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper introduces Roundtable Policy, a framework for aggregating responses from multiple LLMs at inference time using weighted consensus based on performance metrics. It does not involve training a model with human-ranked data, a reward model, or reinforcement learning to align with human preferences, which are core to RLHF.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on weighted consensus among multiple LLMs for reasoning tasks, but it does not adapt the iterative refinement process of diffusion models, treat a chain-of-thought as a single entity for holistic correction, or incorporate multi-step logical reasoning via diffusion. It relies on proposal and evaluation mechanisms without any diffusion-based components.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.18200",
      "title": "Conversational Orientation Reasoning: Egocentric-to-Allocentric\n  Navigation with Multimodal Chain-of-Thought",
      "authors": [
        "Yu Ti Huang"
      ],
      "categories": [
        "cs.LG (Machine Learning)",
        "cs.AI (Artificial Intelligence)",
        "cs.CL (Computation and Language)",
        "cs.RO (Robotics)"
      ],
      "abstract": "Conversational agents must translate egocentric utterances (e.g., \"on my\nright\") into allocentric orientations (N/E/S/W). This challenge is particularly\ncritical in indoor or complex facilities where GPS signals are weak and\ndetailed maps are unavailable. While chain-of-thought (CoT) prompting has\nadvanced reasoning in language and vision tasks, its application to multimodal\nspatial orientation remains underexplored. We introduce Conversational\nOrientation Reasoning (COR), a new benchmark designed for Traditional Chinese\nconversational navigation projected from real-world environments, addressing\negocentric-to-allocentric reasoning in non-English and ASR-transcribed\nscenarios. We propose a multimodal chain-of-thought (MCoT) framework, which\nintegrates ASR-transcribed speech with landmark coordinates through a\nstructured three-step reasoning process: (1) extracting spatial relations, (2)\nmapping coordinates to absolute directions, and (3) inferring user orientation.\nA curriculum learning strategy progressively builds these capabilities on\nTaiwan-LLM-13B-v2.0-Chat, a mid-sized model representative of\nresource-constrained settings. Experiments show that MCoT achieves 100%\norientation accuracy on clean transcripts and 98.1% with ASR transcripts,\nsubstantially outperforming unimodal and non-structured baselines. Moreover,\nMCoT demonstrates robustness under noisy conversational conditions, including\nASR recognition errors and multilingual code-switching. The model also\nmaintains high accuracy in cross-domain evaluation and resilience to linguistic\nvariation, domain shift, and referential ambiguity. These findings highlight\nthe potential of structured MCoT spatial reasoning as a path toward\ninterpretable and resource-efficient embodied navigation.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.18200v1",
      "pdf_url": "http://arxiv.org/pdf/2509.18200v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.376,
      "weak_supervision_score": 0.325,
      "diffusion_reasoning_score": 0.488,
      "distributed_training_score": 0.287,
      "datasets_score": 0.32,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on multimodal chain-of-thought (MCoT) prompting for spatial orientation reasoning, involving a structured three-step process for egocentric-to-allocentric navigation. It does not mention or utilize diffusion models, iterative refinement processes, or any adaptation of diffusion for logical tasks. Therefore, there is no connection to diffusion-based reasoning.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.19376",
      "title": "Solving Freshness in RAG: A Simple Recency Prior and the Limits of\n  Heuristic Trend Detection",
      "authors": [
        "Matthew Grofsky"
      ],
      "categories": [
        "cs.LG (Machine Learning)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "We address temporal failures in RAG systems using two methods on\ncybersecurity data. A simple recency prior achieved an accuracy of 1.00 on\nfreshness tasks. In contrast, a clustering heuristic for topic evolution failed\n(0.08 F1-score), showing trend detection requires methods beyond simple\nheuristics.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.19376v1",
      "pdf_url": "http://arxiv.org/pdf/2509.19376v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.398,
      "weak_supervision_score": 0.369,
      "diffusion_reasoning_score": 0.417,
      "distributed_training_score": 0.33,
      "datasets_score": 0.337,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on enhancing RAG systems with temporal signals, such as recency priors and heuristic trend detection for cybersecurity data. It does not involve diffusion models, iterative refinement processes, or adaptations for complex logical tasks like treating a Chain-of-Thought as a single entity. Thus, there is no connection to diffusion-based reasoning.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.19378",
      "title": "Vision-Based Perception for Autonomous Vehicles in Off-Road Environment\n  Using Deep Learning",
      "authors": [
        "Nelson Alves Ferreira Neto"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.AR (Hardware Architecture)",
        "cs.LG (Machine Learning)",
        "eess.IV (Image and Video Processing)",
        "eess.SP (Signal Processing)"
      ],
      "abstract": "Low-latency intelligent systems are required for autonomous driving on\nnon-uniform terrain in open-pit mines and developing countries. This work\nproposes a perception system for autonomous vehicles on unpaved roads and\noff-road environments, capable of navigating rough terrain without a predefined\ntrail. The Configurable Modular Segmentation Network (CMSNet) framework is\nproposed, facilitating different architectural arrangements. CMSNet\nconfigurations were trained to segment obstacles and trafficable ground on new\nimages from unpaved/off-road scenarios with adverse conditions (night, rain,\ndust). We investigated applying deep learning to detect drivable regions\nwithout explicit track boundaries, studied algorithm behavior under visibility\nimpairment, and evaluated field tests with real-time semantic segmentation. A\nnew dataset, Kamino, is presented with almost 12,000 images from an operating\nvehicle with eight synchronized cameras. The Kamino dataset has a high number\nof labeled pixels compared to similar public collections and includes images\nfrom an off-road proving ground emulating a mine under adverse visibility. To\nachieve real-time inference, CMSNet CNN layers were methodically removed and\nfused using TensorRT, C++, and CUDA. Empirical experiments on two datasets\nvalidated the proposed system's effectiveness.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.19378v1",
      "pdf_url": "http://arxiv.org/pdf/2509.19378v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.312,
      "weak_supervision_score": 0.385,
      "diffusion_reasoning_score": 0.327,
      "distributed_training_score": 0.376,
      "datasets_score": 0.382,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.19379",
      "title": "Learning from Observation: A Survey of Recent Advances",
      "authors": [
        "Returaj Burnwal",
        "Hriday Mehta",
        "Nirav Pravinbhai Bhatt",
        "Balaraman Ravindran"
      ],
      "categories": [
        "cs.LG (Machine Learning)",
        "cs.AI (Artificial Intelligence)",
        "cs.RO (Robotics)",
        "stat.ML (Machine Learning)"
      ],
      "abstract": "Imitation Learning (IL) algorithms offer an efficient way to train an agent\nby mimicking an expert's behavior without requiring a reward function. IL\nalgorithms often necessitate access to state and action information from expert\ndemonstrations. Although expert actions can provide detailed guidance,\nrequiring such action information may prove impractical for real-world\napplications where expert actions are difficult to obtain. To address this\nlimitation, the concept of learning from observation (LfO) or state-only\nimitation learning (SOIL) has recently gained attention, wherein the imitator\nonly has access to expert state visitation information. In this paper, we\npresent a framework for LfO and use it to survey and classify existing LfO\nmethods in terms of their trajectory construction, assumptions and algorithm's\ndesign choices. This survey also draws connections between several related\nfields like offline RL, model-based RL and hierarchical RL. Finally, we use our\nframework to identify open problems and suggest future research directions.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.19379v1",
      "pdf_url": "http://arxiv.org/pdf/2509.19379v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.454,
      "weak_supervision_score": 0.417,
      "diffusion_reasoning_score": 0.349,
      "distributed_training_score": 0.308,
      "datasets_score": 0.35,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Tangentially Relevant",
      "weak_supervision_relevance": "Moderately Relevant",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper focuses on Learning from Observation (LfO), where agents mimic expert state sequences, often from humans, but it does not involve training a reward model based on human preferences or rankings. While human demonstrations are mentioned, the core is imitation learning, not preference-based alignment as in RLHF.",
      "weak_supervision_justification": "The paper discusses LfO using state-only demonstrations, which provide partial or imprecise information compared to full state-action pairs, aligning with weak supervision's use of noisy or high-level data. However, it does not explicitly cover programmatically generated labels, limiting deeper relevance.",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "completed",
      "summary": "This paper provides a comprehensive survey of recent advances in Learning from Observation (LfO), also known as State-Only Imitation Learning (SOIL), where agents learn to mimic expert behavior using only state visitation information without requiring action data. It introduces a novel framework to classify LfO methods based on aspects such as expert identity, trajectory collection methods, dataset types, and algorithm design choices, while surveying existing approaches, drawing connections to related fields like offline reinforcement learning, and identifying open problems and future research directions.",
      "novelty_score": "Moderate",
      "novelty_justification": "The paper presents a notable improvement by introducing a new framework for classifying LfO methods and addressing limitations in existing taxonomies, but it primarily synthesizes and organizes existing ideas rather than introducing a entirely new problem or technique.",
      "impact_score": "Moderate",
      "impact_justification": "The work is likely to be cited and built upon within the subfield of imitation learning and related areas in AI and robotics, as it provides a structured overview and suggests future directions, though its influence may be limited to specialists.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "This is a high-quality survey that offers valuable insights and a useful framework for researchers in imitation learning, making it essential for those working in LfO or related fields to stay informed.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/59bac4616c94920d83783b8c53b7024a9ee69723",
      "total_authors": 4,
      "authors_found": 4,
      "highest_h_index": 3,
      "average_h_index": 1.0,
      "notable_authors_count": 0,
      "author_h_indexes": [
        {
          "name": "Returaj Burnwal",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2218502711"
        },
        {
          "name": "Hriday Mehta",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2381834059"
        },
        {
          "name": "N. Bhatt",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2287965299"
        },
        {
          "name": "Balaraman Ravindran",
          "h_index": 3,
          "profile_url": "https://www.semanticscholar.org/author/2268206514"
        }
      ]
    },
    {
      "id": "2509.20375",
      "title": "Assessing Classical Machine Learning and Transformer-based Approaches\n  for Detecting AI-Generated Research Text",
      "authors": [
        "Sharanya Parimanoharan",
        "Ruwan D. Nawarathna"
      ],
      "categories": [
        "cs.CL (Computation and Language)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "The rapid adoption of large language models (LLMs) such as ChatGPT has\nblurred the line between human and AI-generated texts, raising urgent questions\nabout academic integrity, intellectual property, and the spread of\nmisinformation. Thus, reliable AI-text detection is needed for fair assessment\nto safeguard human authenticity and cultivate trust in digital communication.\nIn this study, we investigate how well current machine learning (ML) approaches\ncan distinguish ChatGPT-3.5-generated texts from human-written texts employing\na labeled data set of 250 pairs of abstracts from a wide range of research\ntopics. We test and compare both classical (Logistic Regression armed with\nclassical Bag-of-Words, POS, and TF-IDF features) and transformer-based (BERT\naugmented with N-grams, DistilBERT, BERT with a lightweight custom classifier,\nand LSTM-based N-gram models) ML detection techniques. As we aim to assess each\nmodel's performance in detecting AI-generated research texts, we also aim to\ntest whether an ensemble of these models can outperform any single detector.\nResults show DistilBERT achieves the overall best performance, while Logistic\nRegression and BERT-Custom offer solid, balanced alternatives; LSTM- and\nBERT-N-gram approaches lag. The max voting ensemble of the three best models\nfails to surpass DistilBERT itself, highlighting the primacy of a single\ntransformer-based representation over mere model diversity. By comprehensively\nassessing the strengths and weaknesses of these AI-text detection approaches,\nthis work lays a foundation for more robust transformer frameworks with larger,\nricher datasets to keep pace with ever-improving generative AI models.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.20375v1",
      "pdf_url": "http://arxiv.org/pdf/2509.20375v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "extraction_failed",
      "embedding_status": "completed",
      "rlhf_score": 0.406,
      "weak_supervision_score": 0.374,
      "diffusion_reasoning_score": 0.437,
      "distributed_training_score": 0.359,
      "datasets_score": 0.409,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "Tangentially Relevant",
      "rlhf_justification": "The paper focuses on detecting AI-generated text using classical and transformer-based machine learning methods, with no mention of reinforcement learning, human feedback, reward models, or fine-tuning via human preferences.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper evaluates text detection techniques using models like BERT and DistilBERT for classification purposes, without any reference to diffusion models, iterative refinement processes, or multi-step logical reasoning.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "The paper employs a labeled dataset of 250 pairs of abstracts to evaluate AI-text detection models, which involves some benchmarking and evaluation, but the main contribution is the comparison of detection methods rather than dataset creation, analysis, or curation.",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.20376",
      "title": "ConceptViz: A Visual Analytics Approach for Exploring Concepts in Large\n  Language Models",
      "authors": [
        "Haoxuan Li",
        "Zhen Wen",
        "Qiqi Jiang",
        "Chenxiao Li",
        "Yuwei Wu",
        "Yuchen Yang",
        "Yiyao Wang",
        "Xiuqi Huang",
        "Minfeng Zhu",
        "Wei Chen"
      ],
      "categories": [
        "cs.CL (Computation and Language)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Large language models (LLMs) have achieved remarkable performance across a\nwide range of natural language tasks. Understanding how LLMs internally\nrepresent knowledge remains a significant challenge. Despite Sparse\nAutoencoders (SAEs) have emerged as a promising technique for extracting\ninterpretable features from LLMs, SAE features do not inherently align with\nhuman-understandable concepts, making their interpretation cumbersome and\nlabor-intensive. To bridge the gap between SAE features and human concepts, we\npresent ConceptViz, a visual analytics system designed for exploring concepts\nin LLMs. ConceptViz implements a novel dentification => Interpretation =>\nValidation pipeline, enabling users to query SAEs using concepts of interest,\ninteractively explore concept-to-feature alignments, and validate the\ncorrespondences through model behavior verification. We demonstrate the\neffectiveness of ConceptViz through two usage scenarios and a user study. Our\nresults show that ConceptViz enhances interpretability research by streamlining\nthe discovery and validation of meaningful concept representations in LLMs,\nultimately aiding researchers in building more accurate mental models of LLM\nfeatures. Our code and user guide are publicly available at\nhttps://github.com/Happy-Hippo209/ConceptViz.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.20376v1",
      "pdf_url": "http://arxiv.org/pdf/2509.20376v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.402,
      "weak_supervision_score": 0.368,
      "diffusion_reasoning_score": 0.47,
      "distributed_training_score": 0.336,
      "datasets_score": 0.374,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper focuses on visual analytics for interpreting Sparse Autoencoders in LLMs, emphasizing concept alignment and user interaction for validation, but it does not involve training models with human-ranked data, reward models, or reinforcement learning techniques.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper addresses interpretability of LLMs using SAEs and a visual analytics pipeline, with no mention of diffusion models, iterative refinement processes, or multi-step logical reasoning as described.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.20377",
      "title": "SKILL-RAG: Self-Knowledge Induced Learning and Filtering for\n  Retrieval-Augmented Generation",
      "authors": [
        "Tomoaki Isoda"
      ],
      "categories": [
        "cs.CL (Computation and Language)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Retrieval-Augmented Generation (RAG) has significantly improved the\nperformance of large language models (LLMs) on knowledge-intensive tasks in\nrecent years. However, since retrieval systems may return irrelevant content,\nincorporating such information into the model often leads to hallucinations.\nThus, identifying and filtering out unhelpful retrieved content is a key\nchallenge for improving RAG performance.To better integrate the internal\nknowledge of the model with external knowledge from retrieval, it is essential\nto understand what the model \"knows\" and \"does not know\" (which is also called\n\"self-knowledge\"). Based on this insight, we propose SKILL-RAG (Self-Knowledge\nInduced Learning and Filtering for RAG), a novel method that leverages the\nmodel's self-knowledge to determine which retrieved documents are beneficial\nfor answering a given query. We design a reinforcement learning-based training\nframework to explicitly elicit self-knowledge from the model and employs\nsentence-level granularity to filter out irrelevant content while preserving\nuseful knowledge.We evaluate SKILL-RAG using Llama2-7B and Qwen3-8B on several\nquestion answering benchmarks. Experimental results demonstrate that SKILL-RAG\nnot only improves generation quality but also significantly reduces the number\nof input documents, validating the importance of self-knowledge in guiding the\nselection of high-quality retrievals.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.20377v1",
      "pdf_url": "http://arxiv.org/pdf/2509.20377v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.441,
      "weak_supervision_score": 0.424,
      "diffusion_reasoning_score": 0.485,
      "distributed_training_score": 0.337,
      "datasets_score": 0.348,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "Not Relevant",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper uses a reinforcement learning-based training framework to elicit self-knowledge in SKILL-RAG, but it does not involve human feedback, such as training a reward model on human-ranked data. Instead, it focuses on the model's internal knowledge for filtering retrieved content, which does not align with the definition of RLHF.",
      "weak_supervision_justification": "The paper does not describe training models using programmatically generated labels from noisy or imprecise sources. Its approach relies on reinforcement learning for self-knowledge induction and filtering, without any mention of weak supervision techniques like label generation from high-level sources.",
      "diffusion_reasoning_justification": "The paper's main contribution is a reinforcement learning framework for filtering in RAG systems, with no reference to diffusion models, iterative refinement processes, or multi-step logical reasoning as described in diffusion-based approaches. It focuses on knowledge integration and filtering, not holistic reasoning paths.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.20378",
      "title": "Beyond Global Emotion: Fine-Grained Emotional Speech Synthesis with\n  Dynamic Word-Level Modulation",
      "authors": [
        "Sirui Wang",
        "Andong Chen",
        "Tiejun Zhao"
      ],
      "categories": [
        "cs.CL (Computation and Language)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Emotional text-to-speech (E-TTS) is central to creating natural and\ntrustworthy human-computer interaction. Existing systems typically rely on\nsentence-level control through predefined labels, reference audio, or natural\nlanguage prompts. While effective for global emotion expression, these\napproaches fail to capture dynamic shifts within a sentence. To address this\nlimitation, we introduce Emo-FiLM, a fine-grained emotion modeling framework\nfor LLM-based TTS. Emo-FiLM aligns frame-level features from emotion2vec to\nwords to obtain word-level emotion annotations, and maps them through a\nFeature-wise Linear Modulation (FiLM) layer, enabling word-level emotion\ncontrol by directly modulating text embeddings. To support evaluation, we\nconstruct the Fine-grained Emotion Dynamics Dataset (FEDD) with detailed\nannotations of emotional transitions. Experiments show that Emo-FiLM\noutperforms existing approaches on both global and fine-grained tasks,\ndemonstrating its effectiveness and generality for expressive speech synthesis.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.20378v1",
      "pdf_url": "http://arxiv.org/pdf/2509.20378v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.396,
      "weak_supervision_score": 0.349,
      "diffusion_reasoning_score": 0.399,
      "distributed_training_score": 0.327,
      "datasets_score": 0.331,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.20379",
      "title": "Leveraging NTPs for Efficient Hallucination Detection in VLMs",
      "authors": [
        "Ofir Azachi",
        "Kfir Eliyahu",
        "Eyal El Ani",
        "Rom Himelstein",
        "Roi Reichart",
        "Yuval Pinter",
        "Nitay Calderon"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.CL (Computation and Language)",
        "cs.LG (Machine Learning)"
      ],
      "abstract": "Hallucinations of vision-language models (VLMs), which are misalignments\nbetween visual content and generated text, undermine the reliability of VLMs.\nOne common approach for detecting them employs the same VLM, or a different\none, to assess generated outputs. This process is computationally intensive and\nincreases model latency. In this paper, we explore an efficient on-the-fly\nmethod for hallucination detection by training traditional ML models over\nsignals based on the VLM's next-token probabilities (NTPs). NTPs provide a\ndirect quantification of model uncertainty. We hypothesize that high\nuncertainty (i.e., a low NTP value) is strongly associated with hallucinations.\nTo test this, we introduce a dataset of 1,400 human-annotated statements\nderived from VLM-generated content, each labeled as hallucinated or not, and\nuse it to test our NTP-based lightweight method. Our results demonstrate that\nNTP-based features are valuable predictors of hallucinations, enabling fast and\nsimple ML models to achieve performance comparable to that of strong VLMs.\nFurthermore, augmenting these NTPs with linguistic NTPs, computed by feeding\nonly the generated text back into the VLM, enhances hallucination detection\nperformance. Finally, integrating hallucination prediction scores from VLMs\ninto the NTP-based models led to better performance than using either VLMs or\nNTPs alone. We hope this study paves the way for simple, lightweight solutions\nthat enhance the reliability of VLMs.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.20379v1",
      "pdf_url": "http://arxiv.org/pdf/2509.20379v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.425,
      "weak_supervision_score": 0.398,
      "diffusion_reasoning_score": 0.456,
      "distributed_training_score": 0.364,
      "datasets_score": 0.33,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper focuses on using human-annotated data to train traditional ML models for hallucination detection in VLMs, but it does not involve reinforcement learning, a reward model, or fine-tuning via human feedback as required for RLHF. The human annotations are used in a supervised manner, not for aligning models through reinforcement.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper deals with hallucination detection using next-token probabilities from VLMs and traditional ML models, with no mention of diffusion models, iterative refinement processes, or multi-step logical reasoning as defined. It lacks any components related to treating Chain-of-Thought as an entity for holistic correction.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.20380",
      "title": "ACCeLLiuM: Supervised Fine-Tuning for Automated OpenACC Pragma\n  Generation",
      "authors": [
        "Samyak Jhaveri",
        "Vanessa Klotzmann",
        "Crista Lopes"
      ],
      "categories": [
        "cs.SE (Software Engineering)",
        "cs.AI (Artificial Intelligence)",
        "cs.PL (Programming Languages)"
      ],
      "abstract": "The increasing ubiquity of GPUs is accompanied by the increasing complexity\nof their hardware and parallel programming frameworks. Directive-based parallel\nprogramming standards like OpenACC simplify GPU programming to some extent by\nabstracting away low-level complexities, but a fair amount of expertise is\nstill required in order to use those directives effectively.\n  We introduce ACCeLLiuM, two open weights Large Language Models specifically\nfine-tuned for generating expert OpenACC directives for data-parallel loops,\nalong with the supervised fine-tuning dataset that was used to train them. The\nACCeLLiuM SFT dataset contains 4,033 OpenACC pragma-loop pairs mined from\npublic GitHub C/C++ repositories, with 3,223 pairs for training and 810 for\ntesting. Experimental evaluations show a pronounced performance gap in\ngenerating correct OpenACC pragmas between base LLMs and our fine-tuned\nversions. On the held-out test set, base LLMs fail to consistently generate\nvalid pragmas, whereas LLMs fine-tuned on the ACCeLLiuM dataset generate valid\npragmas with the correct directive type for $87\\%$ of the data-parallel loops,\nand exact pragmas--including directives, clauses, clause order, and clause\nvariables--for $50\\%$ of the cases. Even when not exact, generated pragmas\nfrequently incorporate the correct clauses in a different order than the\nground-truth label, or include additional clauses that enable finer control\nover parallel execution, data movement, and concurrency, offering practical\nvalue beyond strict string-matching. By publicly releasing the code, models,\nand dataset as ACCeLLiuM we hope to establish a reproducible benchmark for\nLLM-powered OpenACC pragma generation, and lower the barrier to automated GPU\noffloading of serially written programs.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.20380v2",
      "pdf_url": "http://arxiv.org/pdf/2509.20380v2",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.416,
      "weak_supervision_score": 0.425,
      "diffusion_reasoning_score": 0.363,
      "distributed_training_score": 0.504,
      "datasets_score": 0.386,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "Moderately Relevant",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "Not Relevant",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper focuses on supervised fine-tuning (SFT) of LLMs using a curated dataset of OpenACC pragma-loop pairs, without any mention of human feedback, reward models, or reinforcement learning techniques. RLHF specifically involves training with human-ranked data and reinforcement, which is not present here.",
      "weak_supervision_justification": "The paper involves programmatically mining and labeling OpenACC pragma-loop pairs from public GitHub repositories, which aligns with weak supervision by using noisy or automated sources for training data rather than hand-labeled examples. However, the main contribution is on fine-tuning LLMs for pragma generation, not primarily on weak supervision techniques.",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "The paper does not discuss distributed training, parallel computing across nodes, or strategies for partitioning data/computation; it only describes standard supervised fine-tuning of LLMs on a dataset, with no evidence of multi-node or distributed setups.",
      "datasets_justification": "below_threshold",
      "llm_score_status": "completed",
      "summary": "The paper introduces ACCeLLiuM, a framework comprising a curated dataset of 4,033 OpenACC pragma-loop pairs from public GitHub repositories and two fine-tuned Large Language Models (based on Llama 3.1 70B and CodeLlama 34B) for automating the generation of OpenACC directives for data-parallel loops in C/C++ code. The methodology involves supervised fine-tuning on this dataset, with experiments demonstrating that fine-tuned models significantly outperform base LLMs, achieving 87% accuracy for correct directive types and 50% for exact pragma matches, thereby addressing challenges in GPU programming and providing an open-source benchmark for future research.",
      "novelty_score": "Moderate",
      "novelty_justification": "The paper presents a notable improvement by fine-tuning LLMs specifically for OpenACC pragma generation, filling a gap in automated parallelization tools, though it builds on existing LLM techniques rather than introducing a entirely new problem or architecture.",
      "impact_score": "Moderate",
      "impact_justification": "The work is likely to be cited and built upon in the subfield of AI-assisted programming for parallel computing, given the open-source release of the dataset and models, which could lower barriers to GPU offloading and inspire further developments.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "This paper provides a valuable contribution to software engineering and AI for programming languages by demonstrating effective LLM fine-tuning for parallelization tasks, making it essential for researchers in those areas but not broadly mandatory.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/872a2d939ebf737c24cd2046488f90ce686c528f",
      "total_authors": 3,
      "authors_found": 3,
      "highest_h_index": 1,
      "average_h_index": 0.3333333333333333,
      "notable_authors_count": 0,
      "author_h_indexes": [
        {
          "name": "Samyak Jhaveri",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2260346972"
        },
        {
          "name": "Vanessa Klotzmann",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2381986300"
        },
        {
          "name": "Crista Lopes",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2381987777"
        }
      ]
    },
    {
      "id": "2509.20381",
      "title": "USB-Rec: An Effective Framework for Improving Conversational\n  Recommendation Capability of Large Language Model",
      "authors": [
        "Jianyu Wen",
        "Jingyun Wang",
        "Cilin Yan",
        "Jiayin Cai",
        "Xiaolong Jiang",
        "Ying Zhang"
      ],
      "categories": [
        "cs.CL (Computation and Language)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Recently, Large Language Models (LLMs) have been widely employed in\nConversational Recommender Systems (CRSs). Unlike traditional language model\napproaches that focus on training, all existing LLMs-based approaches are\nmainly centered around how to leverage the summarization and analysis\ncapabilities of LLMs while ignoring the issue of training. Therefore, in this\nwork, we propose an integrated training-inference framework,\nUser-Simulator-Based framework (USB-Rec), for improving the performance of LLMs\nin conversational recommendation at the model level. Firstly, we design a\nLLM-based Preference Optimization (PO) dataset construction strategy for RL\ntraining, which helps the LLMs understand the strategies and methods in\nconversational recommendation. Secondly, we propose a Self-Enhancement Strategy\n(SES) at the inference stage to further exploit the conversational\nrecommendation potential obtained from RL training. Extensive experiments on\nvarious datasets demonstrate that our method consistently outperforms previous\nstate-of-the-art methods.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.20381v1",
      "pdf_url": "http://arxiv.org/pdf/2509.20381v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.46,
      "weak_supervision_score": 0.387,
      "diffusion_reasoning_score": 0.403,
      "distributed_training_score": 0.354,
      "datasets_score": 0.348,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper uses a simulated user (an LLM-based simulator) to generate feedback for RL training, rather than human-ranked data or actual human feedback. This does not align with RLHF, which specifically requires human involvement in ranking and scoring to train a reward model and fine-tune the main model.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on RL-based training and inference strategies for conversational recommendation, with no mention of diffusion models, iterative refinement processes, or multi-step logical reasoning akin to diffusion-based approaches. There is no component involving diffusion for holistic correction of reasoning paths.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.21354",
      "title": "KV-Efficient VLA: A Method of Speed up Vision Language Model with\n  RNN-Gated Chunked KV Cache",
      "authors": [
        "Wanshun Xu",
        "Long Zhuang"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Vision-Language-Action (VLA) models promise unified robotic perception and\ncontrol, yet their scalability is constrained by the quadratic cost of\nattention and the unbounded growth of key-value (KV) memory during long-horizon\ninference. While recent methods improve generalization through scaling backbone\narchitectures, they often neglect the inference inefficiencies critical to\nreal-time deployment. In this work, we present KV-Efficient VLA, a\nmodel-agnostic memory compression framework that addresses these limitations by\nintroducing a lightweight, training-friendly mechanism to selectively retain\nhigh-utility context. Our method partitions the KV cache into fixed size chunks\nand employs a recurrent gating module to summarize and filter historical\ncontext according to learned utility scores. This design preserves recent\nfine-grained detail while aggressively pruning stale, low-relevance memory, all\nwhile maintaining causality. Theoretically, KV-Efficient VLA yields up to 1.21x\ninference speedup and 36% KV memory reduction, with minimal impact on task\nsuccess. Our method integrates seamlessly into existing autoregressive and\nhybrid VLA stacks, enabling scalable inference without modifying training\npipelines or downstream control logic.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.21354v1",
      "pdf_url": "http://arxiv.org/pdf/2509.21354v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.361,
      "weak_supervision_score": 0.34,
      "diffusion_reasoning_score": 0.426,
      "distributed_training_score": 0.403,
      "datasets_score": 0.297,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Tangentially Relevant",
      "distributed_training_relevance": "Not Relevant",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper mentions inefficiencies in diffusion-based components of VLA models, such as repeated sampling in HybridVLA, but its main contribution is a KV cache optimization technique for general efficiency, not the adaptation of diffusion for multi-step logical reasoning or iterative refinement of a 'Chain-of-Thought'. Thus, it touches on diffusion peripherally as a problem aspect but does not feature it as a core component.",
      "distributed_training_justification": "The paper discusses fine-tuning with LoRA on multiple GPUs (e.g., 5K A800 GPU hours), but it does not propose, evaluate, or focus on distributed training algorithms, parallel computing strategies, or partitioning across nodes. Its primary contribution is inference efficiency via KV cache management, not accelerating training through distributed methods.",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.21355",
      "title": "Domain-Informed Genetic Superposition Programming: A Case Study on SFRC\n  Beams",
      "authors": [
        "Mohammad Sadegh Khorshidi",
        "Navid Yazdanjue",
        "Hassan Gharoun",
        "Mohammad Reza Nikoo",
        "Fang Chen",
        "Amir H. Gandomi"
      ],
      "categories": [
        "cs.NE (Neural and Evolutionary Computing)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "This study presents domain-informed genetic superposition programming\n(DIGSP), a symbolic regression framework tailored for engineering systems\ngoverned by separable physical mechanisms. DIGSP partitions the input space\ninto domain-specific feature subsets and evolves independent genetic\nprogramming (GP) populations to model material-specific effects. Early\nevolution occurs in isolation, while ensemble fitness promotes inter-population\ncooperation. To enable symbolic superposition, an adaptive hierarchical\nsymbolic abstraction mechanism (AHSAM) is triggered after stagnation across all\npopulations. AHSAM performs analysis of variance- (ANOVA) based filtering to\nidentify statistically significant individuals, compresses them into symbolic\nconstructs, and injects them into all populations through a validation-guided\npruning cycle. The DIGSP is benchmarked against a baseline multi-gene genetic\nprogramming (BGP) model using a dataset of steel fiber-reinforced concrete\n(SFRC) beams. Across 30 independent trials with 65% training, 10% validation,\nand 25% testing splits, DIGSP consistently outperformed BGP in training and\ntest root mean squared error (RMSE). The Wilcoxon rank-sum test confirmed\nstatistical significance (p < 0.01), and DIGSP showed tighter error\ndistributions and fewer outliers. No significant difference was observed in\nvalidation RMSE due to limited sample size. These results demonstrate that\ndomain-informed structural decomposition and symbolic abstraction improve\nconvergence and generalization. DIGSP offers a principled and interpretable\nmodeling strategy for systems where symbolic superposition aligns with the\nunderlying physical structure.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.21355v1",
      "pdf_url": "http://arxiv.org/pdf/2509.21355v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.35,
      "weak_supervision_score": 0.353,
      "diffusion_reasoning_score": 0.384,
      "distributed_training_score": 0.392,
      "datasets_score": 0.33,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.21356",
      "title": "Phrase-grounded Fact-checking for Automatically Generated Chest X-ray\n  Reports",
      "authors": [
        "Razi Mahmood",
        "Diego Machado-Reyes",
        "Joy Wu",
        "Parisa Kaviani",
        "Ken C. L. Wong",
        "Niharika D'Souza",
        "Mannudeep Kalra",
        "Ge Wang",
        "Pingkun Yan",
        "Tanveer Syeda-Mahmood"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "With the emergence of large-scale vision language models (VLM), it is now\npossible to produce realistic-looking radiology reports for chest X-ray images.\nHowever, their clinical translation has been hampered by the factual errors and\nhallucinations in the produced descriptions during inference. In this paper, we\npresent a novel phrase-grounded fact-checking model (FC model) that detects\nerrors in findings and their indicated locations in automatically generated\nchest radiology reports.\n  Specifically, we simulate the errors in reports through a large synthetic\ndataset derived by perturbing findings and their locations in ground truth\nreports to form real and fake findings-location pairs with images. A new\nmulti-label cross-modal contrastive regression network is then trained on this\ndataset. We present results demonstrating the robustness of our method in terms\nof accuracy of finding veracity prediction and localization on multiple X-ray\ndatasets. We also show its effectiveness for error detection in reports of SOTA\nreport generators on multiple datasets achieving a concordance correlation\ncoefficient of 0.997 with ground truth-based verification, thus pointing to its\nutility during clinical inference in radiology workflows.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.21356v1",
      "pdf_url": "http://arxiv.org/pdf/2509.21356v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.385,
      "weak_supervision_score": 0.366,
      "diffusion_reasoning_score": 0.419,
      "distributed_training_score": 0.312,
      "datasets_score": 0.322,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper's main contribution is a phrase-grounded fact-checking model for detecting errors in chest X-ray reports using a synthetic dataset and a multi-label cross-modal contrastive regression network. It does not involve diffusion models, iterative refinement processes, or any adaptation of diffusion for multi-step logical reasoning tasks. Therefore, it has no connection to the topic.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.21357",
      "title": "A Novel Differential Feature Learning for Effective Hallucination\n  Detection and Classification",
      "authors": [
        "Wenkai Wang",
        "Vincent Lee",
        "Yizhen Zheng"
      ],
      "categories": [
        "cs.CL (Computation and Language)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Large language model hallucination represents a critical challenge where\noutputs deviate from factual accuracy due to distributional biases in training\ndata. While recent investigations establish that specific hidden layers exhibit\ndifferences between hallucinatory and factual content, the precise localization\nof hallucination signals within layers remains unclear, limiting the\ndevelopment of efficient detection methods. We propose a dual-model\narchitecture integrating a Projected Fusion (PF) block for adaptive inter-layer\nfeature weighting and a Differential Feature Learning (DFL) mechanism that\nidentifies discriminative features by computing differences between parallel\nencoders learning complementary representations from identical inputs. Through\nsystematic experiments across HaluEval's question answering, dialogue, and\nsummarization datasets, we demonstrate that hallucination signals concentrate\nin highly sparse feature subsets, achieving significant accuracy improvements\non question answering and dialogue tasks. Notably, our analysis reveals a\nhierarchical \"funnel pattern\" where shallow layers exhibit high feature\ndiversity while deep layers demonstrate concentrated usage, enabling detection\nperformance to be maintained with minimal degradation using only 1\\% of feature\ndimensions. These findings suggest that hallucination signals are more\nconcentrated than previously assumed, offering a pathway toward computationally\nefficient detection systems that could reduce inference costs while maintaining\naccuracy.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.21357v1",
      "pdf_url": "http://arxiv.org/pdf/2509.21357v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.445,
      "weak_supervision_score": 0.415,
      "diffusion_reasoning_score": 0.497,
      "distributed_training_score": 0.406,
      "datasets_score": 0.367,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "Not Relevant",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "Not Relevant",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper focuses on detecting hallucinations in large language models through feature analysis and does not involve human feedback, reward models, or reinforcement learning for model alignment.",
      "weak_supervision_justification": "The paper does not involve training models with programmatically generated or noisy labels; it instead analyzes internal representations for hallucination detection without any supervision techniques.",
      "diffusion_reasoning_justification": "The paper proposes methods for hallucination detection using feature learning and does not incorporate diffusion models, iterative refinement, or multi-step logical reasoning processes.",
      "distributed_training_justification": "The paper discusses experiments on datasets for hallucination detection but does not address distributed computing, parallel processing, or strategies for training across multiple nodes.",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.22695",
      "title": "ReSeFlow: Rectifying SE(3)-Equivariant Policy Learning Flows",
      "authors": [
        "Zhitao Wang",
        "Yanke Wang",
        "Jiangtao Wen",
        "Roberto Horowitz",
        "Yuxing Han"
      ],
      "categories": [
        "cs.RO (Robotics)",
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Robotic manipulation in unstructured environments requires the generation of\nrobust and long-horizon trajectory-level policy with conditions of perceptual\nobservations and benefits from the advantages of SE(3)-equivariant diffusion\nmodels that are data-efficient. However, these models suffer from the inference\ntime costs. Inspired by the inference efficiency of rectified flows, we\nintroduce the rectification to the SE(3)-diffusion models and propose the\nReSeFlow, i.e., Rectifying SE(3)-Equivariant Policy Learning Flows, providing\nfast, geodesic-consistent, least-computational policy generation. Crucially,\nboth components employ SE(3)-equivariant networks to preserve rotational and\ntranslational symmetry, enabling robust generalization under rigid-body\nmotions. With the verification on the simulated benchmarks, we find that the\nproposed ReSeFlow with only one inference step can achieve better performance\nwith lower geodesic distance than the baseline methods, achieving up to a 48.5%\nerror reduction on the painting task and a 21.9% reduction on the rotating\ntriangle task compared to the baseline's 100-step inference. This method takes\nadvantages of both SE(3) equivariance and rectified flow and puts it forward\nfor the real-world application of generative policy learning models with the\ndata and inference efficiency.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.22695v1",
      "pdf_url": "http://arxiv.org/pdf/2509.22695v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.418,
      "weak_supervision_score": 0.31,
      "diffusion_reasoning_score": 0.51,
      "distributed_training_score": 0.333,
      "datasets_score": 0.263,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Tangentially Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper focuses on SE(3)-equivariant diffusion models for robotic policy generation and mentions training with demonstrations, but it does not involve human feedback for creating a reward model or fine-tuning via reinforcement learning. There is no element of ranking data or aligning models with human preferences, making it unrelated to RLHF.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper uses diffusion models for iterative refinement in generating robotic trajectories, which shares the concept of multi-step processes, but it applies this to physical manipulation tasks rather than solving complex logical tasks or treating a Chain-of-Thought as a holistic entity for reasoning. Thus, it is only loosely connected to diffusion-based reasoning.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.22696",
      "title": "Explainable Deep Learning for Cataract Detection in Retinal Images: A\n  Dual-Eye and Knowledge Distillation Approach",
      "authors": [
        "MohammadReza Abbaszadeh Bavil Soflaei",
        "Karim SamadZamini"
      ],
      "categories": [
        "eess.IV (Image and Video Processing)",
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Cataract remains a leading cause of visual impairment worldwide, and early\ndetection from retinal imaging is critical for timely intervention. We present\na deep learning pipeline for cataract classification using the Ocular Disease\nRecognition dataset, containing left and right fundus photographs from 5000\npatients. We evaluated CNNs, transformers, lightweight architectures, and\nknowledge-distilled models. The top-performing model, Swin-Base Transformer,\nachieved 98.58% accuracy and an F1-score of 0.9836. A distilled MobileNetV3,\ntrained with Swin-Base knowledge, reached 98.42% accuracy and a 0.9787 F1-score\nwith greatly reduced computational cost. The proposed dual-eye Siamese variant\nof the distilled MobileNet, integrating information from both eyes, achieved an\naccuracy of 98.21%. Explainability analysis using Grad-CAM demonstrated that\nthe CNNs concentrated on medically significant features, such as lens opacity\nand central blur. These results show that accurate, interpretable cataract\ndetection is achievable even with lightweight models, supporting potential\nclinical integration in resource-limited settings",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.22696v1",
      "pdf_url": "http://arxiv.org/pdf/2509.22696v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.296,
      "weak_supervision_score": 0.354,
      "diffusion_reasoning_score": 0.392,
      "distributed_training_score": 0.351,
      "datasets_score": 0.354,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.22697",
      "title": "Learning Hyperspectral Images with Curated Text Prompts for Efficient\n  Multimodal Alignment",
      "authors": [
        "Abhiroop Chatterjee",
        "Susmita Ghosh"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.AI (Artificial Intelligence)",
        "cs.LG (Machine Learning)"
      ],
      "abstract": "As data requirements continue to grow, efficient learning increasingly\ndepends on the curation and distillation of high-value data rather than\nbrute-force scaling of model sizes. In the case of a hyperspectral image (HSI),\nthe challenge is amplified by the high-dimensional 3D voxel structure, where\neach spatial location is associated with hundreds of contiguous spectral\nchannels. While vision and language models have been optimized effectively for\nnatural image or text tasks, their cross-modal alignment in the hyperspectral\ndomain remains an open and underexplored problem. In this article, we make an\nattempt to optimize a Vision-Language Model (VLM) for hyperspectral scene\nunderstanding by exploiting a CLIP-style contrastive training framework. Our\nframework maps voxel-level embeddings from a vision backbone onto the latent\nspace of a frozen large embedding model (LEM), where a trainable probe aligns\nvision features with the model's textual token representations. The two\nmodalities are aligned via a contrastive loss restricted to a curated set of\nhard (closest wrong classes) and semi-hard (random distractors) negatives,\nalong with positive pairs. To further enhance alignment, descriptive prompts\nthat encode class semantics are introduced and act as structured anchors for\nthe HSI embeddings. It is seen that the proposed method updates only 0.07\npercent of the total parameters, yet yields state-of-the-art performance. For\nexample, on Indian Pines (IP) the model produces better results over unimodal\nand multimodal baselines by +0.92 Overall Accuracy (OA) and +1.60 Kappa\n($\\kappa$), while on Pavia University (PU) data it provides gains of +0.69 OA\nand +0.90 $\\kappa$. Moreover, this is achieved with the set of parameters,\nnearly 50$\\times$ smaller than DCTN and 90$\\times$ smaller than SS-TMNet.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.22697v1",
      "pdf_url": "http://arxiv.org/pdf/2509.22697v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.42,
      "weak_supervision_score": 0.399,
      "diffusion_reasoning_score": 0.395,
      "distributed_training_score": 0.372,
      "datasets_score": 0.389,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper's main contribution is developing a Vision-Language Model for hyperspectral image alignment using contrastive learning, curated text prompts, and a frozen embedding model. It does not involve reinforcement learning, human feedback, reward models, or any mechanism for aligning AI models with human preferences. Therefore, it has no connection to RLHF.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.25206",
      "title": "Hyperbolic Optimization",
      "authors": [
        "Yanke Wang",
        "Kyriakos Flouris"
      ],
      "categories": [
        "cs.LG (Machine Learning)",
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "This work explores optimization methods on hyperbolic manifolds. Building on\nRiemannian optimization principles, we extend the Hyperbolic Stochastic\nGradient Descent (a specialization of Riemannian SGD) to a Hyperbolic Adam\noptimizer. While these methods are particularly relevant for learning on the\nPoincar\\'e ball, they may also provide benefits in Euclidean and other\nnon-Euclidean settings, as the chosen optimization encourages the learning of\nPoincar\\'e embeddings. This representation, in turn, accelerates convergence in\nthe early stages of training, when parameters are far from the optimum. As a\ncase study, we train diffusion models using the hyperbolic optimization methods\nwith hyperbolic time-discretization of the Langevin dynamics, and show that\nthey achieve faster convergence on certain datasets without sacrificing\ngenerative quality.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.25206v1",
      "pdf_url": "http://arxiv.org/pdf/2509.25206v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.385,
      "weak_supervision_score": 0.31,
      "diffusion_reasoning_score": 0.407,
      "distributed_training_score": 0.387,
      "datasets_score": 0.253,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Tangentially Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper discusses hyperbolic optimization techniques applied to train diffusion models for image generation, which involves iterative refinement processes similar to diffusion models. However, it does not adapt these processes for multi-step logical reasoning or solving complex logical tasks, such as treating a 'Chain-of-Thought' as a single entity. Instead, the focus is on optimization for generative tasks, making the connection indirect and not central to the topic.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.25207",
      "title": "Multi-level Diagnosis and Evaluation for Robust Tabular Feature\n  Engineering with Large Language Models",
      "authors": [
        "Yebin Lim",
        "Susik Yoon"
      ],
      "categories": [
        "cs.LG (Machine Learning)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Recent advancements in large language models (LLMs) have shown promise in\nfeature engineering for tabular data, but concerns about their reliability\npersist, especially due to variability in generated outputs. We introduce a\nmulti-level diagnosis and evaluation framework to assess the robustness of LLMs\nin feature engineering across diverse domains, focusing on the three main\nfactors: key variables, relationships, and decision boundary values for\npredicting target classes. We demonstrate that the robustness of LLMs varies\nsignificantly over different datasets, and that high-quality LLM-generated\nfeatures can improve few-shot prediction performance by up to 10.52%. This work\nopens a new direction for assessing and enhancing the reliability of LLM-driven\nfeature engineering in various domains.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2509.25207v1",
      "pdf_url": "http://arxiv.org/pdf/2509.25207v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.451,
      "weak_supervision_score": 0.442,
      "diffusion_reasoning_score": 0.432,
      "distributed_training_score": 0.384,
      "datasets_score": 0.42,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "Tangentially Relevant",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "Moderately Relevant",
      "rlhf_justification": "The paper focuses on evaluating the robustness of LLMs in feature engineering for tabular data, without any mention of reinforcement learning, human feedback, or training models to align with preferences.",
      "weak_supervision_justification": "The paper involves LLMs using a few examples for feature engineering, which could loosely relate to noisy or imprecise supervision, but it does not center on programmatically generating labels or training with weak sources; instead, it emphasizes evaluation and robustness.",
      "diffusion_reasoning_justification": "The paper does not involve diffusion models, iterative refinement for logical reasoning, or multi-step reasoning processes; it is solely about assessing LLMs for feature engineering in tabular data.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "The paper analyzes and evaluates LLMs on benchmark datasets to assess robustness, including experiments on eight datasets, which aligns with dataset benchmarking and analysis, though the primary focus is on the evaluation framework rather than dataset creation or curation.",
      "llm_score_status": "completed",
      "summary": "This paper introduces a multi-level diagnosis and evaluation framework to assess the robustness of large language models (LLMs) in feature engineering for tabular data, focusing on key variables, relationships, and decision boundary values. By analyzing six LLMs across eight datasets, the study reveals significant variations in LLM robustness and demonstrates that using high-quality LLM-generated features can enhance few-shot prediction performance by up to 10.52%, emphasizing the importance of high-quality examples for reliability.",
      "novelty_score": "High",
      "novelty_justification": "The paper introduces a novel multi-level framework for diagnosing and evaluating LLM robustness in feature engineering, addressing a previously underexplored aspect of feature-target relationships in tabular data, thus significantly advancing the state-of-the-art in LLM reliability assessments.",
      "impact_score": "Moderate",
      "impact_justification": "The work is likely to be cited and built upon in subfields of AI and machine learning focused on LLM-driven feature engineering, as it provides practical tools for improving reliability, though its influence may remain confined to specific applications in tabular data processing.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "The paper represents a strong and valuable contribution to understanding LLM limitations in feature engineering, making it essential for researchers in AI and machine learning to be aware of for advancing robust model development.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/d18b95eb9dda301b0edba0dee8f6841fb46e3076",
      "total_authors": 2,
      "authors_found": 2,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": [
        {
          "name": "Yebin Lim",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2383112058"
        },
        {
          "name": "Susik Yoon",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2383104633"
        }
      ]
    },
    {
      "id": "2510.01218",
      "title": "Control the Temperature: Selective Sampling for Diverse and High-Quality\n  LLM Outputs",
      "authors": [
        "Sergey Troshin",
        "Wafaa Mohammed",
        "Yan Meng",
        "Christof Monz",
        "Antske Fokkens",
        "Vlad Niculae"
      ],
      "categories": [
        "cs.LG (Machine Learning)",
        "cs.AI (Artificial Intelligence)",
        "cs.CL (Computation and Language)"
      ],
      "abstract": "Diversity is an essential metric for evaluating the creativity of outputs\ngenerated by language models. Temperature-based sampling is a common strategy\nto increase diversity. However, for tasks that require high precision, e.g.,\nmathematical reasoning, uncontrolled high temperature sampling, e.g., min-$p$\nor top-$p$, degrades reasoning quality. We demonstrate that the loss of\naccuracy is caused by sampling incorrect continuations in sensitive decoding\npositions. To address this, in this paper, we propose \\textbf{selective\nsampling}, a method that dynamically switches between greedy and\nhigh-temperature sampling based on a sampling risk metric. This risk metric\nestimates the likelihood of output errors when applying high-temperature\nsampling on the current token position. To predict sampling risk, we train a\nlightweight classifier on a small subset of verifiable problems. The trained\nclassifier can be integrated with the base language model with minimal latency\noverhead. Experiments on mathematical reasoning tasks demonstrate that\nselective sampling enhances the quality-diversity trade-off, even in\nhigh-temperature settings.",
      "published_date": "2025-09-20",
      "arxiv_url": "http://arxiv.org/abs/2510.01218v1",
      "pdf_url": "http://arxiv.org/pdf/2510.01218v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.404,
      "weak_supervision_score": 0.406,
      "diffusion_reasoning_score": 0.453,
      "distributed_training_score": 0.369,
      "datasets_score": 0.332,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Tangentially Relevant",
      "weak_supervision_relevance": "Not Relevant",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper discusses generating diverse outputs to better align with human preferences, as mentioned in the introduction, but it does not involve training a model using a reward model or reinforcement learning based on human feedback. It focuses on sampling strategies rather than RLHF techniques.",
      "weak_supervision_justification": "The paper trains a lightweight classifier on a small subset of verifiable problems, which appears to use standard supervised learning with likely accurate labels, rather than programmatically generated, noisy, or imprecise labels characteristic of weak supervision.",
      "diffusion_reasoning_justification": "The paper proposes a sampling method for LLMs and does not involve diffusion models, iterative refinement processes, or multi-step logical reasoning as described in diffusion-based approaches.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    }
  ],
  "total_papers": 122,
  "date": "2025-09-20"
};
    </script>

    <script>
        // ============================================================================
        // GLOBAL VARIABLES & CONFIGURATION
        // ============================================================================
        
        // Page configuration - get data from embedded PAPER_DATA
        const PAGE_DATE = PAPER_DATA.date;
        const PAPERS_PER_PAGE = 5;
        let currentPage = 1;
        let totalPapers = PAPER_DATA.total_papers;
        let totalPages = 0;
        let allPapers = PAPER_DATA.papers;  // Use embedded papers data
        let filteredSortedPapers = [];  // Store papers after filtering/sorting
        let currentPagePapers = [];  // Store papers for current page display
        let currentSort = 'recommend_best';  // Default sort
        
        // H-Index Filter State Management
        let currentHIndexFilters = {
            found: true,
            notFound: true,
            highestMin: 0,
            highestMax: 1000,
            averageMin: 0,
            averageMax: 1000
        };
        
        let pendingHIndexFilters = { ...currentHIndexFilters };
        
        // Topic Filter State Management
        let currentTopicFilters = {
            rlhf: true,
            weakSupervision: true,
            diffusionReasoning: true,
            distributedTraining: true,
            datasets: true
        };
        
        let pendingTopicFilters = { ...currentTopicFilters };
        
        // Relevance Filter State Management
        let currentRelevanceFilters = {
            highlyRelevant: true,
            moderatelyRelevant: true,
            tangentiallyRelevant: true,
            notRelevant: true
        };
        
        let pendingRelevanceFilters = { ...currentRelevanceFilters };
        
        // Sidebar state variables
        let isMobileSidebarOpen = false;
        let isDesktopSidebarOpen = false;

        // ============================================================================
        // URL PARAMETER UTILITIES
        // ============================================================================
        
        function getUrlParameter(name) {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get(name);
        }
        
        function setUrlParameter(name, value) {
            const url = new URL(window.location.href);
            url.searchParams.set(name, value);
            window.history.pushState(null, '', url.toString());
        }
        
        function updateHIndexFiltersFromURL() {
            // Get H-Index filter parameters from URL
            const hindexFound = getUrlParameter('hindex_found');
            const hindexNotFound = getUrlParameter('hindex_not_found');
            const highestMin = getUrlParameter('highest_min');
            const highestMax = getUrlParameter('highest_max');
            const averageMin = getUrlParameter('average_min');
            const averageMax = getUrlParameter('average_max');
            
            // Update current filters if parameters exist
            if (hindexFound !== null) currentHIndexFilters.found = hindexFound === 'true';
            if (hindexNotFound !== null) currentHIndexFilters.notFound = hindexNotFound === 'true';
            if (highestMin !== null) currentHIndexFilters.highestMin = parseInt(highestMin) || 0;
            if (highestMax !== null) currentHIndexFilters.highestMax = parseInt(highestMax) || 1000;
            if (averageMin !== null) currentHIndexFilters.averageMin = parseInt(averageMin) || 0;
            if (averageMax !== null) currentHIndexFilters.averageMax = parseInt(averageMax) || 1000;
            
            // Sync pending filters
            pendingHIndexFilters = { ...currentHIndexFilters };
            
            // Sync UI and update button text
            syncHIndexUI();
        }
        
        function updateURLWithHIndexFilters() {
            const url = new URL(window.location.href);
            
            // Only set parameters if they differ from defaults
            if (!currentHIndexFilters.found || !currentHIndexFilters.notFound) {
                url.searchParams.set('hindex_found', currentHIndexFilters.found);
                url.searchParams.set('hindex_not_found', currentHIndexFilters.notFound);
            } else {
                url.searchParams.delete('hindex_found');
                url.searchParams.delete('hindex_not_found');
            }
            
            if (currentHIndexFilters.highestMin !== 0 || currentHIndexFilters.highestMax !== 1000) {
                url.searchParams.set('highest_min', currentHIndexFilters.highestMin);
                url.searchParams.set('highest_max', currentHIndexFilters.highestMax);
            } else {
                url.searchParams.delete('highest_min');
                url.searchParams.delete('highest_max');
            }
            
            if (currentHIndexFilters.averageMin !== 0 || currentHIndexFilters.averageMax !== 1000) {
                url.searchParams.set('average_min', currentHIndexFilters.averageMin);
                url.searchParams.set('average_max', currentHIndexFilters.averageMax);
            } else {
                url.searchParams.delete('average_min');
                url.searchParams.delete('average_max');
            }
            
            window.history.pushState(null, '', url.toString());
        }

        // ============================================================================
        // DATE FORMATTING FUNCTIONS
        // ============================================================================
        
        function formatPageDate(dateString) {
            const date = new Date(dateString);
            const options = { day: 'numeric', month: 'long', year: 'numeric' };
            return date.toLocaleDateString('en-GB', options);
        }

        function formatPublicationDate(dateString) {
            const date = new Date(dateString);
            const options = { day: 'numeric', month: 'long', year: 'numeric' };
            return date.toLocaleDateString('en-GB', options);
        }

        // ============================================================================
        // UI UPDATE FUNCTIONS FOR PAGE LOAD
        // ============================================================================
        
        function updatePageTitles(date) {
            const formattedDate = formatPageDate(date);
            const titleText = `Papers Published on ${formattedDate}`;
            
            // Update page title
            document.title = `Research Feed -- ${formattedDate}`;
            
            // Update mobile and desktop headers
            const mobileTitle = document.getElementById('page-title-mobile');
            const desktopTitle = document.getElementById('page-title-desktop');
            
            if (mobileTitle) {
                mobileTitle.textContent = titleText;
            }
            if (desktopTitle) {
                desktopTitle.textContent = titleText;
            }
        }

        function updatePaperCount() {
            const mobileCount = document.getElementById('mobile-paper-count');
            const desktopCount = document.getElementById('desktop-paper-count');
            const mobileMainCount = document.getElementById('mobile-main-paper-count');
            const desktopMainCount = document.getElementById('desktop-main-paper-count');
            
            const showing = filteredSortedPapers.length;
            const sidebarCountText = `Showing: ${showing}/${totalPapers} Papers`;
            const mainCountText = `Showing ${showing} / ${totalPapers} papers`;
            
            // Update sidebar counts
            if (mobileCount) {
                mobileCount.textContent = sidebarCountText;
            }
            if (desktopCount) {
                desktopCount.textContent = sidebarCountText;
            }
            
            // Update main header counts
            if (mobileMainCount) {
                mobileMainCount.textContent = mainCountText;
            }
            if (desktopMainCount) {
                desktopMainCount.textContent = mainCountText;
            }
        }

        // ============================================================================
        // SORTING FUNCTIONS
        // ============================================================================
        
        function calculateRecommendationScore(paper) {
            // Skip calculation if already calculated or if not relevant enough
            if (paper.recommendation_numerical_score !== undefined) {
                return paper.recommendation_numerical_score;
            }
            
            if (paper.llm_score_status === 'not_relevant_enough') {
                paper.recommendation_numerical_score = 0;
                return 0;
            }
            
            let score = 0;
            
            // Recommendation scores (primary)
            const recommendationScores = {
                'Must Read': 40,
                'Should Read': 30,
                'Can Skip': 20,
                'Ignore': 10
            };
            score += recommendationScores[paper.recommendation_score] || 0;
            
            // Novelty scores (first tiebreaker)
            const noveltyScores = {
                'High': 4,
                'Moderate': 3,
                'Low': 2,
                'None': 1
            };
            score += noveltyScores[paper.novelty_score] || 0;
            
            // Impact scores (second tiebreaker)
            const impactScores = {
                'High': 4,
                'Moderate': 3,
                'Low': 2,
                'Negligible': 1
            };
            score += impactScores[paper.impact_score] || 0;
            
            paper.recommendation_numerical_score = score;
            return score;
        }
        
        function getHighestHIndex(paper) {
            // Return the highest H-index value, or -1 if not available (so unavailable papers sort last)
            return paper.highest_h_index !== undefined ? paper.highest_h_index : -1;
        }
        
        function getAverageHIndex(paper) {
            // Return the average H-index value, or -1 if not available (so unavailable papers sort last)
            return paper.average_h_index !== undefined ? paper.average_h_index : -1;
        }
        
        function calculateRelevanceScore(paper) {
            let score = 0;
            
            // Only consider topics that are currently selected/enabled in the topic filter
            const topicsToConsider = [];
            if (currentTopicFilters.rlhf) topicsToConsider.push('rlhf_relevance');
            if (currentTopicFilters.weakSupervision) topicsToConsider.push('weak_supervision_relevance');
            if (currentTopicFilters.diffusionReasoning) topicsToConsider.push('diffusion_reasoning_relevance');
            if (currentTopicFilters.distributedTraining) topicsToConsider.push('distributed_training_relevance');
            if (currentTopicFilters.datasets) topicsToConsider.push('datasets_relevance');
            
            // If no topics are selected, return 0
            if (topicsToConsider.length === 0) return 0;
            
            // Weighted scoring system
            const relevanceWeights = {
                'Highly Relevant': 4,
                'Moderately Relevant': 3,
                'Tangentially Relevant': 2,
                'Not Relevant': 1
            };
            
            // Sum up scores for selected topics only
            for (let topicField of topicsToConsider) {
                const relevance = paper[topicField];
                // Treat "not_validated" same as "Not Relevant"
                const normalizedRelevance = relevance === "not_validated" ? "Not Relevant" : relevance;
                score += relevanceWeights[normalizedRelevance] || 1; // Default to 1 if unknown
            }
            
            return score;
        }
        
        function sortPapers(sortType) {
            switch (sortType) {
                case 'recommend_best':
                    filteredSortedPapers.sort((a, b) => calculateRecommendationScore(b) - calculateRecommendationScore(a));
                    break;
                case 'recommend_worst':
                    filteredSortedPapers.sort((a, b) => calculateRecommendationScore(a) - calculateRecommendationScore(b));
                    break;
                case 'relevance_high':
                    filteredSortedPapers.sort((a, b) => calculateRelevanceScore(b) - calculateRelevanceScore(a));
                    break;
                case 'relevance_low':
                    filteredSortedPapers.sort((a, b) => calculateRelevanceScore(a) - calculateRelevanceScore(b));
                    break;
                case 'highest_hindex_asc':
                    filteredSortedPapers.sort((a, b) => getHighestHIndex(a) - getHighestHIndex(b));
                    break;
                case 'highest_hindex_desc':
                    filteredSortedPapers.sort((a, b) => getHighestHIndex(b) - getHighestHIndex(a));
                    break;
                case 'average_hindex_asc':
                    filteredSortedPapers.sort((a, b) => getAverageHIndex(a) - getAverageHIndex(b));
                    break;
                case 'average_hindex_desc':
                    filteredSortedPapers.sort((a, b) => getAverageHIndex(b) - getAverageHIndex(a));
                    break;
                case 'id_asc':
                    filteredSortedPapers.sort((a, b) => a.id.localeCompare(b.id));
                    break;
                case 'id_desc':
                    filteredSortedPapers.sort((a, b) => b.id.localeCompare(a.id));
                    break;
                case 'title_az':
                    filteredSortedPapers.sort((a, b) => a.title.localeCompare(b.title));
                    break;
                case 'title_za':
                    filteredSortedPapers.sort((a, b) => b.title.localeCompare(a.title));
                    break;
                default:
                    // Default to recommendation best first
                    filteredSortedPapers.sort((a, b) => calculateRecommendationScore(b) - calculateRecommendationScore(a));
            }
        }

        // ============================================================================
        // DROPDOWN DIRECTION FUNCTIONS
        // ============================================================================
        
        function setDropdownDirection(button, dropdown) {
            const buttonRect = button.getBoundingClientRect();
            const sidebar = button.closest('#mobile-sidebar, #desktop-sidebar');
            
            // Get the sidebar content area instead of the entire sidebar
            const sidebarContent = sidebar.querySelector('.flex-1');
            const sidebarContentRect = sidebarContent ? sidebarContent.getBoundingClientRect() : sidebar.getBoundingClientRect();
            
            // Calculate available space within the entire sidebar content area
            const spaceBelow = sidebarContentRect.bottom - buttonRect.bottom;
            const spaceAbove = buttonRect.top - sidebarContentRect.top;
            
            // Estimate dropdown height (roughly 6 items * 40px each)
            const estimatedDropdownHeight = 240;
            
            // Determine direction based on available space in the whole sidebar content
            if (spaceBelow >= estimatedDropdownHeight || spaceBelow >= spaceAbove) {
                // Dropdown goes down
                dropdown.classList.remove('dropdown-up');
                dropdown.classList.add('dropdown-down');
            } else {
                // Dropdown goes up
                dropdown.classList.remove('dropdown-down');
                dropdown.classList.add('dropdown-up');
            }
        }

        // ============================================================================
        // SORTING DROPDOWN FUNCTIONS
        // ============================================================================
        
        function toggleMobileSortDropdown() {
            const button = document.getElementById('mobile-sort-btn');
            const dropdown = document.getElementById('mobile-sort-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                // Set direction before showing
                setDropdownDirection(button, dropdown);
                // Change button to expanded state
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                // Change button back to normal state
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function toggleDesktopSortDropdown() {
            const button = document.getElementById('desktop-sort-btn');
            const dropdown = document.getElementById('desktop-sort-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                // Set direction before showing
                setDropdownDirection(button, dropdown);
                // Change button to expanded state
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                // Change button back to normal state
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function changeSortAndClose(sortType) {
            // Update current sort
            currentSort = sortType;
            
            // Update URL
            setUrlParameter('sort', sortType);
            
            // Update dropdown text
            updateSortDropdownUI();
            
            // Close dropdowns and reset button states
            const mobileDropdown = document.getElementById('mobile-sort-dropdown');
            const desktopDropdown = document.getElementById('desktop-sort-dropdown');
            const mobileButton = document.getElementById('mobile-sort-btn');
            const desktopButton = document.getElementById('desktop-sort-btn');
            
            mobileDropdown.classList.add('hidden');
            desktopDropdown.classList.add('hidden');
            
            // Reset button states to normal
            mobileButton.classList.remove('bg-neutral-600');
            mobileButton.classList.add('bg-neutral-500');
            desktopButton.classList.remove('bg-neutral-600');
            desktopButton.classList.add('bg-neutral-500');
            
            // Close the appropriate sidebar
            if (isMobileSidebarOpen) {
                closeMobileMenu();
            }
            if (isDesktopSidebarOpen) {
                closeDesktopMenu();
            }
            
            // Apply new sorting
            applyFiltersAndSort();
            displayCurrentPage();
        }
        
        function updateSortDropdownUI() {
            const sortNames = {
                'recommend_best': 'Recommendation (Best First)',
                'recommend_worst': 'Recommendation (Worst First)',
                'relevance_high': 'Relevance (Highest to Lowest)',
                'relevance_low': 'Relevance (Lowest to Highest)',
                'highest_hindex_asc': 'Highest H-Index (Ascending)',
                'highest_hindex_desc': 'Highest H-Index (Descending)',
                'average_hindex_asc': 'Average H-Index (Ascending)',
                'average_hindex_desc': 'Average H-Index (Descending)',
                'id_asc': 'arXiv ID (Ascending)',
                'id_desc': 'arXiv ID (Descending)',
                'title_az': 'Title (A-Z)',
                'title_za': 'Title (Z-A)'
            };
            
            const sortName = sortNames[currentSort] || 'Recommendation (Best First)';
            
            const mobileText = document.getElementById('mobile-sort-text');
            const desktopText = document.getElementById('desktop-sort-text');
            
            if (mobileText) {
                mobileText.textContent = sortName;
            }
            if (desktopText) {
                desktopText.textContent = sortName;
            }
        }

        // ============================================================================
        // H-INDEX FILTER DROPDOWN FUNCTIONS
        // ============================================================================
        
        function toggleMobileHIndexDropdown() {
            const button = document.getElementById('mobile-hindex-btn');
            const dropdown = document.getElementById('mobile-hindex-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                // Set direction before showing
                setDropdownDirection(button, dropdown);
                // Change button to expanded state
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                // Change button back to normal state
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function toggleDesktopHIndexDropdown() {
            const button = document.getElementById('desktop-hindex-btn');
            const dropdown = document.getElementById('desktop-hindex-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                // Set direction before showing
                setDropdownDirection(button, dropdown);
                // Change button to expanded state
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                // Change button back to normal state
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function toggleHIndexRanges() {
            const mobileFoundCheckbox = document.getElementById('mobile-hindex-found');
            const desktopFoundCheckbox = document.getElementById('desktop-hindex-found');
            const mobileHighestRange = document.getElementById('mobile-highest-range');
            const mobileAverageRange = document.getElementById('mobile-average-range');
            const desktopHighestRange = document.getElementById('desktop-highest-range');
            const desktopAverageRange = document.getElementById('desktop-average-range');
            
            // Sync the checkboxes
            if (event.target.id === 'mobile-hindex-found') {
                desktopFoundCheckbox.checked = mobileFoundCheckbox.checked;
            } else if (event.target.id === 'desktop-hindex-found') {
                mobileFoundCheckbox.checked = desktopFoundCheckbox.checked;
            }
            
            const isEnabled = mobileFoundCheckbox.checked;
            
            // Update pending filters
            updatePendingHIndexFilters();
            
            // Update button text to reflect current state
            updateHIndexButtonText();
            
            // Toggle disabled state for range sections
            [mobileHighestRange, mobileAverageRange, desktopHighestRange, desktopAverageRange].forEach(range => {
                if (range) {
                    if (isEnabled) {
                        range.classList.remove('disabled');
                        range.querySelectorAll('input').forEach(input => {
                            input.disabled = false;
                        });
                    } else {
                        range.classList.add('disabled');
                        range.querySelectorAll('input').forEach(input => {
                            input.disabled = true;
                        });
                    }
                }
            });
        }
        
        function updatePendingHIndexFilters() {
            // Read current UI state into pending filters
            const mobileFoundCheckbox = document.getElementById('mobile-hindex-found');
            const mobileNotFoundCheckbox = document.getElementById('mobile-hindex-not-found');
            const mobileHighestMin = document.getElementById('mobile-highest-min');
            const mobileHighestMax = document.getElementById('mobile-highest-max');
            const mobileAverageMin = document.getElementById('mobile-average-min');
            const mobileAverageMax = document.getElementById('mobile-average-max');
            
            pendingHIndexFilters = {
                found: mobileFoundCheckbox.checked,
                notFound: mobileNotFoundCheckbox.checked,
                highestMin: parseInt(mobileHighestMin.value) || 0,
                highestMax: parseInt(mobileHighestMax.value) || 1000,
                averageMin: parseInt(mobileAverageMin.value) || 0,
                averageMax: parseInt(mobileAverageMax.value) || 1000
            };
        }
        
        function resetPendingHIndexFilters() {
            // Revert pending filters to current applied filters
            pendingHIndexFilters = { ...currentHIndexFilters };
            
            // Update UI to reflect current filters
            syncHIndexUI();
        }
        
        function resetPendingNoveltyFilters() {
            // Revert pending filters to current applied filters
            pendingNoveltyFilters = { ...currentNoveltyFilters };
            
            // Update UI to reflect current filters
            syncPendingNoveltyUI();
            updateNoveltyButtonText();
        }
        
        function resetPendingImpactFilters() {
            // Revert pending filters to current applied filters
            pendingImpactFilters = { ...currentImpactFilters };
            
            // Update UI to reflect current filters
            syncPendingImpactUI();
            updateImpactButtonText();
        }
        
        function syncHIndexUI() {
            // Update checkboxes
            document.getElementById('mobile-hindex-found').checked = currentHIndexFilters.found;
            document.getElementById('mobile-hindex-not-found').checked = currentHIndexFilters.notFound;
            document.getElementById('desktop-hindex-found').checked = currentHIndexFilters.found;
            document.getElementById('desktop-hindex-not-found').checked = currentHIndexFilters.notFound;
            
            // Update range inputs
            document.getElementById('mobile-highest-min').value = currentHIndexFilters.highestMin;
            document.getElementById('mobile-highest-max').value = currentHIndexFilters.highestMax;
            document.getElementById('mobile-average-min').value = currentHIndexFilters.averageMin;
            document.getElementById('mobile-average-max').value = currentHIndexFilters.averageMax;
            document.getElementById('desktop-highest-min').value = currentHIndexFilters.highestMin;
            document.getElementById('desktop-highest-max').value = currentHIndexFilters.highestMax;
            document.getElementById('desktop-average-min').value = currentHIndexFilters.averageMin;
            document.getElementById('desktop-average-max').value = currentHIndexFilters.averageMax;
            
            // Update disabled states
            toggleHIndexRanges();
            
            // Update button text
            updateHIndexButtonText();
        }
        
        function updateHIndexButtonText() {
            // Read the current checkbox states from the UI
            const foundChecked = document.getElementById('mobile-hindex-found').checked;
            const notFoundChecked = document.getElementById('mobile-hindex-not-found').checked;
            
            let selectionText;
            if (foundChecked && notFoundChecked) {
                selectionText = "All Selected";
            } else if (foundChecked && !notFoundChecked) {
                selectionText = "H-Index Found";
            } else if (!foundChecked && notFoundChecked) {
                selectionText = "H-Index Not Found";
            } else {
                selectionText = "None Selected";
            }
            
            // Update mobile button
            const mobileButton = document.getElementById('mobile-hindex-btn');
            if (mobileButton) {
                mobileButton.innerHTML = `<span class="font-bold">H-Index:</span> <span class="font-normal">${selectionText}</span> <span class="text-base">▼</span>`;
            }
            
            // Update desktop button
            const desktopButton = document.getElementById('desktop-hindex-btn');
            if (desktopButton) {
                desktopButton.innerHTML = `<span class="font-bold">H-Index:</span> <span class="font-normal">${selectionText}</span> <span class="text-sm">▼</span>`;
            }
        }
        
        function applyHIndexFilter() {
            // Update pending filters one final time
            updatePendingHIndexFilters();
            
            // Apply pending filters as current filters
            currentHIndexFilters = { ...pendingHIndexFilters };
            
            // Update URL with new filter state
            updateURLWithHIndexFilters();
            
            // Update button text to reflect applied filters
            updateHIndexButtonText();
            
            // Close both dropdowns
            const mobileDropdown = document.getElementById('mobile-hindex-dropdown');
            const desktopDropdown = document.getElementById('desktop-hindex-dropdown');
            const mobileButton = document.getElementById('mobile-hindex-btn');
            const desktopButton = document.getElementById('desktop-hindex-btn');
            
            mobileDropdown.classList.add('hidden');
            desktopDropdown.classList.add('hidden');
            
            // Reset button states to normal
            mobileButton.classList.remove('bg-neutral-600');
            mobileButton.classList.add('bg-neutral-500');
            desktopButton.classList.remove('bg-neutral-600');
            desktopButton.classList.add('bg-neutral-500');
            
            // Don't close sidebar - just close dropdown
            // (Sidebar should stay open for more filtering)
            
            // Apply new filtering and update display
            applyFiltersAndSort();
            displayCurrentPage();
        }

        // ============================================================================
        // INPUT VALIDATION FOR H-INDEX RANGES
        // ============================================================================
        
        function validateHIndexInput(input) {
            // Allow empty input temporarily (user might be typing)
            if (input.value === '') {
                return;
            }
            
            let value = parseInt(input.value);
            
            // Ensure value is within 0-1000 range
            if (isNaN(value) || value < 0) {
                input.value = 0;
            } else if (value > 1000) {
                input.value = 1000;
            }
            
            // Auto-correct min/max relationships
            enforceMinMaxConstraints(input);
        }
        
        function enforceMinMaxConstraints(changedInput) {
            const inputId = changedInput.id;
            let minInput, maxInput;
            
            // Determine which min/max pair this input belongs to
            if (inputId.includes('highest-min')) {
                minInput = changedInput;
                maxInput = document.getElementById(inputId.replace('min', 'max'));
            } else if (inputId.includes('highest-max')) {
                maxInput = changedInput;
                minInput = document.getElementById(inputId.replace('max', 'min'));
            } else if (inputId.includes('average-min')) {
                minInput = changedInput;
                maxInput = document.getElementById(inputId.replace('min', 'max'));
            } else if (inputId.includes('average-max')) {
                maxInput = changedInput;
                minInput = document.getElementById(inputId.replace('max', 'min'));
            }
            
            if (minInput && maxInput) {
                const minVal = parseInt(minInput.value) || 0;
                const maxVal = parseInt(maxInput.value) || 0;
                
                // If min > max, auto-correct
                if (minVal > maxVal) {
                    if (changedInput === minInput) {
                        // User changed min to be > max, set max = min
                        maxInput.value = minVal;
                    } else {
                        // User changed max to be < min, set min = max
                        minInput.value = maxVal;
                    }
                }
            }
        }
        
        // Add input validation when page loads
        function setupHIndexValidation() {
            const inputs = [
                'mobile-highest-min', 'mobile-highest-max',
                'mobile-average-min', 'mobile-average-max',
                'desktop-highest-min', 'desktop-highest-max',
                'desktop-average-min', 'desktop-average-max'
            ];
            
            inputs.forEach(id => {
                const input = document.getElementById(id);
                if (input) {
                    // Validate on input (while typing) - but allow empty temporarily
                    input.addEventListener('input', () => {
                        validateHIndexInput(input);
                        updatePendingHIndexFilters(); // Update pending filters as user types
                    });
                    
                    // Validate on blur (when user leaves field) - ensure it's not empty
                    input.addEventListener('blur', () => {
                        if (input.value === '') {
                            input.value = 0; // Set default if user leaves it empty
                        }
                        validateHIndexInput(input);
                        updatePendingHIndexFilters(); // Update pending filters
                    });
                    
                    // Prevent non-numeric characters except for selection/deletion
                    input.addEventListener('keydown', (e) => {
                        // Allow: backspace, delete, tab, escape, enter, and numbers
                        if ([8, 9, 27, 13, 46].includes(e.keyCode) || 
                            // Allow Ctrl+A, Ctrl+C, Ctrl+V, Ctrl+X
                            (e.keyCode === 65 && e.ctrlKey) || 
                            (e.keyCode === 67 && e.ctrlKey) || 
                            (e.keyCode === 86 && e.ctrlKey) || 
                            (e.keyCode === 88 && e.ctrlKey) ||
                            // Allow numbers (0-9) on main keyboard and numpad
                            (e.keyCode >= 48 && e.keyCode <= 57) ||
                            (e.keyCode >= 96 && e.keyCode <= 105)) {
                            return;
                        }
                        e.preventDefault();
                    });
                }
            });
            
            // Add event listeners for checkboxes to update pending filters
            document.getElementById('mobile-hindex-not-found').addEventListener('change', () => {
                // Sync desktop checkbox
                document.getElementById('desktop-hindex-not-found').checked = 
                    document.getElementById('mobile-hindex-not-found').checked;
                updatePendingHIndexFilters();
                updateHIndexButtonText();
            });
            
            document.getElementById('desktop-hindex-not-found').addEventListener('change', () => {
                // Sync mobile checkbox
                document.getElementById('mobile-hindex-not-found').checked = 
                    document.getElementById('desktop-hindex-not-found').checked;
                updatePendingHIndexFilters();
                updateHIndexButtonText();
            });
            
            // Add event listeners for scoring checkboxes to update pending filters
            document.getElementById('mobile-scoring-has').addEventListener('change', () => {
                // Sync desktop checkbox
                document.getElementById('desktop-scoring-has').checked = 
                    document.getElementById('mobile-scoring-has').checked;
                updatePendingScoringFilters();
                updateScoringButtonText();
            });
            
            document.getElementById('mobile-scoring-no').addEventListener('change', () => {
                // Sync desktop checkbox
                document.getElementById('desktop-scoring-no').checked = 
                    document.getElementById('mobile-scoring-no').checked;
                updatePendingScoringFilters();
                updateScoringButtonText();
            });
            
            document.getElementById('desktop-scoring-has').addEventListener('change', () => {
                // Sync mobile checkbox
                document.getElementById('mobile-scoring-has').checked = 
                    document.getElementById('desktop-scoring-has').checked;
                updatePendingScoringFilters();
                updateScoringButtonText();
            });
            
            document.getElementById('desktop-scoring-no').addEventListener('change', () => {
                // Sync mobile checkbox
                document.getElementById('mobile-scoring-no').checked = 
                    document.getElementById('desktop-scoring-no').checked;
                updatePendingScoringFilters();
                updateScoringButtonText();
            });
            
            // Add event listeners for scoring checkboxes to update pending filters
            document.getElementById('mobile-scoring-has').addEventListener('change', () => {
                // Sync desktop checkbox
                document.getElementById('desktop-scoring-has').checked = 
                    document.getElementById('mobile-scoring-has').checked;
                updatePendingScoringFilters();
                updateScoringButtonText();
            });
            
            document.getElementById('desktop-scoring-has').addEventListener('change', () => {
                // Sync mobile checkbox
                document.getElementById('mobile-scoring-has').checked = 
                    document.getElementById('desktop-scoring-has').checked;
                updatePendingScoringFilters();
                updateScoringButtonText();
            });
            
            document.getElementById('mobile-scoring-no').addEventListener('change', () => {
                // Sync desktop checkbox
                document.getElementById('desktop-scoring-no').checked = 
                    document.getElementById('mobile-scoring-no').checked;
                updatePendingScoringFilters();
                updateScoringButtonText();
            });
            
            document.getElementById('desktop-scoring-no').addEventListener('change', () => {
                // Sync mobile checkbox
                document.getElementById('mobile-scoring-no').checked = 
                    document.getElementById('desktop-scoring-no').checked;
                updatePendingScoringFilters();
                updateScoringButtonText();
            });
            
            // Add event listeners for recommendation checkboxes to sync between mobile and desktop
            document.getElementById('mobile-recommendation-must').addEventListener('change', () => {
                document.getElementById('desktop-recommendation-must').checked = 
                    document.getElementById('mobile-recommendation-must').checked;
                updatePendingRecommendationFilters();
                updateRecommendationButtonText();
            });
            
            document.getElementById('mobile-recommendation-should').addEventListener('change', () => {
                document.getElementById('desktop-recommendation-should').checked = 
                    document.getElementById('mobile-recommendation-should').checked;
                updatePendingRecommendationFilters();
                updateRecommendationButtonText();
            });
            
            document.getElementById('mobile-recommendation-skip').addEventListener('change', () => {
                document.getElementById('desktop-recommendation-skip').checked = 
                    document.getElementById('mobile-recommendation-skip').checked;
                updatePendingRecommendationFilters();
                updateRecommendationButtonText();
            });
            
            document.getElementById('mobile-recommendation-ignore').addEventListener('change', () => {
                document.getElementById('desktop-recommendation-ignore').checked = 
                    document.getElementById('mobile-recommendation-ignore').checked;
                updatePendingRecommendationFilters();
                updateRecommendationButtonText();
            });
            
            document.getElementById('desktop-recommendation-must').addEventListener('change', () => {
                document.getElementById('mobile-recommendation-must').checked = 
                    document.getElementById('desktop-recommendation-must').checked;
                updatePendingRecommendationFilters();
                updateRecommendationButtonText();
            });
            
            document.getElementById('desktop-recommendation-should').addEventListener('change', () => {
                document.getElementById('mobile-recommendation-should').checked = 
                    document.getElementById('desktop-recommendation-should').checked;
                updatePendingRecommendationFilters();
                updateRecommendationButtonText();
            });
            
            document.getElementById('desktop-recommendation-skip').addEventListener('change', () => {
                document.getElementById('mobile-recommendation-skip').checked = 
                    document.getElementById('desktop-recommendation-skip').checked;
                updatePendingRecommendationFilters();
                updateRecommendationButtonText();
            });
            
            document.getElementById('desktop-recommendation-ignore').addEventListener('change', () => {
                document.getElementById('mobile-recommendation-ignore').checked = 
                    document.getElementById('desktop-recommendation-ignore').checked;
                updatePendingRecommendationFilters();
                updateRecommendationButtonText();
            });
            
            // Add event listeners for novelty checkboxes to sync between mobile and desktop
            document.getElementById('mobile-novelty-high').addEventListener('change', () => {
                document.getElementById('desktop-novelty-high').checked = 
                    document.getElementById('mobile-novelty-high').checked;
                updatePendingNoveltyFilters();
                updateNoveltyButtonText();
            });
            
            document.getElementById('mobile-novelty-moderate').addEventListener('change', () => {
                document.getElementById('desktop-novelty-moderate').checked = 
                    document.getElementById('mobile-novelty-moderate').checked;
                updatePendingNoveltyFilters();
                updateNoveltyButtonText();
            });
            
            document.getElementById('mobile-novelty-low').addEventListener('change', () => {
                document.getElementById('desktop-novelty-low').checked = 
                    document.getElementById('mobile-novelty-low').checked;
                updatePendingNoveltyFilters();
                updateNoveltyButtonText();
            });
            
            document.getElementById('mobile-novelty-none').addEventListener('change', () => {
                document.getElementById('desktop-novelty-none').checked = 
                    document.getElementById('mobile-novelty-none').checked;
                updatePendingNoveltyFilters();
                updateNoveltyButtonText();
            });
            
            document.getElementById('desktop-novelty-high').addEventListener('change', () => {
                document.getElementById('mobile-novelty-high').checked = 
                    document.getElementById('desktop-novelty-high').checked;
                updatePendingNoveltyFilters();
                updateNoveltyButtonText();
            });
            
            document.getElementById('desktop-novelty-moderate').addEventListener('change', () => {
                document.getElementById('mobile-novelty-moderate').checked = 
                    document.getElementById('desktop-novelty-moderate').checked;
                updatePendingNoveltyFilters();
                updateNoveltyButtonText();
            });
            
            document.getElementById('desktop-novelty-low').addEventListener('change', () => {
                document.getElementById('mobile-novelty-low').checked = 
                    document.getElementById('desktop-novelty-low').checked;
                updatePendingNoveltyFilters();
                updateNoveltyButtonText();
            });
            
            document.getElementById('desktop-novelty-none').addEventListener('change', () => {
                document.getElementById('mobile-novelty-none').checked = 
                    document.getElementById('desktop-novelty-none').checked;
                updatePendingNoveltyFilters();
                updateNoveltyButtonText();
            });
            
            // Add event listeners for impact checkboxes to sync between mobile and desktop
            document.getElementById('mobile-impact-high').addEventListener('change', () => {
                document.getElementById('desktop-impact-high').checked = 
                    document.getElementById('mobile-impact-high').checked;
                updatePendingImpactFilters();
                updateImpactButtonText();
            });
            
            document.getElementById('mobile-impact-moderate').addEventListener('change', () => {
                document.getElementById('desktop-impact-moderate').checked = 
                    document.getElementById('mobile-impact-moderate').checked;
                updatePendingImpactFilters();
                updateImpactButtonText();
            });
            
            document.getElementById('mobile-impact-low').addEventListener('change', () => {
                document.getElementById('desktop-impact-low').checked = 
                    document.getElementById('mobile-impact-low').checked;
                updatePendingImpactFilters();
                updateImpactButtonText();
            });
            
            document.getElementById('mobile-impact-negligible').addEventListener('change', () => {
                document.getElementById('desktop-impact-negligible').checked = 
                    document.getElementById('mobile-impact-negligible').checked;
                updatePendingImpactFilters();
                updateImpactButtonText();
            });
            
            document.getElementById('desktop-impact-high').addEventListener('change', () => {
                document.getElementById('mobile-impact-high').checked = 
                    document.getElementById('desktop-impact-high').checked;
                updatePendingImpactFilters();
                updateImpactButtonText();
            });
            
            document.getElementById('desktop-impact-moderate').addEventListener('change', () => {
                document.getElementById('mobile-impact-moderate').checked = 
                    document.getElementById('desktop-impact-moderate').checked;
                updatePendingImpactFilters();
                updateImpactButtonText();
            });
            
            document.getElementById('desktop-impact-low').addEventListener('change', () => {
                document.getElementById('mobile-impact-low').checked = 
                    document.getElementById('desktop-impact-low').checked;
                updatePendingImpactFilters();
                updateImpactButtonText();
            });
            
            document.getElementById('desktop-impact-negligible').addEventListener('change', () => {
                document.getElementById('mobile-impact-negligible').checked = 
                    document.getElementById('desktop-impact-negligible').checked;
                updatePendingImpactFilters();
                updateImpactButtonText();
            });
            
            // Add event listeners for relevance checkboxes to sync between mobile and desktop
            document.getElementById('mobile-relevance-highly').addEventListener('change', () => {
                document.getElementById('desktop-relevance-highly').checked = 
                    document.getElementById('mobile-relevance-highly').checked;
                updatePendingRelevanceFilters();
                updateRelevanceButtonText();
            });
            
            document.getElementById('mobile-relevance-moderately').addEventListener('change', () => {
                document.getElementById('desktop-relevance-moderately').checked = 
                    document.getElementById('mobile-relevance-moderately').checked;
                updatePendingRelevanceFilters();
                updateRelevanceButtonText();
            });
            
            document.getElementById('mobile-relevance-tangentially').addEventListener('change', () => {
                document.getElementById('desktop-relevance-tangentially').checked = 
                    document.getElementById('mobile-relevance-tangentially').checked;
                updatePendingRelevanceFilters();
                updateRelevanceButtonText();
            });
            
            document.getElementById('mobile-relevance-not').addEventListener('change', () => {
                document.getElementById('desktop-relevance-not').checked = 
                    document.getElementById('mobile-relevance-not').checked;
                updatePendingRelevanceFilters();
                updateRelevanceButtonText();
            });
            
            document.getElementById('desktop-relevance-highly').addEventListener('change', () => {
                document.getElementById('mobile-relevance-highly').checked = 
                    document.getElementById('desktop-relevance-highly').checked;
                updatePendingRelevanceFilters();
                updateRelevanceButtonText();
            });
            
            document.getElementById('desktop-relevance-moderately').addEventListener('change', () => {
                document.getElementById('mobile-relevance-moderately').checked = 
                    document.getElementById('desktop-relevance-moderately').checked;
                updatePendingRelevanceFilters();
                updateRelevanceButtonText();
            });
            
            document.getElementById('desktop-relevance-tangentially').addEventListener('change', () => {
                document.getElementById('mobile-relevance-tangentially').checked = 
                    document.getElementById('desktop-relevance-tangentially').checked;
                updatePendingRelevanceFilters();
                updateRelevanceButtonText();
            });
            
            document.getElementById('desktop-relevance-not').addEventListener('change', () => {
                document.getElementById('mobile-relevance-not').checked = 
                    document.getElementById('desktop-relevance-not').checked;
                updatePendingRelevanceFilters();
                updateRelevanceButtonText();
            });
            
            // Add event listeners for topic checkboxes to sync between mobile and desktop
            document.getElementById('mobile-topic-rlhf').addEventListener('change', () => {
                document.getElementById('desktop-topic-rlhf').checked = 
                    document.getElementById('mobile-topic-rlhf').checked;
                updatePendingTopicFilters();
                updateTopicButtonText();
            });
            
            document.getElementById('mobile-topic-weak-supervision').addEventListener('change', () => {
                document.getElementById('desktop-topic-weak-supervision').checked = 
                    document.getElementById('mobile-topic-weak-supervision').checked;
                updatePendingTopicFilters();
                updateTopicButtonText();
            });
            
            document.getElementById('mobile-topic-diffusion-reasoning').addEventListener('change', () => {
                document.getElementById('desktop-topic-diffusion-reasoning').checked = 
                    document.getElementById('mobile-topic-diffusion-reasoning').checked;
                updatePendingTopicFilters();
                updateTopicButtonText();
            });
            
            document.getElementById('mobile-topic-distributed-training').addEventListener('change', () => {
                document.getElementById('desktop-topic-distributed-training').checked = 
                    document.getElementById('mobile-topic-distributed-training').checked;
                updatePendingTopicFilters();
                updateTopicButtonText();
            });
            
            document.getElementById('mobile-topic-datasets').addEventListener('change', () => {
                document.getElementById('desktop-topic-datasets').checked = 
                    document.getElementById('mobile-topic-datasets').checked;
                updatePendingTopicFilters();
                updateTopicButtonText();
            });
            
            document.getElementById('desktop-topic-rlhf').addEventListener('change', () => {
                document.getElementById('mobile-topic-rlhf').checked = 
                    document.getElementById('desktop-topic-rlhf').checked;
                updatePendingTopicFilters();
                updateTopicButtonText();
            });
            
            document.getElementById('desktop-topic-weak-supervision').addEventListener('change', () => {
                document.getElementById('mobile-topic-weak-supervision').checked = 
                    document.getElementById('desktop-topic-weak-supervision').checked;
                updatePendingTopicFilters();
                updateTopicButtonText();
            });
            
            document.getElementById('desktop-topic-diffusion-reasoning').addEventListener('change', () => {
                document.getElementById('mobile-topic-diffusion-reasoning').checked = 
                    document.getElementById('desktop-topic-diffusion-reasoning').checked;
                updatePendingTopicFilters();
                updateTopicButtonText();
            });
            
            document.getElementById('desktop-topic-distributed-training').addEventListener('change', () => {
                document.getElementById('mobile-topic-distributed-training').checked = 
                    document.getElementById('desktop-topic-distributed-training').checked;
                updatePendingTopicFilters();
                updateTopicButtonText();
            });
            
            document.getElementById('desktop-topic-datasets').addEventListener('change', () => {
                document.getElementById('mobile-topic-datasets').checked = 
                    document.getElementById('desktop-topic-datasets').checked;
                updatePendingTopicFilters();
                updateTopicButtonText();
            });
        }

        // ============================================================================
        // SCORING FILTER DROPDOWN FUNCTIONS
        // ============================================================================
        
        // Current and pending scoring filter states
        let currentScoringFilters = {
            hasScoring: true,
            noScoring: true
        };
        
        let pendingScoringFilters = {
            hasScoring: true,
            noScoring: true
        };
        
        function toggleMobileScoringDropdown() {
            const button = document.getElementById('mobile-scoring-btn');
            const dropdown = document.getElementById('mobile-scoring-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                // Set direction before showing
                setDropdownDirection(button, dropdown);
                // Change button to expanded state
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                // Change button back to normal state
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function toggleDesktopScoringDropdown() {
            const button = document.getElementById('desktop-scoring-btn');
            const dropdown = document.getElementById('desktop-scoring-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                // Set direction before showing
                setDropdownDirection(button, dropdown);
                // Change button to expanded state
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                // Change button back to normal state
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        
        function syncPendingScoringUI() {
            // Update all checkboxes to match pending state
            document.getElementById('mobile-scoring-has').checked = pendingScoringFilters.hasScoring;
            document.getElementById('mobile-scoring-no').checked = pendingScoringFilters.noScoring;
            document.getElementById('desktop-scoring-has').checked = pendingScoringFilters.hasScoring;
            document.getElementById('desktop-scoring-no').checked = pendingScoringFilters.noScoring;
        }
        
        function syncScoringUI() {
            // Update checkboxes
            document.getElementById('mobile-scoring-has').checked = currentScoringFilters.hasScoring;
            document.getElementById('mobile-scoring-no').checked = currentScoringFilters.noScoring;
            document.getElementById('desktop-scoring-has').checked = currentScoringFilters.hasScoring;
            document.getElementById('desktop-scoring-no').checked = currentScoringFilters.noScoring;
            
            // Update button text
            updateScoringButtonText();
        }
        
        function updateScoringButtonText() {
            // Read the current checkbox states from the UI
            const hasChecked = document.getElementById('mobile-scoring-has').checked;
            const noChecked = document.getElementById('mobile-scoring-no').checked;
            
            let selectionText;
            if (hasChecked && noChecked) {
                selectionText = "All Selected";
            } else if (hasChecked && !noChecked) {
                selectionText = "Completed";
            } else if (!hasChecked && noChecked) {
                selectionText = "Not relevant enough";
            } else {
                selectionText = "None Selected";
            }
            
            // Update mobile button
            const mobileButton = document.getElementById('mobile-scoring-btn');
            if (mobileButton) {
                mobileButton.innerHTML = `<span class="font-bold">Scoring:</span> <span class="font-normal">${selectionText}</span> <span class="text-base">▼</span>`;
            }
            
            // Update desktop button
            const desktopButton = document.getElementById('desktop-scoring-btn');
            if (desktopButton) {
                desktopButton.innerHTML = `<span class="font-bold">Scoring:</span> <span class="font-normal">${selectionText}</span> <span class="text-sm">▼</span>`;
            }
        }
        
        function applyScoringFilter() {
            // Update pending filters one final time
            updatePendingScoringFilters();
            
            // Apply the pending filters as current filters
            currentScoringFilters = { ...pendingScoringFilters };
            
            // Update UI to reflect current state
            syncScoringUI();
            
            // Update URL with current filters
            updateScoringFiltersInURL();
            
            // Close dropdown and apply filters
            closeMobileScoringDropdown();
            closeDesktopScoringDropdown();
            
            // Update disabled state for advanced filters
            updateAdvancedFiltersDisabledState();
            
            // Apply all filters and redisplay
            applyFiltersAndSort();
        }
        
        function updatePendingScoringFilters() {
            // Read current UI state into pending filters
            const mobileScoringHas = document.getElementById('mobile-scoring-has');
            const mobileScoringNo = document.getElementById('mobile-scoring-no');
            
            if (mobileScoringHas && mobileScoringNo) {
                pendingScoringFilters.hasScoring = mobileScoringHas.checked;
                pendingScoringFilters.noScoring = mobileScoringNo.checked;
            }
        }
        
        function resetPendingScoringFilters() {
            pendingScoringFilters = { ...currentScoringFilters };
            syncPendingScoringUI();
            updateScoringButtonText();
        }
        
        function closeMobileScoringDropdown() {
            const dropdown = document.getElementById('mobile-scoring-dropdown');
            const button = document.getElementById('mobile-scoring-btn');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                dropdown.classList.add('hidden');
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
        }
        
        function closeDesktopScoringDropdown() {
            const dropdown = document.getElementById('desktop-scoring-dropdown');
            const button = document.getElementById('desktop-scoring-btn');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                dropdown.classList.add('hidden');
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
        }
        
        function updateScoringFiltersInURL() {
            const params = new URLSearchParams(window.location.search);
            
            // Add scoring filter parameters
            params.set('scoring_has', currentScoringFilters.hasScoring.toString());
            params.set('scoring_no', currentScoringFilters.noScoring.toString());
            
            // Update URL without reload
            const newURL = `${window.location.pathname}?${params.toString()}`;
            window.history.pushState({}, '', newURL);
        }
        
        function updateScoringFiltersFromURL() {
            const params = new URLSearchParams(window.location.search);
            
            // Read scoring filter parameters from URL
            const hasScoring = params.get('scoring_has');
            const noScoring = params.get('scoring_no');
            
            if (hasScoring !== null) {
                currentScoringFilters.hasScoring = hasScoring === 'true';
                pendingScoringFilters.hasScoring = hasScoring === 'true';
            }
            
            if (noScoring !== null) {
                currentScoringFilters.noScoring = noScoring === 'true';
                pendingScoringFilters.noScoring = noScoring === 'true';
            }
            
            // Update UI to match loaded filters
            syncScoringUI();
            
            // Update disabled state for advanced filters
            updateAdvancedFiltersDisabledState();
        }

        // ============================================================================
        // RECOMMENDATION FILTER DROPDOWN FUNCTIONS
        // ============================================================================
        
        // Current and pending recommendation filter states
        let currentRecommendationFilters = {
            mustRead: true,
            shouldRead: true,
            canSkip: true,
            ignore: true
        };
        
        let pendingRecommendationFilters = {
            mustRead: true,
            shouldRead: true,
            canSkip: true,
            ignore: true
        };
        
        function toggleMobileRecommendationDropdown() {
            const button = document.getElementById('mobile-recommendation-btn');
            const dropdown = document.getElementById('mobile-recommendation-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                setDropdownDirection(button, dropdown);
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function toggleDesktopRecommendationDropdown() {
            const button = document.getElementById('desktop-recommendation-btn');
            const dropdown = document.getElementById('desktop-recommendation-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                setDropdownDirection(button, dropdown);
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function syncPendingRecommendationUI() {
            document.getElementById('mobile-recommendation-must').checked = pendingRecommendationFilters.mustRead;
            document.getElementById('mobile-recommendation-should').checked = pendingRecommendationFilters.shouldRead;
            document.getElementById('mobile-recommendation-skip').checked = pendingRecommendationFilters.canSkip;
            document.getElementById('mobile-recommendation-ignore').checked = pendingRecommendationFilters.ignore;
            document.getElementById('desktop-recommendation-must').checked = pendingRecommendationFilters.mustRead;
            document.getElementById('desktop-recommendation-should').checked = pendingRecommendationFilters.shouldRead;
            document.getElementById('desktop-recommendation-skip').checked = pendingRecommendationFilters.canSkip;
            document.getElementById('desktop-recommendation-ignore').checked = pendingRecommendationFilters.ignore;
        }
        
        function syncRecommendationUI() {
            document.getElementById('mobile-recommendation-must').checked = currentRecommendationFilters.mustRead;
            document.getElementById('mobile-recommendation-should').checked = currentRecommendationFilters.shouldRead;
            document.getElementById('mobile-recommendation-skip').checked = currentRecommendationFilters.canSkip;
            document.getElementById('mobile-recommendation-ignore').checked = currentRecommendationFilters.ignore;
            document.getElementById('desktop-recommendation-must').checked = currentRecommendationFilters.mustRead;
            document.getElementById('desktop-recommendation-should').checked = currentRecommendationFilters.shouldRead;
            document.getElementById('desktop-recommendation-skip').checked = currentRecommendationFilters.canSkip;
            document.getElementById('desktop-recommendation-ignore').checked = currentRecommendationFilters.ignore;
            
            updateRecommendationButtonText();
        }
        
        function updateRecommendationButtonText() {
            const mustChecked = document.getElementById('mobile-recommendation-must').checked;
            const shouldChecked = document.getElementById('mobile-recommendation-should').checked;
            const skipChecked = document.getElementById('mobile-recommendation-skip').checked;
            const ignoreChecked = document.getElementById('mobile-recommendation-ignore').checked;
            
            const checkedCount = [mustChecked, shouldChecked, skipChecked, ignoreChecked].filter(Boolean).length;
            
            let selectionText;
            if (checkedCount === 4) {
                selectionText = "All Selected";
            } else if (checkedCount === 0) {
                selectionText = "None Selected";
            } else {
                selectionText = `${checkedCount} Selected`;
            }
            
            const mobileButton = document.getElementById('mobile-recommendation-btn');
            if (mobileButton) {
                mobileButton.innerHTML = `<span class="font-bold">Recommendation:</span> <span class="font-normal">${selectionText}</span> <span class="text-base">▼</span>`;
            }
            
            const desktopButton = document.getElementById('desktop-recommendation-btn');
            if (desktopButton) {
                desktopButton.innerHTML = `<span class="font-bold">Recommendation:</span> <span class="font-normal">${selectionText}</span> <span class="text-sm">▼</span>`;
            }
        }
        
        function applyRecommendationFilter() {
            updatePendingRecommendationFilters();
            currentRecommendationFilters = { ...pendingRecommendationFilters };
            syncRecommendationUI();
            updateRecommendationFiltersInURL();
            closeMobileRecommendationDropdown();
            closeDesktopRecommendationDropdown();
            applyFiltersAndSort();
        }
        
        function updatePendingRecommendationFilters() {
            pendingRecommendationFilters.mustRead = document.getElementById('mobile-recommendation-must').checked;
            pendingRecommendationFilters.shouldRead = document.getElementById('mobile-recommendation-should').checked;
            pendingRecommendationFilters.canSkip = document.getElementById('mobile-recommendation-skip').checked;
            pendingRecommendationFilters.ignore = document.getElementById('mobile-recommendation-ignore').checked;
        }
        
        function resetPendingRecommendationFilters() {
            pendingRecommendationFilters = { ...currentRecommendationFilters };
            syncPendingRecommendationUI();
            updateRecommendationButtonText();
        }
        
        function closeMobileRecommendationDropdown() {
            const dropdown = document.getElementById('mobile-recommendation-dropdown');
            const button = document.getElementById('mobile-recommendation-btn');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                dropdown.classList.add('hidden');
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
        }
        
        function closeDesktopRecommendationDropdown() {
            const dropdown = document.getElementById('desktop-recommendation-dropdown');
            const button = document.getElementById('desktop-recommendation-btn');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                dropdown.classList.add('hidden');
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
        }
        
        function updateRecommendationFiltersInURL() {
            const params = new URLSearchParams(window.location.search);
            params.set('recommendation_must', currentRecommendationFilters.mustRead.toString());
            params.set('recommendation_should', currentRecommendationFilters.shouldRead.toString());
            params.set('recommendation_skip', currentRecommendationFilters.canSkip.toString());
            params.set('recommendation_ignore', currentRecommendationFilters.ignore.toString());
            const newURL = `${window.location.pathname}?${params.toString()}`;
            window.history.pushState({}, '', newURL);
        }
        
        function updateRecommendationFiltersFromURL() {
            const params = new URLSearchParams(window.location.search);
            
            const mustRead = params.get('recommendation_must');
            const shouldRead = params.get('recommendation_should');
            const canSkip = params.get('recommendation_skip');
            const ignore = params.get('recommendation_ignore');
            
            if (mustRead !== null) {
                currentRecommendationFilters.mustRead = mustRead === 'true';
                pendingRecommendationFilters.mustRead = mustRead === 'true';
            }
            if (shouldRead !== null) {
                currentRecommendationFilters.shouldRead = shouldRead === 'true';
                pendingRecommendationFilters.shouldRead = shouldRead === 'true';
            }
            if (canSkip !== null) {
                currentRecommendationFilters.canSkip = canSkip === 'true';
                pendingRecommendationFilters.canSkip = canSkip === 'true';
            }
            if (ignore !== null) {
                currentRecommendationFilters.ignore = ignore === 'true';
                pendingRecommendationFilters.ignore = ignore === 'true';
            }
            
            syncRecommendationUI();
        }

        // ============================================================================
        // NOVELTY FILTER DROPDOWN FUNCTIONS
        // ============================================================================
        
        // Current and pending novelty filter states
        let currentNoveltyFilters = {
            high: true,
            moderate: true,
            low: true,
            none: true
        };
        
        let pendingNoveltyFilters = {
            high: true,
            moderate: true,
            low: true,
            none: true
        };
        
        function toggleMobileNoveltyDropdown() {
            const button = document.getElementById('mobile-novelty-btn');
            const dropdown = document.getElementById('mobile-novelty-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                setDropdownDirection(button, dropdown);
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function toggleDesktopNoveltyDropdown() {
            const button = document.getElementById('desktop-novelty-btn');
            const dropdown = document.getElementById('desktop-novelty-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                setDropdownDirection(button, dropdown);
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function syncPendingNoveltyUI() {
            document.getElementById('mobile-novelty-high').checked = pendingNoveltyFilters.high;
            document.getElementById('mobile-novelty-moderate').checked = pendingNoveltyFilters.moderate;
            document.getElementById('mobile-novelty-low').checked = pendingNoveltyFilters.low;
            document.getElementById('mobile-novelty-none').checked = pendingNoveltyFilters.none;
            document.getElementById('desktop-novelty-high').checked = pendingNoveltyFilters.high;
            document.getElementById('desktop-novelty-moderate').checked = pendingNoveltyFilters.moderate;
            document.getElementById('desktop-novelty-low').checked = pendingNoveltyFilters.low;
            document.getElementById('desktop-novelty-none').checked = pendingNoveltyFilters.none;
        }
        
        function syncNoveltyUI() {
            document.getElementById('mobile-novelty-high').checked = currentNoveltyFilters.high;
            document.getElementById('mobile-novelty-moderate').checked = currentNoveltyFilters.moderate;
            document.getElementById('mobile-novelty-low').checked = currentNoveltyFilters.low;
            document.getElementById('mobile-novelty-none').checked = currentNoveltyFilters.none;
            document.getElementById('desktop-novelty-high').checked = currentNoveltyFilters.high;
            document.getElementById('desktop-novelty-moderate').checked = currentNoveltyFilters.moderate;
            document.getElementById('desktop-novelty-low').checked = currentNoveltyFilters.low;
            document.getElementById('desktop-novelty-none').checked = currentNoveltyFilters.none;
            
            updateNoveltyButtonText();
        }
        
        function updateNoveltyButtonText() {
            const highChecked = document.getElementById('mobile-novelty-high').checked;
            const moderateChecked = document.getElementById('mobile-novelty-moderate').checked;
            const lowChecked = document.getElementById('mobile-novelty-low').checked;
            const noneChecked = document.getElementById('mobile-novelty-none').checked;
            
            const checkedCount = [highChecked, moderateChecked, lowChecked, noneChecked].filter(Boolean).length;
            
            let selectionText;
            if (checkedCount === 4) {
                selectionText = "All Selected";
            } else if (checkedCount === 0) {
                selectionText = "None Selected";
            } else {
                selectionText = `${checkedCount} Selected`;
            }
            
            const mobileButton = document.getElementById('mobile-novelty-btn');
            if (mobileButton) {
                mobileButton.innerHTML = `<span class="font-bold">Novelty:</span> <span class="font-normal">${selectionText}</span> <span class="text-base">▼</span>`;
            }
            
            const desktopButton = document.getElementById('desktop-novelty-btn');
            if (desktopButton) {
                desktopButton.innerHTML = `<span class="font-bold">Novelty:</span> <span class="font-normal">${selectionText}</span> <span class="text-sm">▼</span>`;
            }
        }
        
        function applyNoveltyFilter() {
            updatePendingNoveltyFilters();
            currentNoveltyFilters = { ...pendingNoveltyFilters };
            syncNoveltyUI();
            updateNoveltyFiltersInURL();
            closeMobileNoveltyDropdown();
            closeDesktopNoveltyDropdown();
            applyFiltersAndSort();
        }
        
        function updatePendingNoveltyFilters() {
            pendingNoveltyFilters.high = document.getElementById('mobile-novelty-high').checked;
            pendingNoveltyFilters.moderate = document.getElementById('mobile-novelty-moderate').checked;
            pendingNoveltyFilters.low = document.getElementById('mobile-novelty-low').checked;
            pendingNoveltyFilters.none = document.getElementById('mobile-novelty-none').checked;
        }
        
        function closeMobileNoveltyDropdown() {
            const dropdown = document.getElementById('mobile-novelty-dropdown');
            const button = document.getElementById('mobile-novelty-btn');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                dropdown.classList.add('hidden');
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
        }
        
        function closeDesktopNoveltyDropdown() {
            const dropdown = document.getElementById('desktop-novelty-dropdown');
            const button = document.getElementById('desktop-novelty-btn');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                dropdown.classList.add('hidden');
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
        }
        
        function updateNoveltyFiltersInURL() {
            const params = new URLSearchParams(window.location.search);
            params.set('novelty_high', currentNoveltyFilters.high.toString());
            params.set('novelty_moderate', currentNoveltyFilters.moderate.toString());
            params.set('novelty_low', currentNoveltyFilters.low.toString());
            params.set('novelty_none', currentNoveltyFilters.none.toString());
            const newURL = `${window.location.pathname}?${params.toString()}`;
            window.history.pushState({}, '', newURL);
        }
        
        function updateNoveltyFiltersFromURL() {
            const params = new URLSearchParams(window.location.search);
            
            const high = params.get('novelty_high');
            const moderate = params.get('novelty_moderate');
            const low = params.get('novelty_low');
            const none = params.get('novelty_none');
            
            if (high !== null) {
                currentNoveltyFilters.high = high === 'true';
                pendingNoveltyFilters.high = high === 'true';
            }
            if (moderate !== null) {
                currentNoveltyFilters.moderate = moderate === 'true';
                pendingNoveltyFilters.moderate = moderate === 'true';
            }
            if (low !== null) {
                currentNoveltyFilters.low = low === 'true';
                pendingNoveltyFilters.low = low === 'true';
            }
            if (none !== null) {
                currentNoveltyFilters.none = none === 'true';
                pendingNoveltyFilters.none = none === 'true';
            }
            
            syncNoveltyUI();
        }

        // ============================================================================
        // POTENTIAL IMPACT FILTER DROPDOWN FUNCTIONS
        // ============================================================================
        
        // Current and pending impact filter states
        let currentImpactFilters = {
            high: true,
            moderate: true,
            low: true,
            negligible: true
        };
        
        let pendingImpactFilters = {
            high: true,
            moderate: true,
            low: true,
            negligible: true
        };
        
        function toggleMobileImpactDropdown() {
            const button = document.getElementById('mobile-impact-btn');
            const dropdown = document.getElementById('mobile-impact-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                setDropdownDirection(button, dropdown);
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function toggleDesktopImpactDropdown() {
            const button = document.getElementById('desktop-impact-btn');
            const dropdown = document.getElementById('desktop-impact-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                setDropdownDirection(button, dropdown);
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function syncPendingImpactUI() {
            document.getElementById('mobile-impact-high').checked = pendingImpactFilters.high;
            document.getElementById('mobile-impact-moderate').checked = pendingImpactFilters.moderate;
            document.getElementById('mobile-impact-low').checked = pendingImpactFilters.low;
            document.getElementById('mobile-impact-negligible').checked = pendingImpactFilters.negligible;
            document.getElementById('desktop-impact-high').checked = pendingImpactFilters.high;
            document.getElementById('desktop-impact-moderate').checked = pendingImpactFilters.moderate;
            document.getElementById('desktop-impact-low').checked = pendingImpactFilters.low;
            document.getElementById('desktop-impact-negligible').checked = pendingImpactFilters.negligible;
        }
        
        function syncImpactUI() {
            document.getElementById('mobile-impact-high').checked = currentImpactFilters.high;
            document.getElementById('mobile-impact-moderate').checked = currentImpactFilters.moderate;
            document.getElementById('mobile-impact-low').checked = currentImpactFilters.low;
            document.getElementById('mobile-impact-negligible').checked = currentImpactFilters.negligible;
            document.getElementById('desktop-impact-high').checked = currentImpactFilters.high;
            document.getElementById('desktop-impact-moderate').checked = currentImpactFilters.moderate;
            document.getElementById('desktop-impact-low').checked = currentImpactFilters.low;
            document.getElementById('desktop-impact-negligible').checked = currentImpactFilters.negligible;
            
            updateImpactButtonText();
        }
        
        function updateImpactButtonText() {
            const highChecked = document.getElementById('mobile-impact-high').checked;
            const moderateChecked = document.getElementById('mobile-impact-moderate').checked;
            const lowChecked = document.getElementById('mobile-impact-low').checked;
            const negligibleChecked = document.getElementById('mobile-impact-negligible').checked;
            
            const checkedCount = [highChecked, moderateChecked, lowChecked, negligibleChecked].filter(Boolean).length;
            
            let selectionText;
            if (checkedCount === 4) {
                selectionText = "All Selected";
            } else if (checkedCount === 0) {
                selectionText = "None Selected";
            } else {
                selectionText = `${checkedCount} Selected`;
            }
            
            const mobileButton = document.getElementById('mobile-impact-btn');
            if (mobileButton) {
                mobileButton.innerHTML = `<span class="font-bold">Potential Impact:</span> <span class="font-normal">${selectionText}</span> <span class="text-base">▼</span>`;
            }
            
            const desktopButton = document.getElementById('desktop-impact-btn');
            if (desktopButton) {
                desktopButton.innerHTML = `<span class="font-bold">Potential Impact:</span> <span class="font-normal">${selectionText}</span> <span class="text-sm">▼</span>`;
            }
        }
        
        function applyImpactFilter() {
            updatePendingImpactFilters();
            currentImpactFilters = { ...pendingImpactFilters };
            syncImpactUI();
            updateImpactFiltersInURL();
            closeMobileImpactDropdown();
            closeDesktopImpactDropdown();
            applyFiltersAndSort();
        }
        
        function updatePendingImpactFilters() {
            pendingImpactFilters.high = document.getElementById('mobile-impact-high').checked;
            pendingImpactFilters.moderate = document.getElementById('mobile-impact-moderate').checked;
            pendingImpactFilters.low = document.getElementById('mobile-impact-low').checked;
            pendingImpactFilters.negligible = document.getElementById('mobile-impact-negligible').checked;
        }
        
        function closeMobileImpactDropdown() {
            const dropdown = document.getElementById('mobile-impact-dropdown');
            const button = document.getElementById('mobile-impact-btn');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                dropdown.classList.add('hidden');
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
        }
        
        function closeDesktopImpactDropdown() {
            const dropdown = document.getElementById('desktop-impact-dropdown');
            const button = document.getElementById('desktop-impact-btn');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                dropdown.classList.add('hidden');
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
        }
        
        function updateImpactFiltersInURL() {
            const params = new URLSearchParams(window.location.search);
            params.set('impact_high', currentImpactFilters.high.toString());
            params.set('impact_moderate', currentImpactFilters.moderate.toString());
            params.set('impact_low', currentImpactFilters.low.toString());
            params.set('impact_negligible', currentImpactFilters.negligible.toString());
            const newURL = `${window.location.pathname}?${params.toString()}`;
            window.history.pushState({}, '', newURL);
        }
        
        function updateImpactFiltersFromURL() {
            const params = new URLSearchParams(window.location.search);
            
            const high = params.get('impact_high');
            const moderate = params.get('impact_moderate');
            const low = params.get('impact_low');
            const negligible = params.get('impact_negligible');
            
            if (high !== null) {
                currentImpactFilters.high = high === 'true';
                pendingImpactFilters.high = high === 'true';
            }
            if (moderate !== null) {
                currentImpactFilters.moderate = moderate === 'true';
                pendingImpactFilters.moderate = moderate === 'true';
            }
            if (low !== null) {
                currentImpactFilters.low = low === 'true';
                pendingImpactFilters.low = low === 'true';
            }
            if (negligible !== null) {
                currentImpactFilters.negligible = negligible === 'true';
                pendingImpactFilters.negligible = negligible === 'true';
            }
            
            syncImpactUI();
        }

        // ============================================================================
        // TOPIC FILTER DROPDOWN FUNCTIONS
        // ============================================================================
        
        function toggleMobileTopicDropdown() {
            const button = document.getElementById('mobile-topic-btn');
            const dropdown = document.getElementById('mobile-topic-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                setDropdownDirection(button, dropdown);
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function toggleDesktopTopicDropdown() {
            const button = document.getElementById('desktop-topic-btn');
            const dropdown = document.getElementById('desktop-topic-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                setDropdownDirection(button, dropdown);
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function syncPendingTopicUI() {
            document.getElementById('mobile-topic-rlhf').checked = pendingTopicFilters.rlhf;
            document.getElementById('mobile-topic-weak-supervision').checked = pendingTopicFilters.weakSupervision;
            document.getElementById('mobile-topic-diffusion-reasoning').checked = pendingTopicFilters.diffusionReasoning;
            document.getElementById('mobile-topic-distributed-training').checked = pendingTopicFilters.distributedTraining;
            document.getElementById('mobile-topic-datasets').checked = pendingTopicFilters.datasets;
            document.getElementById('desktop-topic-rlhf').checked = pendingTopicFilters.rlhf;
            document.getElementById('desktop-topic-weak-supervision').checked = pendingTopicFilters.weakSupervision;
            document.getElementById('desktop-topic-diffusion-reasoning').checked = pendingTopicFilters.diffusionReasoning;
            document.getElementById('desktop-topic-distributed-training').checked = pendingTopicFilters.distributedTraining;
            document.getElementById('desktop-topic-datasets').checked = pendingTopicFilters.datasets;
        }
        
        function syncTopicUI() {
            document.getElementById('mobile-topic-rlhf').checked = currentTopicFilters.rlhf;
            document.getElementById('mobile-topic-weak-supervision').checked = currentTopicFilters.weakSupervision;
            document.getElementById('mobile-topic-diffusion-reasoning').checked = currentTopicFilters.diffusionReasoning;
            document.getElementById('mobile-topic-distributed-training').checked = currentTopicFilters.distributedTraining;
            document.getElementById('mobile-topic-datasets').checked = currentTopicFilters.datasets;
            document.getElementById('desktop-topic-rlhf').checked = currentTopicFilters.rlhf;
            document.getElementById('desktop-topic-weak-supervision').checked = currentTopicFilters.weakSupervision;
            document.getElementById('desktop-topic-diffusion-reasoning').checked = currentTopicFilters.diffusionReasoning;
            document.getElementById('desktop-topic-distributed-training').checked = currentTopicFilters.distributedTraining;
            document.getElementById('desktop-topic-datasets').checked = currentTopicFilters.datasets;
            
            updateTopicButtonText();
        }
        
        function updateTopicButtonText() {
            const rlhfChecked = document.getElementById('mobile-topic-rlhf').checked;
            const weakSupervisionChecked = document.getElementById('mobile-topic-weak-supervision').checked;
            const diffusionReasoningChecked = document.getElementById('mobile-topic-diffusion-reasoning').checked;
            const distributedTrainingChecked = document.getElementById('mobile-topic-distributed-training').checked;
            const datasetsChecked = document.getElementById('mobile-topic-datasets').checked;
            
            const checkedCount = [rlhfChecked, weakSupervisionChecked, diffusionReasoningChecked, distributedTrainingChecked, datasetsChecked].filter(Boolean).length;
            
            let selectionText;
            if (checkedCount === 5) {
                selectionText = "All Selected";
            } else if (checkedCount === 0) {
                selectionText = "None Selected";
            } else {
                selectionText = `${checkedCount} Selected`;
            }
            
            const mobileButton = document.getElementById('mobile-topic-btn');
            if (mobileButton) {
                mobileButton.innerHTML = `<span class="font-bold">Topics:</span> <span class="font-normal">${selectionText}</span> <span class="text-base">▼</span>`;
            }
            
            const desktopButton = document.getElementById('desktop-topic-btn');
            if (desktopButton) {
                desktopButton.innerHTML = `<span class="font-bold">Topics:</span> <span class="font-normal">${selectionText}</span> <span class="text-sm">▼</span>`;
            }
        }
        
        function applyTopicFilter() {
            updatePendingTopicFilters();
            currentTopicFilters = { ...pendingTopicFilters };
            syncTopicUI();
            updateTopicFiltersInURL();
            closeMobileTopicDropdown();
            closeDesktopTopicDropdown();
            updateAllPaperModules();
            applyFiltersAndSort();
        }
        
        function updatePendingTopicFilters() {
            pendingTopicFilters.rlhf = document.getElementById('mobile-topic-rlhf').checked;
            pendingTopicFilters.weakSupervision = document.getElementById('mobile-topic-weak-supervision').checked;
            pendingTopicFilters.diffusionReasoning = document.getElementById('mobile-topic-diffusion-reasoning').checked;
            pendingTopicFilters.distributedTraining = document.getElementById('mobile-topic-distributed-training').checked;
            pendingTopicFilters.datasets = document.getElementById('mobile-topic-datasets').checked;
        }
        
        function resetPendingTopicFilters() {
            pendingTopicFilters = { ...currentTopicFilters };
            syncPendingTopicUI();
            updateTopicButtonText();
        }
        
        function closeMobileTopicDropdown() {
            const dropdown = document.getElementById('mobile-topic-dropdown');
            const button = document.getElementById('mobile-topic-btn');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                dropdown.classList.add('hidden');
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
        }
        
        function closeDesktopTopicDropdown() {
            const dropdown = document.getElementById('desktop-topic-dropdown');
            const button = document.getElementById('desktop-topic-btn');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                dropdown.classList.add('hidden');
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
        }
        
        function updateTopicFiltersInURL() {
            const params = new URLSearchParams(window.location.search);
            params.set('topic_rlhf', currentTopicFilters.rlhf.toString());
            params.set('topic_weak_supervision', currentTopicFilters.weakSupervision.toString());
            params.set('topic_diffusion_reasoning', currentTopicFilters.diffusionReasoning.toString());
            params.set('topic_distributed_training', currentTopicFilters.distributedTraining.toString());
            params.set('topic_datasets', currentTopicFilters.datasets.toString());
            const newURL = `${window.location.pathname}?${params.toString()}`;
            window.history.pushState({}, '', newURL);
        }
        
        function updateTopicFiltersFromURL() {
            const params = new URLSearchParams(window.location.search);
            
            const rlhf = params.get('topic_rlhf');
            const weakSupervision = params.get('topic_weak_supervision');
            const diffusionReasoning = params.get('topic_diffusion_reasoning');
            const distributedTraining = params.get('topic_distributed_training');
            const datasets = params.get('topic_datasets');
            
            if (rlhf !== null) {
                currentTopicFilters.rlhf = rlhf === 'true';
                pendingTopicFilters.rlhf = rlhf === 'true';
            }
            if (weakSupervision !== null) {
                currentTopicFilters.weakSupervision = weakSupervision === 'true';
                pendingTopicFilters.weakSupervision = weakSupervision === 'true';
            }
            if (diffusionReasoning !== null) {
                currentTopicFilters.diffusionReasoning = diffusionReasoning === 'true';
                pendingTopicFilters.diffusionReasoning = diffusionReasoning === 'true';
            }
            if (distributedTraining !== null) {
                currentTopicFilters.distributedTraining = distributedTraining === 'true';
                pendingTopicFilters.distributedTraining = distributedTraining === 'true';
            }
            if (datasets !== null) {
                currentTopicFilters.datasets = datasets === 'true';
                pendingTopicFilters.datasets = datasets === 'true';
            }
            
            syncTopicUI();
        }
        
        function passesTopicFilter(paper) {
            // Topic filter doesn't actually filter papers, it only affects module display
            return true;
        }
        
        function updateAllPaperModules() {
            // Update all similarity and relevance modules when topic filters change
            currentPagePapers.forEach(paper => {
                updateSimilarityModuleTopics(paper.id);
                updateRelevanceModuleTopics(paper.id);
            });
        }

        // ============================================================================
        // RELEVANCE FILTER FUNCTIONS  
        // ============================================================================
        
        function toggleMobileRelevanceDropdown() {
            const button = document.getElementById('mobile-relevance-btn');
            const dropdown = document.getElementById('mobile-relevance-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                setDropdownDirection(button, dropdown);
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function toggleDesktopRelevanceDropdown() {
            const button = document.getElementById('desktop-relevance-btn');
            const dropdown = document.getElementById('desktop-relevance-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                setDropdownDirection(button, dropdown);
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function syncPendingRelevanceUI() {
            document.getElementById('mobile-relevance-highly').checked = pendingRelevanceFilters.highlyRelevant;
            document.getElementById('mobile-relevance-moderately').checked = pendingRelevanceFilters.moderatelyRelevant;
            document.getElementById('mobile-relevance-tangentially').checked = pendingRelevanceFilters.tangentiallyRelevant;
            document.getElementById('mobile-relevance-not').checked = pendingRelevanceFilters.notRelevant;
            document.getElementById('desktop-relevance-highly').checked = pendingRelevanceFilters.highlyRelevant;
            document.getElementById('desktop-relevance-moderately').checked = pendingRelevanceFilters.moderatelyRelevant;
            document.getElementById('desktop-relevance-tangentially').checked = pendingRelevanceFilters.tangentiallyRelevant;
            document.getElementById('desktop-relevance-not').checked = pendingRelevanceFilters.notRelevant;
        }
        
        function syncRelevanceUI() {
            document.getElementById('mobile-relevance-highly').checked = currentRelevanceFilters.highlyRelevant;
            document.getElementById('mobile-relevance-moderately').checked = currentRelevanceFilters.moderatelyRelevant;
            document.getElementById('mobile-relevance-tangentially').checked = currentRelevanceFilters.tangentiallyRelevant;
            document.getElementById('mobile-relevance-not').checked = currentRelevanceFilters.notRelevant;
            document.getElementById('desktop-relevance-highly').checked = currentRelevanceFilters.highlyRelevant;
            document.getElementById('desktop-relevance-moderately').checked = currentRelevanceFilters.moderatelyRelevant;
            document.getElementById('desktop-relevance-tangentially').checked = currentRelevanceFilters.tangentiallyRelevant;
            document.getElementById('desktop-relevance-not').checked = currentRelevanceFilters.notRelevant;
            
            updateRelevanceButtonText();
        }
        
        function updateRelevanceButtonText() {
            // Read the current checkbox states from the UI (like H-Index filter does)
            const highlyRelevantChecked = document.getElementById('mobile-relevance-highly').checked;
            const moderatelyRelevantChecked = document.getElementById('mobile-relevance-moderately').checked;
            const tangentiallyRelevantChecked = document.getElementById('mobile-relevance-tangentially').checked;
            const notRelevantChecked = document.getElementById('mobile-relevance-not').checked;
            
            const selectedOptions = [];
            if (highlyRelevantChecked) selectedOptions.push("Highly Relevant");
            if (moderatelyRelevantChecked) selectedOptions.push("Moderately Relevant");
            if (tangentiallyRelevantChecked) selectedOptions.push("Tangentially Relevant");
            if (notRelevantChecked) selectedOptions.push("Not Relevant");
            
            const selectionText = selectedOptions.length === 4 ? "All Selected" : 
                                selectedOptions.length === 0 ? "None Selected" : 
                                `${selectedOptions.length} Selected`;
            
            const mobileButton = document.getElementById('mobile-relevance-btn');
            if (mobileButton) {
                mobileButton.innerHTML = `<span class="font-bold">Relevance:</span> <span class="font-normal">${selectionText}</span> <span class="text-base">▼</span>`;
            }
            
            const desktopButton = document.getElementById('desktop-relevance-btn');
            if (desktopButton) {
                desktopButton.innerHTML = `<span class="font-bold">Relevance:</span> <span class="font-normal">${selectionText}</span> <span class="text-sm">▼</span>`;
            }
        }
        
        function applyRelevanceFilter() {
            updatePendingRelevanceFilters();
            currentRelevanceFilters = { ...pendingRelevanceFilters };
            syncRelevanceUI();
            updateRelevanceFiltersInURL();
            closeMobileRelevanceDropdown();
            closeDesktopRelevanceDropdown();
            applyFiltersAndSort();
        }
        
        function updatePendingRelevanceFilters() {
            // Get values from mobile (primary source)
            const mobileHighly = document.getElementById('mobile-relevance-highly');
            const mobileModerately = document.getElementById('mobile-relevance-moderately');
            const mobileTangentially = document.getElementById('mobile-relevance-tangentially');
            const mobileNot = document.getElementById('mobile-relevance-not');
            
            // Update pending filters from mobile if available, otherwise from desktop
            pendingRelevanceFilters.highlyRelevant = mobileHighly ? mobileHighly.checked : document.getElementById('desktop-relevance-highly').checked;
            pendingRelevanceFilters.moderatelyRelevant = mobileModerately ? mobileModerately.checked : document.getElementById('desktop-relevance-moderately').checked;
            pendingRelevanceFilters.tangentiallyRelevant = mobileTangentially ? mobileTangentially.checked : document.getElementById('desktop-relevance-tangentially').checked;
            pendingRelevanceFilters.notRelevant = mobileNot ? mobileNot.checked : document.getElementById('desktop-relevance-not').checked;
        }
        
        function resetPendingRelevanceFilters() {
            pendingRelevanceFilters = { ...currentRelevanceFilters };
            syncPendingRelevanceUI();
            updateRelevanceButtonText();
        }
        
        function closeMobileRelevanceDropdown() {
            const dropdown = document.getElementById('mobile-relevance-dropdown');
            const button = document.getElementById('mobile-relevance-btn');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                dropdown.classList.add('hidden');
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
        }
        
        function closeDesktopRelevanceDropdown() {
            const dropdown = document.getElementById('desktop-relevance-dropdown');
            const button = document.getElementById('desktop-relevance-btn');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                dropdown.classList.add('hidden');
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
        }
        
        function updateRelevanceFiltersInURL() {
            const params = new URLSearchParams(window.location.search);
            params.set('relevance_highly', currentRelevanceFilters.highlyRelevant.toString());
            params.set('relevance_moderately', currentRelevanceFilters.moderatelyRelevant.toString());
            params.set('relevance_tangentially', currentRelevanceFilters.tangentiallyRelevant.toString());
            params.set('relevance_not', currentRelevanceFilters.notRelevant.toString());
            window.history.replaceState({}, '', `${window.location.pathname}?${params.toString()}`);
        }
        
        function loadRelevanceFiltersFromURL() {
            const highlyRelevant = getUrlParameter('relevance_highly');
            const moderatelyRelevant = getUrlParameter('relevance_moderately');
            const tangentiallyRelevant = getUrlParameter('relevance_tangentially');
            const notRelevant = getUrlParameter('relevance_not');
            
            if (highlyRelevant !== null) {
                currentRelevanceFilters.highlyRelevant = highlyRelevant === 'true';
                pendingRelevanceFilters.highlyRelevant = highlyRelevant === 'true';
            }
            if (moderatelyRelevant !== null) {
                currentRelevanceFilters.moderatelyRelevant = moderatelyRelevant === 'true';
                pendingRelevanceFilters.moderatelyRelevant = moderatelyRelevant === 'true';
            }
            if (tangentiallyRelevant !== null) {
                currentRelevanceFilters.tangentiallyRelevant = tangentiallyRelevant === 'true';
                pendingRelevanceFilters.tangentiallyRelevant = tangentiallyRelevant === 'true';
            }
            if (notRelevant !== null) {
                currentRelevanceFilters.notRelevant = notRelevant === 'true';
                pendingRelevanceFilters.notRelevant = notRelevant === 'true';
            }
            
            syncRelevanceUI();
        }
        
        function passesRelevanceFilter(paper) {
            // Get selected topics
            const selectedTopics = [];
            if (currentTopicFilters.rlhf) selectedTopics.push('rlhf');
            if (currentTopicFilters.weakSupervision) selectedTopics.push('weak_supervision');
            if (currentTopicFilters.diffusionReasoning) selectedTopics.push('diffusion_reasoning');
            if (currentTopicFilters.distributedTraining) selectedTopics.push('distributed_training');
            if (currentTopicFilters.datasets) selectedTopics.push('datasets');
            
            // If no topics selected, skip relevance filtering
            if (selectedTopics.length === 0) return true;
            
            // Get selected relevance levels
            const selectedRelevanceLevels = [];
            if (currentRelevanceFilters.highlyRelevant) selectedRelevanceLevels.push('Highly Relevant');
            if (currentRelevanceFilters.moderatelyRelevant) selectedRelevanceLevels.push('Moderately Relevant');
            if (currentRelevanceFilters.tangentiallyRelevant) selectedRelevanceLevels.push('Tangentially Relevant');
            if (currentRelevanceFilters.notRelevant) selectedRelevanceLevels.push('Not Relevant');
            
            // If no relevance levels selected, show 0 papers
            if (selectedRelevanceLevels.length === 0) return false;
            
            // Check each selected topic
            for (let topic of selectedTopics) {
                const relevanceField = `${topic}_relevance`;
                const paperRelevance = paper[relevanceField];
                
                // Treat "not_validated" same as "Not Relevant"
                const normalizedRelevance = paperRelevance === "not_validated" ? "Not Relevant" : paperRelevance;
                
                // If this topic's relevance matches any selected relevance level, paper passes
                if (selectedRelevanceLevels.includes(normalizedRelevance)) {
                    return true; // At least one topic matches
                }
            }
            
            // No selected topics had matching relevance levels
            return false;
        }

        // ============================================================================
        // FILTERING AND DISPLAY FUNCTIONS
        // ============================================================================
        
        function shouldDisableAdvancedFilters() {
            return !currentScoringFilters.hasScoring && currentScoringFilters.noScoring;
        }
        
        function updateDropdownDisabledState(buttonId, dropdownId, shouldDisable) {
            const button = document.getElementById(buttonId);
            const dropdown = document.getElementById(dropdownId);
            
            if (button && dropdown) {
                if (shouldDisable) {
                    button.classList.add('opacity-50', 'cursor-not-allowed');
                    button.style.pointerEvents = 'none';
                    dropdown.classList.add('hidden'); // Close if open
                } else {
                    button.classList.remove('opacity-50', 'cursor-not-allowed');
                    button.style.pointerEvents = 'auto';
                }
            }
        }
        
        function updateAdvancedFiltersDisabledState() {
            const shouldDisable = shouldDisableAdvancedFilters();
            
            // Update Recommendation
            updateDropdownDisabledState('mobile-recommendation-btn', 'mobile-recommendation-dropdown', shouldDisable);
            updateDropdownDisabledState('desktop-recommendation-btn', 'desktop-recommendation-dropdown', shouldDisable);
            
            // Update Novelty  
            updateDropdownDisabledState('mobile-novelty-btn', 'mobile-novelty-dropdown', shouldDisable);
            updateDropdownDisabledState('desktop-novelty-btn', 'desktop-novelty-dropdown', shouldDisable);
            
            // Update Impact
            updateDropdownDisabledState('mobile-impact-btn', 'mobile-impact-dropdown', shouldDisable);
            updateDropdownDisabledState('desktop-impact-btn', 'desktop-impact-dropdown', shouldDisable);
            
            // Update Relevance
            updateDropdownDisabledState('mobile-relevance-btn', 'mobile-relevance-dropdown', shouldDisable);
            updateDropdownDisabledState('desktop-relevance-btn', 'desktop-relevance-dropdown', shouldDisable);
        }
        
        function applyFiltersAndSort() {
            // Apply H-Index filtering first
            filteredSortedPapers = allPapers.filter(paper => passesHIndexFilter(paper));
            
            // Apply Scoring filtering
            filteredSortedPapers = filteredSortedPapers.filter(paper => passesScoringFilter(paper));
            
            // Apply Recommendation filtering
            filteredSortedPapers = filteredSortedPapers.filter(paper => passesRecommendationFilter(paper));
            
            // Apply Novelty filtering
            filteredSortedPapers = filteredSortedPapers.filter(paper => passesNoveltyFilter(paper));
            
            // Apply Impact filtering
            filteredSortedPapers = filteredSortedPapers.filter(paper => passesImpactFilter(paper));
            
            // Apply Relevance filtering
            filteredSortedPapers = filteredSortedPapers.filter(paper => passesRelevanceFilter(paper));
            
            // Apply Topic filtering (note: this doesn't filter papers, just affects display)
            filteredSortedPapers = filteredSortedPapers.filter(paper => passesTopicFilter(paper));
            
            // Apply current sorting
            sortPapers(currentSort);
            
            // Calculate pagination
            totalPages = Math.ceil(filteredSortedPapers.length / PAPERS_PER_PAGE);
            currentPage = 1;
            
            updatePaperCount();
            updatePaginationUI();
            displayCurrentPage();
        }
        
        function passesHIndexFilter(paper) {
            const { found, notFound, highestMin, highestMax, averageMin, averageMax } = currentHIndexFilters;
            
            // Check H-Index status
            const hasHIndex = paper.h_index_status === 'completed';
            const noHIndex = paper.h_index_status === 'not_fetched';
            
            // If neither found nor not-found is checked, hide all papers
            if (!found && !notFound) return false;
            
            // Check status inclusion
            if (hasHIndex && !found) return false;
            if (noHIndex && !notFound) return false;
            
            // For papers with H-Index data, check ranges (only if "found" is checked)
            if (hasHIndex && found) {
                // Treat null h-index values as 0
                const paperHighest = paper.highest_h_index || 0;
                const paperAverage = paper.average_h_index || 0;
                
                // Check if paper's H-Index values fall within ranges
                if (paperHighest < highestMin || paperHighest > highestMax) return false;
                if (paperAverage < averageMin || paperAverage > averageMax) return false;
            }
            
            return true;
        }
        
        function passesScoringFilter(paper) {
            const { hasScoring, noScoring } = currentScoringFilters;
            
            // Check scoring status
            const hasLLMScoring = paper.llm_score_status === 'completed';
            const noLLMScoring = paper.llm_score_status === 'not_relevant_enough';
            
            // If neither hasScoring nor noScoring is checked, hide all papers
            if (!hasScoring && !noScoring) return false;
            
            // Check status inclusion
            if (hasLLMScoring && !hasScoring) return false;
            if (noLLMScoring && !noScoring) return false;
            
            // Handle other statuses - if paper has a different status, only show if both filters are enabled
            if (!hasLLMScoring && !noLLMScoring) {
                return hasScoring && noScoring;
            }
            
            return true;
        }
        
        function passesRecommendationFilter(paper) {
            const { mustRead, shouldRead, canSkip, ignore } = currentRecommendationFilters;
            
            // If no filters are selected, hide all papers
            if (!mustRead && !shouldRead && !canSkip && !ignore) return false;
            
            // Check recommendation score
            const score = paper.recommendation_score;
            
            if (score === 'Must Read' && !mustRead) return false;
            if (score === 'Should Read' && !shouldRead) return false;
            if (score === 'Can Skip' && !canSkip) return false;
            if (score === 'Ignore' && !ignore) return false;
            
            // If paper has a different/null score, only show if all filters are enabled
            if (!['Must Read', 'Should Read', 'Can Skip', 'Ignore'].includes(score)) {
                return mustRead && shouldRead && canSkip && ignore;
            }
            
            return true;
        }
        
        function passesNoveltyFilter(paper) {
            const { high, moderate, low, none } = currentNoveltyFilters;
            
            // If no filters are selected, hide all papers
            if (!high && !moderate && !low && !none) return false;
            
            // Check novelty score
            const score = paper.novelty_score;
            
            if (score === 'High' && !high) return false;
            if (score === 'Moderate' && !moderate) return false;
            if (score === 'Low' && !low) return false;
            if ((score === null || score === undefined) && !none) return false;
            
            // If paper has a different score, only show if all filters are enabled
            if (score && !['High', 'Moderate', 'Low'].includes(score)) {
                return high && moderate && low && none;
            }
            
            return true;
        }
        
        function passesImpactFilter(paper) {
            const { high, moderate, low, negligible } = currentImpactFilters;
            
            // If no filters are selected, hide all papers
            if (!high && !moderate && !low && !negligible) return false;
            
            // Check impact score
            const score = paper.impact_score;
            
            if (score === 'High' && !high) return false;
            if (score === 'Moderate' && !moderate) return false;
            if (score === 'Low' && !low) return false;
            if (score === 'Negligible' && !negligible) return false;
            
            // If paper has a different/null score, only show if all filters are enabled
            if (!['High', 'Moderate', 'Low', 'Negligible'].includes(score)) {
                return high && moderate && low && negligible;
            }
            
            return true;
        }
        
        function displayCurrentPage() {
            // Check if there are no papers to display
            if (filteredSortedPapers.length === 0) {
                showNoPapersMessage();
                hidePaginationSections();
                return;
            }
            
            const startIndex = (currentPage - 1) * PAPERS_PER_PAGE;
            const endIndex = startIndex + PAPERS_PER_PAGE;
            currentPagePapers = filteredSortedPapers.slice(startIndex, endIndex);
            
            showPaginationSections();
            populatePaperCards(currentPagePapers, startIndex + 1);
            
            // Re-run truncation after new content is displayed
            setTimeout(() => {
                setupAbstractTruncation();
                setupInitialProgressBars();
            }, 50);
        }

        function populatePaperCards(papers, startIndex = 1) {
            const mobileContainer = document.getElementById('mobile-papers');
            const desktopContainer = document.getElementById('desktop-papers');
            
            const papersHTML = papers.map((paper, index) => createPaperCard(paper, startIndex + index)).join('');
            
            if (mobileContainer) {
                mobileContainer.innerHTML = papersHTML;
            }
            if (desktopContainer) {
                desktopContainer.innerHTML = papersHTML;
            }
        }

        function showNoPapersMessage() {
            const mobileContainer = document.getElementById('mobile-papers');
            const desktopContainer = document.getElementById('desktop-papers');
            
            const noPapersHTML = '<div class="flex items-center justify-center min-h-screen"><h2 class="font-heading text-2xl text-neutral-600">No papers to show</h2></div>';
            
            if (mobileContainer) {
                mobileContainer.innerHTML = noPapersHTML;
            }
            if (desktopContainer) {
                desktopContainer.innerHTML = noPapersHTML;
            }
        }

        function hidePaginationSections() {
            const paginationIds = [
                'mobile-prev-btn', 'mobile-next-btn', 'mobile-pagination-numbers',
                'desktop-prev-btn', 'desktop-next-btn', 'desktop-pagination-numbers',
                'mobile-footer-prev-btn', 'mobile-footer-next-btn', 'mobile-footer-pagination-numbers',
                'desktop-footer-prev-btn', 'desktop-footer-next-btn', 'desktop-footer-pagination-numbers'
            ];
            
            paginationIds.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.style.display = 'none';
                }
            });
        }

        function showPaginationSections() {
            const paginationIds = [
                'mobile-prev-btn', 'mobile-next-btn', 'mobile-pagination-numbers',
                'desktop-prev-btn', 'desktop-next-btn', 'desktop-pagination-numbers',
                'mobile-footer-prev-btn', 'mobile-footer-next-btn', 'mobile-footer-pagination-numbers',
                'desktop-footer-prev-btn', 'desktop-footer-next-btn', 'desktop-footer-pagination-numbers'
            ];
            
            paginationIds.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.style.display = '';
                }
            });
        }

        // ============================================================================
        // PAGINATION FUNCTIONS
        // ============================================================================
        
        function goToPage(page) {
            if (page < 1 || page > totalPages) return;
            currentPage = page;
            updatePaginationUI();
            displayCurrentPage();
        }
        
        function updatePaginationUI() {
            // Update all pagination controls
            updatePaginationButtons();
            updatePaginationNumbers();
        }
        
        function updatePaginationButtons() {
            // Previous buttons
            const prevButtons = ['mobile-prev-btn', 'desktop-prev-btn', 'mobile-footer-prev-btn', 'desktop-footer-prev-btn'];
            prevButtons.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) {
                    if (currentPage <= 1) {
                        btn.classList.add('disabled');
                    } else {
                        btn.classList.remove('disabled');
                    }
                }
            });
            
            // Next buttons
            const nextButtons = ['mobile-next-btn', 'desktop-next-btn', 'mobile-footer-next-btn', 'desktop-footer-next-btn'];
            nextButtons.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) {
                    if (currentPage >= totalPages) {
                        btn.classList.add('disabled');
                    } else {
                        btn.classList.remove('disabled');
                    }
                }
            });
        }
        
        function updatePaginationNumbers() {
            const containers = [
                'mobile-pagination-numbers',
                'desktop-pagination-numbers', 
                'mobile-footer-pagination-numbers',
                'desktop-footer-pagination-numbers'
            ];
            
            containers.forEach(containerId => {
                const container = document.getElementById(containerId);
                if (container) {
                    container.innerHTML = generatePaginationNumbers();
                }
            });
        }
        
        function generatePaginationNumbers() {
            if (totalPages <= 1) return '';
            
            let html = '';
            const maxVisiblePages = 5;
            let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
            let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);
            
            // Adjust if we're near the end
            if (endPage - startPage + 1 < maxVisiblePages) {
                startPage = Math.max(1, endPage - maxVisiblePages + 1);
            }
            
            for (let i = startPage; i <= endPage; i++) {
                const isActive = i === currentPage;
                const activeClass = isActive ? 'bg-neutral-500 text-neutral-10' : 'bg-transparent text-neutral-70 hover:bg-neutral-300';
                html += `<button class="pagination-square w-8 h-8 ${activeClass} flex items-center justify-center cursor-pointer font-heading font-bold text-sm" onclick="goToPage(${i})">${i}</button>`;
            }
            
            return html;
        }

        // ============================================================================
        // HELPER FUNCTIONS FOR STYLING
        // ============================================================================

        function getScoreColor(scoreType, value) {
            const colorMap = {
                recommendation: {
                    'Must Read': 'bg-status-green',      
                    'Should Read': 'bg-status-blue',   
                    'Can Skip': 'bg-status-orange',       
                    'Ignore': 'bg-status-red'          
                },
                novelty: {
                    'High': 'bg-status-green',           
                    'Moderate': 'bg-status-blue',      
                    'Low': 'bg-status-orange',            
                    'None': 'bg-status-red'            
                },
                impact: {
                    'High': 'bg-status-green',           
                    'Moderate': 'bg-status-blue',      
                    'Low': 'bg-status-orange',            
                    'Negligible': 'bg-status-red'      
                }
            };
            
            return colorMap[scoreType][value] || 'bg-neutral-500';  // fallback to neutral-500
        }

        function getRelevanceColor(relevanceValue) {
            const colorMap = {
                'Highly Relevant': 'bg-status-green',      
                'Moderately Relevant': 'bg-status-blue', 
                'Tangentially Relevant': 'bg-status-orange', 
                'Not Relevant': 'bg-status-red',         
                'not_validated': 'bg-status-red'         
            };
            
            return colorMap[relevanceValue] || 'bg-status-red';  // fallback to status-red
        }

        function getRelevanceDisplayText(relevanceValue) {
            if (relevanceValue === 'not_validated') {
                return 'Not Relevant';
            }
            return relevanceValue;
        }

        function getJustificationText(justificationValue) {
            if (justificationValue === 'below_threshold') {
                return "Topic similarity score below 0.4, hence default to 'Not Relevant'.";
            }
            return justificationValue;
        }

        // ============================================================================
        // KATEX RENDERING FUNCTIONS
        // ============================================================================

        function renderKatexInElement(element) {
            if (typeof renderMathInElement !== 'undefined' && element) {
                renderMathInElement(element, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false},
                        {left: '\\(', right: '\\)', display: false},
                        {left: '\\[', right: '\\]', display: true},
                    ],
                    throwOnError: false,
                    trust: true
                });
            }
        }

        // ============================================================================
        // TOPIC VISIBILITY HELPER FUNCTIONS
        // ============================================================================
        
        function getTopicKeyMapping() {
            return {
                'rlhf': 'rlhf',
                'weakSupervision': 'weak_supervision', 
                'diffusionReasoning': 'diffusion_reasoning',
                'distributedTraining': 'distributed_training',
                'datasets': 'datasets'
            };
        }
        
        function getTopicDisplayNames() {
            return {
                'rlhf': 'RLHF',
                'weakSupervision': 'Weak Supervision',
                'diffusionReasoning': 'Diffusion Reasoning', 
                'distributedTraining': 'Distributed Training',
                'datasets': 'Datasets'
            };
        }
        
        function getHiddenTopicsCount() {
            const filters = currentTopicFilters;
            return Object.values(filters).filter(visible => !visible).length;
        }
        
        function getVisibleTopics() {
            const filters = currentTopicFilters;
            return Object.keys(filters).filter(topic => filters[topic]);
        }
        
        function getHiddenTopics() {
            const filters = currentTopicFilters;
            return Object.keys(filters).filter(topic => !filters[topic]);
        }
        
        function generateSimilarityTopicRows(paper) {
            const topicMapping = getTopicKeyMapping();
            const displayNames = getTopicDisplayNames();
            const visibleTopics = getVisibleTopics();
            
            let html = '';
            
            // Add visible topic rows
            visibleTopics.forEach(topic => {
                const dataKey = topicMapping[topic];
                const displayName = displayNames[topic];
                const score = paper[`${dataKey}_score`];
                
                html += `
                    <!-- ${displayName} Score Row -->
                    <div class="flex flex-col topic-row visible-topic" data-topic="${topic}">
                        <div class="text-left">
                            <span class="text-neutral-70 font-heading font-bold text-lg">${displayName}:</span>
                        </div>
                        <div class="bg-neutral-200 relative flex items-center justify-end">
                            <div class="similarity-progress-bar ${dataKey.replace('_', '-')}-progress-bar bg-bar-raw absolute inset-0 z-0" 
                                 data-paper-id="${paper.id}" 
                                 data-topic="${dataKey}">
                            </div>
                            <span class="text-neutral-70 font-heading font-bold text-md py-tag-y px-tag-x relative z-10 ${dataKey.replace('_', '-')}-similarity-score">
                                ${score.toFixed(3)}
                            </span>
                        </div>
                    </div>
                `;
            });
            
            return html;
        }
        
        function generateRelevanceTopicRows(paper) {
            const topicMapping = getTopicKeyMapping();
            const displayNames = getTopicDisplayNames();
            const visibleTopics = getVisibleTopics();
            
            let html = '';
            
            // Add visible topic rows
            visibleTopics.forEach(topic => {
                const dataKey = topicMapping[topic];
                const displayName = displayNames[topic];
                const relevance = paper[`${dataKey}_relevance`];
                
                html += `
                    <!-- ${displayName} Relevance Row -->
                    <div class="flex flex-col topic-row visible-topic" data-topic="${topic}">
                        <div class="text-left">
                            <span class="text-neutral-70 font-heading font-bold text-lg">${displayName}:</span>
                        </div>
                        <div class="w-full text-center py-tag-y font-heading font-bold text-md text-neutral-10 ${getRelevanceColor(relevance)}">
                            ${getRelevanceDisplayText(relevance)}
                        </div>
                    </div>
                `;
            });
            
            return html;
        }
        
        function generateRelevanceJustificationContent(paper, showingHidden = false) {
            const topicMapping = getTopicKeyMapping();
            const displayNames = getTopicDisplayNames();
            const visibleTopics = getVisibleTopics();
            
            let html = '';
            
            // Add justification for visible topics only unless showing hidden topics
            const topicsToShow = showingHidden ? Object.keys(displayNames) : visibleTopics;
            
            topicsToShow.forEach(topic => {
                const dataKey = topicMapping[topic];
                const displayName = displayNames[topic];
                const justification = paper[`${dataKey}_justification`];
                
                html += `
                    <div class="justification-topic-section visible-justification" data-topic="${topic}">
                        <div class="font-heading font-bold">${displayName}:</div>
                        <div>${getJustificationText(justification)}</div>
                    </div>
                `;
            });
            
            return html;
        }
        
        function toggleSimilarityHiddenTopics(paperId) {
            // Find the similarity module specifically
            const containers = document.querySelectorAll(`[data-paper-id="${paperId}"][data-show-hidden-topics]`);
            let container = null;
            
            // Find the similarity container (the one that contains similarity-scores-container)
            // and ensure it's in the currently visible layout (mobile or desktop)
            containers.forEach(cont => {
                if (cont.querySelector('.similarity-scores-container')) {
                    // Check if this container is in a visible layout
                    const mobileLayout = cont.closest('#mobile-main-container');
                    const desktopLayout = cont.closest('.tablet\\:block');
                    
                    if (mobileLayout && getComputedStyle(mobileLayout).display !== 'none') {
                        container = cont;
                    } else if (desktopLayout && getComputedStyle(desktopLayout).display !== 'none') {
                        container = cont;
                    }
                }
            });
            
            if (!container) return;
            
            const isShowingHidden = container.getAttribute('data-show-hidden-topics') === 'true';
            const button = container.querySelector('.show-other-topics-container button');
            const hiddenTopicsContainer = container.querySelector('.hidden-topics-container');
            
            if (!isShowingHidden) {
                // Show hidden topics
                container.setAttribute('data-show-hidden-topics', 'true');
                button.innerHTML = 'Hide Other Topics <span class="text-xs">▲</span>';
                button.className = 'bg-neutral-700 text-neutral-10 font-heading font-bold text-md py-tag-y mt-md w-full text-center hover:bg-neutral-600';
                
                // Show and populate the hidden topics container
                hiddenTopicsContainer.style.display = 'block';
                addHiddenSimilarityTopics(paperId, hiddenTopicsContainer);
            } else {
                // Hide other topics  
                container.setAttribute('data-show-hidden-topics', 'false');
                button.innerHTML = 'Show Other Topics <span class="text-xs">▼</span>';
                button.className = 'bg-neutral-500 text-neutral-10 font-heading font-bold text-md py-tag-y mt-md w-full text-center hover:bg-neutral-600';
                
                // Hide and clear the hidden topics container
                hiddenTopicsContainer.style.display = 'none';
                hiddenTopicsContainer.innerHTML = '';
            }
            
            // Recalculate normalized scores if in normalized mode
            if (container.getAttribute('data-normalized') === 'true') {
                updateNormalizedScores(paperId);
            }
        }
        
        function toggleRelevanceHiddenTopics(paperId) {
            // Find the relevance module specifically (not similarity module)
            const containers = document.querySelectorAll(`[data-paper-id="${paperId}"][data-show-hidden-topics]`);
            let container = null;
            
            // Find the relevance container (the one that contains relevance-scores-container)
            // and ensure it's in the currently visible layout (mobile or desktop)
            containers.forEach(cont => {
                if (cont.querySelector('.relevance-scores-container')) {
                    // Check if this container is in a visible layout
                    const mobileLayout = cont.closest('#mobile-main-container');
                    const desktopLayout = cont.closest('.tablet\\:block');
                    
                    if (mobileLayout && getComputedStyle(mobileLayout).display !== 'none') {
                        container = cont;
                    } else if (desktopLayout && getComputedStyle(desktopLayout).display !== 'none') {
                        container = cont;
                    }
                }
            });
            
            if (!container) return;
            
            const isShowingHidden = container.getAttribute('data-show-hidden-topics') === 'true';
            const button = container.querySelector('.show-other-topics-container button');
            const hiddenTopicsContainer = container.querySelector('.hidden-topics-container');
            
            if (!isShowingHidden) {
                // Show hidden topics
                container.setAttribute('data-show-hidden-topics', 'true');
                button.innerHTML = 'Hide Other Topics <span class="text-xs">▲</span>';
                button.className = 'bg-neutral-700 text-neutral-10 font-heading font-bold text-md py-tag-y mt-md w-full text-center hover:bg-neutral-600';
                
                // Show and populate the hidden topics container
                hiddenTopicsContainer.style.display = 'block';
                addHiddenRelevanceTopics(paperId, hiddenTopicsContainer);
            } else {
                // Hide other topics
                container.setAttribute('data-show-hidden-topics', 'false');
                button.innerHTML = 'Show Other Topics <span class="text-xs">▼</span>';
                button.className = 'bg-neutral-500 text-neutral-10 font-heading font-bold text-md py-tag-y mt-md w-full text-center hover:bg-neutral-600';
                
                // Hide and clear the hidden topics container
                hiddenTopicsContainer.style.display = 'none';
                hiddenTopicsContainer.innerHTML = '';
            }
            
            // Update justification content based on new state
            const justificationContainer = container.querySelector('.relevance-justification-section .justification-text');
            if (justificationContainer) {
                const paper = currentPagePapers.find(p => p.id === paperId);
                if (paper) {
                    const newShowingHidden = container.getAttribute('data-show-hidden-topics') === 'true';
                    justificationContainer.innerHTML = generateRelevanceJustificationContent(paper, newShowingHidden);
                }
            }
            
            // Update justification if it's currently visible
            updateRelevanceJustificationVisibility(paperId);
        }
        
        function addHiddenSimilarityTopics(paperId, container) {
            const paper = currentPagePapers.find(p => p.id === paperId);
            if (!paper) return;
            
            const topicMapping = getTopicKeyMapping();
            const displayNames = getTopicDisplayNames();
            const hiddenTopics = getHiddenTopics();
            
            // Check if the parent container is in normalized mode
            const parentContainer = container.closest('[data-normalized]');
            const isNormalized = parentContainer && parentContainer.getAttribute('data-normalized') === 'true';
            const barColorClass = isNormalized ? 'bg-bar-normalized' : 'bg-bar-raw';
            
            hiddenTopics.forEach(topic => {
                const dataKey = topicMapping[topic];
                const displayName = displayNames[topic];
                const score = paper[`${dataKey}_score`];
                
                const rowHtml = `
                    <div class="flex flex-col topic-row hidden-topic" data-topic="${topic}">
                        <div class="text-left">
                            <span class="text-neutral-70 font-heading font-bold text-lg">${displayName}:</span>
                        </div>
                        <div class="bg-neutral-200 relative flex items-center justify-end">
                            <div class="similarity-progress-bar ${dataKey.replace('_', '-')}-progress-bar ${barColorClass} absolute inset-0 z-0" 
                                 data-paper-id="${paperId}" 
                                 data-topic="${dataKey}">
                            </div>
                            <span class="text-neutral-70 font-heading font-bold text-md py-tag-y px-tag-x relative z-10 ${dataKey.replace('_', '-')}-similarity-score">
                                ${score.toFixed(3)}
                            </span>
                        </div>
                    </div>
                `;
                
                container.insertAdjacentHTML('beforeend', rowHtml);
            });
            
            // Update progress bars for newly added rows with correct values and colors
            setupProgressBarsForPaper(paper);
            
            // If in normalized mode, update all scores including the newly added ones
            if (isNormalized) {
                updateNormalizedScores(paperId);
            }
        }
        
        function addHiddenRelevanceTopics(paperId, container) {
            const paper = currentPagePapers.find(p => p.id === paperId);
            if (!paper) return;
            
            const topicMapping = getTopicKeyMapping();
            const displayNames = getTopicDisplayNames();
            const hiddenTopics = getHiddenTopics();
            
            hiddenTopics.forEach(topic => {
                const dataKey = topicMapping[topic];
                const displayName = displayNames[topic];
                const relevance = paper[`${dataKey}_relevance`];
                
                const rowHtml = `
                    <div class="flex flex-col topic-row hidden-topic" data-topic="${topic}">
                        <div class="text-left">
                            <span class="text-neutral-70 font-heading font-bold text-lg">${displayName}:</span>
                        </div>
                        <div class="w-full text-center py-tag-y font-heading font-bold text-md text-neutral-10 ${getRelevanceColor(relevance)}">
                            ${getRelevanceDisplayText(relevance)}
                        </div>
                    </div>
                `;
                
                container.insertAdjacentHTML('beforeend', rowHtml);
            });
        }
        
        function removeHiddenTopicRows(container) {
            const hiddenRows = container.querySelectorAll('.hidden-topic');
            hiddenRows.forEach(row => row.remove());
        }
        
        function updateSimilarityModuleTopics(paperId) {
            // Find the similarity module specifically
            const containers = document.querySelectorAll(`[data-paper-id="${paperId}"][data-normalized]`);
            let container = null;
            
            // Find the similarity container in the currently visible layout
            containers.forEach(cont => {
                if (cont.querySelector('.similarity-scores-container')) {
                    // Check if this container is in a visible layout
                    const mobileLayout = cont.closest('#mobile-main-container');
                    const desktopLayout = cont.closest('.tablet\\:block');
                    
                    if (mobileLayout && getComputedStyle(mobileLayout).display !== 'none') {
                        container = cont;
                    } else if (desktopLayout && getComputedStyle(desktopLayout).display !== 'none') {
                        container = cont;
                    }
                }
            });
            
            if (!container) return;
            
            const scoresContainer = container.querySelector('.similarity-scores-container');
            const showOtherButton = container.querySelector('.show-other-topics-container');
            
            // Remove all existing topic rows
            scoresContainer.innerHTML = '';
            
            // Regenerate visible topic rows
            const paper = currentPagePapers.find(p => p.id === paperId);
            if (paper) {
                scoresContainer.innerHTML = generateSimilarityTopicRows(paper);
                setupProgressBarsForPaper(paper);
                
                // Update normalized scores if needed
                if (container.getAttribute('data-normalized') === 'true') {
                    updateNormalizedScores(paperId);
                }
            }
            
            // Show/hide the "Show Other Topics" button
            if (getHiddenTopicsCount() > 0) {
                if (showOtherButton) {
                    showOtherButton.style.display = 'block';
                }
            } else {
                if (showOtherButton) {
                    showOtherButton.style.display = 'none';
                }
            }
            
            // Reset the hidden topics state
            container.setAttribute('data-show-hidden-topics', 'false');
            
            // Reset button text if it exists
            const button = showOtherButton?.querySelector('button');
            if (button) {
                button.innerHTML = 'Show Other Topics <span class="text-xs">▼</span>';
            }
        }
        
        function updateRelevanceModuleTopics(paperId) {
            // Find all relevance containers for this paper
            const containers = document.querySelectorAll(`[data-paper-id="${paperId}"][data-show-hidden-topics]`);
            
            containers.forEach(container => {
                const scoresContainer = container.querySelector('.relevance-scores-container');
                if (!scoresContainer) return; // Skip if this is not a relevance container
                
                const showOtherButton = container.querySelector('.show-other-topics-container');
                const justificationContainer = container.querySelector('.relevance-justification-section .justification-text');
                
                // Remove all existing topic rows
                scoresContainer.innerHTML = '';
                
                // Regenerate visible topic rows
                const paper = currentPagePapers.find(p => p.id === paperId);
                if (paper) {
                    scoresContainer.innerHTML = generateRelevanceTopicRows(paper);
                    
                    // Update justification content based on current visibility state
                    if (justificationContainer) {
                        const isShowingHidden = container.getAttribute('data-show-hidden-topics') === 'true';
                        justificationContainer.innerHTML = generateRelevanceJustificationContent(paper, isShowingHidden);
                    }
                }
                
                // Show/hide the "Show Other Topics" button
                if (getHiddenTopicsCount() > 0) {
                    if (showOtherButton) {
                        showOtherButton.style.display = 'block';
                    }
                } else {
                    if (showOtherButton) {
                        showOtherButton.style.display = 'none';
                    }
                }
                
                // Reset the hidden topics state
                container.setAttribute('data-show-hidden-topics', 'false');
                
                // Reset button text if it exists
                const button = showOtherButton?.querySelector('button');
                if (button) {
                    button.innerHTML = 'Show Other Topics <span class="text-xs">▼</span>';
                }
            });
        }
        
        function updateRelevanceJustificationVisibility(paperId) {
            // Find the justification container in the currently visible layout
            const containers = document.querySelectorAll(`.relevance-justification-section[data-paper-id="${paperId}"]`);
            let container = null;
            
            containers.forEach(cont => {
                // Check if this container is in a visible layout
                const mobileLayout = cont.closest('#mobile-main-container');
                const desktopLayout = cont.closest('.tablet\\:block');
                
                if (mobileLayout && getComputedStyle(mobileLayout).display !== 'none') {
                    container = cont;
                } else if (desktopLayout && getComputedStyle(desktopLayout).display !== 'none') {
                    container = cont;
                }
            });
            
            if (!container) return;
            
            const justificationDiv = container.querySelector('.justification-text');
            const isVisible = !justificationDiv.classList.contains('hidden');
            
            if (isVisible) {
                const paper = currentPagePapers.find(p => p.id === paperId);
                const relevanceContainer = container.closest('[data-show-hidden-topics]');
                const isShowingHidden = relevanceContainer && relevanceContainer.getAttribute('data-show-hidden-topics') === 'true';
                
                if (paper) {
                    if (isShowingHidden) {
                        // Show all justifications
                        justificationDiv.innerHTML = generateFullRelevanceJustificationContent(paper);
                    } else {
                        // Show only visible justifications
                        justificationDiv.innerHTML = generateRelevanceJustificationContent(paper);
                    }
                }
            }
        }
        
        function generateFullRelevanceJustificationContent(paper) {
            const allTopics = ['rlhf', 'weakSupervision', 'diffusionReasoning', 'distributedTraining', 'datasets'];
            const topicMapping = getTopicKeyMapping();
            const displayNames = getTopicDisplayNames();
            
            let html = '';
            
            allTopics.forEach(topic => {
                const dataKey = topicMapping[topic];
                const displayName = displayNames[topic];
                const justification = paper[`${dataKey}_justification`];
                const isVisible = currentTopicFilters[topic];
                
                html += `
                    <div class="justification-topic-section ${isVisible ? 'visible-justification' : 'hidden-justification'}" data-topic="${topic}">
                        <div class="font-heading font-bold">${displayName}:</div>
                        <div>${getJustificationText(justification)}</div>
                    </div>
                `;
            });
            
            return html;
        }
        
        function setupProgressBarsForPaper(paper) {
            const topics = ['rlhf', 'weak_supervision', 'diffusion_reasoning', 'distributed_training', 'datasets'];
            
            topics.forEach(topic => {
                const progressBars = document.querySelectorAll(
                    `.similarity-progress-bar[data-paper-id="${paper.id}"][data-topic="${topic}"]`
                );
                
                progressBars.forEach(progressBar => {
                    const score = paper[`${topic}_score`];
                    const percentage = (score * 100);
                    progressBar.style.width = `${percentage}%`;
                });
            });
        }
        
        function updateNormalizedScores(paperId) {
            // Find the normalized similarity container in the currently visible layout
            const containers = document.querySelectorAll(`[data-paper-id="${paperId}"][data-normalized="true"]`);
            let container = null;
            
            containers.forEach(cont => {
                // Check if this container is in a visible layout
                const mobileLayout = cont.closest('#mobile-main-container');
                const desktopLayout = cont.closest('.tablet\\:block');
                
                if (mobileLayout && getComputedStyle(mobileLayout).display !== 'none') {
                    container = cont;
                } else if (desktopLayout && getComputedStyle(desktopLayout).display !== 'none') {
                    container = cont;
                }
            });
            
            if (!container) return;
            
            const paper = currentPagePapers.find(p => p.id === paperId);
            if (!paper) return;
            
            const isShowingHidden = container.getAttribute('data-show-hidden-topics') === 'true';
            const topicsToCalculate = isShowingHidden ? 
                ['rlhf', 'weakSupervision', 'diffusionReasoning', 'distributedTraining', 'datasets'] :
                getVisibleTopics();
                
            const topicMapping = getTopicKeyMapping();
            
            // Calculate total score for normalization
            const totalScore = topicsToCalculate.reduce((sum, topic) => {
                const dataKey = topicMapping[topic];
                return sum + paper[`${dataKey}_score`];
            }, 0);
            
            // Update each visible topic
            topicsToCalculate.forEach(topic => {
                const dataKey = topicMapping[topic];
                const rawScore = paper[`${dataKey}_score`];
                const normalizedScore = (rawScore / totalScore) * 100;
                
                // Update progress bar
                const progressBar = container.querySelector(`.${dataKey.replace('_', '-')}-progress-bar`);
                if (progressBar) {
                    progressBar.style.width = `${normalizedScore}%`;
                }
                
                // Update score text
                const scoreElement = container.querySelector(`.${dataKey.replace('_', '-')}-similarity-score`);
                if (scoreElement) {
                    const sigFigScore = normalizedScore.toPrecision(3);
                    scoreElement.textContent = `${sigFigScore}%`;
                }
            });
        }

        // ============================================================================
        // PAPER CARD CREATION FUNCTIONS
        // ============================================================================
        function createPaperCard(paper, paperNumber) {
            const cardId = `paper-${paperNumber}`;
            
            return `
                <article class="bg-neutral-200" role="article" aria-labelledby="${cardId}">
                    <!-- Title Section -->
                    <div class="p-md">
                        <h2 id="${cardId}" class="text-neutral-70 font-heading font-bold text-2xl">
                            <span class="mr-sm">${paperNumber}.</span><a href="${paper.pdf_url}" 
                               class="paper-title-link" 
                               target="_blank" 
                               rel="noopener noreferrer"
                               aria-label="View paper PDF">${paper.title}</a>
                        </h2>
                    </div>
                    
                    <!-- Paper Info Section -->
                    <div class="grid grid-cols-1 gap-lg pb-xl px-xl">
                        <!-- Row 1: Metadata Module -->
                        <div class="flex flex-col gap-xs">
                            <!-- First row: arXiv ID and Publication Date -->
                            <div class="flex gap-xs">
                                <span class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y">
                                    arXiv ID: <a href="${paper.arxiv_url}" target="_blank" rel="noopener noreferrer" class="text-neutral-10 underline hover:no-underline">${paper.id}</a>
                                </span>
                                <span class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y">
                                    Published: ${formatPublicationDate(paper.published_date)}
                                </span>
                            </div>
                            
                            <!-- Second row: Authors -->
                            <div>
                                <span class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y metadata-tag">
                                    Authors: ${paper.h_index_status === 'completed' && paper.author_h_indexes && paper.author_h_indexes.length > 0 
                                        ? paper.author_h_indexes.map(author => 
                                            author.profile_url && author.profile_url !== null && author.profile_url !== '' 
                                                ? `<a href="${author.profile_url}" target="_blank" rel="noopener noreferrer" class="text-neutral-10 underline hover:no-underline">${author.name}</a>`
                                                : author.name
                                        ).join(', ')
                                        : paper.authors.join(', ')
                                    }
                                </span>
                            </div>
                            
                            <!-- Third row: Categories -->
                            <div>
                                <span class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y metadata-tag">
                                    Categories: ${paper.categories.join(', ')}
                                </span>
                            </div>
                        </div>
                        
                        <!-- Row 2: AI Generated Summary Module -->
                        ${paper.summary && paper.summary.trim() ? `
                        <div class="bg-neutral-300 p-lg">
                            <div class="flex flex-col gap-xs">
                                <h3 class="text-neutral-70 font-heading font-bold text-lg">AI-generated summary</h3>
                                <p class="text-neutral-70 font-body text-md">${paper.summary}</p>
                            </div>
                        </div>
                        ` : ''}
                        
                        <!-- Row 3: Abstract Module -->
                        <div class="bg-neutral-300 p-lg">
                            <div class="flex flex-col gap-xs">
                                <h3 class="text-neutral-70 font-heading font-bold text-lg">Abstract</h3>
                                <div class="abstract-container" data-paper-id="${paper.id}">
                                    <p class="abstract-text text-neutral-70 font-body text-md" 
                                       style="line-height: calc(1.5em);">${paper.abstract}</p>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Row 4: Score Row Section -->
                        ${paper.llm_score_status !== 'not_relevant_enough' ? `
                        <div class="flex flex-col tablet:flex-row gap-lg items-start">
                            <!-- Recommendation Score Module -->
                            <div class="bg-neutral-300 p-lg flex-1 w-full">
                                <div class="flex flex-col gap-xs">
                                    <!-- Score Section -->
                                    <div class="flex">
                                        <span class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y text-center">
                                            Recommendation:
                                        </span>
                                        <span class="text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y text-center ${getScoreColor('recommendation', paper.recommendation_score)}">
                                            ${paper.recommendation_score}
                                        </span>
                                    </div>
                                    
                                    <!-- Justification Section -->
                                    <div class="w-full recommendation-justification-section" data-paper-id="${paper.id}">
                                        <button class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y w-full text-left cursor-pointer border-none transition-opacity duration-200" 
                                                onclick="toggleRecommendationJustification('${paper.id}')">
                                            Show Justification <span class="text-xs">▲</span>
                                        </button>
                                        <div class="justification-text hidden text-neutral-20 font-body text-md px-tag-x py-tag-y bg-neutral-500 transition-all duration-300 ease-in-out">
                                            ${paper.recommendation_justification}
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Novelty Score Module -->
                            <div class="bg-neutral-300 p-lg flex-1 w-full">
                                <div class="flex flex-col gap-xs">
                                    <!-- Score Section -->
                                    <div class="flex">
                                        <span class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y text-center">
                                            Novelty:
                                        </span>
                                        <span class="text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y text-center ${getScoreColor('novelty', paper.novelty_score)}">
                                            ${paper.novelty_score}
                                        </span>
                                    </div>
                                    
                                    <!-- Justification Section -->
                                    <div class="w-full novelty-justification-section" data-paper-id="${paper.id}">
                                        <button class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y w-full text-left cursor-pointer border-none transition-opacity duration-200" 
                                                onclick="toggleNoveltyJustification('${paper.id}')">
                                            Show Justification <span class="text-xs">▲</span>
                                        </button>
                                        <div class="justification-text hidden text-neutral-20 font-body text-md px-tag-x py-tag-y bg-neutral-500 transition-all duration-300 ease-in-out">
                                            ${paper.novelty_justification}
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Potential Impact Score Module -->
                            <div class="bg-neutral-300 p-lg flex-1 w-full">
                                <div class="flex flex-col gap-xs">
                                    <!-- Score Section -->
                                    <div class="flex">
                                        <span class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y text-center">
                                            Potential Impact:
                                        </span>
                                        <span class="text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y text-center ${getScoreColor('impact', paper.impact_score)}">
                                            ${paper.impact_score}
                                        </span>
                                    </div>
                                    
                                    <!-- Justification Section -->
                                    <div class="w-full impact-justification-section" data-paper-id="${paper.id}">
                                        <button class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y w-full text-left cursor-pointer border-none transition-opacity duration-200" 
                                                onclick="toggleImpactJustification('${paper.id}')">
                                            Show Justification <span class="text-xs">▲</span>
                                        </button>
                                        <div class="justification-text hidden text-neutral-20 font-body text-md px-tag-x py-tag-y bg-neutral-500 transition-all duration-300 ease-in-out">
                                            ${paper.impact_justification}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        ` : ''}
                        
                        <!-- Row 5: Similarity, Relevance, H-index Section -->
                        <div class="flex flex-col tablet:flex-row gap-lg items-start">
                            <!-- Similarity Scores Module -->
                            <div class="bg-neutral-300 p-lg flex-1 w-full" data-paper-id="${paper.id}" data-normalized="false" data-show-hidden-topics="false">
                                <div class="flex flex-col gap-xs">
                                    <!-- Title Section -->
                                    <div class="text-center py-tag-y">
                                        <h3 class="text-neutral-70 font-heading font-bold text-xl">Similarity Scores</h3>
                                    </div>
                                    
                                    <!-- Scores Section -->
                                    <div class="flex flex-col gap-xs similarity-scores-container">
                                        ${generateSimilarityTopicRows(paper)}
                                    </div>
                                    
                                    <!-- Show Other Topics Button (conditionally shown) -->
                                    <div class="show-other-topics-container" ${getHiddenTopicsCount() > 0 ? '' : 'style="display: none;"'}>
                                        <button class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md py-tag-y mt-md w-full text-center hover:bg-neutral-600" onclick="toggleSimilarityHiddenTopics('${paper.id}')">
                                            Show Other Topics <span class="text-xs">▼</span>
                                        </button>
                                    </div>
                                    
                                    <!-- Hidden Topics Container (appears after button when toggled) -->
                                    <div class="hidden-topics-container" style="display: none;"></div>
                                    
                                    <!-- Button Section -->
                                    <div>
                                        <button class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md py-tag-y mt-md w-full text-center" onclick="toggleSimilarityScores(this)">
                                            Show Normalized Scores ⇄
                                        </button>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Relevance Module -->
                            <div class="bg-neutral-300 p-lg flex-1 w-full" data-paper-id="${paper.id}" data-show-hidden-topics="false">
                                <div class="flex flex-col gap-xs">
                                    <!-- Title Section -->
                                    <div class="text-center py-tag-y">
                                        <h3 class="text-neutral-70 font-heading font-bold text-xl">Topic Relevance</h3>
                                    </div>
                                    
                                    <!-- Scores Section -->
                                    <div class="flex flex-col gap-xs relevance-scores-container">
                                        ${generateRelevanceTopicRows(paper)}
                                    </div>
                                    
                                    <!-- Show Other Topics Button (conditionally shown) -->
                                    <div class="show-other-topics-container" ${getHiddenTopicsCount() > 0 ? '' : 'style="display: none;"'}>
                                        <button class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md py-tag-y mt-md w-full text-center hover:bg-neutral-600" onclick="toggleRelevanceHiddenTopics('${paper.id}')">
                                            Show Other Topics <span class="text-xs">▼</span>
                                        </button>
                                    </div>
                                    
                                    <!-- Hidden Topics Container (appears after button when toggled) -->
                                    <div class="hidden-topics-container" style="display: none;"></div>
                                    
                                    <!-- Justification Section -->
                                    <div class="w-full relevance-justification-section" data-paper-id="${paper.id}">
                                        <button class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y mt-md w-full text-center cursor-pointer border-none transition-opacity duration-200" 
                                                onclick="toggleRelevanceJustification('${paper.id}')">
                                            Show Justification <span class="text-xs">▲</span>
                                        </button>
                                        <div class="justification-text hidden text-neutral-20 font-mono text-md px-tag-x py-tag-y bg-neutral-500 transition-all duration-300 ease-in-out flex flex-col gap-sm">
                                            ${generateRelevanceJustificationContent(paper)}
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Author H-Index Module -->
                            <div class="bg-neutral-300 p-lg flex-1 w-full">
                                <div class="flex flex-col gap-md">
                                    <!-- Title Section -->
                                    <div class="text-center py-tag-y">
                                        <h3 class="text-neutral-70 font-heading font-bold text-xl">Author H-Index</h3>
                                    </div>
                                    
                                    ${paper.h_index_status === 'not_fetched' || paper.h_index_status === 'failed' ? `
                                        <!-- No Data Available Section -->
                                        <div class="text-center pt-lg pb-sm">
                                            <p class="text-neutral-60 font-heading font-bold text-lg">No H-Index data available</p>
                                        </div>
                                    ` : `
                                        <!-- H-Index Info Section -->
                                        <div class="flex flex-col gap-sm">
                                            <!-- Authors Found Row -->
                                            <div class="flex justify-between items-center">
                                                <span class="text-neutral-60 font-heading font-bold text-xl px-tag-x py-tag-y">Authors found:</span>
                                                <span class="text-neutral-60 font-heading font-bold text-xl px-tag-x py-tag-y">${paper.authors_found}/${paper.total_authors}</span>
                                            </div>
                                            
                                            <!-- Highest H-Index Row -->
                                            <div class="flex justify-between items-center">
                                                <span class="text-neutral-60 font-heading font-bold text-xl px-tag-x py-tag-y">Highest H-Index:</span>
                                                <span class="text-neutral-60 font-heading font-bold text-xl px-tag-x py-tag-y">${paper.highest_h_index || 'N/A'}</span>
                                            </div>
                                            
                                            <!-- Average H-Index Row -->
                                            <div class="flex justify-between items-center">
                                                <span class="text-neutral-60 font-heading font-bold text-xl px-tag-x py-tag-y">Average H-Index:</span>
                                                <span class="text-neutral-60 font-heading font-bold text-xl px-tag-x py-tag-y">${paper.average_h_index ? paper.average_h_index.toFixed(1) : 'N/A'}</span>
                                            </div>
                                            
                                            <!-- Notable Authors Row -->
                                            <div class="flex justify-between items-center">
                                                <span class="text-neutral-60 font-heading font-bold text-xl px-tag-x py-tag-y">Notable (H>5):</span>
                                                <span class="text-neutral-60 font-heading font-bold text-xl px-tag-x py-tag-y">${paper.notable_authors_count || 0}</span>
                                            </div>
                                        </div>
                                        
                                        <!-- Semantic Scholar Button -->
                                        <div>
                                            <button class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md py-tag-y mt-md w-full text-center" 
                                                    onclick="window.open('${paper.semantic_scholar_url}', '_blank')">
                                                Verify source on Semantic Scholar
                                            </button>
                                        </div>
                                        
                                        <!-- Individual H-Indices Section -->
                                        <div class="w-full author-h-index-section" data-paper-id="${paper.id}">
                                            <button class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y w-full text-center cursor-pointer border-none transition-opacity duration-200" 
                                                    onclick="toggleAuthorHIndices('${paper.id}')">
                                                Show Individual H-Indices <span class="text-xs">▼</span>
                                            </button>
                                            <div class="individual-authors-text hidden text-neutral-20 font-mono text-md px-xl py-tag-y bg-neutral-500 transition-all duration-300 ease-in-out">
                                                ${paper.author_h_indexes && paper.author_h_indexes.length > 0 ? 
                                                    paper.author_h_indexes.map(author => `
                                                        <div class="flex justify-between items-center py-xs">
                                                            ${author.profile_url && author.profile_url !== null && author.profile_url !== '' 
                                                                ? `<a href="${author.profile_url}" target="_blank" rel="noopener noreferrer" class="text-neutral-20 font-mono text-md underline hover:no-underline">${author.name}:</a>`
                                                                : `<span class="text-neutral-20 font-mono text-md">${author.name}:</span>`
                                                            }
                                                            <span class="text-neutral-20 font-mono text-md">${author.h_index !== null && author.h_index !== undefined ? author.h_index : 'N/A'}</span>
                                                        </div>
                                                    `).join('') 
                                                    : '<div class="text-center text-neutral-20">No individual author data available</div>'
                                                }
                                            </div>
                                        </div>
                                    `}
                                </div>
                            </div>
                        </div>
                    </div>
                </article>
            `;
        }

        // ============================================================================
        // QUICK FILTER FUNCTIONS
        // ============================================================================


        function applyQuickFilter(filterType) {
            // Build URL parameters based on filter type
            const url = new URL(window.location.href);
            
            // Clear all existing parameters
            url.search = '';
            
            // Set sort to recommendation best first for all filters
            url.searchParams.set('sort', 'recommend_best');
            
            switch(filterType) {
                case 'must-read':
                    // Recommendation: Only Must Read + Scoring: Only Has Scoring
                    url.searchParams.set('recommendation_must', 'true');
                    url.searchParams.set('recommendation_should', 'false');
                    url.searchParams.set('recommendation_skip', 'false');
                    url.searchParams.set('recommendation_ignore', 'false');
                    url.searchParams.set('scoring_has', 'true');
                    url.searchParams.set('scoring_no', 'false');
                    break;
                    
                case 'should-read':
                    // Recommendation: Only Should Read + Scoring: Only Has Scoring
                    url.searchParams.set('recommendation_must', 'false');
                    url.searchParams.set('recommendation_should', 'true');
                    url.searchParams.set('recommendation_skip', 'false');
                    url.searchParams.set('recommendation_ignore', 'false');
                    url.searchParams.set('scoring_has', 'true');
                    url.searchParams.set('scoring_no', 'false');
                    break;
                    
                case 'rlhf':
                    // Topic: Only RLHF + Relevance: Exclude Not Relevant
                    url.searchParams.set('topic_rlhf', 'true');
                    url.searchParams.set('topic_weak_supervision', 'false');
                    url.searchParams.set('topic_diffusion_reasoning', 'false');
                    url.searchParams.set('topic_distributed_training', 'false');
                    url.searchParams.set('topic_datasets', 'false');
                    url.searchParams.set('relevance_highly', 'true');
                    url.searchParams.set('relevance_moderately', 'true');
                    url.searchParams.set('relevance_tangentially', 'true');
                    url.searchParams.set('relevance_not', 'false');
                    break;
                    
                case 'weak-supervision':
                    url.searchParams.set('topic_rlhf', 'false');
                    url.searchParams.set('topic_weak_supervision', 'true');
                    url.searchParams.set('topic_diffusion_reasoning', 'false');
                    url.searchParams.set('topic_distributed_training', 'false');
                    url.searchParams.set('topic_datasets', 'false');
                    url.searchParams.set('relevance_highly', 'true');
                    url.searchParams.set('relevance_moderately', 'true');
                    url.searchParams.set('relevance_tangentially', 'true');
                    url.searchParams.set('relevance_not', 'false');
                    break;
                    
                case 'diffusion-reasoning':
                    url.searchParams.set('topic_rlhf', 'false');
                    url.searchParams.set('topic_weak_supervision', 'false');
                    url.searchParams.set('topic_diffusion_reasoning', 'true');
                    url.searchParams.set('topic_distributed_training', 'false');
                    url.searchParams.set('topic_datasets', 'false');
                    url.searchParams.set('relevance_highly', 'true');
                    url.searchParams.set('relevance_moderately', 'true');
                    url.searchParams.set('relevance_tangentially', 'true');
                    url.searchParams.set('relevance_not', 'false');
                    break;
                    
                case 'distributed-training':
                    url.searchParams.set('topic_rlhf', 'false');
                    url.searchParams.set('topic_weak_supervision', 'false');
                    url.searchParams.set('topic_diffusion_reasoning', 'false');
                    url.searchParams.set('topic_distributed_training', 'true');
                    url.searchParams.set('topic_datasets', 'false');
                    url.searchParams.set('relevance_highly', 'true');
                    url.searchParams.set('relevance_moderately', 'true');
                    url.searchParams.set('relevance_tangentially', 'true');
                    url.searchParams.set('relevance_not', 'false');
                    break;
                    
                case 'datasets':
                    url.searchParams.set('topic_rlhf', 'false');
                    url.searchParams.set('topic_weak_supervision', 'false');
                    url.searchParams.set('topic_diffusion_reasoning', 'false');
                    url.searchParams.set('topic_distributed_training', 'false');
                    url.searchParams.set('topic_datasets', 'true');
                    url.searchParams.set('relevance_highly', 'true');
                    url.searchParams.set('relevance_moderately', 'true');
                    url.searchParams.set('relevance_tangentially', 'true');
                    url.searchParams.set('relevance_not', 'false');
                    break;
                    
                case 'reset':
                    // Clear all parameters, which will reset everything to defaults
                    break;
                    
                default:
                    console.warn('Unknown quick filter type:', filterType);
                    return;
            }
            
            // Navigate to new URL, which will trigger existing URL parsing logic
            window.location.href = url.toString();
        }



        // ============================================================================
        // PAGE INITIALIZATION
        // ============================================================================

        function initializePage() {

            // Get sort parameter from URL, default to 'recommend_best'
            currentSort = getUrlParameter('sort') || 'recommend_best';
            
            // Load H-Index filters from URL
            updateHIndexFiltersFromURL();
            
            // Load Scoring filters from URL
            updateScoringFiltersFromURL();
            
            // Load Recommendation filters from URL
            updateRecommendationFiltersFromURL();
            
            // Load Novelty filters from URL
            updateNoveltyFiltersFromURL();
            
            // Load Impact filters from URL
            updateImpactFiltersFromURL();
            
            // Load Topic filters from URL
            updateTopicFiltersFromURL();
            
            // Load Relevance filters from URL
            loadRelevanceFiltersFromURL();
            
            // Update disabled state for advanced filters after loading scoring filters
            updateAdvancedFiltersDisabledState();
            
            // Update page title and headers based on embedded date
            updatePageTitles(PAGE_DATE);
            
            // Update sort dropdown UI
            updateSortDropdownUI();
            
            // Setup H-Index input validation
            setupHIndexValidation();
            
            // Sync H-Index UI with loaded filters
            syncHIndexUI();
            
            // Apply initial sorting and filtering
            applyFiltersAndSort();
            
            // Display first page
            displayCurrentPage();
            
        }

        // ============================================================================
        // ABSTRACT TRUNCATION LOGIC
        // ============================================================================
        
        let resizeTimer;

        function resetAbstractToOriginal(container) {
            const abstractText = container.querySelector('.abstract-text');
            const originalText = abstractText.getAttribute('data-original-text');
            
            if (originalText) {
                // Reset to clean original text
                abstractText.innerHTML = originalText;
                abstractText.setAttribute('data-expanded', 'false');
                // Clear any existing truncated text to force recalculation
                abstractText.removeAttribute('data-truncated-text');
            }
        }

        function calculateAverageCharWidth(fontStyle, fontSize, fontFamily) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            ctx.font = `${fontStyle} ${fontSize} ${fontFamily}`;
            
            const characterSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 ';
            const totalWidth = ctx.measureText(characterSet).width;
            
            return totalWidth / characterSet.length;
        }

        function getTextContentWidth(element) {
            const computedStyle = getComputedStyle(element);
            return element.clientWidth - 
                parseFloat(computedStyle.paddingLeft) - 
                parseFloat(computedStyle.paddingRight);
        }

        function calculateThreeLineCharLimit(element) {
            const computedStyle = getComputedStyle(element);
            const fontSize = computedStyle.fontSize;
            const fontFamily = computedStyle.fontFamily;
            const fontWeight = computedStyle.fontWeight;
            
            // Get average character width
            const avgCharWidth = calculateAverageCharWidth(fontWeight, fontSize, fontFamily);
            
            // Get content width
            const contentWidth = getTextContentWidth(element);
            
            // Calculate characters per line
            const charsPerLine = Math.floor(contentWidth / avgCharWidth);
            
            // Total characters for 3 lines
            const totalChars = charsPerLine * 3;
            
            // Reserve space for "... [Expand]"
            const expandButtonChars = 30;
            
            return Math.max(0, totalChars - expandButtonChars);
        }

        function toggleAbstract(paperId) {
            const containers = document.querySelectorAll(`.abstract-container[data-paper-id="${paperId}"]`);
            
            containers.forEach(container => {
                const abstractText = container.querySelector('.abstract-text');
                if (!abstractText) return; // Safety check
                
                const isExpanded = abstractText.getAttribute('data-expanded') === 'true';
                
                if (isExpanded) {
                    // Collapse - restore truncated text
                    const truncatedText = abstractText.getAttribute('data-truncated-text');
                    abstractText.innerHTML = truncatedText;
                    abstractText.setAttribute('data-expanded', 'false');
                } else {
                    // Expand - show full text
                    const originalText = abstractText.getAttribute('data-original-text');
                    abstractText.innerHTML = `${originalText} <button class="text-neutral-60 font-body font-bold text-md cursor-pointer bg-transparent border-none p-0 hover:opacity-70 transition-opacity duration-200" onclick="toggleAbstract('${paperId}')">[Collapse]</button>`;
                    abstractText.setAttribute('data-expanded', 'true');
                }
                
                // Re-render KaTeX after content change
                setTimeout(() => renderKatexInElement(abstractText), 50);
            });
        }

        // Function to setup abstract truncation using font metrics and binary search
        function setupAbstractTruncation() {
            document.querySelectorAll('.abstract-container').forEach(container => {
                const abstractText = container.querySelector('.abstract-text');
                const paperId = container.getAttribute('data-paper-id');
                
                // Get original text - only set it if not already stored to prevent corruption
                let originalText = abstractText.getAttribute('data-original-text');
                if (!originalText) {
                    // First time setup - get clean text content
                    originalText = abstractText.textContent;
                    abstractText.setAttribute('data-original-text', originalText);
                } else {
                    // Subsequent calls - reset to clean state first
                    resetAbstractToOriginal(container);
                }
                
                // Always reset to collapsed state
                abstractText.setAttribute('data-expanded', 'false');
                
                // Calculate the rough character limit for 3 lines as starting point
                const roughCharLimit = calculateThreeLineCharLimit(abstractText);
                
                // Check if text needs truncation
                if (originalText.length > roughCharLimit) {
                    // Create expand button template
                    const expandButton = '... <button class="text-neutral-60 font-body font-bold text-md cursor-pointer bg-transparent border-none p-0 hover:opacity-70 transition-opacity duration-200" onclick="toggleAbstract(\'' + paperId + '\')">[Expand]</button>';
                    
                    // Calculate 3-line height for comparison
                    const computedStyle = getComputedStyle(abstractText);
                    const lineHeight = parseFloat(computedStyle.lineHeight);
                    const maxHeight = lineHeight * 3;
                    
                    // Binary search for perfect truncation point
                    let left = 0;
                    let right = Math.min(originalText.length, roughCharLimit + 100); // Use rough estimate + buffer
                    let bestFit = '';
                    let bestLength = 0;
                    
                    // Create temporary element for height testing
                    const testElement = abstractText.cloneNode(true);
                    testElement.style.position = 'absolute';
                    testElement.style.visibility = 'hidden';
                    testElement.style.width = abstractText.offsetWidth + 'px';
                    testElement.style.height = 'auto';
                    testElement.style.maxHeight = 'none';
                    document.body.appendChild(testElement);
                    
                    while (left <= right) {
                        const mid = Math.floor((left + right) / 2);
                        const testText = originalText.substring(0, mid) + expandButton;
                        
                        testElement.innerHTML = testText;
                        
                        if (testElement.offsetHeight <= maxHeight) {
                            // Text fits, try longer
                            bestFit = testText;
                            bestLength = mid;
                            left = mid + 1;
                        } else {
                            // Text too long, trying shorter
                            right = mid - 1;
                        }
                    }
                    
                    // Clean up temporary element
                    document.body.removeChild(testElement);
                    
                    // Apply the best fit result
                    if (bestFit) {
                        abstractText.setAttribute('data-truncated-text', bestFit);
                        abstractText.innerHTML = bestFit;
                    } else {
                        // Fallback to rough estimate if binary search fails
                        const fallbackText = originalText.substring(0, Math.max(0, roughCharLimit - 50)) + expandButton;
                        abstractText.setAttribute('data-truncated-text', fallbackText);
                        abstractText.innerHTML = fallbackText;
                    }
                } else {
                    // Text fits without truncation
                    abstractText.innerHTML = originalText;
                }
            });
        }

        // Function to toggle recommendation justification
        function toggleRecommendationJustification(paperId) {
            const containers = document.querySelectorAll(`.recommendation-justification-section[data-paper-id="${paperId}"]`);
            
            containers.forEach(container => {
                const button = container.querySelector('button');
                const textDiv = container.querySelector('.justification-text');
                const isHidden = textDiv.classList.contains('hidden');
                
                if (isHidden) {
                    // Show justification
                    textDiv.classList.remove('hidden');
                    button.innerHTML = 'Hide Justification <span class="text-xs">▼</span>';
                    button.classList.remove('bg-neutral-500');
                    button.classList.add('bg-neutral-600');
                } else {
                    // Hide justification
                    textDiv.classList.add('hidden');
                    button.innerHTML = 'Show Justification <span class="text-xs">▲</span>';
                    button.classList.remove('bg-neutral-600');
                    button.classList.add('bg-neutral-500');
                }
            });
        }

        // Function to toggle novelty justification
        function toggleNoveltyJustification(paperId) {
            const containers = document.querySelectorAll(`.novelty-justification-section[data-paper-id="${paperId}"]`);
            
            containers.forEach(container => {
                const button = container.querySelector('button');
                const textDiv = container.querySelector('.justification-text');
                const isHidden = textDiv.classList.contains('hidden');
                
                if (isHidden) {
                    // Show justification
                    textDiv.classList.remove('hidden');
                    button.innerHTML = 'Hide Justification <span class="text-xs">▼</span>';
                    button.classList.remove('bg-neutral-500');
                    button.classList.add('bg-neutral-600');
                } else {
                    // Hide justification
                    textDiv.classList.add('hidden');
                    button.innerHTML = 'Show Justification <span class="text-xs">▲</span>';
                    button.classList.remove('bg-neutral-600');
                    button.classList.add('bg-neutral-500');
                }
            });
        }

        // Function to toggle impact justification
        function toggleImpactJustification(paperId) {
            const containers = document.querySelectorAll(`.impact-justification-section[data-paper-id="${paperId}"]`);
            
            containers.forEach(container => {
                const button = container.querySelector('button');
                const textDiv = container.querySelector('.justification-text');
                const isHidden = textDiv.classList.contains('hidden');
                
                if (isHidden) {
                    // Show justification
                    textDiv.classList.remove('hidden');
                    button.innerHTML = 'Hide Justification <span class="text-xs">▼</span>';
                    button.classList.remove('bg-neutral-500');
                    button.classList.add('bg-neutral-600');
                } else {
                    // Hide justification
                    textDiv.classList.add('hidden');
                    button.innerHTML = 'Show Justification <span class="text-xs">▲</span>';
                    button.classList.remove('bg-neutral-600');
                    button.classList.add('bg-neutral-500');
                }
            });
        }

        // Function to toggle relevance justification
        function toggleRelevanceJustification(paperId) {
            const containers = document.querySelectorAll(`.relevance-justification-section[data-paper-id="${paperId}"]`);
            
            containers.forEach(container => {
                const button = container.querySelector('button');
                const textDiv = container.querySelector('.justification-text');
                const isHidden = textDiv.classList.contains('hidden');
                
                if (isHidden) {
                    // Show justification
                    textDiv.classList.remove('hidden');
                    button.innerHTML = 'Hide Justification <span class="text-xs">▼</span>';
                    button.classList.remove('bg-neutral-500');
                    button.classList.add('bg-neutral-600');
                } else {
                    // Hide justification
                    textDiv.classList.add('hidden');
                    button.innerHTML = 'Show Justification <span class="text-xs">▲</span>';
                    button.classList.remove('bg-neutral-600');
                    button.classList.add('bg-neutral-500');
                }
            });
        }

        // Function to toggle author H-indices
        function toggleAuthorHIndices(paperId) {
            const containers = document.querySelectorAll(`.author-h-index-section[data-paper-id="${paperId}"]`);
            
            containers.forEach(container => {
                const button = container.querySelector('button');
                const textDiv = container.querySelector('.individual-authors-text');
                const isHidden = textDiv.classList.contains('hidden');
                
                if (isHidden) {
                    // Show individual H-indices
                    textDiv.classList.remove('hidden');
                    button.innerHTML = 'Hide Individual H-Indices <span class="text-xs">▲</span>';
                    button.classList.remove('bg-neutral-500');
                    button.classList.add('bg-neutral-600');
                } else {
                    // Hide individual H-indices
                    textDiv.classList.add('hidden');
                    button.innerHTML = 'Show Individual H-Indices <span class="text-xs">▼</span>';
                    button.classList.remove('bg-neutral-600');
                    button.classList.add('bg-neutral-500');
                }
            });
        }

        // Function to setup initial similarity progress bars (raw scores only)
        function setupInitialProgressBars() {
            currentPagePapers.forEach(paper => {
                setupProgressBarsForPaper(paper);
            });
        }

        // Function to toggle similarity scores between raw and normalized
        function toggleSimilarityScores(buttonElement) {
            // Find the parent container with data-paper-id
            const container = buttonElement.closest('[data-paper-id]');
            if (!container) return;
            
            const paperId = container.getAttribute('data-paper-id');
            const isNormalized = container.getAttribute('data-normalized') === 'true';
            
            // Find the paper data from current page papers
            const paper = currentPagePapers.find(p => p.id === paperId);
            if (!paper) return;
            
            // Toggle state
            container.setAttribute('data-normalized', (!isNormalized).toString());
            
            // Update button text
            buttonElement.textContent = isNormalized ? 'Show Normalized Scores ⇄' : 'Show Raw Scores ⇄';
            
            if (!isNormalized) {
                // Switch to normalized mode
                updateNormalizedScores(paperId);
                
                // Change all progress bars to normalized color
                const progressBars = container.querySelectorAll('.similarity-progress-bar');
                progressBars.forEach(bar => {
                    bar.classList.remove('bg-bar-raw');
                    bar.classList.add('bg-bar-normalized');
                });
            } else {
                // Switch to raw mode
                const isShowingHidden = container.getAttribute('data-show-hidden-topics') === 'true';
                const topicsToShow = isShowingHidden ? 
                    ['rlhf', 'weakSupervision', 'diffusionReasoning', 'distributedTraining', 'datasets'] :
                    getVisibleTopics();
                    
                const topicMapping = getTopicKeyMapping();
                
                topicsToShow.forEach(topic => {
                    const dataKey = topicMapping[topic];
                    const rawScore = paper[`${dataKey}_score`];
                    
                    // Update progress bar
                    const progressBar = container.querySelector(`.${dataKey.replace('_', '-')}-progress-bar`);
                    if (progressBar) {
                        progressBar.style.width = `${(rawScore * 100)}%`;
                        // Change to raw bar color
                        progressBar.classList.remove('bg-bar-normalized');
                        progressBar.classList.add('bg-bar-raw');
                    }
                    
                    // Update score text
                    const scoreElement = container.querySelector(`.${dataKey.replace('_', '-')}-similarity-score`);
                    if (scoreElement) {
                        scoreElement.textContent = rawScore.toFixed(3);
                    }
                });
            }
        }

        // Pagination functions
        function calculatePaginationWindow(currentPage, totalPages) {
            const windowSize = 5;
            const halfWindow = Math.floor(windowSize / 2);
            
            let start = Math.max(1, currentPage - halfWindow);
            let end = Math.min(totalPages, start + windowSize - 1);
            
            // Adjust start if we can't show a full window at the end
            if (end - start + 1 < windowSize) {
                start = Math.max(1, end - windowSize + 1);
            }
            
            return { start, end };
        }

        function updatePaginationUI() {
            const { start, end } = calculatePaginationWindow(currentPage, totalPages);
            
            // Update mobile pagination
            updatePaginationButtons('mobile', start, end);
            
            // Update desktop pagination
            updatePaginationButtons('desktop', start, end);
            
            // Update footer pagination
            updateFooterPaginationButtons('mobile', start, end);
            updateFooterPaginationButtons('desktop', start, end);
        }

        function updatePaginationButtons(layout, start, end) {
            const container = layout === 'mobile' 
                ? document.getElementById('mobile-pagination-numbers')
                : document.getElementById('desktop-pagination-numbers');
            
            if (!container) return;
            
            // Clear existing buttons
            container.innerHTML = '';
            
            // Create pagination buttons
            for (let i = start; i <= end; i++) {
                const isActive = i === currentPage;
                const buttonClass = isActive 
                    ? 'bg-neutral-900 text-neutral-10' 
                    : 'bg-neutral-300 text-neutral-70 hover:bg-neutral-400 cursor-pointer';
                
                const sizeClasses = layout === 'mobile' 
                    ? 'w-8 h-8' 
                    : 'clamp(1.5rem, 3vw, 1.875rem)';
                
                const button = document.createElement('div');
                button.className = `pagination-square ${buttonClass} flex items-center justify-center`;
                
                if (layout === 'desktop') {
                    button.style.width = sizeClasses;
                    button.style.height = sizeClasses;
                } else {
                    button.className += ` ${sizeClasses}`;
                }
                
                button.innerHTML = `<span class="font-heading font-bold text-${layout === 'mobile' ? 'sm' : 'md'}">${i}</span>`;
                
                if (!isActive) {
                    button.onclick = () => goToPage(i);
                    button.style.cursor = 'pointer';
                }
                
                container.appendChild(button);
            }
            
            // Update arrow button states
            updateArrowButtons(layout);
        }

        function updateFooterPaginationButtons(layout, start, end) {
            const container = layout === 'mobile' 
                ? document.getElementById('mobile-footer-pagination-numbers')
                : document.getElementById('desktop-footer-pagination-numbers');
            
            if (!container) return;
            
            // Clear existing buttons
            container.innerHTML = '';
            
            // Create pagination buttons
            for (let i = start; i <= end; i++) {
                const isActive = i === currentPage;
                const buttonClass = isActive 
                    ? 'bg-neutral-900 text-neutral-10' 
                    : 'bg-neutral-300 text-neutral-70 hover:bg-neutral-400 cursor-pointer';
                
                const sizeClasses = layout === 'mobile' 
                    ? 'w-8 h-8' 
                    : 'clamp(1.5rem, 3vw, 1.875rem)';
                
                const button = document.createElement('div');
                button.className = `pagination-square ${buttonClass} flex items-center justify-center`;
                
                if (layout === 'desktop') {
                    button.style.width = sizeClasses;
                    button.style.height = sizeClasses;
                } else {
                    button.className += ` ${sizeClasses}`;
                }
                
                button.innerHTML = `<span class="font-heading font-bold text-${layout === 'mobile' ? 'sm' : 'md'}">${i}</span>`;
                
                if (!isActive) {
                    button.onclick = () => goToPage(i);
                    button.style.cursor = 'pointer';
                }
                
                container.appendChild(button);
            }
            
            // Update footer arrow button states
            updateFooterArrowButtons(layout);
        }

        function updateArrowButtons(layout) {
            const prevBtn = document.getElementById(`${layout}-prev-btn`);
            const nextBtn = document.getElementById(`${layout}-next-btn`);
            
            // Update previous button
            if (prevBtn) {
                if (currentPage <= 1) {
                    // Show disabled state instead of hiding
                    prevBtn.classList.add('disabled');
                    prevBtn.onclick = null;
                } else {
                    // Show enabled state
                    prevBtn.classList.remove('disabled');
                    prevBtn.onclick = () => goToPage(currentPage - 1);
                }
            }
            
            // Update next button
            if (nextBtn) {
                if (currentPage >= totalPages) {
                    // Show disabled state instead of hiding
                    nextBtn.classList.add('disabled');
                    nextBtn.onclick = null;
                } else {
                    // Show enabled state
                    nextBtn.classList.remove('disabled');
                    nextBtn.onclick = () => goToPage(currentPage + 1);
                }
            }
        }

        function updateFooterArrowButtons(layout) {
            const prevBtn = document.getElementById(`${layout}-footer-prev-btn`);
            const nextBtn = document.getElementById(`${layout}-footer-next-btn`);
            
            // Update previous button
            if (prevBtn) {
                if (currentPage <= 1) {
                    // Show disabled state instead of hiding
                    prevBtn.classList.add('disabled');
                    prevBtn.onclick = null;
                } else {
                    // Show enabled state
                    prevBtn.classList.remove('disabled');
                    prevBtn.onclick = () => goToPage(currentPage - 1);
                }
            }
            
            // Update next button
            if (nextBtn) {
                if (currentPage >= totalPages) {
                    // Show disabled state instead of hiding
                    nextBtn.classList.add('disabled');
                    nextBtn.onclick = null;
                } else {
                    // Show enabled state
                    nextBtn.classList.remove('disabled');
                    nextBtn.onclick = () => goToPage(currentPage + 1);
                }
            }
        }

        function goToPage(page) {
            // Prevent navigation if page is out of bounds or is current page
            if (page === currentPage || page < 1 || page > totalPages) {
                return;
            }
            
            console.log(`Navigating to page ${page}`);
            currentPage = page;
            updatePaginationUI();
            displayCurrentPage();
            
            // Re-run truncation after new content is displayed
            setTimeout(() => {
                setupAbstractTruncation();
                setupInitialProgressBars();
            }, 50);
            
            // Scroll to top after loading new page
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // ============================================================================
        // SCROLL LOCK FUNCTIONS
        // ============================================================================
        
        function lockBodyScroll() {
            // Get the width of the scrollbar
            const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
            document.body.style.paddingRight = `${scrollbarWidth}px`;
            
            // Add the class to prevent scrolling
            document.body.classList.add('no-scroll');
        }

        function unlockBodyScroll() {
            // Remove the inline padding
            document.body.style.paddingRight = '';

            // Remove the class to re-enable scrolling
            document.body.classList.remove('no-scroll');
        }

        // ============================================================================
        // SIDEBAR FUNCTIONS
        // ============================================================================

        function toggleMobileMenu() {
            if (isMobileSidebarOpen) {
                closeMobileMenu();
            } else {
                openMobileMenu();
            }
        }

        function openMobileMenu() {
            const sidebar = document.getElementById('mobile-sidebar');
            const mainContainer = document.getElementById('mobile-main-container');
            
            // Move sidebar into view (full screen width)
            sidebar.style.transform = 'translateX(0)';
            
            // Lock body scrolling with padding compensation
            lockBodyScroll();
            
            isMobileSidebarOpen = true;
        }

        function closeMobileMenu() {
            const sidebar = document.getElementById('mobile-sidebar');
            const mainContainer = document.getElementById('mobile-main-container');
            
            // Move sidebar out of view
            sidebar.style.transform = 'translateX(-100%)';
            
            // Unlock body scrolling
            unlockBodyScroll();
            
            isMobileSidebarOpen = false;
        }

        function toggleDesktopMenu() {
            if (isDesktopSidebarOpen) {
                closeDesktopMenu();
            } else {
                openDesktopMenu();
            }
        }

        function openDesktopMenu() {
            const sidebar = document.getElementById('desktop-sidebar');
            const overlay = document.getElementById('desktop-sidebar-overlay');
            
            // Show sidebar
            sidebar.style.transform = 'translateX(0)';
            
            // Show overlay
            overlay.style.opacity = '1';
            overlay.style.pointerEvents = 'auto';
            
            // Lock body scrolling with padding compensation
            lockBodyScroll();
            
            isDesktopSidebarOpen = true;
        }

        function closeDesktopMenu() {
            const sidebar = document.getElementById('desktop-sidebar');
            const overlay = document.getElementById('desktop-sidebar-overlay');
            
            // Hide sidebar
            sidebar.style.transform = 'translateX(-100%)';
            
            // Hide overlay
            overlay.style.opacity = '0';
            overlay.style.pointerEvents = 'none';
            
            // Unlock body scrolling
            unlockBodyScroll();
            
            isDesktopSidebarOpen = false;
        }

        // Handle window resize to close mobile menu if switching to desktop
        window.addEventListener('resize', function() {
            if (window.innerWidth >= 768 && isMobileSidebarOpen) {
                closeMobileMenu();
            }
            if (window.innerWidth < 768 && isDesktopSidebarOpen) {
                closeDesktopMenu();
            }
        });

        // ============================================================================
        // CLICK OUTSIDE TO CLOSE DROPDOWNS
        // ============================================================================
        
        // Add click outside listener to close dropdowns
        document.addEventListener('click', function(event) {
            // List of all dropdown containers
            const dropdowns = [
                { dropdown: document.getElementById('mobile-sort-dropdown'), button: document.getElementById('mobile-sort-btn') },
                { dropdown: document.getElementById('desktop-sort-dropdown'), button: document.getElementById('desktop-sort-btn') },
                { dropdown: document.getElementById('mobile-hindex-dropdown'), button: document.getElementById('mobile-hindex-btn') },
                { dropdown: document.getElementById('desktop-hindex-dropdown'), button: document.getElementById('desktop-hindex-btn') },
                { dropdown: document.getElementById('mobile-scoring-dropdown'), button: document.getElementById('mobile-scoring-btn') },
                { dropdown: document.getElementById('desktop-scoring-dropdown'), button: document.getElementById('desktop-scoring-btn') },
                { dropdown: document.getElementById('mobile-recommendation-dropdown'), button: document.getElementById('mobile-recommendation-btn') },
                { dropdown: document.getElementById('desktop-recommendation-dropdown'), button: document.getElementById('desktop-recommendation-btn') },
                { dropdown: document.getElementById('mobile-novelty-dropdown'), button: document.getElementById('mobile-novelty-btn') },
                { dropdown: document.getElementById('desktop-novelty-dropdown'), button: document.getElementById('desktop-novelty-btn') },
                { dropdown: document.getElementById('mobile-impact-dropdown'), button: document.getElementById('mobile-impact-btn') },
                { dropdown: document.getElementById('desktop-impact-dropdown'), button: document.getElementById('desktop-impact-btn') },
                { dropdown: document.getElementById('mobile-relevance-dropdown'), button: document.getElementById('mobile-relevance-btn') },
                { dropdown: document.getElementById('desktop-relevance-dropdown'), button: document.getElementById('desktop-relevance-btn') },
                { dropdown: document.getElementById('mobile-topic-dropdown'), button: document.getElementById('mobile-topic-btn') },
                { dropdown: document.getElementById('desktop-topic-dropdown'), button: document.getElementById('desktop-topic-btn') }
            ];
            
            dropdowns.forEach(({ dropdown, button }) => {
                if (!dropdown || !button) return;
                
                // Check if dropdown is open and click is outside
                if (!dropdown.classList.contains('hidden')) {
                    const dropdownContainer = dropdown.parentElement; // The relative container
                    
                    // Check if click is outside the dropdown container
                    if (!dropdownContainer.contains(event.target)) {
                        dropdown.classList.add('hidden');
                        button.classList.remove('bg-neutral-600');
                        button.classList.add('bg-neutral-500');
                        
                        // Reset pending filters for specific dropdown types
                        if (dropdown.id.includes('hindex')) {
                            resetPendingHIndexFilters();
                        } else if (dropdown.id.includes('novelty')) {
                            resetPendingNoveltyFilters();
                        } else if (dropdown.id.includes('impact')) {
                            resetPendingImpactFilters();
                        } else if (dropdown.id.includes('relevance')) {
                            resetPendingRelevanceFilters();
                        } else if (dropdown.id.includes('topic')) {
                            resetPendingTopicFilters();
                        } else if (dropdown.id.includes('recommendation')) {
                            resetPendingRecommendationFilters();
                        } else if (dropdown.id.includes('scoring')) {
                            resetPendingScoringFilters();
                        }
                    }
                }
            });
        });

        // Initialize page on load
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Papers Dashboard loaded successfully');
            initializePage();
        });

        // Setup abstract truncation when everything is fully loaded
        window.addEventListener('load', function() {
            setupAbstractTruncation();
            setupInitialProgressBars();
        });

        // Setup debounced resize handler for truncation
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                setupAbstractTruncation();
            }, 250); // Delay to wait for resize to settle
        });
    </script>

    <!-- KaTeX JavaScript -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js" integrity="sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
    
    <!-- KaTeX Auto-render Configuration -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            // Configure KaTeX auto-render after page content is loaded
            setTimeout(function() {
                renderMathInElement(document.body, {
                    // KaTeX rendering options
                    delimiters: [
                        {left: '$$', right: '$$', display: true},       // Block math
                        {left: '$', right: '$', display: false},        // Inline math
                        {left: '\\(', right: '\\)', display: false},    // Inline math alternative
                        {left: '\\[', right: '\\]', display: true},     // Block math alternative
                        {left: '\\begin{equation}', right: '\\end{equation}', display: true},
                        {left: '\\begin{align}', right: '\\end{align}', display: true},
                        {left: '\\begin{alignat}', right: '\\end{alignat}', display: true},
                        {left: '\\begin{gather}', right: '\\end{gather}', display: true},
                        {left: '\\begin{CD}', right: '\\end{CD}', display: true},
                    ],
                    // Throw errors on unknown commands/symbols
                    throwOnError: false,
                    // Allow HTML in math expressions
                    trust: true,
                    // Ignore certain classes/elements
                    ignoredClasses: [
                        "nokatex", 
                        "katex-ignore"
                    ],
                    // Skip script and style tags
                    ignoredTags: [
                        "script", 
                        "noscript", 
                        "style", 
                        "textarea", 
                        "pre", 
                        "code"
                    ]
                });
            }, 500); // Delay to ensure all content is loaded
        });
    </script>
</body>
</html>
