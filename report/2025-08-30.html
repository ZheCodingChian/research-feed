<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Research Feed -- 30 August 2025</title>
    
    <!-- Favicon and Apple Touch Icons -->
    <link rel="icon" type="image/png" href="/favicon.png">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <link rel="apple-touch-icon-precomposed" href="/apple-touch-icon-precomposed.png">
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;700&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- KaTeX CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous">
    
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Custom Tailwind Configuration -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        'heading': ['Space Grotesk', 'Inter', 'system-ui', 'sans-serif'],
                        'body': ['Space Mono', 'Fira Code', 'Consolas', 'monospace'],
                    },
                    
                    fontSize: {
                            // 4px increments with responsive scaling
                            'xs': 'clamp(0.5rem, 1vw, 0.625rem)',     // 8-10px
                            'sm': 'clamp(0.625rem, 1.2vw, 0.75rem)',  // 10-12px
                            'md': 'clamp(0.75rem, 1.4vw, 0.875rem)',  // 12-14px
                            'lg': 'clamp(0.875rem, 1.6vw, 1rem)',     // 14-16px
                            'xl': 'clamp(1rem, 1.8vw, 1.125rem)',     // 16-18px
                            '2xl': 'clamp(1.125rem, 2vw, 1.25rem)',   // 18-20px
                            '3xl': 'clamp(1.25rem, 2.2vw, 1.375rem)', // 20-22px
                            '4xl': 'clamp(1.375rem, 2.4vw, 1.5rem)',  // 22-24px
                            '5xl': 'clamp(1.5rem, 2.6vw, 1.625rem)',  // 24-26px
                            '6xl': 'clamp(1.625rem, 2.8vw, 1.75rem)', // 26-28px
                            '7xl': 'clamp(1.75rem, 3vw, 1.875rem)',   // 28-30px
                            '8xl': 'clamp(1.875rem, 3.2vw, 2rem)',    // 30-32px
                            '9xl': 'clamp(2rem, 3.4vw, 2.125rem)',    // 32-34px
                        },

                    colors: {
                        neutral: {
                            10: '#f5f2e7',
                            20: '#e5e5e5',
                            40: '#a3a3a3',
                            60: '#525252',
                            70: '#404040',
                            90: '#171717',
                            100: '#f5f2e7',
                            200: '#dad7cd',
                            300: '#bebcb3',
                            400: '#a2a199',
                            500: '#86857f',
                            600: '#6b6a65',
                            700: '#4f4e4b',
                            900: '#171717',
                        },
                        // Status colors with 70% opacity
                        status: {
                            green: 'rgba(22, 104, 52, 0.7)',     // #166834 with 70% opacity
                            blue: 'rgba(40, 100, 156, 0.7)',     // #28649C with 70% opacity
                            orange: 'rgba(234, 147, 0, 0.7)',    // #EA9300 with 70% opacity
                            red: 'rgba(129, 12, 12, 0.7)',       // #810C0C with 70% opacity
                        },
                        bar: {
                            raw: 'rgba(107, 106, 101, 0.7)',       // #6B6A65 with 70% opacity
                            normalized: 'rgba(107, 106, 101, 0.7)' // #6B6A65 with 70% opacity
                        }
                    },
                    
                    spacing: {
                        '2xs': 'clamp(0.125rem, 0.5vw, 0.25rem)', // 2-4px
                        'xs': 'clamp(0.25rem, 1vw, 0.5rem)',    // 4-8px
                        'sm': 'clamp(0.5rem, 1.5vw, 0.75rem)',  // 8-12px
                        'md': 'clamp(0.75rem, 2vw, 1rem)',      // 12-16px
                        'lg': 'clamp(1rem, 2.5vw, 1.5rem)',     // 16-24px
                        'xl': 'clamp(1.5rem, 3vw, 2rem)',       // 24-32px
                        '2xl': 'clamp(2rem, 4vw, 3rem)',        // 32-48px
                        '3xl': 'clamp(3rem, 6vw, 4rem)',        // 48-64px
                        '4xl': 'clamp(4rem, 8vw, 5rem)',        // 64-80px
                        '5xl': 'clamp(5rem, 10vw, 6rem)',       // 80-96px
                        '6xl': 'clamp(6rem, 12vw, 7rem)',       // 96-112px
                        
                        // Mobile-specific spacing
                        'mobile-header': '5px',                  // 5px for mobile header padding
                        
                        // Card-specific spacing
                        'card-gap': '20px',                      // 20px gap for card info grid
                        
                        // Tag-specific spacing
                        'tag-x': '8px',                          // 8px horizontal padding for tags
                        'tag-y': '4px',                          // 4px vertical padding for tags
                    },
                    
                    screens: {
                        'mobile': '480px',
                        'tablet': '768px',
                        'desktop': '1024px',
                        'wide': '1440px',
                    },
                }
            }
        }
    </script>
    
    <!-- Custom CSS for additional styles -->
    <style>
        /* Focus states */
        .nav-button:focus-visible {
            outline: 2px solid #86857f;
            outline-offset: 2px;
        }
        
        .pagination-square:focus-visible {
            outline: 2px solid #86857f;
            outline-offset: 2px;
        }
        
        .pagination-arrow:focus-visible {
            outline: 2px solid #86857f;
            outline-offset: 2px;
        }
        
        .pagination-arrow {
            transition: background-color 0.2s ease, opacity 0.2s ease;
        }
        
        .pagination-arrow.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .pagination-arrow.disabled:hover {
            background-color: transparent;
        }
        
        /* Fix for multiline text padding in author and category spans */
        .metadata-tag {
            box-decoration-break: clone;
            -webkit-box-decoration-break: clone;
        }
        
        /* Sidebar styling */
        #mobile-sidebar {
            backdrop-filter: blur(4px);
            /* Move scrollbar to left side */
            direction: rtl;
        }
        
        #mobile-sidebar > div {
            /* Reset text direction inside sidebar */
            direction: ltr;
        }
        
        #desktop-sidebar {
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            /* Move scrollbar to left side */
            direction: rtl;
        }
        
        #desktop-sidebar > div {
            /* Reset text direction inside sidebar */
            direction: ltr;
        }
        
        /* Mobile main container transition */
        #mobile-main-container {
            transition: transform 300ms ease-in-out;
        }
        
        /* Prevent scrolling when any sidebar is open */
        body.no-scroll {
            overflow: hidden;
        }
        
        /* Dropdown positioning */
        .dropdown-up {
            bottom: 100% !important;
            top: auto !important;
        }
        
        .dropdown-down {
            top: 100% !important;
            bottom: auto !important;
        }
        
        /* Mobile active states */
        @media (hover: none) {
            /* Remove button animation */
        }
        
        /* Font fallbacks */
        .font-mono {
            font-family: 'Space Mono', 'Fira Code', 'Consolas', monospace;
        }
        
        /* Paper title link styling */
        .paper-title-link {
            color: inherit;
            text-decoration: none;
            transition: text-decoration 0.2s ease;
        }
        
        .paper-title-link:hover {
            text-decoration: underline;
        }
        
        /* Abstract text styling */
        .abstract-text {
            transition: all 0.3s ease-in-out;
        }

        /* KaTeX styling customization */
        .katex {
            font-size: 1em !important;
            line-height: inherit !important;
        }
        
        /* Inline math styling */
        .katex-display {
            margin: 0.5em 0 !important;
            text-align: left !important;
        }
        
        /* Make KaTeX blend with our color scheme */
        .katex .base {
            color: inherit;
        }
        
        /* Ensure KaTeX math doesn't break responsive design */
        .katex-display > .katex {
            max-width: 100%;
            overflow-x: auto;
            overflow-y: hidden;
        }
        
        /* Prevent double tap to zoom on mobile - Global */
        * {
            touch-action: manipulation;
        }
        
        /* Prevent double tap to zoom on mobile - Specific elements (keeping for compatibility) */
        .button, .interactive-element {
            touch-action: manipulation;
        }
        
        /* Research Feed button hover effect */
        .research-feed-button:hover {
            background-color: #4f4e4b !important; /* bg-neutral-700 */
            color: #f5f2e7 !important; /* text-neutral-10 */
        }
        
        /* Custom checkbox styling */
        .custom-checkbox {
            position: relative;
            display: inline-flex;
            align-items: center;
        }
        
        .custom-checkbox input[type="checkbox"] {
            opacity: 0;
            position: absolute;
            width: 0;
            height: 0;
        }
        
        .custom-checkbox label {
            display: inline-block;
            width: 20px;
            height: 20px;
            background-color: #86857f; /* bg-neutral-500 */
            border: 2px solid #f5f2e7; /* border-neutral-100 */
            border-radius: 4px; /* rounded corners */
            cursor: pointer;
            transition: background-color 0.2s ease, border-color 0.2s ease;
            flex-shrink: 0;
        }
        
        .custom-checkbox input[type="checkbox"]:checked + label {
            background-color: #f5f2e7; /* bg-neutral-100 */
            border-color: #f5f2e7;
        }
        
        .custom-checkbox input[type="checkbox"]:checked + label::after {
            content: '';
            position: absolute;
            left: 6px;
            top: 2px;
            width: 6px;
            height: 10px;
            border: solid #86857f;
            border-width: 0 2px 2px 0;
            transform: rotate(45deg);
        }
        
        /* H-Index range section styling */
        .hindex-range-section {
            transition: opacity 0.2s ease;
        }
        
        .hindex-range-section.disabled {
            opacity: 0.5;
        }
        
        .hindex-range-section.disabled input {
            cursor: not-allowed !important;
        }
        
        .hindex-range-section.disabled input:hover {
            background-color: #6b6a65 !important; /* Keep original bg when disabled */
        }
        
        /* Override any Tailwind hover effects on disabled inputs */
        .hindex-range-section.disabled input.bg-neutral-600:hover {
            background-color: #6b6a65 !important;
        }
        
        /* Advanced filter dropdowns disabled state */
        .opacity-50 {
            opacity: 0.5 !important;
        }
        
        .cursor-not-allowed {
            cursor: not-allowed !important;
        }
    </style>
</head>

<body class="bg-neutral-100 min-h-screen">
    <!-- Mobile Layout (visible < 768px) -->
    <div class="flex flex-col tablet:hidden" id="mobile-main-container">
        <!-- Mobile Header -->
        <header class="bg-neutral-100 w-full flex items-center px-xs pt-xl pb-md relative">
            <!-- Menu Button - Positioned absolutely within header -->
            <button id="mobile-menu-btn" class="absolute top-1/4 left-xs transform -translate-y-1/2 z-10 nav-button w-12 h-12 bg-transparent flex items-center justify-center button" aria-label="Open Menu" onclick="toggleMobileMenu()">
                <svg width="24" height="18" viewBox="0 0 24 18" xmlns="http://www.w3.org/2000/svg">
                    <rect x="0" y="0" width="24" height="5" fill="#4F4E4B"/>
                    <rect x="0" y="6.5" width="24" height="5" fill="#4F4E4B"/>
                    <rect x="0" y="13" width="24" height="5" fill="#4F4E4B"/>
                </svg>
            </button>
            
            <!-- Center: Page info (full width since menu button is positioned absolutely) -->
            <div class="w-full flex flex-col items-center justify-center text-center">
                <h1 class="text-neutral-70 font-heading font-bold text-lg mb-md" id="page-title-mobile">
                    Papers Published on 30 August 2025
                </h1>
                
                <!-- Mobile Pagination -->
                <div class="flex items-center gap-sm mb-md">
                    <!-- Previous Arrow -->
                    <button id="mobile-prev-btn" class="pagination-arrow w-8 h-8 bg-transparent text-neutral-70 flex items-center justify-center hover:bg-neutral-300 cursor-pointer" onclick="goToPage(currentPage - 1)">
                        <span class="font-heading font-bold text-sm">‹</span>
                    </button>
                    
                    <!-- Page Numbers Container -->
                    <div class="flex gap-sm" id="mobile-pagination-numbers">
                        <!-- Page numbers will be populated by JavaScript -->
                    </div>
                    
                    <!-- Next Arrow -->
                    <button id="mobile-next-btn" class="pagination-arrow w-8 h-8 bg-transparent text-neutral-70 flex items-center justify-center hover:bg-neutral-300 cursor-pointer" onclick="goToPage(currentPage + 1)">
                        <span class="font-heading font-bold text-sm">›</span>
                    </button>
                </div>
                
                <!-- Mobile Paper Count -->
                <p id="mobile-main-paper-count" class="text-neutral-60 font-heading font-bold text-lg">
                    Showing 0 / 0 papers
                </p>
            </div>
        </header>
        
        <!-- Mobile Content Area -->
        <main class="bg-neutral-100 min-h-screen">
            <div class="max-w-[500px] mx-auto">
                <!-- Mobile Papers Grid -->
                <div class="flex flex-col gap-3xl" id="mobile-papers">
                    <!-- Paper cards will be populated by JavaScript -->
                </div>
            </div>
        </main>
        
        <!-- Mobile Footer -->
        <footer class="py-xl px-lg bg-neutral-200">
            <div class="flex flex-col items-center justify-center text-center">
                <!-- Mobile Footer Pagination -->
                <div class="flex items-center gap-sm">
                    <!-- Previous Arrow -->
                    <button id="mobile-footer-prev-btn" class="pagination-arrow w-8 h-8 bg-transparent text-neutral-70 flex items-center justify-center hover:bg-neutral-300 cursor-pointer" onclick="goToPage(currentPage - 1)">
                        <span class="font-heading font-bold text-sm">‹</span>
                    </button>
                    
                    <!-- Page Numbers Container -->
                    <div class="flex gap-sm" id="mobile-footer-pagination-numbers">
                        <!-- Page numbers will be populated by JavaScript -->
                    </div>
                    
                    <!-- Next Arrow -->
                    <button id="mobile-footer-next-btn" class="pagination-arrow w-8 h-8 bg-transparent text-neutral-70 flex items-center justify-center hover:bg-neutral-300 cursor-pointer" onclick="goToPage(currentPage + 1)">
                        <span class="font-heading font-bold text-sm">›</span>
                    </button>
                </div>
            </div>
        </footer>
    </div>
    
    <!-- Mobile Sidebar -->
    <div id="mobile-sidebar" class="fixed inset-y-0 left-0 z-50 tablet:hidden bg-neutral-100 transition-transform duration-300 ease-in-out overflow-y-auto" style="width: 100vw; transform: translateX(-100%);">
        <div class="w-full h-full flex flex-col">
            <!-- Mobile Sidebar Header -->
            <div class="flex items-center justify-between pt-lg pr-lg pb-sm pl-lg">
                <!-- Left: Research Feed Home Button -->
                <div>
                    <a href="index.html" class="research-feed-button text-center px-tag-x py-sm bg-neutral-600 transition-colors duration-200">
                        <span class="text-neutral-10 font-heading font-bold text-2xl">Research Feed</span>
                    </a>
                </div>
                
                <!-- Right: Menu Button -->
                <button id="mobile-close-btn" class="nav-button w-12 h-12 bg-transparent flex items-center justify-center button" aria-label="Close Menu" onclick="closeMobileMenu()">
                    <svg width="24" height="18" viewBox="0 0 24 18" xmlns="http://www.w3.org/2000/svg">
                        <rect x="0" y="0" width="24" height="5" fill="#4F4E4B"/>
                        <rect x="0" y="6.5" width="24" height="5" fill="#4F4E4B"/>
                        <rect x="0" y="13" width="24" height="5" fill="#4F4E4B"/>
                    </svg>
                </button>
            </div>
            
            <!-- Mobile Sidebar Content -->
            <div class="flex-1 pt-sm px-lg pb-6xl">
                <div class="flex flex-col gap-lg gap-lg">
                    <!-- Section 1: Paper Count -->
                    <div class="bg-transparent text-left">
                        <span class="text-neutral-70 font-heading font-bold text-2xl" id="mobile-paper-count">
                            Showing: 0/0 Papers
                        </span>
                    </div>
                    
                    <!-- Section 2: Quick Filters -->
                    <div class="flex flex-col gap-sm">
                        <h3 class="text-neutral-60 font-heading font-bold text-2xl text-left bg-transparent">Quick Filters</h3>
                        <button id="mobile-quick-must-read" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('must-read')">Must Read</button>
                        <button id="mobile-quick-should-read" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('should-read')">Should Read</button>
                        <button id="mobile-quick-rlhf" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('rlhf')">RLHF</button>
                        <button id="mobile-quick-weak-supervision" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('weak-supervision')">Weak Supervision</button>
                        <button id="mobile-quick-diffusion-reasoning" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('diffusion-reasoning')">Diffusion Reasoning</button>
                        <button id="mobile-quick-distributed-training" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('distributed-training')">Distributed Training</button>
                        <button id="mobile-quick-datasets" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('datasets')">Datasets</button>
                        <button id="mobile-quick-reset" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('reset')">Reset To Default</button>
                    </div>
                    
                    <!-- Section 3: Advanced Filters -->
                    <div class="flex flex-col gap-sm">
                        <h3 class="text-neutral-60 font-heading font-bold text-2xl text-left bg-transparent">Advanced Filters</h3>
                        <!-- Scoring Filter Dropdown -->
                        <div class="relative">
                            <button id="mobile-scoring-btn" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleMobileScoringDropdown()">
                                <span class="font-bold">Scoring:</span> <span class="font-normal">All Selected</span> <span class="text-base">▼</span>
                            </button>
                            <div id="mobile-scoring-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-md">
                                    <!-- Section 1: Has Scoring and Summary Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-scoring-has" checked>
                                            <label for="mobile-scoring-has"></label>
                                        </div>
                                        <label for="mobile-scoring-has" class="text-neutral-10 text-xl font-heading cursor-pointer">Completed</label>
                                    </div>
                                    
                                    <!-- Section 2: Does not have Scoring and Summary Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-scoring-no" checked>
                                            <label for="mobile-scoring-no"></label>
                                        </div>
                                        <label for="mobile-scoring-no" class="text-neutral-10 text-xl font-heading cursor-pointer">Not relevant enough</label>
                                    </div>
                                    
                                    <!-- Section 3: Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyScoringFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        <!-- Recommendation Filter Dropdown -->
                        <div class="relative">
                            <button id="mobile-recommendation-btn" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleMobileRecommendationDropdown()">
                                <span class="font-bold">Recommendation:</span> <span class="font-normal">All Selected</span> <span class="text-base">▼</span>
                            </button>
                            <div id="mobile-recommendation-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-md">
                                    <!-- Must Read Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-recommendation-must" checked>
                                            <label for="mobile-recommendation-must"></label>
                                        </div>
                                        <label for="mobile-recommendation-must" class="text-neutral-10 text-xl font-heading cursor-pointer">Must Read</label>
                                    </div>
                                    
                                    <!-- Should Read Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-recommendation-should" checked>
                                            <label for="mobile-recommendation-should"></label>
                                        </div>
                                        <label for="mobile-recommendation-should" class="text-neutral-10 text-xl font-heading cursor-pointer">Should Read</label>
                                    </div>
                                    
                                    <!-- Can Skip Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-recommendation-skip" checked>
                                            <label for="mobile-recommendation-skip"></label>
                                        </div>
                                        <label for="mobile-recommendation-skip" class="text-neutral-10 text-xl font-heading cursor-pointer">Can Skip</label>
                                    </div>
                                    
                                    <!-- Ignore Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-recommendation-ignore" checked>
                                            <label for="mobile-recommendation-ignore"></label>
                                        </div>
                                        <label for="mobile-recommendation-ignore" class="text-neutral-10 text-xl font-heading cursor-pointer">Ignore</label>
                                    </div>
                                    
                                    <!-- Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyRecommendationFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        <!-- Novelty Filter Dropdown -->
                        <div class="relative">
                            <button id="mobile-novelty-btn" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleMobileNoveltyDropdown()">
                                <span class="font-bold">Novelty:</span> <span class="font-normal">All Selected</span> <span class="text-base">▼</span>
                            </button>
                            <div id="mobile-novelty-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-md">
                                    <!-- High Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-novelty-high" checked>
                                            <label for="mobile-novelty-high"></label>
                                        </div>
                                        <label for="mobile-novelty-high" class="text-neutral-10 text-xl font-heading cursor-pointer">High</label>
                                    </div>
                                    
                                    <!-- Moderate Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-novelty-moderate" checked>
                                            <label for="mobile-novelty-moderate"></label>
                                        </div>
                                        <label for="mobile-novelty-moderate" class="text-neutral-10 text-xl font-heading cursor-pointer">Moderate</label>
                                    </div>
                                    
                                    <!-- Low Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-novelty-low" checked>
                                            <label for="mobile-novelty-low"></label>
                                        </div>
                                        <label for="mobile-novelty-low" class="text-neutral-10 text-xl font-heading cursor-pointer">Low</label>
                                    </div>
                                    
                                    <!-- None Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-novelty-none" checked>
                                            <label for="mobile-novelty-none"></label>
                                        </div>
                                        <label for="mobile-novelty-none" class="text-neutral-10 text-xl font-heading cursor-pointer">None</label>
                                    </div>
                                    
                                    <!-- Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyNoveltyFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        <!-- Potential Impact Filter Dropdown -->
                        <div class="relative">
                            <button id="mobile-impact-btn" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleMobileImpactDropdown()">
                                <span class="font-bold">Potential Impact:</span> <span class="font-normal">All Selected</span> <span class="text-base">▼</span>
                            </button>
                            <div id="mobile-impact-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-md">
                                    <!-- High Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-impact-high" checked>
                                            <label for="mobile-impact-high"></label>
                                        </div>
                                        <label for="mobile-impact-high" class="text-neutral-10 text-xl font-heading cursor-pointer">High</label>
                                    </div>
                                    
                                    <!-- Moderate Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-impact-moderate" checked>
                                            <label for="mobile-impact-moderate"></label>
                                        </div>
                                        <label for="mobile-impact-moderate" class="text-neutral-10 text-xl font-heading cursor-pointer">Moderate</label>
                                    </div>
                                    
                                    <!-- Low Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-impact-low" checked>
                                            <label for="mobile-impact-low"></label>
                                        </div>
                                        <label for="mobile-impact-low" class="text-neutral-10 text-lg font-heading cursor-pointer">Low</label>
                                    </div>
                                    
                                    <!-- Negligible Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-impact-negligible" checked>
                                            <label for="mobile-impact-negligible"></label>
                                        </div>
                                        <label for="mobile-impact-negligible" class="text-neutral-10 text-xl font-heading cursor-pointer">Negligible</label>
                                    </div>
                                    
                                    <!-- Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyImpactFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        <!-- Relevance Filter Dropdown -->
                        <div class="relative">
                            <button id="mobile-relevance-btn" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleMobileRelevanceDropdown()">
                                <span class="font-bold">Relevance:</span> <span class="font-normal">All Selected</span> <span class="text-base">▼</span>
                            </button>
                            <div id="mobile-relevance-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-md">
                                    <!-- Highly Relevant Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-relevance-highly" checked>
                                            <label for="mobile-relevance-highly"></label>
                                        </div>
                                        <label for="mobile-relevance-highly" class="text-neutral-10 text-xl font-heading cursor-pointer">Highly Relevant</label>
                                    </div>
                                    
                                    <!-- Moderately Relevant Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-relevance-moderately" checked>
                                            <label for="mobile-relevance-moderately"></label>
                                        </div>
                                        <label for="mobile-relevance-moderately" class="text-neutral-10 text-xl font-heading cursor-pointer">Moderately Relevant</label>
                                    </div>
                                    
                                    <!-- Tangentially Relevant Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-relevance-tangentially" checked>
                                            <label for="mobile-relevance-tangentially"></label>
                                        </div>
                                        <label for="mobile-relevance-tangentially" class="text-neutral-10 text-xl font-heading cursor-pointer">Tangentially Relevant</label>
                                    </div>
                                    
                                    <!-- Not Relevant Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-relevance-not" checked>
                                            <label for="mobile-relevance-not"></label>
                                        </div>
                                        <label for="mobile-relevance-not" class="text-neutral-10 text-xl font-heading cursor-pointer">Not Relevant</label>
                                    </div>
                                    
                                    <!-- Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyRelevanceFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Topic Filter Dropdown -->
                        <div class="relative">
                            <button id="mobile-topic-btn" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleMobileTopicDropdown()">
                                <span class="font-bold">Topics:</span> <span class="font-normal">All Selected</span> <span class="text-base">▼</span>
                            </button>
                            <div id="mobile-topic-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-md">
                                    <!-- RLHF Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-topic-rlhf" checked>
                                            <label for="mobile-topic-rlhf"></label>
                                        </div>
                                        <label for="mobile-topic-rlhf" class="text-neutral-10 text-xl font-heading cursor-pointer">RLHF</label>
                                    </div>
                                    
                                    <!-- Weak Supervision Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-topic-weak-supervision" checked>
                                            <label for="mobile-topic-weak-supervision"></label>
                                        </div>
                                        <label for="mobile-topic-weak-supervision" class="text-neutral-10 text-xl font-heading cursor-pointer">Weak Supervision</label>
                                    </div>
                                    
                                    <!-- Diffusion Reasoning Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-topic-diffusion-reasoning" checked>
                                            <label for="mobile-topic-diffusion-reasoning"></label>
                                        </div>
                                        <label for="mobile-topic-diffusion-reasoning" class="text-neutral-10 text-xl font-heading cursor-pointer">Diffusion Reasoning</label>
                                    </div>
                                    
                                    <!-- Distributed Training Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-topic-distributed-training" checked>
                                            <label for="mobile-topic-distributed-training"></label>
                                        </div>
                                        <label for="mobile-topic-distributed-training" class="text-neutral-10 text-xl font-heading cursor-pointer">Distributed Training</label>
                                    </div>
                                    
                                    <!-- Datasets Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-topic-datasets" checked>
                                            <label for="mobile-topic-datasets"></label>
                                        </div>
                                        <label for="mobile-topic-datasets" class="text-neutral-10 text-xl font-heading cursor-pointer">Datasets</label>
                                    </div>
                                    
                                    <!-- Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyTopicFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- H-Index Filter Dropdown -->
                        <div class="relative">
                            <button id="mobile-hindex-btn" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleMobileHIndexDropdown()">
                                H-index: All Selected <span class="text-lg">▼</span>
                            </button>
                            <div id="mobile-hindex-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-lg">
                                    <!-- Section 1: H-Index Found Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-hindex-found" checked onchange="toggleHIndexRanges()">
                                            <label for="mobile-hindex-found"></label>
                                        </div>
                                        <label for="mobile-hindex-found" class="text-neutral-10 text-xl font-heading cursor-pointer">H-Index Found</label>
                                    </div>
                                    
                                    <!-- Section 2: H-Index Not Found Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-hindex-not-found" checked>
                                            <label for="mobile-hindex-not-found"></label>
                                        </div>
                                        <label for="mobile-hindex-not-found" class="text-neutral-10 text-xl font-heading cursor-pointer">H-Index Not Found</label>
                                    </div>
                                    
                                    <!-- Section 3: Highest H-Index Range -->
                                    <div id="mobile-highest-range" class="hindex-range-section">
                                        <div class="text-neutral-10 text-lg font-heading mb-2xs">Highest H-Index Range:</div>
                                        <div class="flex items-center gap-xs">
                                            <span class="text-neutral-10 text-lg font-heading">Min:</span>
                                            <input type="number" id="mobile-highest-min" min="0" max="1000" value="0" class="bg-neutral-600 text-neutral-10 px-2xs py-2xs text-lg font-heading w-16 rounded">
                                            <span class="text-neutral-10 text-lg font-heading">-</span>
                                            <span class="text-neutral-10 text-lg font-heading">Max:</span>
                                            <input type="number" id="mobile-highest-max" min="0" max="1000" value="1000" class="bg-neutral-600 text-neutral-10 px-2xs py-2xs text-lg font-heading w-16 rounded">
                                        </div>
                                    </div>
                                    
                                    <!-- Section 4: Average H-Index Range -->
                                    <div id="mobile-average-range" class="hindex-range-section">
                                        <div class="text-neutral-10 text-lg font-heading mb-2xs">Average H-Index Range:</div>
                                        <div class="flex items-center gap-xs">
                                            <span class="text-neutral-10 text-lg font-heading">Min:</span>
                                            <input type="number" id="mobile-average-min" min="0" max="1000" value="0" class="bg-neutral-600 text-neutral-10 px-2xs py-2xs text-lg font-heading w-16 rounded">
                                            <span class="text-neutral-10 text-lg font-heading">-</span>
                                            <span class="text-neutral-10 text-lg font-heading">Max:</span>
                                            <input type="number" id="mobile-average-max" min="0" max="1000" value="1000" class="bg-neutral-600 text-neutral-10 px-2xs py-2xs text-lg font-heading w-16 rounded">
                                        </div>
                                    </div>
                                    
                                    <!-- Section 5: Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyHIndexFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Sort By Dropdown -->
                        <div class="relative">
                            <button id="mobile-sort-btn" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleMobileSortDropdown()">
                                <span class="font-bold">Sort By:</span> <span id="mobile-sort-text" class="font-normal">Recommendation (Best First)</span> <span class="text-base">▼</span>
                            </button>
                            <div id="mobile-sort-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 py-xs">
                                <div class="flex flex-col gap-xs">
                                    <button class="w-full py-tag-y font-heading text-xl text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('recommend_best')">Recommendation (Best First)</button>
                                    <button class="w-full py-tag-y font-heading text-xl text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('recommend_worst')">Recommendation (Worst First)</button>
                                    <button class="w-full py-tag-y font-heading text-xl text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('relevance_high')">Relevance (Highest to Lowest)</button>
                                    <button class="w-full py-tag-y font-heading text-xl text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('relevance_low')">Relevance (Lowest to Highest)</button>
                                    <button class="w-full py-tag-y font-heading text-xl text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('highest_hindex_asc')">Highest H-Index (Ascending)</button>
                                    <button class="w-full py-tag-y font-heading text-xl text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('highest_hindex_desc')">Highest H-Index (Descending)</button>
                                    <button class="w-full py-tag-y font-heading text-xl text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('average_hindex_asc')">Average H-Index (Ascending)</button>
                                    <button class="w-full py-tag-y font-heading text-xl text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('average_hindex_desc')">Average H-Index (Descending)</button>
                                    <button class="w-full py-tag-y font-heading text-xl text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('id_asc')">arXiv ID (Ascending)</button>
                                    <button class="w-full py-tag-y font-heading text-xl text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('id_desc')">arXiv ID (Descending)</button>
                                    <button class="w-full py-tag-y font-heading text-xl text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('title_az')">Title (A-Z)</button>
                                    <button class="w-full py-tag-y font-heading text-xl text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('title_za')">Title (Z-A)</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Desktop Sidebar Overlay -->
    <div id="desktop-sidebar-overlay" class="hidden tablet:block fixed inset-0 bg-black bg-opacity-50 z-30 opacity-0 pointer-events-none transition-opacity duration-300 ease-in-out" onclick="closeDesktopMenu()"></div>
    
    <!-- Desktop Sidebar -->
    <div id="desktop-sidebar" class="hidden tablet:block fixed inset-y-0 left-0 z-40 bg-neutral-200 transition-transform duration-300 ease-in-out overflow-y-auto" style="width: 500px; transform: translateX(-100%);">
        <div class="w-full h-full flex flex-col">
            <!-- Desktop Sidebar Header -->
            <div class="flex items-center justify-between pt-lg pr-lg pb-sm pl-lg">
                <!-- Left: Research Feed Home Button -->
                <div>
                    <a href="index.html" class="research-feed-button text-center px-tag-x py-sm bg-neutral-600 transition-colors duration-200">
                        <span class="text-neutral-10 font-heading font-bold text-2xl">Research Feed</span>
                    </a>
                </div>
                
                <!-- Right: Menu Button -->
                <button id="desktop-close-btn" class="nav-button bg-transparent flex items-center justify-center button" 
                        style="width: clamp(3rem, 6vw, 3.125rem); height: clamp(3rem, 6vw, 3.125rem);" 
                        aria-label="Close Menu" onclick="closeDesktopMenu()">
                    <svg width="24" height="18" viewBox="0 0 24 18" xmlns="http://www.w3.org/2000/svg">
                        <rect x="0" y="0" width="24" height="5" fill="#4F4E4B"/>
                        <rect x="0" y="6.5" width="24" height="5" fill="#4F4E4B"/>
                        <rect x="0" y="13" width="24" height="5" fill="#4F4E4B"/>
                    </svg>
                </button>
            </div>
            
            <!-- Desktop Sidebar Content -->
            <div class="flex-1 px-lg pt-lg pb-6xl">
                <div class="flex flex-col gap-lg">
                    <!-- Section 1: Paper Count -->
                    <div class="bg-transparent">
                        <span class="text-neutral-70 font-heading text-xl font-bold" id="desktop-paper-count">
                            Showing: 0/0 Papers
                        </span>
                    </div>
                    
                    <!-- Section 2: Quick Filters -->
                    <div class="flex flex-col gap-xs">
                        <h3 class="text-neutral-60 font-heading font-bold text-2xl text-left bg-transparent">Quick Filters</h3>
                        <button id="desktop-quick-must-read" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('must-read')">Must Read</button>
                        <button id="desktop-quick-should-read" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('should-read')">Should Read</button>
                        <button id="desktop-quick-rlhf" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('rlhf')">RLHF</button>
                        <button id="desktop-quick-weak-supervision" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('weak-supervision')">Weak Supervision</button>
                        <button id="desktop-quick-diffusion-reasoning" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('diffusion-reasoning')">Diffusion Reasoning</button>
                        <button id="desktop-quick-distributed-training" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('distributed-training')">Distributed Training</button>
                        <button id="desktop-quick-datasets" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('datasets')">Datasets</button>
                        <button id="desktop-quick-reset" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('reset')">Reset To Default</button>
                    </div>
                    
                    <!-- Section 3: Advanced Filters -->
                    <div class="flex flex-col gap-xs">
                        <h3 class="text-neutral-60 font-heading font-bold text-2xl text-left bg-transparent">Advanced Filters</h3>
                        <!-- Scoring Filter Dropdown -->
                        <div class="relative">
                            <button id="desktop-scoring-btn" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleDesktopScoringDropdown()">
                                <span class="font-bold">Scoring:</span> <span class="font-normal">All Selected</span> <span class="text-sm">▼</span>
                            </button>
                            <div id="desktop-scoring-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-xs">
                                    <!-- Section 1: Has Scoring and Summary Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-scoring-has" checked>
                                            <label for="desktop-scoring-has"></label>
                                        </div>
                                        <label for="desktop-scoring-has" class="text-neutral-10 text-lg font-heading cursor-pointer">Completed</label>
                                    </div>
                                    
                                    <!-- Section 2: Does not have Scoring and Summary Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-scoring-no" checked>
                                            <label for="desktop-scoring-no"></label>
                                        </div>
                                        <label for="desktop-scoring-no" class="text-neutral-10 text-lg font-heading cursor-pointer">Not relevant enough</label>
                                    </div>
                                    
                                    <!-- Section 3: Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyScoringFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        <!-- Recommendation Filter Dropdown -->
                        <div class="relative">
                            <button id="desktop-recommendation-btn" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleDesktopRecommendationDropdown()">
                                <span class="font-bold">Recommendation:</span> <span class="font-normal">All Selected</span> <span class="text-sm">▼</span>
                            </button>
                            <div id="desktop-recommendation-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-xs">
                                    <!-- Must Read Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-recommendation-must" checked>
                                            <label for="desktop-recommendation-must"></label>
                                        </div>
                                        <label for="desktop-recommendation-must" class="text-neutral-10 text-lg font-heading cursor-pointer">Must Read</label>
                                    </div>
                                    
                                    <!-- Should Read Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-recommendation-should" checked>
                                            <label for="desktop-recommendation-should"></label>
                                        </div>
                                        <label for="desktop-recommendation-should" class="text-neutral-10 text-lg font-heading cursor-pointer">Should Read</label>
                                    </div>
                                    
                                    <!-- Can Skip Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-recommendation-skip" checked>
                                            <label for="desktop-recommendation-skip"></label>
                                        </div>
                                        <label for="desktop-recommendation-skip" class="text-neutral-10 text-lg font-heading cursor-pointer">Can Skip</label>
                                    </div>
                                    
                                    <!-- Ignore Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-recommendation-ignore" checked>
                                            <label for="desktop-recommendation-ignore"></label>
                                        </div>
                                        <label for="desktop-recommendation-ignore" class="text-neutral-10 text-lg font-heading cursor-pointer">Ignore</label>
                                    </div>
                                    
                                    <!-- Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyRecommendationFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        <!-- Novelty Filter Dropdown -->
                        <div class="relative">
                            <button id="desktop-novelty-btn" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleDesktopNoveltyDropdown()">
                                <span class="font-bold">Novelty:</span> <span class="font-normal">All Selected</span> <span class="text-sm">▼</span>
                            </button>
                            <div id="desktop-novelty-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-xs">
                                    <!-- High Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-novelty-high" checked>
                                            <label for="desktop-novelty-high"></label>
                                        </div>
                                        <label for="desktop-novelty-high" class="text-neutral-10 text-lg font-heading cursor-pointer">High</label>
                                    </div>
                                    
                                    <!-- Moderate Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-novelty-moderate" checked>
                                            <label for="desktop-novelty-moderate"></label>
                                        </div>
                                        <label for="desktop-novelty-moderate" class="text-neutral-10 text-lg font-heading cursor-pointer">Moderate</label>
                                    </div>
                                    
                                    <!-- Low Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-novelty-low" checked>
                                            <label for="desktop-novelty-low"></label>
                                        </div>
                                        <label for="desktop-novelty-low" class="text-neutral-10 text-lg font-heading cursor-pointer">Low</label>
                                    </div>
                                    
                                    <!-- None Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-novelty-none" checked>
                                            <label for="desktop-novelty-none"></label>
                                        </div>
                                        <label for="desktop-novelty-none" class="text-neutral-10 text-lg font-heading cursor-pointer">None</label>
                                    </div>
                                    
                                    <!-- Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyNoveltyFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        <!-- Potential Impact Filter Dropdown -->
                        <div class="relative">
                            <button id="desktop-impact-btn" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleDesktopImpactDropdown()">
                                <span class="font-bold">Potential Impact:</span> <span class="font-normal">All Selected</span> <span class="text-sm">▼</span>
                            </button>
                            <div id="desktop-impact-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-xs">
                                    <!-- High Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-impact-high" checked>
                                            <label for="desktop-impact-high"></label>
                                        </div>
                                        <label for="desktop-impact-high" class="text-neutral-10 text-lg font-heading cursor-pointer">High</label>
                                    </div>
                                    
                                    <!-- Moderate Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-impact-moderate" checked>
                                            <label for="desktop-impact-moderate"></label>
                                        </div>
                                        <label for="desktop-impact-moderate" class="text-neutral-10 text-lg font-heading cursor-pointer">Moderate</label>
                                    </div>
                                    
                                    <!-- Low Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-impact-low" checked>
                                            <label for="desktop-impact-low"></label>
                                        </div>
                                        <label for="desktop-impact-low" class="text-neutral-10 text-lg font-heading cursor-pointer">Low</label>
                                    </div>
                                    
                                    <!-- Negligible Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-impact-negligible" checked>
                                            <label for="desktop-impact-negligible"></label>
                                        </div>
                                        <label for="desktop-impact-negligible" class="text-neutral-10 text-lg font-heading cursor-pointer">Negligible</label>
                                    </div>
                                    
                                    <!-- Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyImpactFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        <!-- Relevance Filter Dropdown -->
                        <div class="relative">
                            <button id="desktop-relevance-btn" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleDesktopRelevanceDropdown()">
                                <span class="font-bold">Relevance:</span> <span class="font-normal">All Selected</span> <span class="text-sm">▼</span>
                            </button>
                            <div id="desktop-relevance-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-xs">
                                    <!-- Highly Relevant Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-relevance-highly" checked>
                                            <label for="desktop-relevance-highly"></label>
                                        </div>
                                        <label for="desktop-relevance-highly" class="text-neutral-10 text-lg font-heading cursor-pointer">Highly Relevant</label>
                                    </div>
                                    
                                    <!-- Moderately Relevant Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-relevance-moderately" checked>
                                            <label for="desktop-relevance-moderately"></label>
                                        </div>
                                        <label for="desktop-relevance-moderately" class="text-neutral-10 text-lg font-heading cursor-pointer">Moderately Relevant</label>
                                    </div>
                                    
                                    <!-- Tangentially Relevant Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-relevance-tangentially" checked>
                                            <label for="desktop-relevance-tangentially"></label>
                                        </div>
                                        <label for="desktop-relevance-tangentially" class="text-neutral-10 text-lg font-heading cursor-pointer">Tangentially Relevant</label>
                                    </div>
                                    
                                    <!-- Not Relevant Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-relevance-not" checked>
                                            <label for="desktop-relevance-not"></label>
                                        </div>
                                        <label for="desktop-relevance-not" class="text-neutral-10 text-lg font-heading cursor-pointer">Not Relevant</label>
                                    </div>
                                    
                                    <!-- Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyRelevanceFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Topic Filter Dropdown -->
                        <div class="relative">
                            <button id="desktop-topic-btn" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleDesktopTopicDropdown()">
                                <span class="font-bold">Topics:</span> <span class="font-normal">All Selected</span> <span class="text-sm">▼</span>
                            </button>
                            <div id="desktop-topic-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-xs">
                                    <!-- RLHF Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-topic-rlhf" checked>
                                            <label for="desktop-topic-rlhf"></label>
                                        </div>
                                        <label for="desktop-topic-rlhf" class="text-neutral-10 text-lg font-heading cursor-pointer">RLHF</label>
                                    </div>
                                    
                                    <!-- Weak Supervision Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-topic-weak-supervision" checked>
                                            <label for="desktop-topic-weak-supervision"></label>
                                        </div>
                                        <label for="desktop-topic-weak-supervision" class="text-neutral-10 text-lg font-heading cursor-pointer">Weak Supervision</label>
                                    </div>
                                    
                                    <!-- Diffusion Reasoning Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-topic-diffusion-reasoning" checked>
                                            <label for="desktop-topic-diffusion-reasoning"></label>
                                        </div>
                                        <label for="desktop-topic-diffusion-reasoning" class="text-neutral-10 text-lg font-heading cursor-pointer">Diffusion Reasoning</label>
                                    </div>
                                    
                                    <!-- Distributed Training Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-topic-distributed-training" checked>
                                            <label for="desktop-topic-distributed-training"></label>
                                        </div>
                                        <label for="desktop-topic-distributed-training" class="text-neutral-10 text-lg font-heading cursor-pointer">Distributed Training</label>
                                    </div>
                                    
                                    <!-- Datasets Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-topic-datasets" checked>
                                            <label for="desktop-topic-datasets"></label>
                                        </div>
                                        <label for="desktop-topic-datasets" class="text-neutral-10 text-lg font-heading cursor-pointer">Datasets</label>
                                    </div>
                                    
                                    <!-- Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyTopicFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- H-Index Filter Dropdown -->
                        <div class="relative">
                            <button id="desktop-hindex-btn" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleDesktopHIndexDropdown()">
                                H-index: All Selected <span class="text-md">▼</span>
                            </button>
                            <div id="desktop-hindex-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-lg">
                                    <!-- Section 1: H-Index Found Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-hindex-found" checked onchange="toggleHIndexRanges()">
                                            <label for="desktop-hindex-found"></label>
                                        </div>
                                        <label for="desktop-hindex-found" class="text-neutral-10 text-lg font-heading cursor-pointer">H-Index Found</label>
                                    </div>
                                    
                                    <!-- Section 2: H-Index Not Found Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-hindex-not-found" checked>
                                            <label for="desktop-hindex-not-found"></label>
                                        </div>
                                        <label for="desktop-hindex-not-found" class="text-neutral-10 text-lg font-heading cursor-pointer">H-Index Not Found</label>
                                    </div>
                                    
                                    <!-- Section 3: Highest H-Index Range -->
                                    <div id="desktop-highest-range" class="hindex-range-section">
                                        <div class="text-neutral-10 text-lg font-heading mb-2xs">Highest H-Index Range:</div>
                                        <div class="flex items-center gap-xs">
                                            <span class="text-neutral-10 text-lg font-heading">Min:</span>
                                            <input type="number" id="desktop-highest-min" min="0" max="1000" value="0" class="bg-neutral-600 text-neutral-10 px-2xs py-2xs text-lg font-heading w-16 rounded">
                                            <span class="text-neutral-10 text-lg font-heading">-</span>
                                            <span class="text-neutral-10 text-lg font-heading">Max:</span>
                                            <input type="number" id="desktop-highest-max" min="0" max="1000" value="1000" class="bg-neutral-600 text-neutral-10 px-2xs py-2xs text-lg font-heading w-16 rounded">
                                        </div>
                                    </div>
                                    
                                    <!-- Section 4: Average H-Index Range -->
                                    <div id="desktop-average-range" class="hindex-range-section">
                                        <div class="text-neutral-10 text-lg font-heading mb-2xs">Average H-Index Range:</div>
                                        <div class="flex items-center gap-xs">
                                            <span class="text-neutral-10 text-lg font-heading">Min:</span>
                                            <input type="number" id="desktop-average-min" min="0" max="1000" value="0" class="bg-neutral-600 text-neutral-10 px-2xs py-2xs text-lg font-heading w-16 rounded">
                                            <span class="text-neutral-10 text-lg font-heading">-</span>
                                            <span class="text-neutral-10 text-lg font-heading">Max:</span>
                                            <input type="number" id="desktop-average-max" min="0" max="1000" value="1000" class="bg-neutral-600 text-neutral-10 px-2xs py-2xs text-lg font-heading w-16 rounded">
                                        </div>
                                    </div>
                                    
                                    <!-- Section 5: Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyHIndexFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Sort By Dropdown -->
                        <div class="relative">
                            <button id="desktop-sort-btn" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleDesktopSortDropdown()">
                                <span class="font-bold">Sort By:</span> <span id="desktop-sort-text" class="font-normal">Recommendation (Best First)</span> <span class="text-sm">▼</span>
                            </button>
                            <div id="desktop-sort-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50">
                                <div class="flex flex-col gap-xs">
                                    <button class="w-full py-tag-y font-heading text-lg text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('recommend_best')">Recommendation (Best First)</button>
                                    <button class="w-full py-tag-y font-heading text-lg text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('recommend_worst')">Recommendation (Worst First)</button>
                                    <button class="w-full py-tag-y font-heading text-lg text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('relevance_high')">Relevance (Highest to Lowest)</button>
                                    <button class="w-full py-tag-y font-heading text-lg text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('relevance_low')">Relevance (Lowest to Highest)</button>
                                    <button class="w-full py-tag-y font-heading text-lg text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('highest_hindex_asc')">Highest H-Index (Ascending)</button>
                                    <button class="w-full py-tag-y font-heading text-lg text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('highest_hindex_desc')">Highest H-Index (Descending)</button>
                                    <button class="w-full py-tag-y font-heading text-lg text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('average_hindex_asc')">Average H-Index (Ascending)</button>
                                    <button class="w-full py-tag-y font-heading text-lg text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('average_hindex_desc')">Average H-Index (Descending)</button>
                                    <button class="w-full py-tag-y font-heading text-lg text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('id_asc')">arXiv ID (Ascending)</button>
                                    <button class="w-full py-tag-y font-heading text-lg text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('id_desc')">arXiv ID (Descending)</button>
                                    <button class="w-full py-tag-y font-heading text-lg text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('title_az')">Title (A-Z)</button>
                                    <button class="w-full py-tag-y font-heading text-lg text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('title_za')">Title (Z-A)</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Desktop Layout (visible ≥ 768px) -->
    <div class="hidden tablet:block">
        <!-- Desktop Header -->
        <header class="bg-neutral-200 w-full flex items-center px-lg pt-xl pb-md relative">
            <!-- Menu Button - Positioned absolutely within header -->
            <button id="desktop-menu-btn" class="absolute top-1/2 left-lg transform -translate-y-1/2 z-10 nav-button bg-transparent flex items-center justify-center button" 
                    style="width: clamp(3rem, 6vw, 3.125rem); height: clamp(3rem, 6vw, 3.125rem);" 
                    aria-label="Open Menu" onclick="toggleDesktopMenu()">
                <svg width="24" height="18" viewBox="0 0 24 18" xmlns="http://www.w3.org/2000/svg">
                    <rect x="0" y="0" width="24" height="5" fill="#4F4E4B"/>
                    <rect x="0" y="6.5" width="24" height="5" fill="#4F4E4B"/>
                    <rect x="0" y="13" width="24" height="5" fill="#4F4E4B"/>
                </svg>
            </button>
            
            <!-- Center: Page info (full width since menu button is positioned absolutely) -->
            <div class="w-full flex flex-col items-center justify-center text-center">
                <h1 class="text-neutral-70 font-heading font-bold text-4xl mb-md" id="page-title-desktop">
                    Papers Published on 30 August 2025
                </h1>
                
                <!-- Desktop Pagination -->
                <div class="flex items-center mb-md" style="gap: clamp(0.5rem, 1vw, 0.75rem);">
                    <!-- Previous Arrow -->
                    <button id="desktop-prev-btn" class="pagination-arrow bg-transparent text-neutral-70 flex items-center justify-center hover:bg-neutral-300 cursor-pointer" 
                            style="width: clamp(1.5rem, 3vw, 1.875rem); height: clamp(1.5rem, 3vw, 1.875rem);" onclick="goToPage(currentPage - 1)">
                        <span class="font-heading font-bold text-md">‹</span>
                    </button>
                    
                    <!-- Page Numbers Container -->
                    <div class="flex" style="gap: clamp(0.5rem, 1vw, 0.75rem);" id="desktop-pagination-numbers">
                        <!-- Page numbers will be populated by JavaScript -->
                    </div>
                    
                    <!-- Next Arrow -->
                    <button id="desktop-next-btn" class="pagination-arrow bg-transparent text-neutral-70 flex items-center justify-center hover:bg-neutral-300 cursor-pointer" 
                            style="width: clamp(1.5rem, 3vw, 1.875rem); height: clamp(1.5rem, 3vw, 1.875rem);" onclick="goToPage(currentPage + 1)">
                        <span class="font-heading font-bold text-md">›</span>
                    </button>
                </div>
                
                <!-- Desktop Paper Count -->
                <p id="desktop-main-paper-count" class="text-neutral-60 font-heading font-bold text-xl">
                    Showing 0 / 0 papers
                </p>
            </div>
        </header>
        
        <!-- Desktop Content Area -->
        <main class="px-xl py-2xl min-h-screen">
            <div class="max-w-[1400px] mx-auto">
                <!-- Desktop Papers Grid -->
                <div class="flex flex-col gap-3xl" id="desktop-papers">
                    <!-- Paper cards will be populated by JavaScript -->
                </div>
            </div>
        </main>
        
        <!-- Desktop Footer -->
        <footer class="py-xl bg-neutral-200">
            <div class="flex flex-col items-center justify-center text-center">
                <!-- Desktop Footer Pagination -->
                <div class="flex items-center" style="gap: clamp(0.5rem, 1vw, 0.75rem);">
                    <!-- Previous Arrow -->
                    <button id="desktop-footer-prev-btn" class="pagination-arrow bg-transparent text-neutral-70 flex items-center justify-center hover:bg-neutral-300 cursor-pointer" 
                            style="width: clamp(1.5rem, 3vw, 1.875rem); height: clamp(1.5rem, 3vw, 1.875rem);" onclick="goToPage(currentPage - 1)">
                        <span class="font-heading font-bold text-md">‹</span>
                    </button>
                    
                    <!-- Page Numbers Container -->
                    <div class="flex" style="gap: clamp(0.5rem, 1vw, 0.75rem);" id="desktop-footer-pagination-numbers">
                        <!-- Page numbers will be populated by JavaScript -->
                    </div>
                    
                    <!-- Next Arrow -->
                    <button id="desktop-footer-next-btn" class="pagination-arrow bg-transparent text-neutral-70 flex items-center justify-center hover:bg-neutral-300 cursor-pointer" 
                            style="width: clamp(1.5rem, 3vw, 1.875rem); height: clamp(1.5rem, 3vw, 1.875rem);" onclick="goToPage(currentPage + 1)">
                        <span class="font-heading font-bold text-md">›</span>
                    </button>
                </div>
            </div>
        </footer>
    </div>

    <!-- Embedded Paper Data - This will be populated by the builder script -->
    <script>
        // This JSON structure will be injected by the builder script
        // Expected structure:
        // {
        //   "papers": [
        //     {
        //       "id": "2407.xxxxx",
        //       "title": "Paper title with possible LaTeX: $\\alpha$ notation",
        //       "authors": ["Author 1", "Author 2"],
        //       "categories": ["cs.LG", "cs.AI"],
        //       "abstract": "Abstract text with possible LaTeX notation",
        //       "published_date": "2025-07-15",
        //       "arxiv_url": "https://arxiv.org/abs/2407.xxxxx",
        //       "pdf_url": "https://arxiv.org/pdf/2407.xxxxx.pdf",
        //       "summary": "AI generated summary",
        //       "recommendation_score": "Must Read",
        //       "recommendation_justification": "Justification text",
        //       "novelty_score": "High",
        //       "novelty_justification": "Novelty justification",
        //       "impact_score": "High", 
        //       "impact_justification": "Impact justification",
        //       "rlhf_score": 0.85,
        //       "weak_supervision_score": 0.72,
        //       "diffusion_reasoning_score": 0.15,
        //       "distributed_training_score": 0.05,
        //       "datasets_score": 0.92,
        //       "rlhf_relevance": "Highly Relevant",
        //       "weak_supervision_relevance": "Moderately Relevant", 
        //       "diffusion_reasoning_relevance": "Not Relevant",
        //       "distributed_training_relevance": "Not Relevant",
        //       "datasets_relevance": "Highly Relevant",
        //       "rlhf_justification": "Relevance justification text",
        //       "weak_supervision_justification": "Relevance justification text",
        //       "diffusion_reasoning_justification": "below_threshold",
        //       "distributed_training_justification": "below_threshold", 
        //       "datasets_justification": "Relevance justification text",
        //       "h_index_status": "completed",
        //       "semantic_scholar_url": "https://www.semanticscholar.org/...",
        //       "total_authors": 3,
        //       "authors_found": 2,
        //       "highest_h_index": 45,
        //       "average_h_index": 28.5,
        //       "notable_authors_count": 2,
        //       "author_h_indexes": [
        //         {"name": "Author 1", "h_index": 45, "profile_url": "https://..."},
        //         {"name": "Author 2", "h_index": 12, "profile_url": "https://..."}
        //       ],
        //       "llm_score_status": "completed" // or "not_relevant_enough"
        //     }
        //   ],
        //   "total_papers": 25,
        //   "date": "2025-07-15"
        // }
        const PAPER_DATA = {
  "papers": [
    {
      "id": "2509.00285",
      "title": "OpinioRAG: Towards Generating User-Centric Opinion Highlights from\n  Large-scale Online Reviews",
      "authors": [
        "Mir Tafseer Nayeem",
        "Davood Rafiei"
      ],
      "categories": [
        "cs.CL (Computation and Language)",
        "cs.AI (Artificial Intelligence)",
        "cs.IR (Information Retrieval)"
      ],
      "abstract": "We study the problem of opinion highlights generation from large volumes of\nuser reviews, often exceeding thousands per entity, where existing methods\neither fail to scale or produce generic, one-size-fits-all summaries that\noverlook personalized needs. To tackle this, we introduce OpinioRAG, a\nscalable, training-free framework that combines RAG-based evidence retrieval\nwith LLMs to efficiently produce tailored summaries. Additionally, we propose\nnovel reference-free verification metrics designed for sentiment-rich domains,\nwhere accurately capturing opinions and sentiment alignment is essential. These\nmetrics offer a fine-grained, context-sensitive assessment of factual\nconsistency. To facilitate evaluation, we contribute the first large-scale\ndataset of long-form user reviews, comprising entities with over a thousand\nreviews each, paired with unbiased expert summaries and manually annotated\nqueries. Through extensive experiments, we identify key challenges, provide\nactionable insights into improving systems, pave the way for future research,\nand position OpinioRAG as a robust framework for generating accurate, relevant,\nand structured summaries at scale.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00285v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00285v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.419,
      "weak_supervision_score": 0.381,
      "diffusion_reasoning_score": 0.399,
      "distributed_training_score": 0.325,
      "datasets_score": 0.401,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "Highly Relevant",
      "rlhf_justification": "The paper introduces a RAG-based framework for opinion summarization and a new dataset, but it does not involve training AI models using human feedback with reinforcement learning techniques. There is no mention of reward models, fine-tuning via RL, or alignment processes based on human-ranked data.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "The paper's main contribution includes creating and introducing a novel large-scale dataset of long-form user reviews with expert summaries and annotated queries, which directly aligns with research on dataset creation, curation, benchmarking, and evaluation for AI applications in summarization tasks.",
      "llm_score_status": "completed",
      "summary": "The paper introduces OpinioRAG, a scalable, training-free framework that leverages Retrieval-Augmented Generation (RAG) and large language models to generate personalized, user-centric opinion highlights from large-scale online reviews, addressing the limitations of generic summarization methods. It proposes novel reference-free verification metrics for sentiment-rich domains, creates the first large-scale dataset of long-form reviews with expert summaries and annotated queries, and demonstrates through experiments that the framework effectively handles information overload, provides actionable insights, and advances the field by improving accuracy and relevance in review summarization.",
      "novelty_score": "High",
      "novelty_justification": "The paper introduces a truly new framework, OpinioRAG, along with novel metrics and a large-scale dataset for user-centric opinion summarization, significantly advancing the state-of-the-art in handling large volumes of reviews. This represents a fresh approach that combines existing techniques in a way that tackles previously unaddressed scalability and personalization challenges.",
      "impact_score": "High",
      "impact_justification": "The work is likely to influence future research in AI, information retrieval, and computational linguistics by providing a robust framework and dataset for personalized review summarization, potentially extending to commercial applications in e-commerce and review platforms. Its focus on real-world scalability and sentiment accuracy could lead to broader adoption and citations across related subfields.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "The paper represents a high-quality contribution with innovative tools and insights that advance review summarization, making it valuable for researchers in AI and related fields to understand and build upon. While essential for specialists, it may not be groundbreaking enough for a wider audience to consider it a must-read.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/f1bb6f3032bee8245b9e10a9748bd545be422722",
      "total_authors": 2,
      "authors_found": 2,
      "highest_h_index": 10,
      "average_h_index": 6.0,
      "notable_authors_count": 1,
      "author_h_indexes": [
        {
          "name": "Mir Tafseer Nayeem",
          "h_index": 10,
          "profile_url": "https://www.semanticscholar.org/author/1807355"
        },
        {
          "name": "Davood Rafiei",
          "h_index": 2,
          "profile_url": "https://www.semanticscholar.org/author/2260652112"
        }
      ]
    },
    {
      "id": "2509.00286",
      "title": "Intelligent Spectrum Management in Satellite Communications",
      "authors": [
        "Rakshitha De Silva",
        "Shiva Raj Pokhrel",
        "Jonathan Kua",
        "Sithamparanathan Kandeepan"
      ],
      "categories": [
        "cs.NI (Networking and Internet Architecture)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Satellite Communication (SatCom) networks represent a fundamental pillar in\nmodern global connectivity, facilitating reliable service and extensive\ncoverage across a plethora of applications. The expanding demand for\nhigh-bandwidth services and the proliferation of mega satellite constellations\nhighlight the limitations of traditional exclusive satellite spectrum\nallocation approaches. Cognitive Radio (CR) leading to Cognitive Satellite\n(CogSat) networks through Dynamic Spectrum Management (DSM), which enables the\ndynamic adaptability of radio equipment to environmental conditions for optimal\nperformance, presents a promising solution for the emerging spectrum scarcity.\nIn this survey, we explore the adaptation of intelligent DSM methodologies to\nSatCom, leveraging satellite network integrations. We discuss contributions and\nhurdles in regulations and standardizations in realizing intelligent DSM in\nSatCom, and deep dive into DSM techniques, which enable CogSat networks.\nFurthermore, we extensively evaluate and categorize state-of-the-art Artificial\nIntelligence (AI)/Machine Learning (ML) methods leveraged for DSM while\nexploring operational resilience and robustness of such integrations. In\naddition, performance evaluation metrics critical for adaptive resource\nmanagement and system optimization in CogSat networks are thoroughly\ninvestigated. This survey also identifies open challenges and outlines future\nresearch directions in regulatory frameworks, network architectures, and\nintelligent spectrum management, paving the way for sustainable and scalable\nSatCom networks for enhanced global connectivity.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00286v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00286v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.322,
      "weak_supervision_score": 0.291,
      "diffusion_reasoning_score": 0.307,
      "distributed_training_score": 0.322,
      "datasets_score": 0.348,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00287",
      "title": "SIGMUS: Semantic Integration for Knowledge Graphs in Multimodal Urban\n  Spaces",
      "authors": [
        "Brian Wang",
        "Mani Srivastava"
      ],
      "categories": [
        "cs.AI (Artificial Intelligence)",
        "cs.CY (Computers and Society)"
      ],
      "abstract": "Modern urban spaces are equipped with an increasingly diverse set of sensors,\nall producing an abundance of multimodal data. Such multimodal data can be used\nto identify and reason about important incidents occurring in urban landscapes,\nsuch as major emergencies, cultural and social events, as well as natural\ndisasters. However, such data may be fragmented over several sources and\ndifficult to integrate due to the reliance on human-driven reasoning for\nidentifying relationships between the multimodal data corresponding to an\nincident, as well as understanding the different components which define an\nincident. Such relationships and components are critical to identifying the\ncauses of such incidents, as well as producing forecasting the scale and\nintensity of future incidents as they begin to develop. In this work, we create\nSIGMUS, a system for Semantic Integration for Knowledge Graphs in Multimodal\nUrban Spaces. SIGMUS uses Large Language Models (LLMs) to produce the necessary\nworld knowledge for identifying relationships between incidents occurring in\nurban spaces and data from different modalities, allowing us to organize\nevidence and observations relevant to an incident without relying and\nhuman-encoded rules for relating multimodal sensory data with incidents. This\norganized knowledge is represented as a knowledge graph, organizing incidents,\nobservations, and much more. We find that our system is able to produce\nreasonable connections between 5 different data sources (new article text, CCTV\nimages, air quality, weather, and traffic measurements) and relevant incidents\noccurring at the same time and location.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00287v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00287v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.351,
      "weak_supervision_score": 0.383,
      "diffusion_reasoning_score": 0.429,
      "distributed_training_score": 0.346,
      "datasets_score": 0.4,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "Not Relevant",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on using Large Language Models (LLMs) for semantic integration and reasoning about multimodal urban data in knowledge graphs, but it does not mention or utilize diffusion-based models, iterative refinement processes, or any multi-step logical reasoning via diffusion. There is no component involving treating a Chain-of-Thought as a single entity for holistic correction, making this topic unrelated.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "The paper's main contribution is the development of the SIGMUS system for integrating multimodal data into knowledge graphs, using existing data sources as examples (e.g., news articles, CCTV images). It does not involve creating, analyzing, benchmarking, or evaluating new datasets for machine learning or AI applications, nor does it discuss dataset curation methodologies.",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00303",
      "title": "Access Paths for Efficient Ordering with Large Language Models",
      "authors": [
        "Fuheng Zhao",
        "Jiayue Chen",
        "Yiming Pan",
        "Tahseen Rabbani",
        "Divyakant Agrawal",
        "Amr El Abbadi"
      ],
      "categories": [
        "cs.DB (Databases)",
        "cs.AI (Artificial Intelligence)",
        "cs.IR (Information Retrieval)"
      ],
      "abstract": "We present the LLM ORDER BY operator as a logical abstraction and study its\nphysical implementations within a unified evaluation framework. Our experiments\nshow that no single approach is universally optimal, with effectiveness\ndepending on query characteristics and data. We introduce three new designs: an\nagreement-based batch-size policy, a majority voting mechanism for pairwise\nsorting, and a two-way external merge sort adapted for LLMs. With extensive\nexperiments, our agreement-based procedure is effective at determining batch\nsize for value-based methods, the majority-voting mechanism consistently\nstrengthens pairwise comparisons on GPT-4o, and external merge sort achieves\nhigh accuracy-efficiency trade-offs across datasets and models. We further\nobserve a log-linear scaling between compute cost and ordering quality,\noffering the first step toward principled cost models for LLM powered data\nsystems.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00303v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00303v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.38,
      "weak_supervision_score": 0.343,
      "diffusion_reasoning_score": 0.404,
      "distributed_training_score": 0.376,
      "datasets_score": 0.325,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper's main contribution focuses on implementing efficient sorting operations using large language models (LLMs), including new designs like agreement-based batch-size policies and external merge sort for LLM-based ordering. It does not involve diffusion models, iterative refinement processes, or any adaptation of diffusion for multi-step logical reasoning tasks. Therefore, there is no connection to diffusion-based reasoning.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00305",
      "title": "Language-Aware Information Maximization for Transductive Few-Shot CLIP",
      "authors": [
        "Ghassen Baklouti",
        "Maxime Zanella",
        "Ismail Ben Ayed"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Transductive few-shot learning has triggered an abundant literature focusing\non vision-only models, but is still at a nascent stage within the recent\ncontext of foundational vision-language models (VLMs). Only a few recent\nmethods addressed the problem, pointing to the potential of tranduction in VLMs\nand to the need for VLM-tailored methods. Building on this momentum, we\nleverage information-theoretic concepts and recent progress in\nparameter-efficient fine-tuning (PEFT), developing a highly competitive\ntransductive few-shot CLIP method. Specifically, we introduce a novel\nLanguage-aware Information MaximizatiOn (LIMO) loss integrating three\ncomplementary terms: (i) the mutual information between the vision inputs and\nthe textual class descriptions; (ii) a Kullback-Leibler (KL) divergence\npenalizing deviation of the network's probabilistic outputs from the\ntext-driven zero-shot predictions; and (iii) a standard cross-entropy loss\nbased on the labeled shots. Furthermore, we challenge the commonly followed\nfine-tuning practices in the context of transductive few-shot learning, and\nexplore PEFT strategies, completely overlooked in this context. Surprisingly,\nwe observe substantial boosts in performances, which points to the potential of\nadapting a subset of the model's parameters in the transductive few-shot\nsetting. We report comprehensive evaluations, which show that LIMO outperforms\nthe very recent transductive few-shot CLIP methods by a large margin and yields\nsignificant gains over the best-performing inductive methods. Our code is\npublicly available at:\\[\n\\href{https://github.com/ghassenbaklouti/LIMO}{\\text{here}} \\]",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00305v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00305v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.393,
      "weak_supervision_score": 0.381,
      "diffusion_reasoning_score": 0.413,
      "distributed_training_score": 0.349,
      "datasets_score": 0.323,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper's main contribution is a novel loss function for transductive few-shot learning in vision-language models (VLMs) like CLIP, focusing on information maximization, mutual information, KL divergence, and parameter-efficient fine-tuning. It does not involve diffusion models, iterative refinement processes, or multi-step logical reasoning for complex tasks. There is no mention of adapting diffusion mechanisms for chain-of-thought or holistic correction, making it unrelated to the topic.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00310",
      "title": "TReF-6: Inferring Task-Relevant Frames from a Single Demonstration for\n  One-Shot Skill Generalization",
      "authors": [
        "Yuxuan Ding",
        "Shuangge Wang",
        "Tesca Fitzgerald"
      ],
      "categories": [
        "cs.RO (Robotics)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Robots often struggle to generalize from a single demonstration due to the\nlack of a transferable and interpretable spatial representation. In this work,\nwe introduce TReF-6, a method that infers a simplified, abstracted 6DoF\nTask-Relevant Frame from a single trajectory. Our approach identifies an\ninfluence point purely from the trajectory geometry to define the origin for a\nlocal frame, which serves as a reference for parameterizing a Dynamic Movement\nPrimitive (DMP). This influence point captures the task's spatial structure,\nextending the standard DMP formulation beyond start-goal imitation. The\ninferred frame is semantically grounded via a vision-language model and\nlocalized in novel scenes by Grounded-SAM, enabling functionally consistent\nskill generalization. We validate TReF-6 in simulation and demonstrate\nrobustness to trajectory noise. We further deploy an end-to-end pipeline on\nreal-world manipulation tasks, showing that TReF-6 supports one-shot imitation\nlearning that preserves task intent across diverse object configurations.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00310v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00310v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.41,
      "weak_supervision_score": 0.353,
      "diffusion_reasoning_score": 0.439,
      "distributed_training_score": 0.36,
      "datasets_score": 0.3,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper focuses on inferring a task-relevant frame from a single demonstration for robotic skill generalization using methods like trajectory optimization and vision-language models, without involving reinforcement learning, human-ranked data, or a reward model for fine-tuning. It is primarily about imitation learning, not RLHF.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper does not employ diffusion models or iterative refinement processes for multi-step logical reasoning. It uses trajectory geometry optimization and vision-language models for frame inference, which lacks any components related to diffusion-based Chain-of-Thought or holistic reasoning correction.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00311",
      "title": "MorphGen: Morphology-Guided Representation Learning for Robust\n  Single-Domain Generalization in Histopathological Cancer Classification",
      "authors": [
        "Hikmat Khan",
        "Syed Farhan Alam Zaidi",
        "Pir Masoom Shah",
        "Kiruthika Balakrishnan",
        "Rabia Khan",
        "Muhammad Waqas",
        "Jia Wu"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Domain generalization in computational histopathology is hindered by\nheterogeneity in whole slide images (WSIs), caused by variations in tissue\npreparation, staining, and imaging conditions across institutions. Unlike\nmachine learning systems, pathologists rely on domain-invariant morphological\ncues such as nuclear atypia (enlargement, irregular contours, hyperchromasia,\nchromatin texture, spatial disorganization), structural atypia (abnormal\narchitecture and gland formation), and overall morphological atypia that remain\ndiagnostic across diverse settings. Motivated by this, we hypothesize that\nexplicitly modeling biologically robust nuclear morphology and spatial\norganization will enable the learning of cancer representations that are\nresilient to domain shifts. We propose MorphGen (Morphology-Guided\nGeneralization), a method that integrates histopathology images, augmentations,\nand nuclear segmentation masks within a supervised contrastive learning\nframework. By aligning latent representations of images and nuclear masks,\nMorphGen prioritizes diagnostic features such as nuclear and morphological\natypia and spatial organization over staining artifacts and domain-specific\nfeatures. To further enhance out-of-distribution robustness, we incorporate\nstochastic weight averaging (SWA), steering optimization toward flatter minima.\nAttention map analyses revealed that MorphGen primarily relies on nuclear\nmorphology, cellular composition, and spatial cell organization within tumors\nor normal regions for final classification. Finally, we demonstrate resilience\nof the learned representations to image corruptions (such as staining\nartifacts) and adversarial attacks, showcasing not only OOD generalization but\nalso addressing critical vulnerabilities in current deep learning systems for\ndigital pathology. Code, datasets, and trained models are available at:\nhttps://github.com/hikmatkhan/MorphGen",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00311v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00311v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.324,
      "weak_supervision_score": 0.37,
      "diffusion_reasoning_score": 0.39,
      "distributed_training_score": 0.337,
      "datasets_score": 0.34,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00316",
      "title": "Continuously Tempered Diffusion Samplers",
      "authors": [
        "Ezra Erives",
        "Bowen Jing",
        "Peter Holderrieth",
        "Tommi Jaakkola"
      ],
      "categories": [
        "cs.LG (Machine Learning)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Annealing-based neural samplers seek to amortize sampling from unnormalized\ndistributions by training neural networks to transport a family of densities\ninterpolating from source to target. A crucial design choice in the training\nphase of such samplers is the proposal distribution by which locations are\ngenerated at which to evaluate the loss. Previous work has obtained such a\nproposal distribution by combining a partially learned transport with annealed\nLangevin dynamics. However, isolated modes and other pathological properties of\nthe annealing path imply that such proposals achieve insufficient exploration\nand thereby lower performance post training. To remedy this, we propose\ncontinuously tempered diffusion samplers, which leverage exploration techniques\ndeveloped in the context of molecular dynamics to improve proposal\ndistributions. Specifically, a family of distributions across different\ntemperatures is introduced to lower energy barriers at higher temperatures and\ndrive exploration at the lower temperature of interest. We empirically validate\nimproved sampler performance driven by extended exploration. Code is available\nat https://github.com/eje24/ctds.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00316v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00316v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.305,
      "weak_supervision_score": 0.328,
      "diffusion_reasoning_score": 0.467,
      "distributed_training_score": 0.391,
      "datasets_score": 0.303,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper's main contribution involves developing continuously tempered diffusion samplers for improving proposal distributions in neural sampling from unnormalized distributions, focusing on statistical and probabilistic tasks. It does not adapt diffusion processes for multi-step logical reasoning, Chain-of-Thought generation, or solving complex logical tasks, as required by the topic definition.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00317",
      "title": "A Framework for Task and Motion Planning based on Expanding AND/OR\n  Graphs",
      "authors": [
        "Fulvio Mastrogiovanni",
        "Antony Thomas"
      ],
      "categories": [
        "cs.RO (Robotics)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Robot autonomy in space environments presents unique challenges, including\nhigh perception and motion uncertainty, strict kinematic constraints, and\nlimited opportunities for human intervention. Therefore, Task and Motion\nPlanning (TMP) may be critical for autonomous servicing, surface operations, or\neven in-orbit missions, just to name a few, as it models tasks as discrete\naction sequencing integrated with continuous motion feasibility assessments. In\nthis paper, we introduce a TMP framework based on expanding AND/OR graphs,\nreferred to as TMP-EAOG, and demonstrate its adaptability to different\nscenarios. TMP-EAOG encodes task-level abstractions within an AND/OR graph,\nwhich expands iteratively as the plan is executed, and performs in-the-loop\nmotion planning assessments to ascertain their feasibility. As a consequence,\nTMP-EAOG is characterised by the desirable properties of (i) robustness to a\ncertain degree of uncertainty, because AND/OR graph expansion can accommodate\nfor unpredictable information about the robot environment, (ii) controlled\nautonomy, since an AND/OR graph can be validated by human experts, and (iii)\nbounded flexibility, in that unexpected events, including the assessment of\nunfeasible motions, can lead to different courses of action as alternative\npaths in the AND/OR graph. We evaluate TMP-EAOG on two benchmark domains. We\nuse a simulated mobile manipulator as a proxy for space-grade autonomous\nrobots. Our evaluation shows that TMP-EAOG can deal with a wide range of\nchallenges in the benchmarks.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00317v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00317v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.295,
      "weak_supervision_score": 0.261,
      "diffusion_reasoning_score": 0.354,
      "distributed_training_score": 0.299,
      "datasets_score": 0.268,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00319",
      "title": "Contact-Aided Navigation of Flexible Robotic Endoscope Using Deep\n  Reinforcement Learning in Dynamic Stomach",
      "authors": [
        "Chi Kit Ng",
        "Huxin Gao",
        "Tian-Ao Ren",
        "Jiewen Lai",
        "Hongliang Ren"
      ],
      "categories": [
        "cs.RO (Robotics)",
        "cs.AI (Artificial Intelligence)",
        "cs.SY (Systems and Control)",
        "eess.SY (Systems and Control)"
      ],
      "abstract": "Navigating a flexible robotic endoscope (FRE) through the gastrointestinal\ntract is critical for surgical diagnosis and treatment. However, navigation in\nthe dynamic stomach is particularly challenging because the FRE must learn to\neffectively use contact with the deformable stomach walls to reach target\nlocations. To address this, we introduce a deep reinforcement learning (DRL)\nbased Contact-Aided Navigation (CAN) strategy for FREs, leveraging contact\nforce feedback to enhance motion stability and navigation precision. The\ntraining environment is established using a physics-based finite element method\n(FEM) simulation of a deformable stomach. Trained with the Proximal Policy\nOptimization (PPO) algorithm, our approach achieves high navigation success\nrates (within 3 mm error between the FRE's end-effector and target) and\nsignificantly outperforms baseline policies. In both static and dynamic stomach\nenvironments, the CAN agent achieved a 100% success rate with 1.6 mm average\nerror, and it maintained an 85% success rate in challenging unseen scenarios\nwith stronger external disturbances. These results validate that the DRL-based\nCAN strategy substantially enhances FRE navigation performance over prior\nmethods.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00319v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00319v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.409,
      "weak_supervision_score": 0.331,
      "diffusion_reasoning_score": 0.337,
      "distributed_training_score": 0.326,
      "datasets_score": 0.24,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper focuses on deep reinforcement learning (DRL) using the Proximal Policy Optimization (PPO) algorithm in a simulated environment for navigating a flexible robotic endoscope, with rewards based on simulation metrics like navigation success and error distances. It does not involve human feedback, such as training a reward model on human-ranked data or fine-tuning with human preferences, which are core elements of RLHF. Therefore, the paper's contributions are unrelated to RLHF.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00320",
      "title": "Towards Adaptive Visual Token Pruning for Large Multimodal Models",
      "authors": [
        "Hao Zhang",
        "Mengsi Lyu",
        "Chenrui He",
        "Yulong Ao",
        "Yonghua Lin"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Large Multimodal Models (LMMs) have achieved significant success across\nvarious tasks. These models usually encode visual inputs into dense token\nsequences, which are then concatenated with textual tokens and jointly\nprocessed by a language model. However, the increased token count substantially\nraises computational and memory costs during inference. Token pruning has\nemerged as a promising approach to address this issue. Existing token pruning\nmethods often rely on costly calibration or suboptimal importance metrics,\nleading to redundant retained tokens. In this paper, we analyze the redundancy\ndifferences between visual and textual tokens and propose pruning exclusively\non visual tokens. Based on this, we propose a visual token pruning strategy\nthat explicitly preserves both cross-modal alignment and intra-modal\ninformational diversity. We introduce a mutual information-based token pruning\nstrategy that removes visual tokens semantically misaligned with textual\ntokens, effectively preserving the alignment between the visual and textual\nmodalities. To further improve the representational quality of the retained\ntokens, we additionally prune redundant visual tokens by maximizing the\nexpected pairwise distances in the embedding space, which is solved efficiently\nwith a greedy algorithm. Extensive experiments demonstrate that our method\nmaintains strong performance while reducing tokens by 88.9% on models such as\nLLaVA-1.5-7B and LLaVA-NEXT-7B, resulting in a 56.7% improvement in inference\nspeed.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00320v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00320v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.39,
      "weak_supervision_score": 0.353,
      "diffusion_reasoning_score": 0.418,
      "distributed_training_score": 0.401,
      "datasets_score": 0.33,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "Not Relevant",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on visual token pruning for efficiency in Large Multimodal Models, emphasizing computational cost reduction during inference. It does not involve diffusion models, iterative refinement processes, or multi-step logical reasoning for tasks like Chain-of-Thought correction.",
      "distributed_training_justification": "The paper addresses inference optimization through token pruning in multimodal models, not distributed training, parallel computing, or strategies for partitioning data/computation across multiple nodes or processors.",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00329",
      "title": "Jacobian Exploratory Dual-Phase Reinforcement Learning for Dynamic\n  Endoluminal Navigation of Deformable Continuum Robots",
      "authors": [
        "Yu Tian",
        "Chi Kit Ng",
        "Hongliang Ren"
      ],
      "categories": [
        "cs.RO (Robotics)",
        "cs.AI (Artificial Intelligence)",
        "cs.SY (Systems and Control)",
        "eess.SY (Systems and Control)"
      ],
      "abstract": "Deformable continuum robots (DCRs) present unique planning challenges due to\nnonlinear deformation mechanics and partial state observability, violating the\nMarkov assumptions of conventional reinforcement learning (RL) methods. While\nJacobian-based approaches offer theoretical foundations for rigid manipulators,\ntheir direct application to DCRs remains limited by time-varying kinematics and\nunderactuated deformation dynamics. This paper proposes Jacobian Exploratory\nDual-Phase RL (JEDP-RL), a framework that decomposes planning into phased\nJacobian estimation and policy execution. During each training step, we first\nperform small-scale local exploratory actions to estimate the deformation\nJacobian matrix, then augment the state representation with Jacobian features\nto restore approximate Markovianity. Extensive SOFA surgical dynamic\nsimulations demonstrate JEDP-RL's three key advantages over proximal policy\noptimization (PPO) baselines: 1) Convergence speed: 3.2x faster policy\nconvergence, 2) Navigation efficiency: requires 25% fewer steps to reach the\ntarget, and 3) Generalization ability: achieve 92% success rate under material\nproperty variations and achieve 83% (33% higher than PPO) success rate in the\nunseen tissue environment.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00329v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00329v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.384,
      "weak_supervision_score": 0.323,
      "diffusion_reasoning_score": 0.371,
      "distributed_training_score": 0.328,
      "datasets_score": 0.239,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00332",
      "title": "CryptoFace: End-to-End Encrypted Face Recognition",
      "authors": [
        "Wei Ao",
        "Vishnu Naresh Boddeti"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.CR (Cryptography and Security)"
      ],
      "abstract": "Face recognition is central to many authentication, security, and\npersonalized applications. Yet, it suffers from significant privacy risks,\nparticularly arising from unauthorized access to sensitive biometric data. This\npaper introduces CryptoFace, the first end-to-end encrypted face recognition\nsystem with fully homomorphic encryption (FHE). It enables secure processing of\nfacial data across all stages of a face-recognition process--feature\nextraction, storage, and matching--without exposing raw images or features. We\nintroduce a mixture of shallow patch convolutional networks to support\nhigher-dimensional tensors via patch-based processing while reducing the\nmultiplicative depth and, thus, inference latency. Parallel FHE evaluation of\nthese networks ensures near-resolution-independent latency. On standard face\nrecognition benchmarks, CryptoFace significantly accelerates inference and\nincreases verification accuracy compared to the state-of-the-art FHE neural\nnetworks adapted for face recognition. CryptoFace will facilitate secure face\nrecognition systems requiring robust and provable security. The code is\navailable at https://github.com/human-analysis/CryptoFace.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00332v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00332v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.323,
      "weak_supervision_score": 0.269,
      "diffusion_reasoning_score": 0.291,
      "distributed_training_score": 0.332,
      "datasets_score": 0.26,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00338",
      "title": "Scalable Option Learning in High-Throughput Environments",
      "authors": [
        "Mikael Henaff",
        "Scott Fujimoto",
        "Michael Rabbat"
      ],
      "categories": [
        "cs.LG (Machine Learning)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Hierarchical reinforcement learning (RL) has the potential to enable\neffective decision-making over long timescales. Existing approaches, while\npromising, have yet to realize the benefits of large-scale training. In this\nwork, we identify and solve several key challenges in scaling hierarchical RL\nto high-throughput environments. We propose Scalable Option Learning (SOL), a\nhighly scalable hierarchical RL algorithm which achieves a 25x higher\nthroughput compared to existing hierarchical methods. We train our hierarchical\nagents using 20 billion frames of experience on the complex game of NetHack,\nsignificantly surpassing flat agents and demonstrating positive scaling trends.\nWe also validate our algorithm on MiniHack and Mujoco environments, showcasing\nits general applicability. Our code is open sourced at\ngithub.com/facebookresearch/sol.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00338v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00338v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.444,
      "weak_supervision_score": 0.361,
      "diffusion_reasoning_score": 0.356,
      "distributed_training_score": 0.422,
      "datasets_score": 0.261,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "Highly Relevant",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper focuses on scaling hierarchical reinforcement learning through algorithmic improvements and parallelization, without any mention of human feedback, reward models based on human preferences, or fine-tuning with human-ranked data. It relies solely on standard RL environments and rewards, making it unrelated to RLHF.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "The paper's main contribution involves addressing challenges in scaling hierarchical RL via GPU parallelization, achieving 25x higher throughput for training on billions of samples. This directly aligns with distributed training concepts, as it focuses on accelerating computation through parallelization and high-throughput environments.",
      "datasets_justification": "below_threshold",
      "llm_score_status": "completed",
      "summary": "The paper introduces Scalable Option Learning (SOL), a hierarchical reinforcement learning algorithm designed to address challenges in scaling RL to high-throughput environments, enabling training on billions of samples. By solving key issues in GPU parallelization, SOL achieves a 25x higher throughput than existing methods, demonstrates superior performance over flat agents in the complex NetHack environment, and shows positive scaling trends, with validations on MiniHack and Mujoco environments.",
      "novelty_score": "Moderate",
      "novelty_justification": "The paper presents a notable improvement by developing SOL, which cleverly combines existing hierarchical RL ideas to achieve scalable training on large datasets, rather than introducing a entirely new problem or technique. This advancement addresses scaling challenges effectively but builds on established concepts like options and feudal RL.",
      "impact_score": "Moderate",
      "impact_justification": "The work is likely to be cited and built upon in the hierarchical RL subfield due to its demonstration of scaling to billions of samples and open-sourcing, potentially influencing future large-scale training efforts. However, its applicability is primarily within RL for complex environments, limiting broader commercial impact.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "This paper represents a strong contribution to scalable hierarchical RL, offering practical advancements and empirical results that are valuable for researchers working on long-timescale decision-making. While not essential for all AI practitioners, it provides important insights for those focused on RL scaling and large-scale training.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/d015b9a3bf45b7812bdf7d81d9256d643d0c6625",
      "total_authors": 3,
      "authors_found": 3,
      "highest_h_index": 8,
      "average_h_index": 4.0,
      "notable_authors_count": 1,
      "author_h_indexes": [
        {
          "name": "Mikael Henaff",
          "h_index": 3,
          "profile_url": "https://www.semanticscholar.org/author/2321598955"
        },
        {
          "name": "Scott Fujimoto",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2342411708"
        },
        {
          "name": "Michael Rabbat",
          "h_index": 8,
          "profile_url": "https://www.semanticscholar.org/author/2284991448"
        }
      ]
    },
    {
      "id": "2509.00346",
      "title": "LUT-Fuse: Towards Extremely Fast Infrared and Visible Image Fusion via\n  Distillation to Learnable Look-Up Tables",
      "authors": [
        "Xunpeng Yi",
        "Yibing Zhang",
        "Xinyu Xiang",
        "Qinglong Yan",
        "Han Xu",
        "Jiayi Ma"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Current advanced research on infrared and visible image fusion primarily\nfocuses on improving fusion performance, often neglecting the applicability on\nreal-time fusion devices. In this paper, we propose a novel approach that\ntowards extremely fast fusion via distillation to learnable lookup tables\nspecifically designed for image fusion, termed as LUT-Fuse. Firstly, we develop\na look-up table structure that utilizing low-order approximation encoding and\nhigh-level joint contextual scene encoding, which is well-suited for\nmulti-modal fusion. Moreover, given the lack of ground truth in multi-modal\nimage fusion, we naturally proposed the efficient LUT distillation strategy\ninstead of traditional quantization LUT methods. By integrating the performance\nof the multi-modal fusion network (MM-Net) into the MM-LUT model, our method\nachieves significant breakthroughs in efficiency and performance. It typically\nrequires less than one-tenth of the time compared to the current lightweight\nSOTA fusion algorithms, ensuring high operational speed across various\nscenarios, even in low-power mobile devices. Extensive experiments validate the\nsuperiority, reliability, and stability of our fusion approach. The code is\navailable at https://github.com/zyb5/LUT-Fuse.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00346v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00346v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.299,
      "weak_supervision_score": 0.292,
      "diffusion_reasoning_score": 0.406,
      "distributed_training_score": 0.328,
      "datasets_score": 0.278,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on developing an efficient image fusion method using learnable look-up tables (LUTs) and knowledge distillation, primarily for infrared and visible image fusion. While it briefly mentions diffusion-based models in the introduction as part of existing research for improving fusion performance, it does not incorporate or adapt diffusion processes for multi-step logical reasoning or iterative refinement of reasoning paths. The core contributions involve LUT-based techniques and distillation for efficiency, with no clear component related to diffusion-based reasoning as defined.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00347",
      "title": "LLM-Driven Policy Diffusion: Enhancing Generalization in Offline\n  Reinforcement Learning",
      "authors": [
        "Hanping Zhang",
        "Yuhong Guo"
      ],
      "categories": [
        "cs.LG (Machine Learning)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Reinforcement Learning (RL) is known for its strong decision-making\ncapabilities and has been widely applied in various real-world scenarios.\nHowever, with the increasing availability of offline datasets and the lack of\nwell-designed online environments from human experts, the challenge of\ngeneralization in offline RL has become more prominent. Due to the limitations\nof offline data, RL agents trained solely on collected experiences often\nstruggle to generalize to new tasks or environments. To address this challenge,\nwe propose LLM-Driven Policy Diffusion (LLMDPD), a novel approach that enhances\ngeneralization in offline RL using task-specific prompts. Our method\nincorporates both text-based task descriptions and trajectory prompts to guide\npolicy learning. We leverage a large language model (LLM) to process text-based\nprompts, utilizing its natural language understanding and extensive knowledge\nbase to provide rich task-relevant context. Simultaneously, we encode\ntrajectory prompts using a transformer model, capturing structured behavioral\npatterns within the underlying transition dynamics. These prompts serve as\nconditional inputs to a context-aware policy-level diffusion model, enabling\nthe RL agent to generalize effectively to unseen tasks. Our experimental\nresults demonstrate that LLMDPD outperforms state-of-the-art offline RL methods\non unseen tasks, highlighting its effectiveness in improving generalization and\nadaptability in diverse settings.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00347v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00347v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.492,
      "weak_supervision_score": 0.438,
      "diffusion_reasoning_score": 0.532,
      "distributed_training_score": 0.398,
      "datasets_score": 0.318,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "Tangentially Relevant",
      "diffusion_reasoning_relevance": "Moderately Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper focuses on enhancing generalization in offline RL using task-specific prompts and LLMs, without any mention of human feedback, reward models based on human preferences, or fine-tuning with human-ranked data. It relies on pre-collected offline datasets and prompts, not RLHF mechanisms.",
      "weak_supervision_justification": "The paper uses task-specific prompts like text descriptions and trajectories, which are easy to obtain and might involve noisy or imprecise data sources, but it does not primarily focus on programmatically generating labels from high-level sources for training. Instead, it emphasizes offline RL generalization, making the connection indirect.",
      "diffusion_reasoning_justification": "The paper employs a policy-level diffusion model for iterative refinement in RL to generate actions based on prompts, which shares the iterative process of diffusion models. However, it is applied to decision-making in RL rather than multi-step logical reasoning or holistic correction of a chain-of-thought for complex tasks.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "completed",
      "summary": "The paper introduces LLM-Driven Policy Diffusion (LLMDPD), a novel method to improve generalization in offline Reinforcement Learning (RL) by leveraging task-specific prompts, including text-based descriptions and trajectory data, processed via large language models (LLMs) and transformers to guide a context-aware policy diffusion model. The core objective is to enable RL agents trained on offline datasets to perform effectively on unseen tasks, with the methodology involving encoding prompts into embeddings for conditional policy training, and key findings from experiments showing that LLMDPD outperforms existing offline RL methods in generalization benchmarks.",
      "novelty_score": "High",
      "novelty_justification": "The paper introduces a truly new technique by integrating large language models with policy diffusion for enhancing generalization in offline RL, significantly advancing the state-of-the-art in handling unseen tasks. This innovative combination of natural language processing and RL addresses limitations in prior methods, making it a substantial contribution.",
      "impact_score": "High",
      "impact_justification": "The work has the potential to influence a broad range of future research and applications in AI and RL, particularly by incorporating LLMs into offline settings for better adaptability in real-world scenarios like autonomous driving. Its demonstrated performance improvements suggest it could be widely adopted and built upon in subfields focused on generalization and multimodal data integration.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "This paper represents a high-quality and valuable contribution to offline RL research, offering innovative insights that are worth exploring for those in AI and machine learning fields. While essential for RL generalization specialists, it may not be critical for all readers but provides significant advancements that enhance understanding of prompt-based techniques.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/63505f132df7ef525b898b5ec2d11d814258737b",
      "total_authors": 2,
      "authors_found": 2,
      "highest_h_index": 2,
      "average_h_index": 1.5,
      "notable_authors_count": 0,
      "author_h_indexes": [
        {
          "name": "Hanping Zhang",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2297760601"
        },
        {
          "name": "Yuhong Guo",
          "h_index": 2,
          "profile_url": "https://www.semanticscholar.org/author/2366315947"
        }
      ]
    },
    {
      "id": "2509.00348",
      "title": "Theory Foundation of Physics-Enhanced Residual Learning",
      "authors": [
        "Shixiao Liang",
        "Wang Chen",
        "Keke Long",
        "Peng Zhang",
        "Xiaopeng Li",
        "Jintao Ke"
      ],
      "categories": [
        "cs.LG (Machine Learning)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Intensive studies have been conducted in recent years to integrate neural\nnetworks with physics models to balance model accuracy and interpretability.\nOne recently proposed approach, named Physics-Enhanced Residual Learning\n(PERL), is to use learning to estimate the residual between the physics model\nprediction and the ground truth. Numeral examples suggested that integrating\nsuch residual with physics models in PERL has three advantages: (1) a reduction\nin the number of required neural network parameters; (2) faster convergence\nrates; and (3) fewer training samples needed for the same computational\nprecision. However, these numerical results lack theoretical justification and\ncannot be adequately explained.\n  This paper aims to explain these advantages of PERL from a theoretical\nperspective. We investigate a general class of problems with Lipschitz\ncontinuity properties. By examining the relationships between the bounds to the\nloss function and residual learning structure, this study rigorously proves a\nset of theorems explaining the three advantages of PERL.\n  Several numerical examples in the context of automated vehicle trajectory\nprediction are conducted to illustrate the proposed theorems. The results\nconfirm that, even with significantly fewer training samples, PERL consistently\nachieves higher accuracy than a pure neural network. These results demonstrate\nthe practical value of PERL in real world autonomous driving applications where\ncorner case data are costly or hard to obtain. PERL therefore improves\npredictive performance while reducing the amount of data required.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00348v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00348v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.354,
      "weak_supervision_score": 0.312,
      "diffusion_reasoning_score": 0.373,
      "distributed_training_score": 0.353,
      "datasets_score": 0.247,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00351",
      "title": "Target-Oriented Single Domain Generalization",
      "authors": [
        "Marzi Heidari",
        "Yuhong Guo"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.AI (Artificial Intelligence)",
        "cs.LG (Machine Learning)"
      ],
      "abstract": "Deep models trained on a single source domain often fail catastrophically\nunder distribution shifts, a critical challenge in Single Domain Generalization\n(SDG). While existing methods focus on augmenting source data or learning\ninvariant features, they neglect a readily available resource: textual\ndescriptions of the target deployment environment. We propose Target-Oriented\nSingle Domain Generalization (TO-SDG), a novel problem setup that leverages the\ntextual description of the target domain, without requiring any target data, to\nguide model generalization. To address TO-SDG, we introduce Spectral TARget\nAlignment (STAR), a lightweight module that injects target semantics into\nsource features by exploiting visual-language models (VLMs) such as CLIP. STAR\nuses a target-anchored subspace derived from the text embedding of the target\ndescription to recenter image features toward the deployment domain, then\nutilizes spectral projection to retain directions aligned with target cues\nwhile discarding source-specific noise. Moreover, we use a vision-language\ndistillation to align backbone features with VLM's semantic geometry. STAR\nfurther employs feature-space Mixup to ensure smooth transitions between source\nand target-oriented representations. Experiments across various image\nclassification and object detection benchmarks demonstrate STAR's superiority.\nThis work establishes that minimal textual metadata, which is a practical and\noften overlooked resource, significantly enhances generalization under severe\ndata constraints, opening new avenues for deploying robust models in target\nenvironments with unseen data.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00351v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00351v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.392,
      "weak_supervision_score": 0.424,
      "diffusion_reasoning_score": 0.429,
      "distributed_training_score": 0.422,
      "datasets_score": 0.356,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "Moderately Relevant",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "Not Relevant",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "The paper uses textual descriptions as a high-level, imprecise source to guide model generalization, similar to weak supervision, by injecting semantics into features without relying on hand-labeled target data. However, it focuses more on domain adaptation than programmatically generating labels, making it moderately relevant rather than central.",
      "diffusion_reasoning_justification": "The paper does not involve diffusion models, iterative refinement for logical tasks, or multi-step reasoning processes. It centers on spectral alignment and feature adaptation using vision-language models, with no components related to diffusion-based approaches.",
      "distributed_training_justification": "The paper does not address distributed training, parallel computing, or partitioning data/computation across nodes. Its focus is solely on improving model generalization through textual guidance and feature alignment, without any discussion of multi-node or accelerated training techniques.",
      "datasets_justification": "below_threshold",
      "llm_score_status": "completed",
      "summary": "This paper introduces Target-Oriented Single Domain Generalization (TO-SDG), a novel framework that leverages textual descriptions of the target domain to enhance model generalization from a single source domain, addressing the limitations of traditional Single Domain Generalization (SDG). The proposed Spectral Target Alignment (STAR) method utilizes vision-language models like CLIP to align source features with target semantics through spectral projection for noise filtering, vision-language distillation for semantic alignment, and feature-space Mixup for smooth transitions, demonstrating superior performance on image classification and object detection benchmarks, thereby showing that textual metadata can significantly improve generalization without requiring target data.",
      "novelty_score": "High",
      "novelty_justification": "The paper introduces a truly new problem setup (TO-SDG) and a novel technique (STAR) that integrates textual descriptions with vision-language models to advance state-of-the-art in domain generalization, representing a significant departure from existing methods that ignore such resources.",
      "impact_score": "High",
      "impact_justification": "This work has the potential to influence a wide range of future research and applications in AI by demonstrating how easily accessible textual metadata can enhance robust model deployment in data-scarce environments, likely leading to broader adoption in computer vision and machine learning fields.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "The paper offers a high-quality, innovative contribution that advances domain generalization techniques, making it valuable for researchers in AI and computer vision to understand and build upon, though it may not be essential for all audiences.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/c693525959daff733c3fa6b7a6f9c76a7162cb72",
      "total_authors": 2,
      "authors_found": 2,
      "highest_h_index": 1,
      "average_h_index": 1.0,
      "notable_authors_count": 0,
      "author_h_indexes": [
        {
          "name": "Marzi Heidari",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2218330152"
        },
        {
          "name": "Yuhong Guo",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2297372808"
        }
      ]
    },
    {
      "id": "2509.00353",
      "title": "AQFusionNet: Multimodal Deep Learning for Air Quality Index Prediction\n  with Imagery and Sensor Data",
      "authors": [
        "Koushik Ahmed Kushal",
        "Abdullah Al Mamun"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Air pollution monitoring in resource-constrained regions remains challenging\ndue to sparse sensor deployment and limited infrastructure. This work\nintroduces AQFusionNet, a multimodal deep learning framework for robust Air\nQuality Index (AQI) prediction. The framework integrates ground-level\natmospheric imagery with pollutant concentration data using lightweight CNN\nbackbones (MobileNetV2, ResNet18, EfficientNet-B0). Visual and sensor features\nare combined through semantically aligned embedding spaces, enabling accurate\nand efficient prediction. Experiments on more than 8,000 samples from India and\nNepal demonstrate that AQFusionNet consistently outperforms unimodal baselines,\nachieving up to 92.02% classification accuracy and an RMSE of 7.70 with the\nEfficientNet-B0 backbone. The model delivers an 18.5% improvement over\nsingle-modality approaches while maintaining low computational overhead, making\nit suitable for deployment on edge devices. AQFusionNet provides a scalable and\npractical solution for AQI monitoring in infrastructure-limited environments,\noffering robust predictive capability even under partial sensor availability.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00353v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00353v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.332,
      "weak_supervision_score": 0.379,
      "diffusion_reasoning_score": 0.391,
      "distributed_training_score": 0.318,
      "datasets_score": 0.407,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "Tangentially Relevant",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "The paper utilizes a dataset of over 8,000 samples from India and Nepal for evaluating AQFusionNet, which involves benchmarking model performance. However, the primary focus is on developing and testing the multimodal deep learning framework for AQI prediction, not on creating, analyzing, curating, or benchmarking datasets as a main contribution. The dataset is mentioned as a tool for experiments rather than a central element of the research.",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00356",
      "title": "Iterative Low-rank Network for Hyperspectral Image Denoising",
      "authors": [
        "Jin Ye",
        "Fengchao Xiong",
        "Jun Zhou",
        "Yuntao Qian"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Hyperspectral image (HSI) denoising is a crucial preprocessing step for\nsubsequent tasks. The clean HSI usually reside in a low-dimensional subspace,\nwhich can be captured by low-rank and sparse representation, known as the\nphysical prior of HSI. It is generally challenging to adequately use such\nphysical properties for effective denoising while preserving image details.\nThis paper introduces a novel iterative low-rank network (ILRNet) to address\nthese challenges. ILRNet integrates the strengths of model-driven and\ndata-driven approaches by embedding a rank minimization module (RMM) within a\nU-Net architecture. This module transforms feature maps into the wavelet domain\nand applies singular value thresholding (SVT) to the low-frequency components\nduring the forward pass, leveraging the spectral low-rankness of HSIs in the\nfeature domain. The parameter, closely related to the hyperparameter of the\nsingular vector thresholding algorithm, is adaptively learned from the data,\nallowing for flexible and effective capture of low-rankness across different\nscenarios. Additionally, ILRNet features an iterative refinement process that\nadaptively combines intermediate denoised HSIs with noisy inputs. This manner\nensures progressive enhancement and superior preservation of image details.\nExperimental results demonstrate that ILRNet achieves state-of-the-art\nperformance in both synthetic and real-world noise removal tasks.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00356v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00356v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.321,
      "weak_supervision_score": 0.356,
      "diffusion_reasoning_score": 0.319,
      "distributed_training_score": 0.308,
      "datasets_score": 0.295,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00357",
      "title": "SurgLLM: A Versatile Large Multimodal Model with Spatial Focus and\n  Temporal Awareness for Surgical Video Understanding",
      "authors": [
        "Zhen Chen",
        "Xingjian Luo",
        "Kun Yuan",
        "Jinlin Wu",
        "Danny T. M. Chan",
        "Nassir Navab",
        "Hongbin Liu",
        "Zhen Lei",
        "Jiebo Luo"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.AI (Artificial Intelligence)",
        "cs.LG (Machine Learning)"
      ],
      "abstract": "Surgical video understanding is crucial for facilitating Computer-Assisted\nSurgery (CAS) systems. Despite significant progress in existing studies, two\nmajor limitations persist, including inadequate visual content perception and\ninsufficient temporal awareness in surgical videos, and hinder the development\nof versatile CAS solutions. In this work, we propose the SurgLLM framework, an\neffective large multimodal model tailored for versatile surgical video\nunderstanding tasks with enhanced spatial focus and temporal awareness.\nSpecifically, to empower the spatial focus of surgical videos, we first devise\nSurgical Context-aware Multimodal Pretraining (Surg-Pretrain) for the video\nencoder of SurgLLM, by performing instrument-centric Masked Video\nReconstruction (MV-Recon) and subsequent multimodal alignment. To incorporate\nsurgical temporal knowledge into SurgLLM, we further propose Temporal-aware\nMultimodal Tuning (TM-Tuning) to enhance temporal reasoning with interleaved\nmultimodal embeddings. Moreover, to accommodate various understanding tasks of\nsurgical videos without conflicts, we devise a Surgical Task Dynamic Ensemble\nto efficiently triage a query with optimal learnable parameters in our SurgLLM.\nExtensive experiments performed on diverse surgical video understanding tasks,\nincluding captioning, general VQA, and temporal VQA, demonstrate significant\nimprovements over the state-of-the-art approaches, validating the effectiveness\nof our SurgLLM in versatile surgical video understanding. The source code is\navailable at https://github.com/franciszchen/SurgLLM.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00357v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00357v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.323,
      "weak_supervision_score": 0.374,
      "diffusion_reasoning_score": 0.397,
      "distributed_training_score": 0.334,
      "datasets_score": 0.345,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00367",
      "title": "A Multimodal and Multi-centric Head and Neck Cancer Dataset for Tumor\n  Segmentation and Outcome Prediction",
      "authors": [
        "Numan Saeed",
        "Salma Hassan",
        "Shahad Hardan",
        "Ahmed Aly",
        "Darya Taratynova",
        "Umair Nawaz",
        "Ufaq Khan",
        "Muhammad Ridzuan",
        "Vincent Andrearczyk",
        "Adrien Depeursinge",
        "Mathieu Hatt",
        "Thomas Eugene",
        "Raphaël Metz",
        "Mélanie Dore",
        "Gregory Delpon",
        "Vijay Ram Kumar Papineni",
        "Kareem Wahid",
        "Cem Dede",
        "Alaa Mohamed Shawky Ali",
        "Carlos Sjogreen",
        "Mohamed Naser",
        "Clifton D. Fuller",
        "Valentin Oreiller",
        "Mario Jreige",
        "John O. Prior",
        "Catherine Cheze Le Rest",
        "Olena Tankyevych",
        "Pierre Decazes",
        "Su Ruan",
        "Stephanie Tanadini-Lang",
        "Martin Vallières",
        "Hesham Elhalawani",
        "Ronan Abgral",
        "Romain Floch",
        "Kevin Kerleguer",
        "Ulrike Schick",
        "Maelle Mauguen",
        "Arman Rahmim",
        "Mohammad Yaqub"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "We describe a publicly available multimodal dataset of annotated Positron\nEmission Tomography/Computed Tomography (PET/CT) studies for head and neck\ncancer research. The dataset includes 1123 FDG-PET/CT studies from patients\nwith histologically confirmed head and neck cancer, acquired from 10\ninternational medical centers. All examinations consisted of co-registered\nPET/CT scans with varying acquisition protocols, reflecting real-world clinical\ndiversity across institutions. Primary gross tumor volumes (GTVp) and involved\nlymph nodes (GTVn) were manually segmented by experienced radiation oncologists\nand radiologists following standardized guidelines and quality control\nmeasures. We provide anonymized NifTi files of all studies, along with\nexpert-annotated segmentation masks, radiotherapy dose distribution for a\nsubset of patients, and comprehensive clinical metadata. This metadata includes\nTNM staging, HPV status, demographics (age and gender), long-term follow-up\noutcomes, survival times, censoring indicators, and treatment information. We\ndemonstrate how this dataset can be used for three key clinical tasks:\nautomated tumor segmentation, recurrence-free survival prediction, and HPV\nstatus classification, providing benchmark results using state-of-the-art deep\nlearning models, including UNet, SegResNet, and multimodal prognostic\nframeworks.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00367v2",
      "pdf_url": "http://arxiv.org/pdf/2509.00367v2",
      "scraper_status": "successfully_scraped",
      "intro_status": "no_intro_found",
      "embedding_status": "completed",
      "rlhf_score": 0.267,
      "weak_supervision_score": 0.274,
      "diffusion_reasoning_score": 0.239,
      "distributed_training_score": 0.28,
      "datasets_score": 0.37,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00371",
      "title": "Two Causes, Not One: Rethinking Omission and Fabrication Hallucinations\n  in MLLMs",
      "authors": [
        "Guangzong Si",
        "Hao Yin",
        "Xianfei Li",
        "Qing Ding",
        "Wenlong Liao",
        "Tao He",
        "Pai Peng"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Multimodal Large Language Models (MLLMs) have achieved impressive advances,\nyet object hallucination remains a persistent challenge. Existing methods,\nbased on the flawed assumption that omission and fabrication hallucinations\nshare a common cause, often reduce omissions only to trigger more fabrications.\nIn this work, we overturn this view by demonstrating that omission\nhallucinations arise from insufficient confidence when mapping perceived visual\nfeatures to linguistic expressions, whereas fabrication hallucinations result\nfrom spurious associations within the cross-modal representation space due to\nstatistical biases in the training corpus. Building on findings from visual\nattention intervention experiments, we propose the Visual-Semantic Attention\nPotential Field, a conceptual framework that reveals how the model constructs\nvisual evidence to infer the presence or absence of objects. Leveraging this\ninsight, we introduce Visual Potential Field Calibration (VPFC), a\nplug-and-play hallucination mitigation method that effectively reduces omission\nhallucinations without introducing additional fabrication hallucinations. Our\nfindings reveal a critical oversight in current object hallucination research\nand chart new directions for developing more robust and balanced hallucination\nmitigation strategies.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00371v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00371v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.411,
      "weak_supervision_score": 0.376,
      "diffusion_reasoning_score": 0.453,
      "distributed_training_score": 0.334,
      "datasets_score": 0.308,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper focuses on analyzing and mitigating hallucinations in Multimodal Large Language Models through visual attention mechanisms and calibration techniques, with no mention of reinforcement learning, human feedback, reward models, or fine-tuning based on human preferences.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper addresses object hallucinations in MLLMs using attention-based frameworks and calibration methods, without any involvement of diffusion models, iterative refinement processes, or multi-step logical reasoning as described in the topic.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00373",
      "title": "Activation Steering Meets Preference Optimization: Defense Against\n  Jailbreaks in Vision Language Models",
      "authors": [
        "Sihao Wu",
        "Gaojie Jin",
        "Wei Huang",
        "Jianhong Wang",
        "Xiaowei Huang"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Vision Language Models (VLMs) have demonstrated impressive capabilities in\nintegrating visual and textual information for understanding and reasoning, but\nremain highly vulnerable to adversarial attacks. While activation steering has\nemerged as a promising defence, existing approaches often rely on task-specific\ncontrastive prompts to extract harmful directions, which exhibit suboptimal\nperformance and can degrade visual grounding performance. To address these\nlimitations, we propose \\textit{Sequence-Level Preference Optimization} for VLM\n(\\textit{SPO-VLM}), a novel two-stage defense framework that combines\nactivation-level intervention with policy-level optimization to enhance model\nrobustness. In \\textit{Stage I}, we compute adaptive layer-specific steering\nvectors from diverse data sources, enabling generalized suppression of harmful\nbehaviors during inference. In \\textit{Stage II}, we refine these steering\nvectors through a sequence-level preference optimization process. This stage\nintegrates automated toxicity assessment, as well as visual-consistency rewards\nbased on caption-image alignment, to achieve safe and semantically grounded\ntext generation. The two-stage structure of SPO-VLM balances efficiency and\neffectiveness by combining a lightweight mitigation foundation in Stage I with\ndeeper policy refinement in Stage II. Extensive experiments shown SPO-VLM\nenhances safety against attacks via activation steering and preference\noptimization, while maintaining strong performance on benign tasks without\ncompromising visual understanding capabilities. We will release our code, model\nweights, and evaluation toolkit to support reproducibility and future research.\n\\textcolor{red}{Warning: This paper may contain examples of offensive or\nharmful text and images.}",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00373v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00373v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.471,
      "weak_supervision_score": 0.381,
      "diffusion_reasoning_score": 0.424,
      "distributed_training_score": 0.337,
      "datasets_score": 0.278,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Moderately Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper employs a sequence-level preference optimization process using PPO, which is part of the RLHF framework, to refine steering vectors with rewards like toxicity assessment. However, it relies on automated tools (e.g., Detoxify) rather than human-ranked data, so it does not fully align with the definition of RLHF requiring human feedback.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper's main contribution is a defense framework for VLMs using activation steering and preference optimization, with no reference to diffusion models, iterative refinement processes, or multi-step logical reasoning as described in the topic.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "completed",
      "summary": "This paper introduces SPO-VLM, a two-stage defense framework designed to protect Vision Language Models (VLMs) from jailbreak attacks by combining activation steering and preference optimization. In Stage I, adaptive layer-specific steering vectors are computed from diverse data sources to suppress harmful behaviors during inference, while in Stage II, these vectors are refined using sequence-level preference optimization with rewards for toxicity assessment and visual-text consistency, resulting in improved safety without compromising visual understanding or performance on benign tasks.",
      "novelty_score": "Moderate",
      "novelty_justification": "The paper presents a notable improvement by combining activation steering with sequence-level preference optimization in a novel way for VLMs, addressing limitations of existing defenses, though it builds on established techniques rather than introducing a entirely new problem.",
      "impact_score": "Moderate",
      "impact_justification": "The work is likely to be cited and built upon in the subfield of VLM security and adversarial defenses, given its practical framework and planned release of code, but its influence may be limited to specific applications rather than broader AI fields.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "This paper provides a strong, valuable contribution to AI safety for VLMs, offering innovative defense strategies that researchers in computer vision and artificial intelligence should be aware of, though it is not essential for all audiences.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/05760ad455151ac032276ee22e6344da4a8c1d84",
      "total_authors": 5,
      "authors_found": 5,
      "highest_h_index": 9,
      "average_h_index": 2.8,
      "notable_authors_count": 1,
      "author_h_indexes": [
        {
          "name": "Sihao Wu",
          "h_index": 3,
          "profile_url": "https://www.semanticscholar.org/author/2218423966"
        },
        {
          "name": "Gao Jin",
          "h_index": 9,
          "profile_url": "https://www.semanticscholar.org/author/2071131446"
        },
        {
          "name": "Wei Huang",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2366164842"
        },
        {
          "name": "Jianhong Wang",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2302459978"
        },
        {
          "name": "Xiaowei Huang",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2377643151"
        }
      ]
    },
    {
      "id": "2509.00374",
      "title": "Adaptive Point-Prompt Tuning: Fine-Tuning Heterogeneous Foundation\n  Models for 3D Point Cloud Analysis",
      "authors": [
        "Mengke Li",
        "Lihao Chen",
        "Peng Zhang",
        "Yiu-ming Cheung",
        "Hui Huang"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Parameter-efficient fine-tuning strategies for foundation models in 1D\ntextual and 2D visual analysis have demonstrated remarkable efficacy. However,\ndue to the scarcity of point cloud data, pre-training large 3D models remains a\nchallenging task. While many efforts have been made to apply pre-trained visual\nmodels to 3D domains through \"high-to-low\" mapping, these approaches often lead\nto the loss of spatial geometries and lack a generalizable framework for\nadapting any modality to 3D. This paper, therefore, attempts to directly\nleverage point features to calibrate the heterogeneous foundation model of any\nmodality for 3D point cloud analysis. Specifically, we propose the Adaptive\nPoint-Prompt Tuning (APPT) method, which fine-tunes pre-trained models with a\nmodest number of parameters, enabling direct point cloud processing without\nheterogeneous mappings. We convert raw point clouds into point embeddings by\naggregating local geometry to capture spatial features followed by linear\nlayers to ensure seamless utilization of frozen pre-trained models. Given the\ninherent disorder of point clouds, in contrast to the structured nature of\nimages and language, we employ a permutation-invariant feature to capture the\nrelative positions of point embeddings, thereby obtaining point tokens enriched\nwith location information to optimize self-attention mechanisms. To calibrate\nself-attention across source domains of any modality to 3D and reduce\ncomputational overhead, we introduce a prompt generator that shares weights\nwith the point embedding module, dynamically producing point-prompts without\nadding additional parameters. These prompts are then concatenated into a frozen\nfoundation model, providing rich global structural information and compensating\nfor the lack of structural context in the heterogeneous data.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00374v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00374v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.406,
      "weak_supervision_score": 0.365,
      "diffusion_reasoning_score": 0.401,
      "distributed_training_score": 0.385,
      "datasets_score": 0.326,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper focuses on adaptive point-prompt tuning for fine-tuning foundation models on 3D point clouds, emphasizing parameter-efficient methods and knowledge transfer from other modalities. It does not involve reinforcement learning, human feedback, reward models, or any alignment with human preferences.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper discusses techniques for adapting pre-trained models to 3D point cloud analysis using embeddings and prompt tuning, but it does not incorporate diffusion models, iterative refinement processes, or multi-step logical reasoning for complex tasks.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00375",
      "title": "Open Data Synthesis For Deep Research",
      "authors": [
        "Ziyi Xia",
        "Kun Luo",
        "Hongjin Qian",
        "Zheng Liu"
      ],
      "categories": [
        "cs.CL (Computation and Language)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Large language models (LLMs) are increasingly expected to go beyond simple\nfactual queries toward Deep Research-tasks that require decomposing questions\ninto sub-problems, coordinating multi-step reasoning, and synthesizing evidence\nfrom diverse sources. We formalize Deep Research tasks with verifiable answers\nas Hierarchical Constraint Satisfaction Problems (HCSPs), which are\nfundamentally different from single-constraint, multi-hop, or flat CSP\nformulations. However, existing benchmarks (e.g., Natural Questions, HotpotQA)\nfail to capture this complexity, while recent synthetic datasets often\nintroduce shortcut reasoning, knowledge leakage, or lack sufficient structural\ndepth. To address this gap, we introduce InfoSeek, a scalable framework for\nsynthesizing complex Deep Research tasks. InfoSeek uses a dual-agent system to\nrecursively build a Research Tree from large-scale webpages, blurring\nintermediate nodes into valid sub-problems, and converting these trees into\nnatural language questions that require traversing the full hierarchy. It also\nenables rapid scaling, yielding over 50K training examples, a curated test set,\nand reasoning trajectories generated via reject sampling. Experiments show that\nmodels trained on InfoSeek consistently outperform strong baselines. On a\nchallenging benchmark BrowseComp-Plus, 3B LLMs optimized with InfoSeek surpass\nmuch larger 32B models and lightweight commercial APIs (e.g., Gemini2.5-Flash),\nwhile achieving performance comparable to stronger APIs (e.g., Gemini2.5-Pro).\nBy preserving meta-information such as intermediate steps and retrieval labels,\nInfoSeek further supports advanced optimization strategies, including compound\nreward design and trajectory-level exploration. We provide our codes and\ndatasets in \\href{https://github.com/VectorSpaceLab/InfoSeek}{this repository}.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00375v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00375v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.449,
      "weak_supervision_score": 0.465,
      "diffusion_reasoning_score": 0.504,
      "distributed_training_score": 0.44,
      "datasets_score": 0.475,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "Highly Relevant",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "Not Relevant",
      "datasets_relevance": "Highly Relevant",
      "rlhf_justification": "The paper discusses standard reinforcement learning for model optimization on the InfoSeek dataset but does not involve human feedback, such as training a reward model on human-ranked data. It uses automated methods like reject sampling for trajectories, which aligns more with general RL than RLHF.",
      "weak_supervision_justification": "The paper's InfoSeek framework programmatically generates large-scale training labels and QA pairs from unstructured web sources, such as by mining entities and building Research Trees, which exemplifies weak supervision by relying on noisy, automated sources rather than hand-labeled data.",
      "diffusion_reasoning_justification": "The paper focuses on hierarchical reasoning and tree-based structures for Deep Research tasks but does not involve diffusion models, iterative refinement processes, or treating Chain-of-Thought as a holistic entity for logical tasks.",
      "distributed_training_justification": "The paper does not address distributed training, parallel computing, or multi-node systems for accelerating model training; it instead emphasizes dataset synthesis and model evaluation without mentioning partitioning data or computation across processors.",
      "datasets_justification": "The paper's main contribution is the creation and evaluation of the InfoSeek dataset, including methodologies for synthesis, benchmarking against existing datasets, and open-sourcing over 50K QA pairs and trajectories, directly aligning with research on dataset curation and analysis.",
      "llm_score_status": "completed",
      "summary": "The paper introduces InfoSeek, a scalable framework for synthesizing datasets of complex Deep Research tasks, which are formalized as Hierarchical Constraint Satisfaction Problems (HCSPs) to address limitations in existing benchmarks. By using a dual-agent system to build Research Trees from webpages, blur intermediate nodes into sub-problems, and generate natural language questions requiring full hierarchical traversal, InfoSeek produces over 50,000 training examples and reasoning trajectories; experiments show that models trained on this data outperform strong baselines, with 3B parameter models surpassing 32B models and certain commercial APIs.",
      "novelty_score": "High",
      "novelty_justification": "The paper introduces a novel formalization of Deep Research as Hierarchical Constraint Satisfaction Problems and a new scalable framework (InfoSeek) for synthesizing complex datasets, significantly advancing beyond existing benchmarks by enabling genuine multi-step reasoning without shortcuts.",
      "impact_score": "High",
      "impact_justification": "The work provides an open-source framework and large-scale dataset that could broadly influence LLM training for complex tasks like Deep Research, potentially leading to advancements in AI applications such as scientific discovery and policy analysis.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "This paper offers a high-quality contribution with practical tools and empirical evidence that advance AI research, making it valuable for those working on LLMs and complex reasoning, though it may not be essential for all readers.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/8f8b05fa273e652a73ea791e641f6835281a9291",
      "total_authors": 4,
      "authors_found": 4,
      "highest_h_index": 1,
      "average_h_index": 0.75,
      "notable_authors_count": 0,
      "author_h_indexes": [
        {
          "name": "Ziyi Xia",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2371011181"
        },
        {
          "name": "Kun Luo",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2360322620"
        },
        {
          "name": "Hongjin Qian",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2374412422"
        },
        {
          "name": "Zheng Liu",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2362012611"
        }
      ]
    },
    {
      "id": "2509.00378",
      "title": "NoiseCutMix: A Novel Data Augmentation Approach by Mixing Estimated\n  Noise in Diffusion Models",
      "authors": [
        "Shumpei Takezaki",
        "Ryoma Bise",
        "Shinnosuke Matsuo"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "In this study, we propose a novel data augmentation method that introduces\nthe concept of CutMix into the generation process of diffusion models, thereby\nexploiting both the ability of diffusion models to generate natural and\nhigh-resolution images and the characteristic of CutMix, which combines\nfeatures from two classes to create diverse augmented data. Representative data\naugmentation methods for combining images from multiple classes include CutMix\nand MixUp. However, techniques like CutMix often result in unnatural boundaries\nbetween the two images due to contextual differences. Therefore, in this study,\nwe propose a method, called NoiseCutMix, to achieve natural, high-resolution\nimage generation featuring the fused characteristics of two classes by\npartially combining the estimated noise corresponding to two different classes\nin a diffusion model. In the classification experiments, we verified the\neffectiveness of the proposed method by comparing it with conventional data\naugmentation techniques that combine multiple classes, random image generation\nusing Stable Diffusion, and combinations of these methods. Our codes are\navailable at: https://github.com/shumpei-takezaki/NoiseCutMix",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00378v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00378v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.297,
      "weak_supervision_score": 0.424,
      "diffusion_reasoning_score": 0.489,
      "distributed_training_score": 0.321,
      "datasets_score": 0.353,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "Not Relevant",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "The paper focuses on a data augmentation technique using diffusion models to generate mixed images, which enhances training data diversity but does not involve programmatically generating labels from noisy or imprecise sources. It relies on standard labeled data for classification experiments, without addressing weak supervision concepts like using high-level or noisy label sources.",
      "diffusion_reasoning_justification": "The paper applies diffusion models for image generation and augmentation by mixing noise, but it does not adapt the iterative refinement process for complex logical tasks, multi-step reasoning, or treating a chain-of-thought as an entity. It is solely focused on visual data augmentation, lacking any components for logical reasoning.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00379",
      "title": "Domain Adaptation-Based Crossmodal Knowledge Distillation for 3D\n  Semantic Segmentation",
      "authors": [
        "Jialiang Kang",
        "Jiawen Wang",
        "Dingsheng Luo"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.RO (Robotics)"
      ],
      "abstract": "Semantic segmentation of 3D LiDAR data plays a pivotal role in autonomous\ndriving. Traditional approaches rely on extensive annotated data for point\ncloud analysis, incurring high costs and time investments. In contrast,\nrealworld image datasets offer abundant availability and substantial scale. To\nmitigate the burden of annotating 3D LiDAR point clouds, we propose two\ncrossmodal knowledge distillation methods: Unsupervised Domain Adaptation\nKnowledge Distillation (UDAKD) and Feature and Semantic-based Knowledge\nDistillation (FSKD). Leveraging readily available spatio-temporally\nsynchronized data from cameras and LiDARs in autonomous driving scenarios, we\ndirectly apply a pretrained 2D image model to unlabeled 2D data. Through\ncrossmodal knowledge distillation with known 2D-3D correspondence, we actively\nalign the output of the 3D network with the corresponding points of the 2D\nnetwork, thereby obviating the necessity for 3D annotations. Our focus is on\npreserving modality-general information while filtering out modality-specific\ndetails during crossmodal distillation. To achieve this, we deploy\nself-calibrated convolution on 3D point clouds as the foundation of our domain\nadaptation module. Rigorous experimentation validates the effectiveness of our\nproposed methods, consistently surpassing the performance of state-of-the-art\napproaches in the field.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00379v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00379v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.332,
      "weak_supervision_score": 0.393,
      "diffusion_reasoning_score": 0.369,
      "distributed_training_score": 0.375,
      "datasets_score": 0.386,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00381",
      "title": "Visually Grounded Narratives: Reducing Cognitive Burden in\n  Researcher-Participant Interaction",
      "authors": [
        "Runtong Wu",
        "Jiayao Song",
        "Fei Teng",
        "Xianhao Ren",
        "Yuyan Gao",
        "Kailun Yang"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.HC (Human-Computer Interaction)"
      ],
      "abstract": "Narrative inquiry has been one of the prominent application domains for the\nanalysis of human experience, aiming to know more about the complexity of human\nsociety. However, researchers are often required to transform various forms of\ndata into coherent hand-drafted narratives in storied form throughout narrative\nanalysis, which brings an immense burden of data analysis. Participants, too,\nare expected to engage in member checking and presentation of these narrative\nproducts, which involves reviewing and responding to large volumes of\ndocuments. Given the dual burden and the need for more efficient and\nparticipant-friendly approaches to narrative making and representation, we made\na first attempt: (i) a new paradigm is proposed, NAME, as the initial attempt\nto push the field of narrative inquiry. Name is able to transfer research\ndocuments into coherent story images, alleviating the cognitive burden of\ninterpreting extensive text-based materials during member checking for both\nresearchers and participants. (ii) We develop an actor location and shape\nmodule to facilitate plausible image generation. (iii) We have designed a set\nof robust evaluation metrics comprising three key dimensions to objectively\nmeasure the perceptual quality and narrative consistency of generated\ncharacters. Our approach consistently demonstrates state-of-the-art performance\nacross different data partitioning schemes. Remarkably, while the baseline\nrelies on the full 100% of the available data, our method requires only 0.96%\nyet still reduces the FID score from 195 to 152. Under identical data volumes,\nour method delivers substantial improvements: for the 70:30 split, the FID\nscore decreases from 175 to 152, and for the 95:5 split, it is nearly halved\nfrom 96 to 49. Furthermore, the proposed model achieves a score of 3.62 on the\nnewly introduced metric, surpassing the baseline score of 2.66.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00381v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00381v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.388,
      "weak_supervision_score": 0.355,
      "diffusion_reasoning_score": 0.47,
      "distributed_training_score": 0.324,
      "datasets_score": 0.396,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Tangentially Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on using generative AI, potentially including diffusion-based models, for image generation from textual narratives to reduce cognitive burden in research. It mentions FID scores, which are commonly associated with diffusion models in image evaluation. However, the paper does not involve adapting diffusion for multi-step logical reasoning or treating a Chain-of-Thought as an entity for holistic correction. Instead, it emphasizes visual generation and narrative coherence, lacking a clear component for complex logical tasks, making it only tangentially related.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00385",
      "title": "HERO-VQL: Hierarchical, Egocentric and Robust Visual Query Localization",
      "authors": [
        "Joohyun Chang",
        "Soyeon Hong",
        "Hyogun Lee",
        "Seong Jong Ha",
        "Dongho Lee",
        "Seong Tae Kim",
        "Jinwoo Choi"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "In this work, we tackle the egocentric visual query localization (VQL), where\na model should localize the query object in a long-form egocentric video.\nFrequent and abrupt viewpoint changes in egocentric videos cause significant\nobject appearance variations and partial occlusions, making it difficult for\nexisting methods to achieve accurate localization. To tackle these challenges,\nwe introduce Hierarchical, Egocentric and RObust Visual Query Localization\n(HERO-VQL), a novel method inspired by human cognitive process in object\nrecognition. We propose i) Top-down Attention Guidance (TAG) and ii) Egocentric\nAugmentation based Consistency Training (EgoACT). Top-down Attention Guidance\nrefines the attention mechanism by leveraging the class token for high-level\ncontext and principal component score maps for fine-grained localization. To\nenhance learning in diverse and challenging matching scenarios, EgoAug enhances\nquery diversity by replacing the query with a randomly selected corresponding\nobject from groundtruth annotations and simulates extreme viewpoint changes by\nreordering video frames. Additionally, CT loss enforces stable object\nlocalization across different augmentation scenarios. Extensive experiments on\nVQ2D dataset validate that HERO-VQL effectively handles egocentric challenges,\nsignificantly outperforming baselines.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00385v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00385v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.357,
      "weak_supervision_score": 0.314,
      "diffusion_reasoning_score": 0.348,
      "distributed_training_score": 0.304,
      "datasets_score": 0.286,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00387",
      "title": "Unifying Adversarial Perturbation for Graph Neural Networks",
      "authors": [
        "Jinluan Yang",
        "Ruihao Zhang",
        "Zhengyu Chen",
        "Fei Wu",
        "Kun Kuang"
      ],
      "categories": [
        "cs.LG (Machine Learning)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "This paper studies the vulnerability of Graph Neural Networks (GNNs) to\nadversarial attacks on node features and graph structure. Various methods have\nimplemented adversarial training to augment graph data, aiming to bolster the\nrobustness and generalization of GNNs. These methods typically involve applying\nperturbations to the node feature, weights, or graph structure and subsequently\nminimizing the loss by learning more robust graph model parameters under the\nadversarial perturbations. Despite the effectiveness of adversarial training in\nenhancing GNNs' robustness and generalization abilities, its application has\nbeen largely confined to specific datasets and GNN types. In this paper, we\npropose a novel method, PerturbEmbedding, that integrates adversarial\nperturbation and training, enhancing GNNs' resilience to such attacks and\nimproving their generalization ability. PerturbEmbedding performs perturbation\noperations directly on every hidden embedding of GNNs and provides a unified\nframework for most existing perturbation strategies/methods. We also offer a\nunified perspective on the forms of perturbations, namely random and\nadversarial perturbations. Through experiments on various datasets using\ndifferent backbone models, we demonstrate that PerturbEmbedding significantly\nimproves both the robustness and generalization abilities of GNNs,\noutperforming existing methods. The rejection of both random (non-targeted) and\nadversarial (targeted) perturbations further enhances the backbone model's\nperformance.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00387v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00387v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.338,
      "weak_supervision_score": 0.351,
      "diffusion_reasoning_score": 0.37,
      "distributed_training_score": 0.365,
      "datasets_score": 0.306,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00389",
      "title": "Beyond Negative Transfer: Disentangled Preference-Guided Diffusion for\n  Cross-Domain Sequential Recommendation",
      "authors": [
        "Xiaoxin Ye",
        "Chengkai Huang",
        "Hongtao Huang",
        "Lina Yao"
      ],
      "categories": [
        "cs.IR (Information Retrieval)",
        "cs.AI (Artificial Intelligence)",
        "cs.SI (Social and Information Networks)"
      ],
      "abstract": "Cross-Domain Sequential Recommendation (CDSR) leverages user behaviors across\ndomains to enhance recommendation quality. However, naive aggregation of\nsequential signals can introduce conflicting domain-specific preferences,\nleading to negative transfer. While Sequential Recommendation (SR) already\nsuffers from noisy behaviors such as misclicks and impulsive actions, CDSR\nfurther amplifies this issue due to domain heterogeneity arising from diverse\nitem types and user intents. The core challenge is disentangling three\nintertwined signals: domain-invariant preferences, domain-specific preferences,\nand noise. Diffusion Models (DMs) offer a generative denoising framework\nwell-suited for disentangling complex user preferences and enhancing robustness\nto noise. Their iterative refinement process enables gradual denoising, making\nthem effective at capturing subtle preference signals. However, existing\napplications in recommendation face notable limitations: sequential DMs often\nconflate shared and domain-specific preferences, while cross-domain\ncollaborative filtering DMs neglect temporal dynamics, limiting their ability\nto model evolving user preferences. To bridge these gaps, we propose\n\\textbf{DPG-Diff}, a novel Disentangled Preference-Guided Diffusion Model, the\nfirst diffusion-based approach tailored for CDSR, to or best knowledge.\nDPG-Diff decomposes user preferences into domain-invariant and domain-specific\ncomponents, which jointly guide the reverse diffusion process. This\ndisentangled guidance enables robust cross-domain knowledge transfer, mitigates\nnegative transfer, and filters sequential noise. Extensive experiments on\nreal-world datasets demonstrate that DPG-Diff consistently outperforms\nstate-of-the-art baselines across multiple metrics.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00389v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00389v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.433,
      "weak_supervision_score": 0.393,
      "diffusion_reasoning_score": 0.574,
      "distributed_training_score": 0.389,
      "datasets_score": 0.351,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper focuses on diffusion models for cross-domain sequential recommendation and does not involve reinforcement learning, human feedback, reward models, or fine-tuning based on human-ranked data.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper applies diffusion models to iterative refinement for user preference disentanglement in recommendation systems, but it does not involve multi-step logical reasoning, Chain-of-Thought processes, or solving complex logical tasks as defined.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00391",
      "title": "The Resurgence of GCG Adversarial Attacks on Large Language Models",
      "authors": [
        "Yuting Tan",
        "Xuying Li",
        "Zhuo Li",
        "Huizhen Shu",
        "Peikang Hu"
      ],
      "categories": [
        "cs.CL (Computation and Language)",
        "cs.AI (Artificial Intelligence)",
        "cs.CR (Cryptography and Security)",
        "cs.LG (Machine Learning)"
      ],
      "abstract": "Gradient-based adversarial prompting, such as the Greedy Coordinate Gradient\n(GCG) algorithm, has emerged as a powerful method for jailbreaking large\nlanguage models (LLMs). In this paper, we present a systematic appraisal of GCG\nand its annealing-augmented variant, T-GCG, across open-source LLMs of varying\nscales. Using Qwen2.5-0.5B, LLaMA-3.2-1B, and GPT-OSS-20B, we evaluate attack\neffectiveness on both safety-oriented prompts (AdvBench) and\nreasoning-intensive coding prompts. Our study reveals three key findings: (1)\nattack success rates (ASR) decrease with model size, reflecting the increasing\ncomplexity and non-convexity of larger models' loss landscapes; (2)\nprefix-based heuristics substantially overestimate attack effectiveness\ncompared to GPT-4o semantic judgments, which provide a stricter and more\nrealistic evaluation; and (3) coding-related prompts are significantly more\nvulnerable than adversarial safety prompts, suggesting that reasoning itself\ncan be exploited as an attack vector. In addition, preliminary results with\nT-GCG show that simulated annealing can diversify adversarial search and\nachieve competitive ASR under prefix evaluation, though its benefits under\nsemantic judgment remain limited. Together, these findings highlight the\nscalability limits of GCG, expose overlooked vulnerabilities in reasoning\ntasks, and motivate further development of annealing-inspired strategies for\nmore robust adversarial evaluation.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00391v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00391v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.405,
      "weak_supervision_score": 0.384,
      "diffusion_reasoning_score": 0.442,
      "distributed_training_score": 0.374,
      "datasets_score": 0.304,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Tangentially Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper mentions alignment efforts for LLMs, which often involve RLHF, and discusses vulnerabilities despite such alignments, but its main focus is on adversarial attacks (e.g., GCG and T-GCG) rather than implementing or evaluating RLHF systems.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on gradient-based adversarial attacks like GCG and its annealing variant T-GCG, with no mention of diffusion models, iterative refinement for reasoning, or multi-step logical processes as described in the topic.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00395",
      "title": "Double-Constraint Diffusion Model with Nuclear Regularization for\n  Ultra-low-dose PET Reconstruction",
      "authors": [
        "Mengxiao Geng",
        "Ran Hong",
        "Bingxuan Li",
        "Qiegen Liu"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Ultra-low-dose positron emission tomography (PET) reconstruction holds\nsignificant potential for reducing patient radiation exposure and shortening\nexamination times. However, it may also lead to increased noise and reduced\nimaging detail, which could decrease the image quality. In this study, we\npresent a Double-Constraint Diffusion Model (DCDM), which freezes the weights\nof a pre-trained diffusion model and injects a trainable double-constraint\ncontroller into the encoding architecture, greatly reducing the number of\ntrainable parameters for ultra-low-dose PET reconstruction. Unlike full\nfine-tuning models, DCDM can adapt to different dose levels without retraining\nall model parameters, thereby improving reconstruction flexibility.\nSpecifically, the two constraint modules, named the Nuclear Transformer\nConstraint (NTC) and the Encoding Nexus Constraint (ENC), serve to refine the\npre-trained diffusion model. The NTC leverages the nuclear norm as an\napproximation for matrix rank minimization, integrates the low-rank property\ninto the Transformer architecture, and enables efficient information extraction\nfrom low-dose images and conversion into compressed feature representations in\nthe latent space. Subsequently, the ENC utilizes these compressed feature\nrepresentations to encode and control the pre-trained diffusion model,\nultimately obtaining reconstructed PET images in the pixel space. In clinical\nreconstruction, the compressed feature representations from NTC help select the\nmost suitable ENC for efficient unknown low-dose PET reconstruction.\nExperiments conducted on the UDPET public dataset and the Clinical dataset\ndemonstrated that DCDM outperforms state-of-the-art methods on known dose\nreduction factors (DRF) and generalizes well to unknown DRF scenarios, proving\nvaluable even at ultra-low dose levels, such as 1% of the full dose.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00395v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00395v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "extraction_failed",
      "embedding_status": "completed",
      "rlhf_score": 0.3,
      "weak_supervision_score": 0.347,
      "diffusion_reasoning_score": 0.46,
      "distributed_training_score": 0.365,
      "datasets_score": 0.287,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on using a diffusion model for ultra-low-dose PET image reconstruction, emphasizing image denoising and generation techniques. However, it does not involve adapting the iterative refinement process of diffusion models for solving complex logical tasks, such as multi-step Chain-of-Thought reasoning. The core application is medical imaging, not logical or reasoning-based tasks, so there is no clear component for diffusion-based reasoning as defined.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00396",
      "title": "DAOVI: Distortion-Aware Omnidirectional Video Inpainting",
      "authors": [
        "Ryosuke Seshimo",
        "Mariko Isogawa"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Omnidirectional videos that capture the entire surroundings are employed in a\nvariety of fields such as VR applications and remote sensing. However, their\nwide field of view often causes unwanted objects to appear in the videos. This\nproblem can be addressed by video inpainting, which enables the natural removal\nof such objects while preserving both spatial and temporal consistency.\nNevertheless, most existing methods assume processing ordinary videos with a\nnarrow field of view and do not tackle the distortion in equirectangular\nprojection of omnidirectional videos. To address this issue, this paper\nproposes a novel deep learning model for omnidirectional video inpainting,\ncalled Distortion-Aware Omnidirectional Video Inpainting (DAOVI). DAOVI\nintroduces a module that evaluates temporal motion information in the image\nspace considering geodesic distance, as well as a depth-aware feature\npropagation module in the feature space that is designed to address the\ngeometric distortion inherent to omnidirectional videos. The experimental\nresults demonstrate that our proposed method outperforms existing methods both\nquantitatively and qualitatively.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00396v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00396v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.294,
      "weak_supervision_score": 0.283,
      "diffusion_reasoning_score": 0.38,
      "distributed_training_score": 0.304,
      "datasets_score": 0.284,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00398",
      "title": "A Study on the Framework for Evaluating the Ethics and Trustworthiness\n  of Generative AI",
      "authors": [
        "Cheonsu Jeong",
        "Seunghyun Lee",
        "Sunny Jeong",
        "Sungsu Kim"
      ],
      "categories": [
        "cs.CY (Computers and Society)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "This study provides an in_depth analysis of the ethical and trustworthiness\nchallenges emerging alongside the rapid advancement of generative artificial\nintelligence (AI) technologies and proposes a comprehensive framework for their\nsystematic evaluation. While generative AI, such as ChatGPT, demonstrates\nremarkable innovative potential, it simultaneously raises ethical and social\nconcerns, including bias, harmfulness, copyright infringement, privacy\nviolations, and hallucination. Current AI evaluation methodologies, which\nmainly focus on performance and accuracy, are insufficient to address these\nmultifaceted issues. Thus, this study emphasizes the need for new\nhuman_centered criteria that also reflect social impact. To this end, it\nidentifies key dimensions for evaluating the ethics and trustworthiness of\ngenerative AI_fairness, transparency, accountability, safety, privacy,\naccuracy, consistency, robustness, explainability, copyright and intellectual\nproperty protection, and source traceability and develops detailed indicators\nand assessment methodologies for each. Moreover, it provides a comparative\nanalysis of AI ethics policies and guidelines in South Korea, the United\nStates, the European Union, and China, deriving key approaches and implications\nfrom each. The proposed framework applies across the AI lifecycle and\nintegrates technical assessments with multidisciplinary perspectives, thereby\noffering practical means to identify and manage ethical risks in real_world\ncontexts. Ultimately, the study establishes an academic foundation for the\nresponsible advancement of generative AI and delivers actionable insights for\npolicymakers, developers, users, and other stakeholders, supporting the\npositive societal contributions of AI technologies.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00398v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00398v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "extraction_failed",
      "embedding_status": "completed",
      "rlhf_score": 0.427,
      "weak_supervision_score": 0.352,
      "diffusion_reasoning_score": 0.383,
      "distributed_training_score": 0.331,
      "datasets_score": 0.418,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "Tangentially Relevant",
      "rlhf_justification": "The paper's main contribution is a framework for evaluating the ethics and trustworthiness of generative AI, focusing on dimensions like fairness and transparency, without any discussion of reinforcement learning, human feedback, or training models with human-ranked data.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "The paper proposes a framework that includes ethical dimensions potentially related to datasets, such as bias and fairness, but it does not focus on creating, analyzing, benchmarking, or evaluating datasets directly; instead, it emphasizes broader ethical assessments.",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00402",
      "title": "Curriculum Guided Personalized Subgraph Federated Learning",
      "authors": [
        "Minku Kang",
        "Hogun Park"
      ],
      "categories": [
        "cs.LG (Machine Learning)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Subgraph Federated Learning (FL) aims to train Graph Neural Networks (GNNs)\nacross distributed private subgraphs, but it suffers from severe data\nheterogeneity. To mitigate data heterogeneity, weighted model aggregation\npersonalizes each local GNN by assigning larger weights to parameters from\nclients with similar subgraph characteristics inferred from their current model\nstates. However, the sparse and biased subgraphs often trigger rapid\noverfitting, causing the estimated client similarity matrix to stagnate or even\ncollapse. As a result, aggregation loses effectiveness as clients reinforce\ntheir own biases instead of exploiting diverse knowledge otherwise available.\nTo this end, we propose a novel personalized subgraph FL framework called\nCurriculum guided personalized sUbgraph Federated Learning (CUFL). On the\nclient side, CUFL adopts Curriculum Learning (CL) that adaptively selects edges\nfor training according to their reconstruction scores, exposing each GNN first\nto easier, generic cross-client substructures and only later to harder,\nclient-specific ones. This paced exposure prevents early overfitting to biased\npatterns and enables gradual personalization. By regulating personalization,\nthe curriculum also reshapes server aggregation from exchanging generic\nknowledge to propagating client-specific knowledge. Further, CUFL improves\nweighted aggregation by estimating client similarity using fine-grained\nstructural indicators reconstructed on a random reference graph. Extensive\nexperiments on six benchmark datasets confirm that CUFL achieves superior\nperformance compared to relevant baselines. Code is available at\nhttps://github.com/Kang-Min-Ku/CUFL.git.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00402v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00402v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.389,
      "weak_supervision_score": 0.349,
      "diffusion_reasoning_score": 0.327,
      "distributed_training_score": 0.416,
      "datasets_score": 0.344,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "Highly Relevant",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "The paper's main contribution, CUFL, is a framework for Subgraph Federated Learning, which is a form of distributed training. It involves partitioning graph data across multiple clients (nodes), training local GNN models, and aggregating updates on a server to handle data heterogeneity. This directly aligns with distributed training concepts, such as strategically partitioning data and computation across nodes to improve model performance, making the paper highly relevant to the topic.",
      "datasets_justification": "below_threshold",
      "llm_score_status": "completed",
      "summary": "The paper introduces CUFL, a novel framework for personalized Subgraph Federated Learning, designed to address data heterogeneity and rapid overfitting in training Graph Neural Networks (GNNs) across distributed private subgraphs. By incorporating Curriculum Learning to adaptively select training edges based on reconstruction scores—starting with easier, generic structures and progressing to harder, client-specific ones—CUFL prevents early overfitting, enables gradual personalization, and enhances weighted aggregation through fine-grained client similarity estimation on a shared random reference graph, resulting in superior performance on six benchmark datasets compared to baselines.",
      "novelty_score": "Moderate",
      "novelty_justification": "The paper presents a clever combination of Curriculum Learning with existing Subgraph Federated Learning techniques to mitigate overfitting, offering a notable improvement on known challenges rather than introducing a entirely new problem or architecture. While innovative in application, it builds on established methods without significantly advancing the overall state-of-the-art.",
      "impact_score": "Moderate",
      "impact_justification": "The work is likely to be cited and built upon in the subfield of federated learning for graphs, as it provides effective strategies for handling data heterogeneity in GNN training. However, its influence may remain confined to specific applications in privacy-preserving distributed learning rather than broadly affecting general AI or commercial domains.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "The paper delivers a strong, valuable contribution by innovating on personalized federated learning for GNNs, making it essential for researchers in machine learning and AI focused on distributed systems. Its experimental validation and practical insights justify awareness, though it may not be groundbreaking for broader audiences.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/822804a231c07392d1a523cae90be4e1aab9ee3d",
      "total_authors": 2,
      "authors_found": 2,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": [
        {
          "name": "Minku Kang",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2376111355"
        },
        {
          "name": "Hogun Park",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2378728789"
        }
      ]
    },
    {
      "id": "2509.00403",
      "title": "DevilSight: Augmenting Monocular Human Avatar Reconstruction through a\n  Virtual Perspective",
      "authors": [
        "Yushuo Chen",
        "Ruizhi Shao",
        "Youxin Pang",
        "Hongwen Zhang",
        "Xinyi Wu",
        "Rihui Wu",
        "Yebin Liu"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "We present a novel framework to reconstruct human avatars from monocular\nvideos. Recent approaches have struggled either to capture the fine-grained\ndynamic details from the input or to generate plausible details at novel\nviewpoints, which mainly stem from the limited representational capacity of the\navatar model and insufficient observational data. To overcome these challenges,\nwe propose to leverage the advanced video generative model, Human4DiT, to\ngenerate the human motions from alternative perspective as an additional\nsupervision signal. This approach not only enriches the details in previously\nunseen regions but also effectively regularizes the avatar representation to\nmitigate artifacts. Furthermore, we introduce two complementary strategies to\nenhance video generation: To ensure consistent reproduction of human motion, we\ninject the physical identity into the model through video fine-tuning. For\nhigher-resolution outputs with finer details, a patch-based denoising algorithm\nis employed. Experimental results demonstrate that our method outperforms\nrecent state-of-the-art approaches and validate the effectiveness of our\nproposed strategies.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00403v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00403v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.37,
      "weak_supervision_score": 0.343,
      "diffusion_reasoning_score": 0.406,
      "distributed_training_score": 0.343,
      "datasets_score": 0.321,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper utilizes a diffusion-based model (Human4DiT) for generating videos from alternative perspectives to enhance human avatar reconstruction, which involves iterative refinement in the generative process. However, it does not adapt this process for solving complex logical tasks, multi-step reasoning, or treating a chain-of-thought as a single entity. The focus is on visual generation for 3D reconstruction, not on logical reasoning applications.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00414",
      "title": "MedSEBA: Synthesizing Evidence-Based Answers Grounded in Evolving\n  Medical Literature",
      "authors": [
        "Juraj Vladika",
        "Florian Matthes"
      ],
      "categories": [
        "cs.CL (Computation and Language)",
        "cs.AI (Artificial Intelligence)",
        "cs.IR (Information Retrieval)"
      ],
      "abstract": "In the digital age, people often turn to the Internet in search of medical\nadvice and recommendations. With the increasing volume of online content, it\nhas become difficult to distinguish reliable sources from misleading\ninformation. Similarly, millions of medical studies are published every year,\nmaking it challenging for researchers to keep track of the latest scientific\nfindings. These evolving studies can reach differing conclusions, which is not\nreflected in traditional search tools. To address these challenges, we\nintroduce MedSEBA, an interactive AI-powered system for synthesizing\nevidence-based answers to medical questions. It utilizes the power of Large\nLanguage Models to generate coherent and expressive answers, but grounds them\nin trustworthy medical studies dynamically retrieved from the research database\nPubMed. The answers consist of key points and arguments, which can be traced\nback to respective studies. Notably, the platform also provides an overview of\nthe extent to which the most relevant studies support or refute the given\nmedical claim, and a visualization of how the research consensus evolved\nthrough time. Our user study revealed that medical experts and lay users find\nthe system usable and helpful, and the provided answers trustworthy and\ninformative. This makes the system well-suited for both everyday health\nquestions and advanced research insights.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00414v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00414v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.342,
      "weak_supervision_score": 0.346,
      "diffusion_reasoning_score": 0.42,
      "distributed_training_score": 0.299,
      "datasets_score": 0.344,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper introduces MedSEBA, a system using Large Language Models (LLMs) for synthesizing evidence-based medical answers from PubMed, focusing on retrieval, generation, and visualization of medical literature. It does not involve diffusion models, iterative refinement processes, or multi-step logical reasoning via diffusion. The core contribution is on LLM-based answer synthesis, not diffusion-based reasoning.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00419",
      "title": "LightVLM: Acceleraing Large Multimodal Models with Pyramid Token Merging\n  and KV Cache Compression",
      "authors": [
        "Lianyu Hu",
        "Fanhua Shang",
        "Wei Feng",
        "Liang Wan"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "In this paper, we introduce LightVLM, a simple but effective method that can\nbe seamlessly deployed upon existing Vision-Language Models (VLMs) to greatly\naccelerate the inference process in a training-free manner. We divide the\ninference procedure of VLMs into two stages, i.e., encoding and decoding, and\npropose to simultaneously accelerate VLMs in both stages to largely improve\nmodel efficiency. During encoding, we propose pyramid token merging to reduce\ntokens of different LLM layers in a hierarchical manner by finally only keeping\na few dominant tokens to achieve high efficiency. During decoding, aimed at\nreducing the high latency of outputting long sequences, we propose KV Cache\ncompression to remove unnecessary caches to increase the network throughput.\nExperimental results show that LightVLM successfully retains 100% performance\nwhen only preserving 35% image tokens, and maintains around 98% performance\nwhen keeping only 3% image tokens. LightVLM could 2.02$\\times$ the network\nthroughput and reduce the prefilling time by 3.65$\\times$. LightVLM also makes\nlarge VLMs faster again by enabling a heavy model (e.g., InternVL2.5 26B) to\ninfer faster than significantly smaller models (e.g., InternVL2.5 8B),\nhopefully facilitating the real-world deployment. When generating long text\nsequences (e.g., 4096 tokens), LightVLM could reduce the inference time by\n3.21$\\times$, largely outperforming existing methods.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00419v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00419v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.372,
      "weak_supervision_score": 0.344,
      "diffusion_reasoning_score": 0.422,
      "distributed_training_score": 0.415,
      "datasets_score": 0.304,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "Not Relevant",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on accelerating Vision-Language Models (VLMs) through techniques like pyramid token merging and KV cache compression to improve inference efficiency, without any involvement of diffusion models, iterative refinement processes, or multi-step logical reasoning. There is no mention of adapting diffusion for reasoning tasks, making it unrelated to this topic.",
      "distributed_training_justification": "The paper addresses inference optimization for VLMs, such as reducing tokens and compressing caches, but does not discuss distributed training, parallel computing, multi-node setups, or strategies for partitioning data/computation during model training. It is solely about enhancing inference speed, not training acceleration across processors or nodes.",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00428",
      "title": "Mixture of Global and Local Experts with Diffusion Transformer for\n  Controllable Face Generation",
      "authors": [
        "Xuechao Zou",
        "Shun Zhang",
        "Xing Fu",
        "Yue Li",
        "Kai Li",
        "Yushe Cao",
        "Congyan Lang",
        "Pin Tao",
        "Junliang Xing"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Controllable face generation poses critical challenges in generative modeling\ndue to the intricate balance required between semantic controllability and\nphotorealism. While existing approaches struggle with disentangling semantic\ncontrols from generation pipelines, we revisit the architectural potential of\nDiffusion Transformers (DiTs) through the lens of expert specialization. This\npaper introduces Face-MoGLE, a novel framework featuring: (1)\nSemantic-decoupled latent modeling through mask-conditioned space\nfactorization, enabling precise attribute manipulation; (2) A mixture of global\nand local experts that captures holistic structure and region-level semantics\nfor fine-grained controllability; (3) A dynamic gating network producing\ntime-dependent coefficients that evolve with diffusion steps and spatial\nlocations. Face-MoGLE provides a powerful and flexible solution for\nhigh-quality, controllable face generation, with strong potential in generative\nmodeling and security applications. Extensive experiments demonstrate its\neffectiveness in multimodal and monomodal face generation settings and its\nrobust zero-shot generalization capability. Project page is available at\nhttps://github.com/XavierJiezou/Face-MoGLE.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00428v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00428v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.327,
      "weak_supervision_score": 0.321,
      "diffusion_reasoning_score": 0.509,
      "distributed_training_score": 0.351,
      "datasets_score": 0.315,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper's main contribution is a framework for controllable face generation using Diffusion Transformers, focusing on image synthesis with semantic control and expert mixtures. It employs diffusion models for iterative denoising in visual tasks, but does not adapt this process for complex logical reasoning, Chain-of-Thought entities, or multi-step problem-solving as specified in the topic.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00442",
      "title": "SemaMIL: Semantic Reordering with Retrieval-Guided State Space Modeling\n  for Whole Slide Image Classification",
      "authors": [
        "Lubin Gan",
        "Xiaoman Wu",
        "Jing Zhang",
        "Zhifeng Wang",
        "Linhao Qu",
        "Siying Wu",
        "Xiaoyan Sun"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Multiple instance learning (MIL) has become the leading approach for\nextracting discriminative features from whole slide images (WSIs) in\ncomputational pathology. Attention-based MIL methods can identify key patches\nbut tend to overlook contextual relationships. Transformer models are able to\nmodel interactions but require quadratic computational cost and are prone to\noverfitting. State space models (SSMs) offer linear complexity, yet shuffling\npatch order disrupts histological meaning and reduces interpretability. In this\nwork, we introduce SemaMIL, which integrates Semantic Reordering (SR), an\nadaptive method that clusters and arranges semantically similar patches in\nsequence through a reversible permutation, with a Semantic-guided Retrieval\nState Space Module (SRSM) that chooses a representative subset of queries to\nadjust state space parameters for improved global modeling. Evaluation on four\nWSI subtype datasets shows that, compared to strong baselines, SemaMIL achieves\nstate-of-the-art accuracy with fewer FLOPs and parameters.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00442v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00442v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.31,
      "weak_supervision_score": 0.373,
      "diffusion_reasoning_score": 0.387,
      "distributed_training_score": 0.336,
      "datasets_score": 0.314,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00446",
      "title": "NEWSAGENT: Benchmarking Multimodal Agents as Journalists with Real-World\n  Newswriting Tasks",
      "authors": [
        "Yen-Che Chien",
        "Kuang-Da Wang",
        "Wei-Yao Wang",
        "Wen-Chih Peng"
      ],
      "categories": [
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Recent advances in autonomous digital agents from industry (e.g., Manus AI\nand Gemini's research mode) highlight potential for structured tasks by\nautonomous decision-making and task decomposition; however, it remains unclear\nto what extent the agent-based systems can improve multimodal web data\nproductivity. We study this in the realm of journalism, which requires\niterative planning, interpretation, and contextual reasoning from multimodal\nraw contents to form a well structured news. We introduce NEWSAGENT, a\nbenchmark for evaluating how agents can automatically search available raw\ncontents, select desired information, and edit and rephrase to form a news\narticle by accessing core journalistic functions. Given a writing instruction\nand firsthand data as how a journalist initiates a news draft, agents are\ntasked to identify narrative perspectives, issue keyword-based queries,\nretrieve historical background, and generate complete articles. Unlike typical\nsummarization or retrieval tasks, essential context is not directly available\nand must be actively discovered, reflecting the information gaps faced in\nreal-world news writing. NEWSAGENT includes 6k human-verified examples derived\nfrom real news, with multimodal contents converted to text for broad model\ncompatibility. We evaluate open- and closed-sourced LLMs with commonly-used\nagentic frameworks on NEWSAGENT, which shows that agents are capable of\nretrieving relevant facts but struggling with planning and narrative\nintegration. We believe that NEWSAGENT serves a realistic testbed for iterating\nand evaluating agent capabilities in terms of multimodal web data manipulation\nto real-world productivity.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00446v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00446v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.377,
      "weak_supervision_score": 0.363,
      "diffusion_reasoning_score": 0.42,
      "distributed_training_score": 0.313,
      "datasets_score": 0.379,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper introduces NEWSAGENT, a benchmark for evaluating multimodal agents in journalistic tasks, focusing on iterative planning, searching, and editing using LLMs and agentic frameworks. While it involves iterative refinement in workflows, such as progressively editing drafts, there is no mention or use of diffusion models or their adaptation for multi-step logical reasoning. The core contributions center on agent capabilities for web data manipulation, not diffusion-based approaches, so it does not align with the topic.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00450",
      "title": "Stage-wise Adaptive Label Distribution for Facial Age Estimation",
      "authors": [
        "Bo Wu",
        "Zhiqi Ai",
        "Jun Jiang",
        "Congcong Zhu",
        "Shugong Xu"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Label ambiguity poses a significant challenge in age estimation tasks. Most\nexisting methods address this issue by modeling correlations between adjacent\nage groups through label distribution learning. However, they often overlook\nthe varying degrees of ambiguity present across different age stages. In this\npaper, we propose a Stage-wise Adaptive Label Distribution Learning (SA-LDL)\nalgorithm, which leverages the observation -- revealed through our analysis of\nembedding similarities between an anchor and all other ages -- that label\nambiguity exhibits clear stage-wise patterns. By jointly employing stage-wise\nadaptive variance modeling and weighted loss function, SA-LDL effectively\ncaptures the complex and structured nature of label ambiguity, leading to more\naccurate and robust age estimation. Extensive experiments demonstrate that\nSA-LDL achieves competitive performance, with MAE of 1.74 and 2.15 on the\nMORPH-II and FG-NET datasets.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00450v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00450v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.335,
      "weak_supervision_score": 0.381,
      "diffusion_reasoning_score": 0.326,
      "distributed_training_score": 0.331,
      "datasets_score": 0.317,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00451",
      "title": "Encoder-Only Image Registration",
      "authors": [
        "Xiang Chen",
        "Renjiu Hu",
        "Jinwei Zhang",
        "Yuxi Zhang",
        "Xinyao Yue",
        "Min Liu",
        "Yaonan Wang",
        "Hang Zhang"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Learning-based techniques have significantly improved the accuracy and speed\nof deformable image registration. However, challenges such as reducing\ncomputational complexity and handling large deformations persist. To address\nthese challenges, we analyze how convolutional neural networks (ConvNets)\ninfluence registration performance using the Horn-Schunck optical flow\nequation. Supported by prior studies and our empirical experiments, we observe\nthat ConvNets play two key roles in registration: linearizing local intensities\nand harmonizing global contrast variations. Based on these insights, we propose\nthe Encoder-Only Image Registration (EOIR) framework, designed to achieve a\nbetter accuracy-efficiency trade-off. EOIR separates feature learning from flow\nestimation, employing only a 3-layer ConvNet for feature extraction and a set\nof 3-layer flow estimators to construct a Laplacian feature pyramid,\nprogressively composing diffeomorphic deformations under a large-deformation\nmodel. Results on five datasets across different modalities and anatomical\nregions demonstrate EOIR's effectiveness, achieving superior\naccuracy-efficiency and accuracy-smoothness trade-offs. With comparable\naccuracy, EOIR provides better efficiency and smoothness, and vice versa. The\nsource code of EOIR is publicly available on\nhttps://github.com/XiangChen1994/EOIR.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00451v2",
      "pdf_url": "http://arxiv.org/pdf/2509.00451v2",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.302,
      "weak_supervision_score": 0.283,
      "diffusion_reasoning_score": 0.345,
      "distributed_training_score": 0.31,
      "datasets_score": 0.25,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00461",
      "title": "TECP: Token-Entropy Conformal Prediction for LLMs",
      "authors": [
        "Beining Xu",
        "Yongming Lu"
      ],
      "categories": [
        "cs.CL (Computation and Language)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Uncertainty quantification (UQ) for open-ended language generation remains a\ncritical yet underexplored challenge, especially under black-box constraints\nwhere internal model signals are inaccessible. In this paper, we introduce\nToken-Entropy Conformal Prediction (TECP), a novel framework that leverages\ntoken-level entropy as a logit-free, reference-free uncertainty measure and\nintegrates it into a split conformal prediction (CP) pipeline to construct\nprediction sets with formal coverage guarantees. Unlike existing approaches\nthat rely on semantic consistency heuristics or white-box features, TECP\ndirectly estimates epistemic uncertainty from the token entropy structure of\nsampled generations and calibrates uncertainty thresholds via CP quantiles to\nensure provable error control. Empirical evaluations across six large language\nmodels and two benchmarks (CoQA and TriviaQA) demonstrate that TECP\nconsistently achieves reliable coverage and compact prediction sets,\noutperforming prior self-consistency-based UQ methods. Our method provides a\nprincipled and efficient solution for trustworthy generation in black-box LLM\nsettings.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00461v2",
      "pdf_url": "http://arxiv.org/pdf/2509.00461v2",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.408,
      "weak_supervision_score": 0.407,
      "diffusion_reasoning_score": 0.443,
      "distributed_training_score": 0.329,
      "datasets_score": 0.325,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "Not Relevant",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper focuses on uncertainty quantification for LLMs using token-entropy conformal prediction, without any discussion of training models with human feedback, reward models, or reinforcement learning techniques. While it mentions LLMs aligned with human preferences in general terms, this is not the paper's main contribution and does not involve RLHF.",
      "weak_supervision_justification": "The paper's main contribution is a framework for uncertainty quantification in LLMs, using conformal prediction and token entropy, and does not involve training models with programmatically generated noisy labels or weak supervision sources. Although it mentions minimal assumptions and no reliance on labeled supervision for prediction sets, this is unrelated to weak supervision as a training paradigm.",
      "diffusion_reasoning_justification": "The paper introduces a method for uncertainty quantification based on token entropy and conformal prediction, with no reference to diffusion models, iterative refinement processes, or multi-step logical reasoning. It does not adapt diffusion techniques for reasoning tasks or treat reasoning paths holistically.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00465",
      "title": "Embodied Spatial Intelligence: from Implicit Scene Modeling to Spatial\n  Reasoning",
      "authors": [
        "Jiading Fang"
      ],
      "categories": [
        "cs.RO (Robotics)",
        "cs.AI (Artificial Intelligence)",
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "This thesis introduces \"Embodied Spatial Intelligence\" to address the\nchallenge of creating robots that can perceive and act in the real world based\non natural language instructions. To bridge the gap between Large Language\nModels (LLMs) and physical embodiment, we present contributions on two fronts:\nscene representation and spatial reasoning. For perception, we develop robust,\nscalable, and accurate scene representations using implicit neural models, with\ncontributions in self-supervised camera calibration, high-fidelity depth field\ngeneration, and large-scale reconstruction. For spatial reasoning, we enhance\nthe spatial capabilities of LLMs by introducing a novel navigation benchmark, a\nmethod for grounding language in 3D, and a state-feedback mechanism to improve\nlong-horizon decision-making. This work lays a foundation for robots that can\nrobustly perceive their surroundings and intelligently act upon complex,\nlanguage-based commands.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00465v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00465v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.393,
      "weak_supervision_score": 0.36,
      "diffusion_reasoning_score": 0.497,
      "distributed_training_score": 0.34,
      "datasets_score": 0.341,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on embodied spatial intelligence for robots, emphasizing scene representation using implicit neural models and spatial reasoning with LLMs, including navigation benchmarks and state-feedback mechanisms. It does not mention or utilize diffusion models for multi-step logical reasoning or iterative refinement processes, such as treating a Chain-of-Thought as a single entity. Therefore, there is no clear component aligning with diffusion-based reasoning.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00476",
      "title": "Cross-Domain Malware Detection via Probability-Level Fusion of\n  Lightweight Gradient Boosting Models",
      "authors": [
        "Omar Khalid Ali Mohamed"
      ],
      "categories": [
        "cs.CR (Cryptography and Security)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "The escalating sophistication of malware necessitates robust detection\nmechanisms that generalize across diverse data sources. Traditional\nsingle-dataset models struggle with cross-domain generalization and often incur\nhigh computational costs. This paper presents a novel, lightweight framework\nfor malware detection that employs probability-level fusion across three\ndistinct datasets: EMBER (static features), API Call Sequences (behavioral\nfeatures), and CIC Obfuscated Memory (memory patterns). Our method trains\nindividual LightGBM classifiers on each dataset, selects top predictive\nfeatures to ensure efficiency, and fuses their prediction probabilities using\noptimized weights determined via grid search. Extensive experiments demonstrate\nthat our fusion approach achieves a macro F1-score of 0.823 on a cross-domain\nvalidation set, significantly outperforming individual models and providing\nsuperior generalization. The framework maintains low computational overhead,\nmaking it suitable for real-time deployment, and all code and data are provided\nfor full reproducibility.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00476v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00476v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.326,
      "weak_supervision_score": 0.376,
      "diffusion_reasoning_score": 0.382,
      "distributed_training_score": 0.355,
      "datasets_score": 0.37,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00479",
      "title": "A Novel Method to Determine Total Oxidant Concentration Produced by\n  Non-Thermal Plasma Based on Image Processing and Machine Learning",
      "authors": [
        "Mirkan Emir Sancak",
        "Unal Sen",
        "Ulker Diler Keris-Sen"
      ],
      "categories": [
        "eess.IV (Image and Video Processing)",
        "cs.AI (Artificial Intelligence)",
        "cs.LG (Machine Learning)"
      ],
      "abstract": "Accurate determination of total oxidant concentration ([Ox]_{tot}) in\nnon-thermal plasma (NTP)-treated aqueous systems remains a critical challenge\ndue to the transient nature of reactive oxygen and nitrogen species and the\nsubjectivity of conventional titration methods used for [Ox]_{tot}\ndetermination. This study introduces a novel, color-based computer analysis\n(CBCA) method that integrates advanced image processing with machine learning\n(ML) to quantify colorimetric shifts in potassium iodide (KI) solutions during\noxidation. First, a custom-built visual data acquisition system captured\nhigh-resolution video of the color transitions in a KI solution during\noxidation with an NTP system. The change in [Ox]_{tot} during the experiments\nwas monitored with a standard titrimetric method. Second, the captured frames\nwere processed using a robust image processing pipeline to extract RGB, HSV,\nand Lab color features. The extracted features were statistically evaluated,\nand the results revealed strong linear correlations with the measured\n[Ox]_{tot} values, particularly in the saturation (HSV), a and b (Lab), and\nblue (RGB) channels. Subsequently, the [Ox]_{tot} measurements and the\nextracted color features were used to train and validate five ML models. Among\nthem, linear regression and gradient boosting models achieved the highest\npredictive accuracy (R^2 > 0.990). It was also found that reducing the feature\nset from nine to four resulted in comparable performance with improved\nprediction efficiency, especially for gradient boosting. Finally, comparison of\nthe model predictions with real titration measurements revealed that the CBCA\nsystem successfully predicts the [Ox]_{tot} in KI solution with high accuracy\n(R^2 > 0.998) even with a reduced number of features.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00479v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00479v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "extraction_failed",
      "embedding_status": "completed",
      "rlhf_score": 0.285,
      "weak_supervision_score": 0.325,
      "diffusion_reasoning_score": 0.29,
      "distributed_training_score": 0.283,
      "datasets_score": 0.274,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00481",
      "title": "Multi-Agent Data Visualization and Narrative Generation",
      "authors": [
        "Anton Wolter",
        "Georgios Vidalakis",
        "Michael Yu",
        "Ankit Grover",
        "Vaishali Dhanoa"
      ],
      "categories": [
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Recent advancements in the field of AI agents have impacted the way we work,\nenabling greater automation and collaboration between humans and agents. In the\ndata visualization field, multi-agent systems can be useful for employing\nagents throughout the entire data-to-communication pipeline. We present a\nlightweight multi-agent system that automates the data analysis workflow, from\ndata exploration to generating coherent visual narratives for insight\ncommunication. Our approach combines a hybrid multi-agent architecture with\ndeterministic components, strategically externalizing critical logic from LLMs\nto improve transparency and reliability. The system delivers granular, modular\noutputs that enable surgical modifications without full regeneration,\nsupporting sustainable human-AI collaboration. We evaluated our system across 4\ndiverse datasets, demonstrating strong generalizability, narrative quality, and\ncomputational efficiency with minimal dependencies.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00481v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00481v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.359,
      "weak_supervision_score": 0.35,
      "diffusion_reasoning_score": 0.428,
      "distributed_training_score": 0.32,
      "datasets_score": 0.404,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "Tangentially Relevant",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on a multi-agent system for data visualization and narrative generation, using hybrid architectures and deterministic components, but it does not involve diffusion models, iterative refinement for reasoning, or any multi-step logical reasoning based on diffusion processes.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "The paper evaluates its multi-agent system on 4 diverse datasets to demonstrate generalizability and efficiency, which touches on dataset evaluation in AI applications, but its primary contribution is the development of the visualization system, not the creation, analysis, benchmarking, or curation of datasets.",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00482",
      "title": "Talk Less, Call Right: Enhancing Role-Play LLM Agents with Automatic\n  Prompt Optimization and Role Prompting",
      "authors": [
        "Saksorn Ruangtanusak",
        "Pittawat Taveekitworachai",
        "Kunat Pipatanakul"
      ],
      "categories": [
        "cs.CL (Computation and Language)",
        "cs.AI (Artificial Intelligence)",
        "cs.HC (Human-Computer Interaction)"
      ],
      "abstract": "This report investigates approaches for prompting a tool-augmented large\nlanguage model (LLM) to act as a role-playing dialogue agent in the API track\nof the Commonsense Persona-grounded Dialogue Challenge (CPDC) 2025. In this\nsetting, dialogue agents often produce overly long in-character responses\n(over-speaking) while failing to use tools effectively according to the persona\n(under-acting), such as generating function calls that do not exist or making\nunnecessary tool calls before answering. We explore four prompting approaches\nto address these issues: 1) basic role prompting, 2) human-crafted role\nprompting, 3) automatic prompt optimization (APO), and 4) rule-based role\nprompting. The rule-based role prompting (RRP) approach achieved the best\nperformance through two novel techniques--character-card/scene-contract design\nand strict enforcement of function calling--which led to an overall score of\n0.571, improving on the zero-shot baseline score of 0.519. These findings\ndemonstrate that RRP design can substantially improve the effectiveness and\nreliability of role-playing dialogue agents compared with more elaborate\nmethods such as APO. To support future efforts in developing persona prompts,\nwe are open-sourcing all of our best-performing prompts and the APO tool.\nSource code is available at https://github.com/scb-10x/apo.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00482v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00482v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.468,
      "weak_supervision_score": 0.365,
      "diffusion_reasoning_score": 0.397,
      "distributed_training_score": 0.304,
      "datasets_score": 0.288,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper's main contribution is on prompting techniques for role-playing LLM agents, including basic role prompting, human-crafted prompting, automatic prompt optimization, and rule-based prompting. It does not involve reinforcement learning, human feedback for training a reward model, or fine-tuning models based on human-ranked data, as required for RLHF.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00483",
      "title": "Exploring Decision-Making Capabilities of LLM Agents: An Experimental\n  Study on Jump-Jump Game",
      "authors": [
        "Juwu Li"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "The Jump-Jump game, as a simple yet challenging casual game, provides an\nideal testing environment for studying LLM decision-making capabilities. The\ngame requires players to precisely control jumping force based on current\nposition and target platform distance, involving multiple cognitive aspects\nincluding spatial reasoning, physical modeling, and strategic planning. It\nillustrates the basic gameplay mechanics of the Jump-Jump game, where the\nplayer character (red circle) must jump across platforms with appropriate force\nto maximize score.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00483v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00483v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.422,
      "weak_supervision_score": 0.346,
      "diffusion_reasoning_score": 0.452,
      "distributed_training_score": 0.302,
      "datasets_score": 0.311,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper focuses on designing an LLM-based agent for the Jump-Jump game using prompt optimization and experimental validation, without any mention of human feedback, reward models, or reinforcement learning techniques for fine-tuning. It does not involve aligning AI with human preferences through RLHF.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper examines LLM decision-making in a game via prompt strategies and cognitive aspects like spatial reasoning, but it does not reference diffusion models, iterative refinement processes, or multi-step logical reasoning as described in diffusion-based approaches. There is no indication of treating a Chain-of-Thought as a holistically refined entity.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00484",
      "title": "VideoRewardBench: Comprehensive Evaluation of Multimodal Reward Models\n  for Video Understanding",
      "authors": [
        "Zhihong Zhang",
        "Xiaojian Huang",
        "Jin Xu",
        "Zhuodong Luo",
        "Xinzhi Wang",
        "Jiansheng Wei",
        "Xuejin Chen"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Multimodal reward models (MRMs) play a crucial role in the training,\ninference, and evaluation of Large Vision Language Models (LVLMs) by assessing\nresponse quality. However, existing benchmarks for evaluating MRMs in the video\ndomain suffer from a limited number and diversity of questions, a lack of\ncomprehensive evaluation dimensions, and inadequate evaluation of diverse types\nof MRMs. To address these gaps, we introduce VideoRewardBench, the first\ncomprehensive benchmark covering four core aspects of video understanding:\nperception, knowledge, reasoning, and safety. Through our AI-assisted data\npipeline, we curate a high-quality preference dataset of 1,563 annotated\nsamples, including 1,482 unique videos and 1,559 distinct questions--15 times\nthe number found in the most question-rich prior benchmark. Each sample is a\ntriplet consisting of a video-text prompt, a chosen response, and a rejected\nresponse. We also conduct a comprehensive evaluation across 28 multimodal\nreward models spanning three categories: generative, discriminative, and\nsemi-scalar. Results show that even the top-performing model GPT-4o achieves\nonly 57.0% overall accuracy, and the state-of-the-art open-source model\nQwen2.5-VL-72B reaches merely 53.3%. Our analysis further reveals three key\ninsights: (i) MRMs trained with reinforcement learning (RL) do not necessarily\nexhibit stronger cross-modal generalization than those trained without RL; (ii)\nexcept for discriminative MRMs, other types of MRMs across varying model\ncapacities can benefit from inference-time scaling; and (iii) variations in\ninput video frame count have different effects on different types of MRMs. We\nbelieve VideoRewardBench offers a challenging and valuable benchmark for\nadvancing the evaluation and development of MRMs in the video domain.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00484v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00484v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.485,
      "weak_supervision_score": 0.364,
      "diffusion_reasoning_score": 0.431,
      "distributed_training_score": 0.359,
      "datasets_score": 0.4,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Moderately Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "Highly Relevant",
      "rlhf_justification": "The paper discusses multimodal reward models (MRMs) that provide reward signals for RLHF, as used in training LVLMs, and evaluates MRMs trained with RL. However, the main focus is on benchmarking MRMs rather than developing or innovating RLHF systems directly, making it moderately relevant.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper does not mention diffusion models, iterative refinement processes, or any multi-step logical reasoning adapted from diffusion techniques. It focuses on general video understanding and MRM evaluation, with no connection to diffusion-based methods.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "The paper's primary contribution is the creation and evaluation of the VideoRewardBench dataset, including its curation methodology, annotation process, and benchmarking for MRMs in video understanding, directly aligning with research on datasets.",
      "llm_score_status": "completed",
      "summary": "This paper introduces VideoRewardBench, a comprehensive benchmark designed to evaluate multimodal reward models (MRMs) for video understanding, addressing limitations in existing benchmarks by incorporating four key dimensions: perception, knowledge, reasoning, and safety, with a dataset of 1,563 annotated samples derived from an AI-assisted pipeline. The authors evaluate 28 MRMs across generative, discriminative, and semi-scalar categories, revealing suboptimal performance even from top models like GPT-4o (57% accuracy) and providing key insights into the effects of reinforcement learning, inference-time scaling, and video frame counts on model generalization and effectiveness.",
      "novelty_score": "High",
      "novelty_justification": "The paper introduces a truly new and comprehensive benchmark for MRMs in video understanding, significantly expanding on prior works with a much larger dataset and broader evaluation dimensions, thus advancing the state-of-the-art in multimodal model assessment.",
      "impact_score": "Moderate",
      "impact_justification": "The work is likely to be cited and built upon within the subfield of AI and computer vision for improving MRM development and evaluation, though its influence may be limited to specific applications in video understanding.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "The paper offers a high-quality, significant contribution by establishing a robust benchmark for MRMs, making it essential for researchers focused on multimodal AI to stay informed on advancements in video evaluation techniques.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/a2b7b7670eb8b27ded1e8a0e34399d9951a2c581",
      "total_authors": 7,
      "authors_found": 6,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": [
        {
          "name": "Zhihong Zhang",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2378662457"
        },
        {
          "name": "Xiaojian Huang",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2378615501"
        },
        {
          "name": "Jin Xu",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2378724169"
        },
        {
          "name": "Zhuodong Luo",
          "h_index": null,
          "profile_url": null
        },
        {
          "name": "Xinzhi Wang",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2378606990"
        },
        {
          "name": "Jiansheng Wei",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2379154188"
        },
        {
          "name": "Xuejin Chen",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2378771295"
        }
      ]
    },
    {
      "id": "2509.00490",
      "title": "Multi-Focused Video Group Activities Hashing",
      "authors": [
        "Zhongmiao Qi",
        "Yan Jiang",
        "Bolin Zhang",
        "Lijun Guo",
        "Chong Wang",
        "Qiangbo Qian"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "With the explosive growth of video data in various complex scenarios, quickly\nretrieving group activities has become an urgent problem. However, many tasks\ncan only retrieve videos focusing on an entire video, not the activity\ngranularity. To solve this problem, we propose a new STVH (spatiotemporal\ninterleaved video hashing) technique for the first time. Through a unified\nframework, the STVH simultaneously models individual object dynamics and group\ninteractions, capturing the spatiotemporal evolution on both group visual\nfeatures and positional features. Moreover, in real-life video retrieval\nscenarios, it may sometimes require activity features, while at other times, it\nmay require visual features of objects. We then further propose a novel M-STVH\n(multi-focused spatiotemporal video hashing) as an enhanced version to handle\nthis difficult task. The advanced method incorporates hierarchical feature\nintegration through multi-focused representation learning, allowing the model\nto jointly focus on activity semantics features and object visual features. We\nconducted comparative experiments on publicly available datasets, and both STVH\nand M-STVH can achieve excellent results.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00490v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00490v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.325,
      "weak_supervision_score": 0.272,
      "diffusion_reasoning_score": 0.32,
      "distributed_training_score": 0.317,
      "datasets_score": 0.297,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00496",
      "title": "ResearchQA: Evaluating Scholarly Question Answering at Scale Across 75\n  Fields with Survey-Mined Questions and Rubrics",
      "authors": [
        "Li S. Yifei",
        "Allen Chang",
        "Chaitanya Malaviya",
        "Mark Yatskar"
      ],
      "categories": [
        "cs.CL (Computation and Language)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Evaluating long-form responses to research queries heavily relies on expert\nannotators, restricting attention to areas like AI where researchers can\nconveniently enlist colleagues. Yet, research expertise is widespread: survey\narticles synthesize knowledge distributed across the literature. We introduce\nResearchQA, a resource for evaluating LLM systems by distilling survey articles\nfrom 75 research fields into 21K queries and 160K rubric items. Each rubric,\nderived jointly with queries from survey sections, lists query-specific answer\nevaluation criteria, i.e., citing papers, making explanations, and describing\nlimitations. Assessments by 31 Ph.D. annotators in 8 fields indicate 96% of\nqueries support Ph.D. information needs and 87% of rubric items should be\naddressed in system responses by a sentence or more. Using our rubrics, we are\nable to construct an automatic pairwise judge obtaining 74% agreement with\nexpert judgments. We leverage ResearchQA to analyze competency gaps in 18\nsystems in over 7.6K pairwise evaluations. No parametric or retrieval-augmented\nsystem we evaluate exceeds 70% on covering rubric items, and the\nhighest-ranking agentic system shows 75% coverage. Error analysis reveals that\nthe highest-ranking system fully addresses less than 11% of citation rubric\nitems, 48% of limitation items, and 49% of comparison items. We release our\ndata to facilitate more comprehensive multi-field evaluations.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00496v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00496v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.42,
      "weak_supervision_score": 0.415,
      "diffusion_reasoning_score": 0.383,
      "distributed_training_score": 0.366,
      "datasets_score": 0.46,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Tangentially Relevant",
      "weak_supervision_relevance": "Not Relevant",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "Highly Relevant",
      "rlhf_justification": "The paper uses human feedback for evaluating LLM responses, such as through annotator preferences and rubrics, which indirectly relates to aligning models with human judgments. However, it does not involve training or fine-tuning models using RLHF techniques, focusing instead on evaluation rather than the RLHF process itself.",
      "weak_supervision_justification": "The paper involves distilling queries and rubrics from survey articles, which might include some automated extraction, but it does not address weak supervision as a machine learning approach for generating training labels from noisy sources. The main focus is on creating an evaluation resource, not on weak supervision methodologies.",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "The paper's primary contribution is the creation and evaluation of the ResearchQA dataset, which includes 21K queries and 160K rubric items across 75 fields for benchmarking LLM systems. This directly aligns with research on creating, analyzing, and evaluating datasets for AI applications, including benchmarking and dataset analysis.",
      "llm_score_status": "completed",
      "summary": "The paper introduces ResearchQA, a comprehensive resource derived from academic survey articles across 75 research fields, featuring 21,000 queries and 160,000 rubric items designed to evaluate large language models' (LLMs) ability to answer scholarly questions. By validating these queries and rubrics with 31 Ph.D. annotators and developing an automatic pairwise judge that achieves 74% agreement with experts, the authors assess 18 LLMs through over 7,600 evaluations, revealing significant competency gaps—such as no system exceeding 70% rubric coverage and deficiencies in citing papers, describing limitations, and making comparisons—while highlighting the need for multi-field evaluations and releasing the data for broader use.",
      "novelty_score": "Moderate",
      "novelty_justification": "The paper presents a clever combination of existing resources like academic surveys to create a scalable evaluation framework for LLMs, offering a notable improvement in addressing the challenge of expert-dependent assessments, though it does not introduce an entirely new problem or technique.",
      "impact_score": "High",
      "impact_justification": "The work provides a versatile, publicly available dataset that could enable widespread improvements in LLM evaluation for research tasks, potentially influencing future developments in AI assistants and multi-field benchmarking within the AI and computational linguistics communities.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "The paper delivers a high-quality, practical resource for evaluating LLMs on scholarly queries, making it essential for researchers in AI and language processing to understand and build upon for advancing model capabilities.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/783c03bd491b5c7533f259e0318e02b287e02e80",
      "total_authors": 4,
      "authors_found": 4,
      "highest_h_index": 26,
      "average_h_index": 10.5,
      "notable_authors_count": 2,
      "author_h_indexes": [
        {
          "name": "Li S. Yifei",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2378703850"
        },
        {
          "name": "Allen Chang",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2379606139"
        },
        {
          "name": "Chaitanya Malaviya",
          "h_index": 16,
          "profile_url": "https://www.semanticscholar.org/author/8805254"
        },
        {
          "name": "Mark Yatskar",
          "h_index": 26,
          "profile_url": "https://www.semanticscholar.org/author/2064210"
        }
      ]
    },
    {
      "id": "2509.00497",
      "title": "FLUID: A Fine-Grained Lightweight Urban Signalized-Intersection Dataset\n  of Dense Conflict Trajectories",
      "authors": [
        "Yiyang Chen",
        "Zhigang Wu",
        "Guohong Zheng",
        "Xuesong Wu",
        "Liwen Xu",
        "Haoyuan Tang",
        "Zhaocheng He",
        "Haipeng Zeng"
      ],
      "categories": [
        "cs.RO (Robotics)",
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "The trajectory data of traffic participants (TPs) is a fundamental resource\nfor evaluating traffic conditions and optimizing policies, especially at urban\nintersections. Although data acquisition using drones is efficient, existing\ndatasets still have limitations in scene representativeness, information\nrichness, and data fidelity. This study introduces FLUID, comprising a\nfine-grained trajectory dataset that captures dense conflicts at typical urban\nsignalized intersections, and a lightweight, full-pipeline framework for\ndrone-based trajectory processing. FLUID covers three distinct intersection\ntypes, with approximately 5 hours of recording time and featuring over 20,000\nTPs across 8 categories. Notably, the dataset averages two vehicle conflicts\nper minute, involving roughly 25% of all motor vehicles. FLUID provides\ncomprehensive data, including trajectories, traffic signals, maps, and raw\nvideos. Comparison with the DataFromSky platform and ground-truth measurements\nvalidates its high spatio-temporal accuracy. Through a detailed classification\nof motor vehicle conflicts and violations, FLUID reveals a diversity of\ninteractive behaviors, demonstrating its value for human preference mining,\ntraffic behavior modeling, and autonomous driving research.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00497v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00497v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "no_intro_found",
      "embedding_status": "completed",
      "rlhf_score": 0.322,
      "weak_supervision_score": 0.304,
      "diffusion_reasoning_score": 0.281,
      "distributed_training_score": 0.304,
      "datasets_score": 0.365,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00499",
      "title": "NeuralSVCD for Efficient Swept Volume Collision Detection",
      "authors": [
        "Dongwon Son",
        "Hojin Jung",
        "Beomjoon Kim"
      ],
      "categories": [
        "cs.RO (Robotics)",
        "cs.AI (Artificial Intelligence)",
        "cs.LG (Machine Learning)"
      ],
      "abstract": "Robot manipulation in unstructured environments requires efficient and\nreliable Swept Volume Collision Detection (SVCD) for safe motion planning.\nTraditional discrete methods potentially miss collisions between these points,\nwhereas SVCD continuously checks for collisions along the entire trajectory.\nExisting SVCD methods typically face a trade-off between efficiency and\naccuracy, limiting practical use. In this paper, we introduce NeuralSVCD, a\nnovel neural encoder-decoder architecture tailored to overcome this trade-off.\nOur approach leverages shape locality and temporal locality through distributed\ngeometric representations and temporal optimization. This enhances\ncomputational efficiency without sacrificing accuracy. Comprehensive\nexperiments show that NeuralSVCD consistently outperforms existing\nstate-of-the-art SVCD methods in terms of both collision detection accuracy and\ncomputational efficiency, demonstrating its robust applicability across diverse\nrobotic manipulation scenarios. Code and videos are available at\nhttps://neuralsvcd.github.io/.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00499v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00499v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.285,
      "weak_supervision_score": 0.298,
      "diffusion_reasoning_score": 0.34,
      "distributed_training_score": 0.341,
      "datasets_score": 0.265,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00507",
      "title": "Artificial Intelligence-Based Analysis of Ice Cream Melting Behavior\n  Under Various Ingredients",
      "authors": [
        "Zhang Lai Bin",
        "Zhen Bin It"
      ],
      "categories": [
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "The stability of ice cream during melting is a critical factor for consumer's\nacceptance and product quality. With the commonly added stabilizer to improve\ntexture, structure and slower melting as the factors to analyze. This report\nexplores the effects of locust bean gum, guar gum, maltodextrin, and\ncarrageenan on the melting behavior of homemade ice cream. The main objective\nwas to assess how these additives influence melting resistance and to identify\na more cost-effective recipe formulation. Ice cream samples incorporating each\nadditive were prepared and subjected to melting tests under controlled\nconditions. Timelapse recordings were used to capture and analyze the\nprogression of melting over time. Python and OpenCV is used for process and\nanalysis. Observations revealed that all samples retained a foam-like structure\neven after melting, suggesting the stabilizers contributed to the formation of\na stable air-cell matrix. Furthermore, when the melted samples were re-frozen\nand subsequently melted again, they displayed increased sturdiness, indicating\nimproved resilience of the ice cream structure. Comparative analysis of the\ndifferent stabilizers highlighted variations in their effectiveness, with some\noffering stronger melting resistance and structural support than others.\nOverall, the findings provide insights into the functional roles of commonly\nused food additives in ice cream formulation. By evaluating both performance\nand cost, this study demonstrates the potential for developing recipes that\nbalance durability with economic efficiency, contributing to practical\napplications in both small-scale and commercial ice cream production.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00507v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00507v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "extraction_failed",
      "embedding_status": "completed",
      "rlhf_score": 0.304,
      "weak_supervision_score": 0.292,
      "diffusion_reasoning_score": 0.29,
      "distributed_training_score": 0.255,
      "datasets_score": 0.3,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00508",
      "title": "TRUST: Token-dRiven Ultrasound Style Transfer for Cross-Device\n  Adaptation",
      "authors": [
        "Nhat-Tuong Do-Tran",
        "Ngoc-Hoang-Lam Le",
        "Ian Chiu",
        "Po-Tsun Paul Kuo",
        "Ching-Chun Huang"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Ultrasound images acquired from different devices exhibit diverse styles,\nresulting in decreased performance of downstream tasks. To mitigate the style\ngap, unpaired image-to-image (UI2I) translation methods aim to transfer images\nfrom a source domain, corresponding to new device acquisitions, to a target\ndomain where a frozen task model has been trained for downstream applications.\nHowever, existing UI2I methods have not explicitly considered filtering the\nmost relevant style features, which may result in translated images misaligned\nwith the needs of downstream tasks. In this work, we propose TRUST, a\ntoken-driven dual-stream framework that preserves source content while\ntransferring the common style of the target domain, ensuring that content and\nstyle remain unblended. Given multiple styles in the target domain, we\nintroduce a Token-dRiven (TR) module that operates from two perspectives: (1) a\ndata view--selecting \"suitable\" target tokens corresponding to each source\ntoken, and (2) a model view--identifying ``optimal\" target tokens for the\ndownstream model, guided by a behavior mirror loss. Additionally, we inject\nauxiliary prompts into the source encoder to match content representation with\ndownstream behavior. Experimental results on ultrasound datasets demonstrate\nthat TRUST outperforms existing UI2I methods in both visual quality and\ndownstream task performance.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00508v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00508v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.364,
      "weak_supervision_score": 0.353,
      "diffusion_reasoning_score": 0.393,
      "distributed_training_score": 0.369,
      "datasets_score": 0.307,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00509",
      "title": "Make me an Expert: Distilling from Generalist Black-Box Models into\n  Specialized Models for Semantic Segmentation",
      "authors": [
        "Yasser Benigmim",
        "Subhankar Roy",
        "Khalid Oublal",
        "Imad Eddine Marouf",
        "Slim Essid",
        "Vicky Kalogeiton",
        "Stéphane Lathuilière"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "The rise of Artificial Intelligence as a Service (AIaaS) democratizes access\nto pre-trained models via Application Programming Interfaces (APIs), but also\nraises a fundamental question: how can local models be effectively trained\nusing black-box models that do not expose their weights, training data, or\nlogits, a constraint in which current domain adaptation paradigms are\nimpractical ? To address this challenge, we introduce the Black-Box\nDistillation (B2D) setting, which enables local model adaptation under\nrealistic constraints: (1) the API model is open-vocabulary and trained on\nlarge-scale general-purpose data, and (2) access is limited to one-hot\npredictions only. We identify that open-vocabulary models exhibit significant\nsensitivity to input resolution, with different object classes being segmented\noptimally at different scales, a limitation termed the \"curse of resolution\".\nOur method, ATtention-Guided sCaler (ATGC), addresses this challenge by\nleveraging DINOv2 attention maps to dynamically select optimal scales for\nblack-box model inference. ATGC scores the attention maps with entropy to\nidentify informative scales for pseudo-labelling, enabling effective\ndistillation. Experiments demonstrate substantial improvements under black-box\nsupervision across multiple datasets while requiring only one-hot API\npredictions. Our code is available at https://github.com/yasserben/ATGC.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00509v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00509v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.369,
      "weak_supervision_score": 0.43,
      "diffusion_reasoning_score": 0.442,
      "distributed_training_score": 0.442,
      "datasets_score": 0.366,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "Highly Relevant",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "Not Relevant",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "The paper's main contribution involves using pseudo-labels generated from a black-box API model for training a student model in semantic segmentation. This aligns directly with weak supervision, as it relies on programmatically derived, potentially noisy labels (one-hot predictions) rather than hand-labeled data, enabling model training without perfect ground truth.",
      "diffusion_reasoning_justification": "The paper focuses on knowledge distillation for semantic segmentation using attention maps and pseudo-labels, with no mention of diffusion models, iterative refinement processes, or multi-step logical reasoning. It does not involve adapting diffusion for complex tasks.",
      "distributed_training_justification": "The paper's core contribution is on black-box distillation and dynamic scale selection for semantic segmentation, without any discussion of parallel computing, data partitioning, or accelerating training across multiple nodes or processors.",
      "datasets_justification": "below_threshold",
      "llm_score_status": "completed",
      "summary": "The paper introduces the Black-Box Distillation (B2D) setting for adapting local models from generalist black-box APIs in semantic segmentation, addressing the challenge of limited access to only one-hot predictions. It proposes the ATtention-Guided sCaler (ATGC) method, which uses DINOv2 attention maps scored by entropy to dynamically select optimal input resolutions for generating high-quality pseudo-labels, enabling effective knowledge distillation and demonstrating significant performance improvements on datasets like Cityscapes and ACDC.",
      "novelty_score": "High",
      "novelty_justification": "The paper introduces a truly new problem setting (B2D) and a novel technique (ATGC) that advances state-of-the-art in black-box model adaptation for semantic segmentation by addressing real-world API constraints without relying on logits.",
      "impact_score": "Moderate",
      "impact_justification": "The work is likely to be cited and built upon within the subfield of computer vision and model distillation, as it tackles practical challenges in AIaaS, though its influence may be limited to specific applications in semantic segmentation.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "This paper offers a strong, valuable contribution by formalizing a realistic black-box adaptation scenario and proposing an effective method, making it essential for researchers focused on model distillation and computer vision.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/d8ea748df570653d6ecc66e3c402acdb98880a38",
      "total_authors": 7,
      "authors_found": 7,
      "highest_h_index": 29,
      "average_h_index": 7.428571428571429,
      "notable_authors_count": 2,
      "author_h_indexes": [
        {
          "name": "Yasser Benigmim",
          "h_index": 2,
          "profile_url": "https://www.semanticscholar.org/author/2213257421"
        },
        {
          "name": "Subhankar Roy",
          "h_index": 13,
          "profile_url": "https://www.semanticscholar.org/author/2933549"
        },
        {
          "name": "Khalid Oublal",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2378713011"
        },
        {
          "name": "Imad Eddine Marouf",
          "h_index": 3,
          "profile_url": "https://www.semanticscholar.org/author/2137066954"
        },
        {
          "name": "S. Essid",
          "h_index": 29,
          "profile_url": "https://www.semanticscholar.org/author/1807587"
        },
        {
          "name": "Vicky Kalogeiton",
          "h_index": 3,
          "profile_url": "https://www.semanticscholar.org/author/2306786839"
        },
        {
          "name": "Stéphane Lathuilière",
          "h_index": 2,
          "profile_url": "https://www.semanticscholar.org/author/2313642648"
        }
      ]
    },
    {
      "id": "2509.00510",
      "title": "LLM-Assisted Iterative Evolution with Swarm Intelligence Toward\n  SuperBrain",
      "authors": [
        "Li Weigang",
        "Pedro Carvalho Brom",
        "Lucas Ramson Siefert"
      ],
      "categories": [
        "cs.AI (Artificial Intelligence)",
        "cs.CL (Computation and Language)"
      ],
      "abstract": "We propose a novel SuperBrain framework for collective intelligence, grounded\nin the co-evolution of large language models (LLMs) and human users. Unlike\nstatic prompt engineering or isolated agent simulations, our approach\nemphasizes a dynamic pathway from Subclass Brain to Superclass Brain: (1) A\nSubclass Brain arises from persistent, personalized interaction between a user\nand an LLM, forming a cognitive dyad with adaptive learning memory. (2) Through\nGA-assisted forward-backward evolution, these dyads iteratively refine prompts\nand task performance. (3) Multiple Subclass Brains coordinate via Swarm\nIntelligence, optimizing across multi-objective fitness landscapes and\nexchanging distilled heuristics. (4) Their standardized behaviors and cognitive\nsignatures integrate into a Superclass Brain, an emergent meta-intelligence\ncapable of abstraction, generalization and self-improvement. We outline the\ntheoretical constructs, present initial implementations (e.g., UAV scheduling,\nKU/KI keyword filtering) and propose a registry for cross-dyad knowledge\nconsolidation. This work provides both a conceptual foundation and an\narchitectural roadmap toward scalable, explainable and ethically aligned\ncollective AI.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00510v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00510v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.469,
      "weak_supervision_score": 0.415,
      "diffusion_reasoning_score": 0.439,
      "distributed_training_score": 0.401,
      "datasets_score": 0.341,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Tangentially Relevant",
      "weak_supervision_relevance": "Not Relevant",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "Moderately Relevant",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper discusses persistent human-LLM interactions and backward iterative evolution, where user feedback refines LLM strategies, similar to RLHF concepts. However, it focuses on GA-assisted evolution and prompt optimization rather than explicitly using a reward model and reinforcement learning for fine-tuning, making it only loosely connected.",
      "weak_supervision_justification": "The paper does not involve training models with programmatically generated or noisy labels; it centers on human-LLM co-evolution, GA-based optimization, and swarm intelligence, without any reference to weak supervision techniques for label generation.",
      "diffusion_reasoning_justification": "The paper describes iterative evolution and reasoning through GA and swarm intelligence but does not mention or adapt diffusion models for multi-step logical reasoning or holistic correction of reasoning paths.",
      "distributed_training_justification": "The framework involves coordination of multiple Subclass Brains via Swarm Intelligence, which implies distributed elements across users and agents, but it focuses on collective intelligence and evolution rather than specific techniques for parallelizing model training across nodes.",
      "datasets_justification": "below_threshold",
      "llm_score_status": "completed",
      "summary": "The paper proposes the SuperBrain framework, which fosters collective intelligence through the co-evolution of large language models (LLMs) and human users, progressing from individual user-LLM interactions forming Subclass Brains to coordinated swarms that synthesize a Superclass Brain capable of abstraction and self-improvement. It outlines a methodology involving genetic algorithm-assisted iterative evolution for refining prompts and task performance, demonstrates initial implementations like UAV scheduling and keyword filtering, and highlights innovations such as symbiotic human-LLM interactions and swarm intelligence for scalable, ethical AI, addressing limitations in current LLM-based systems.",
      "novelty_score": "High",
      "novelty_justification": "The paper introduces a truly innovative framework that integrates human-LLM co-evolution with swarm intelligence and iterative genetic algorithms to advance toward superintelligence, significantly extending beyond existing multi-agent systems and prompt engineering techniques.",
      "impact_score": "High",
      "impact_justification": "The work has the potential to broadly influence AI research and applications by providing a roadmap for human-centered collective intelligence, possibly leading to advancements in AGI and real-world scenarios like urban mobility.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "This paper offers a strong, innovative contribution to AI collective intelligence with conceptual depth and practical implications, making it valuable for researchers in human-AI interaction and multi-agent systems, though it remains more theoretical than empirically validated.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/16f421ce71fc5e581ac27e5dc84a1dd8039bf635",
      "total_authors": 3,
      "authors_found": 3,
      "highest_h_index": 2,
      "average_h_index": 1.3333333333333333,
      "notable_authors_count": 0,
      "author_h_indexes": [
        {
          "name": "Weigang Li",
          "h_index": 2,
          "profile_url": "https://www.semanticscholar.org/author/2315257383"
        },
        {
          "name": "P. C. Brom",
          "h_index": 2,
          "profile_url": "https://www.semanticscholar.org/author/2102214330"
        },
        {
          "name": "Lucas Ramson Siefert",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2378713565"
        }
      ]
    },
    {
      "id": "2509.00527",
      "title": "Learning Yourself: Class-Incremental Semantic Segmentation with\n  Language-Inspired Bootstrapped Disentanglement",
      "authors": [
        "Ruitao Wu",
        "Yifan Zhao",
        "Jia Li"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Class-Incremental Semantic Segmentation (CISS) requires continuous learning\nof newly introduced classes while retaining knowledge of past classes. By\nabstracting mainstream methods into two stages (visual feature extraction and\nprototype-feature matching), we identify a more fundamental challenge termed\ncatastrophic semantic entanglement. This phenomenon involves Prototype-Feature\nEntanglement caused by semantic misalignment during the incremental process,\nand Background-Increment Entanglement due to dynamic data evolution. Existing\ntechniques, which rely on visual feature learning without sufficient cues to\ndistinguish targets, introduce significant noise and errors. To address these\nissues, we introduce a Language-inspired Bootstrapped Disentanglement framework\n(LBD). We leverage the prior class semantics of pre-trained visual-language\nmodels (e.g., CLIP) to guide the model in autonomously disentangling features\nthrough Language-guided Prototypical Disentanglement and Manifold Mutual\nBackground Disentanglement. The former guides the disentangling of new\nprototypes by treating hand-crafted text features as topological templates,\nwhile the latter employs multiple learnable prototypes and mask-pooling-based\nsupervision for background-incremental class disentanglement. By incorporating\nsoft prompt tuning and encoder adaptation modifications, we further bridge the\ncapability gap of CLIP between dense and sparse tasks, achieving\nstate-of-the-art performance on both Pascal VOC and ADE20k, particularly in\nmulti-step scenarios.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00527v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00527v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.371,
      "weak_supervision_score": 0.415,
      "diffusion_reasoning_score": 0.413,
      "distributed_training_score": 0.376,
      "datasets_score": 0.356,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "Tangentially Relevant",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "The paper uses pre-trained CLIP text features as priors to guide feature disentanglement in semantic segmentation, which indirectly involves noisy or imprecise supervisory signals from language models. However, it still relies on ground truth labels for training, rather than programmatically generated labels as the core approach, making it only loosely connected to weak supervision.",
      "diffusion_reasoning_justification": "The paper focuses on class-incremental semantic segmentation using language-guided disentanglement with CLIP, with no mention of diffusion models, iterative refinement processes, or multi-step logical reasoning. It does not adapt diffusion for any reasoning tasks.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00541",
      "title": "LatentEdit: Adaptive Latent Control for Consistent Semantic Editing",
      "authors": [
        "Siyi Liu",
        "Weiming Chen",
        "Yushun Tang",
        "Zhihai He"
      ],
      "categories": [
        "cs.GR (Graphics)",
        "cs.AI (Artificial Intelligence)",
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Diffusion-based Image Editing has achieved significant success in recent\nyears. However, it remains challenging to achieve high-quality image editing\nwhile maintaining the background similarity without sacrificing speed or memory\nefficiency. In this work, we introduce LatentEdit, an adaptive latent fusion\nframework that dynamically combines the current latent code with a reference\nlatent code inverted from the source image. By selectively preserving source\nfeatures in high-similarity, semantically important regions while generating\ntarget content in other regions guided by the target prompt, LatentEdit enables\nfine-grained, controllable editing. Critically, the method requires no internal\nmodel modifications or complex attention mechanisms, offering a lightweight,\nplug-and-play solution compatible with both UNet-based and DiT-based\narchitectures. Extensive experiments on the PIE-Bench dataset demonstrate that\nour proposed LatentEdit achieves an optimal balance between fidelity and\neditability, outperforming the state-of-the-art method even in 8-15 steps.\nAdditionally, its inversion-free variant further halves the number of neural\nfunction evaluations and eliminates the need for storing any intermediate\nvariables, substantially enhancing real-time deployment efficiency.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00541v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00541v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.347,
      "weak_supervision_score": 0.345,
      "diffusion_reasoning_score": 0.493,
      "distributed_training_score": 0.298,
      "datasets_score": 0.297,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on diffusion-based image editing, specifically developing a framework for adaptive latent control to enhance semantic editing in images. It does not involve adapting the diffusion process for multi-step logical reasoning, chain-of-thought entities, or solving complex logical tasks. Instead, it applies diffusion models to visual generation and editing, which is unrelated to the topic's emphasis on reasoning.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00543",
      "title": "Text-to-Layout: A Generative Workflow for Drafting Architectural Floor\n  Plans Using LLMs",
      "authors": [
        "Jayakrishna Duggempudi",
        "Lu Gao",
        "Ahmed Senouci",
        "Zhe Han",
        "Yunpeng Zhang"
      ],
      "categories": [
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "This paper presents the development of an AI-powered workflow that uses Large\nLanguage Models (LLMs) to assist in drafting schematic architectural floor\nplans from natural language prompts. The proposed system interprets textual\ninput to automatically generate layout options including walls, doors, windows,\nand furniture arrangements. It combines prompt engineering, a furniture\nplacement refinement algorithm, and Python scripting to produce spatially\ncoherent draft plans compatible with design tools such as Autodesk Revit. A\ncase study of a mid-sized residential layout demonstrates the approach's\nability to generate functional and structured outputs with minimal manual\neffort. The workflow is designed for transparent replication, with all key\nprompt specifications documented to enable independent implementation by other\nresearchers. In addition, the generated models preserve the full range of\nRevit-native parametric attributes required for direct integration into\nprofessional BIM processes.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00543v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00543v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.435,
      "weak_supervision_score": 0.378,
      "diffusion_reasoning_score": 0.496,
      "distributed_training_score": 0.343,
      "datasets_score": 0.371,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper focuses on using LLMs with prompt engineering and algorithms to generate architectural floor plans from text, without any mention of reinforcement learning, human feedback, reward models, or fine-tuning based on human preferences.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "Although the paper references diffusion models in the context of related generative AI work, its main contribution involves LLMs and a furniture placement refinement algorithm, with no clear use of diffusion processes for multi-step logical reasoning or iterative refinement of a chain-of-thought.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00549",
      "title": "A Modality-agnostic Multi-task Foundation Model for Human Brain Imaging",
      "authors": [
        "Peirong Liu",
        "Oula Puonti",
        "Xiaoling Hu",
        "Karthik Gopinath",
        "Annabel Sorby-Adams",
        "Daniel C. Alexander",
        "W. Taylor Kimberly",
        "Juan E. Iglesias"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Recent learning-based approaches have made astonishing advances in calibrated\nmedical imaging like computerized tomography (CT), yet they struggle to\ngeneralize in uncalibrated modalities -- notably magnetic resonance (MR)\nimaging, where performance is highly sensitive to the differences in MR\ncontrast, resolution, and orientation. This prevents broad applicability to\ndiverse real-world clinical protocols. Here we introduce BrainFM, a\nmodality-agnostic, multi-task vision foundation model for human brain imaging.\nWith the proposed \"mild-to-severe\" intra-subject generation and \"real-synth\"\nmix-up training strategy, BrainFM is resilient to the appearance of acquired\nimages (e.g., modality, contrast, deformation, resolution, artifacts), and can\nbe directly applied to five fundamental brain imaging tasks, including image\nsynthesis for CT and T1w/T2w/FLAIR MRI, anatomy segmentation, scalp-to-cortical\ndistance, bias field estimation, and registration. We evaluate the efficacy of\nBrainFM on eleven public datasets, and demonstrate its robustness and\neffectiveness across all tasks and input modalities. Code is available at\nhttps://github.com/jhuldr/BrainFM.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00549v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00549v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.353,
      "weak_supervision_score": 0.352,
      "diffusion_reasoning_score": 0.431,
      "distributed_training_score": 0.379,
      "datasets_score": 0.37,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper introduces BrainFM, a foundation model for brain imaging tasks such as image synthesis and segmentation, using strategies like intra-subject generation and mix-up training. It does not involve diffusion models, iterative refinement for logical reasoning, or any adaptation of diffusion processes for complex tasks like Chain-of-Thought reasoning. Therefore, there is no connection to the topic.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00550",
      "title": "Integrated Multivariate Segmentation Tree for the Analysis of\n  Heterogeneous Credit Data in Small and Medium-Sized Enterprises",
      "authors": [
        "Lu Han",
        "Xiuying Wang"
      ],
      "categories": [
        "cs.LG (Machine Learning)",
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Traditional decision tree models, which rely exclusively on numerical\nvariables, often encounter difficulties in handling high-dimensional data and\nfail to effectively incorporate textual information. To address these\nlimitations, we propose the Integrated Multivariate Segmentation Tree (IMST), a\ncomprehensive framework designed to enhance credit evaluation for small and\nmedium-sized enterprises (SMEs) by integrating financial data with textual\nsources. The methodology comprises three core stages: (1) transforming textual\ndata into numerical matrices through matrix factorization; (2) selecting\nsalient financial features using Lasso regression; and (3) constructing a\nmultivariate segmentation tree based on the Gini index or Entropy, with\nweakest-link pruning applied to regulate model complexity. Experimental results\nderived from a dataset of 1,428 Chinese SMEs demonstrate that IMST achieves an\naccuracy of 88.9%, surpassing baseline decision trees (87.4%) as well as\nconventional models such as logistic regression and support vector machines\n(SVM). Furthermore, the proposed model exhibits superior interpretability and\ncomputational efficiency, featuring a more streamlined architecture and\nenhanced risk detection capabilities.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00550v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00550v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "extraction_failed",
      "embedding_status": "completed",
      "rlhf_score": 0.286,
      "weak_supervision_score": 0.315,
      "diffusion_reasoning_score": 0.287,
      "distributed_training_score": 0.255,
      "datasets_score": 0.304,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00559",
      "title": "Social World Models",
      "authors": [
        "Xuhui Zhou",
        "Jiarui Liu",
        "Akhila Yerukola",
        "Hyunwoo Kim",
        "Maarten Sap"
      ],
      "categories": [
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Humans intuitively navigate social interactions by simulating unspoken\ndynamics and reasoning about others' perspectives, even with limited\ninformation. In contrast, AI systems struggle to automatically structure and\nreason about these implicit social contexts. In this paper, we introduce a\nnovel structured social world representation formalism (S3AP), designed to help\nAI systems reason more effectively about social dynamics. Following a\nPOMDP-driven design, S3AP represents social interactions as structured tuples,\nsuch as state, observation, agent actions, and mental states, which can be\nautomatically induced from free-form narratives or other inputs. We first show\nS3AP can help LLMs better understand social narratives across 5 social\nreasoning tasks (e.g., +51% improvement on FANToM's theory-of-mind reasoning\nwith OpenAI's o1), reaching new state-of-the-art (SOTA) performance. We then\ninduce social world models from these structured representations, demonstrating\ntheir ability to predict future social dynamics and improve agent\ndecision-making, yielding up to +18% improvement on the SOTOPIA social\ninteraction benchmark. Our findings highlight the promise of S3AP as a\npowerful, general-purpose representation for social world states, enabling the\ndevelopment of more socially-aware systems that better navigate social\ninteractions.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00559v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00559v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.417,
      "weak_supervision_score": 0.366,
      "diffusion_reasoning_score": 0.469,
      "distributed_training_score": 0.31,
      "datasets_score": 0.345,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Tangentially Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper draws inspiration from reinforcement learning theories in designing S3AP and social world models, referencing concepts like planning and embodied agents. However, it does not involve training models using human feedback, a reward model, or fine-tuning via RLHF. The core contribution focuses on structured representations for social reasoning, not alignment with human preferences.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper does not mention or utilize diffusion models, iterative refinement processes, or any mechanism for multi-step logical reasoning via diffusion. Its main focus is on structured representations (S3AP) and LLMs for social dynamics, with no components related to diffusion-based approaches.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00564",
      "title": "Reinforcement Learning of Dolly-In Filming Using a Ground-Based Robot",
      "authors": [
        "Philip Lorimer",
        "Jack Saunders",
        "Alan Hunter",
        "Wenbin Li"
      ],
      "categories": [
        "cs.RO (Robotics)",
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.LG (Machine Learning)"
      ],
      "abstract": "Free-roaming dollies enhance filmmaking with dynamic movement, but challenges\nin automated camera control remain unresolved. Our study advances this field by\napplying Reinforcement Learning (RL) to automate dolly-in shots using\nfree-roaming ground-based filming robots, overcoming traditional control\nhurdles. We demonstrate the effectiveness of combined control for precise film\ntasks by comparing it to independent control strategies. Our robust RL pipeline\nsurpasses traditional Proportional-Derivative controller performance in\nsimulation and proves its efficacy in real-world tests on a modified ROSBot 2.0\nplatform equipped with a camera turret. This validates our approach's\npracticality and sets the stage for further research in complex filming\nscenarios, contributing significantly to the fusion of technology with\ncinematic creativity. This work presents a leap forward in the field and opens\nnew avenues for research and development, effectively bridging the gap between\ntechnological advancement and creative filmmaking.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00564v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00564v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.441,
      "weak_supervision_score": 0.328,
      "diffusion_reasoning_score": 0.329,
      "distributed_training_score": 0.331,
      "datasets_score": 0.294,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper applies standard Reinforcement Learning (RL) to automate dolly-in shots on a ground-based robot, focusing on control strategies and simulation-to-real-world transfer. It does not involve human feedback, such as training a reward model on human-ranked data or fine-tuning based on human preferences, which are core to RLHF. Therefore, the paper's contributions are unrelated to RLHF.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00575",
      "title": "Can AI be Auditable?",
      "authors": [
        "Himanshu Verma",
        "Kirtan Padh",
        "Eva Thelisson"
      ],
      "categories": [
        "cs.CY (Computers and Society)",
        "cs.AI (Artificial Intelligence)",
        "cs.HC (Human-Computer Interaction)"
      ],
      "abstract": "Auditability is defined as the capacity of AI systems to be independently\nassessed for compliance with ethical, legal, and technical standards throughout\ntheir lifecycle. The chapter explores how auditability is being formalized\nthrough emerging regulatory frameworks, such as the EU AI Act, which mandate\ndocumentation, risk assessments, and governance structures. It analyzes the\ndiverse challenges facing AI auditability, including technical opacity,\ninconsistent documentation practices, lack of standardized audit tools and\nmetrics, and conflicting principles within existing responsible AI frameworks.\nThe discussion highlights the need for clear guidelines, harmonized\ninternational regulations, and robust socio-technical methodologies to\noperationalize auditability at scale. The chapter concludes by emphasizing the\nimportance of multi-stakeholder collaboration and auditor empowerment in\nbuilding an effective AI audit ecosystem. It argues that auditability must be\nembedded in AI development practices and governance infrastructures to ensure\nthat AI systems are not only functional but also ethically and legally aligned.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00575v3",
      "pdf_url": "http://arxiv.org/pdf/2509.00575v3",
      "scraper_status": "successfully_scraped",
      "intro_status": "extraction_failed",
      "embedding_status": "completed",
      "rlhf_score": 0.375,
      "weak_supervision_score": 0.302,
      "diffusion_reasoning_score": 0.278,
      "distributed_training_score": 0.275,
      "datasets_score": 0.355,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00576",
      "title": "Galaxea Open-World Dataset and G0 Dual-System VLA Model",
      "authors": [
        "Tao Jiang",
        "Tianyuan Yuan",
        "Yicheng Liu",
        "Chenhao Lu",
        "Jianning Cui",
        "Xiao Liu",
        "Shuiqi Cheng",
        "Jiyang Gao",
        "Huazhe Xu",
        "Hang Zhao"
      ],
      "categories": [
        "cs.RO (Robotics)",
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "We present Galaxea Open-World Dataset, a large-scale, diverse collection of\nrobot behaviors recorded in authentic human living and working environments.\nAll demonstrations are gathered using a consistent robotic embodiment, paired\nwith precise subtask-level language annotations to facilitate both training and\nevaluation. Building on this dataset, we introduce G0, a dual-system framework\nthat couples a Vision-Language Model (VLM) for multimodal planning with a\nVision-Language-Action (VLA) model for fine-grained execution. G0 is trained\nusing a three-stage curriculum: cross-embodiment pre-training,\nsingle-embodiment pre-training, and task-specific post-training. A\ncomprehensive benchmark spanning tabletop manipulation, few-shot learning, and\nlong-horizon mobile manipulation, demonstrates the effectiveness of our\napproach. In particular, we find that the single-embodiment pre-training stage,\ntogether with the Galaxea Open-World Dataset, plays a critical role in\nachieving strong performance.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00576v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00576v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.359,
      "weak_supervision_score": 0.353,
      "diffusion_reasoning_score": 0.387,
      "distributed_training_score": 0.38,
      "datasets_score": 0.433,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "Highly Relevant",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "The paper's main contribution is the introduction of the Galaxea Open-World Dataset, which involves creating a large-scale, curated dataset for robot behaviors in real-world environments. It details dataset curation methodologies, such as data collection with a consistent robotic embodiment, precise language annotations, and comprehensive filtering. Additionally, the paper discusses benchmarking using this dataset for mobile manipulation tasks, directly aligning with research on dataset creation, analysis, and evaluation for AI applications.",
      "llm_score_status": "completed",
      "summary": "The paper introduces the Galaxea Open-World Dataset, a comprehensive collection of 500 hours of robot behavior data from real human environments across 150 tasks and 50 scenes, designed to address the lack of high-quality open-world data for robot training. It proposes the G0 dual-system framework, which combines a Vision-Language Model for planning and a Vision-Language-Action model for execution, trained via a three-stage curriculum including cross-embodiment pre-training, single-embodiment pre-training on the Galaxea dataset, and task-specific fine-tuning; benchmarks demonstrate its effectiveness, particularly highlighting the importance of single-embodiment pre-training for robust performance in mobile manipulation tasks.",
      "novelty_score": "High",
      "novelty_justification": "The paper introduces a new large-scale dataset and a novel dual-system framework with a specialized training curriculum, significantly advancing the state-of-the-art in robot learning for open-world environments by addressing data scarcity and improving generalization.",
      "impact_score": "Moderate",
      "impact_justification": "The work is likely to be cited and built upon within the robotics and computer vision subfields due to its open-sourced dataset and framework, which could enhance future research in real-world robot applications, though its influence may be limited to specific domains.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "The paper offers a high-quality contribution with a new dataset and effective model framework that advances robotics research, making it essential for researchers in embodied AI to be aware of and potentially utilize.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/f6da39ef0dfc0df48c64ee96943a37d07cea1990",
      "total_authors": 10,
      "authors_found": 9,
      "highest_h_index": 6,
      "average_h_index": 1.4444444444444444,
      "notable_authors_count": 1,
      "author_h_indexes": [
        {
          "name": "Tao Jiang",
          "h_index": null,
          "profile_url": null
        },
        {
          "name": "Tianyuan Yuan",
          "h_index": 6,
          "profile_url": "https://www.semanticscholar.org/author/2214583235"
        },
        {
          "name": "Yicheng Liu",
          "h_index": 3,
          "profile_url": "https://www.semanticscholar.org/author/2284726857"
        },
        {
          "name": "Chenhao Lu",
          "h_index": 3,
          "profile_url": "https://www.semanticscholar.org/author/2265619607"
        },
        {
          "name": "Jianning Cui",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2378575327"
        },
        {
          "name": "Xiao Liu",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2379318301"
        },
        {
          "name": "Shuiqi Cheng",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2312346725"
        },
        {
          "name": "Jiyang Gao",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2378606389"
        },
        {
          "name": "Huazhe Xu",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2373743788"
        },
        {
          "name": "Hang Zhao",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2378973882"
        }
      ]
    },
    {
      "id": "2509.00578",
      "title": "C-DiffDet+: Fusing Global Scene Context with Generative Denoising for\n  High-Fidelity Object Detection",
      "authors": [
        "Abdellah Zakaria Sellam",
        "Ilyes Benaissa",
        "Salah Eddine Bekhouche",
        "Abdenour Hadid",
        "Vito Renó",
        "Cosimo Distante"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Fine-grained object detection in challenging visual domains, such as vehicle\ndamage assessment, presents a formidable challenge even for human experts to\nresolve reliably. While DiffusionDet has advanced the state-of-the-art through\nconditional denoising diffusion, its performance remains limited by local\nfeature conditioning in context-dependent scenarios. We address this\nfundamental limitation by introducing Context-Aware Fusion (CAF), which\nleverages cross-attention mechanisms to integrate global scene context with\nlocal proposal features directly. The global context is generated using a\nseparate dedicated encoder that captures comprehensive environmental\ninformation, enabling each object proposal to attend to scene-level\nunderstanding. Our framework significantly enhances the generative detection\nparadigm by enabling each object proposal to attend to comprehensive\nenvironmental information. Experimental results demonstrate an improvement over\nstate-of-the-art models on the CarDD benchmark, establishing new performance\nbenchmarks for context-aware object detection in fine-grained domains",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00578v3",
      "pdf_url": "http://arxiv.org/pdf/2509.00578v3",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.32,
      "weak_supervision_score": 0.358,
      "diffusion_reasoning_score": 0.545,
      "distributed_training_score": 0.369,
      "datasets_score": 0.369,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Tangentially Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper builds on DiffusionDet, which uses iterative refinement via denoising diffusion for object detection, aligning somewhat with the iterative process in diffusion models. However, it applies this to visual tasks like refining bounding boxes in images, not to complex logical tasks or a 'Chain-of-Thought' for holistic reasoning. Thus, while diffusion mechanisms are present, they are not adapted for multi-step logical reasoning as defined.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00579",
      "title": "KVComp: A High-Performance, LLM-Aware, Lossy Compression Framework for\n  KV Cache",
      "authors": [
        "Bo Jiang",
        "Taolue Yang",
        "Youyuan Liu",
        "Chengming Zhang",
        "Xubin He",
        "Sian Jin"
      ],
      "categories": [
        "cs.DC (Distributed, Parallel, and Cluster Computing)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Transformer-based large language models (LLMs) demonstrate impressive\npotential in various practical applications. However, long context inference\nposes a significant challenge due to the enormous memory requirements of the\nkey-value (KV) cache, which can scale to multiple gigabytes as sequence length\nand batch size increase. In this paper, we present KVComp, a generic and\nefficient KV cache management framework optimized for long-text generation that\nsynergistically works with both latency-critical and throughput-critical\ninference systems. KVComp employs novel lossy compression techniques\nspecifically designed for KV cache data characteristics, featuring careful\nco-design of compression algorithms and system architecture. Our approach\nmaintains compatibility with the growing nature of KV cache while preserving\nhigh computational efficiency. Experimental results show that KVComp achieves\non average 47\\% and up to 83\\% higher memory reduction rate compared to\nexisting methods with little/no model accuracy degradation. Furthermore, KVComp\nachieves extremely high execution throughput, effectively reducing\ndecompression overhead and, in some cases, even accelerating the matrix-vector\nmultiplication operation and outperform cuBLAS-based attention kernels with\nless data movement.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00579v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00579v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.332,
      "weak_supervision_score": 0.335,
      "diffusion_reasoning_score": 0.4,
      "distributed_training_score": 0.418,
      "datasets_score": 0.296,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "Not Relevant",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on KV cache compression for Transformer-based LLMs to optimize memory during inference, with no mention of diffusion models, iterative refinement processes, or multi-step logical reasoning tasks. It does not adapt diffusion techniques for reasoning.",
      "distributed_training_justification": "The paper addresses GPU-based optimization for LLM inference through compression techniques, but it does not discuss distributed training, parallel computing across multiple nodes, or strategies for partitioning data/computation in training scenarios. It is centered on single-device inference efficiency.",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00598",
      "title": "DGL-RSIS: Decoupling Global Spatial Context and Local Class Semantics\n  for Training-Free Remote Sensing Image Segmentation",
      "authors": [
        "Boyi Li",
        "Ce Zhang",
        "Richard M. Timmerman",
        "Wenxuan Bao"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "The emergence of vision language models (VLMs) has bridged vision and\nlanguage, enabling joint multimodal understanding beyond traditional\nvisual-only deep learning models. However, transferring VLMs from the natural\nimage domain to remote sensing (RS) segmentation remains challenging due to the\nlimited category diversity in RS datasets and the domain gap between natural\nand RS imagery. Here, we propose a training-free framework, DGL-RSIS, that\ndecouples visual and textual inputs, performing visual-language alignment at\nboth the local semantic and global contextual levels through tailored\nstrategies. Specifically, we first introduce a global-local decoupling (GLD)\nmodule, where text inputs are divided into local class nouns and global\nmodifiers using natural language processing (NLP) techniques; image inputs are\npartitioned into a set of class-agnostic mask proposals via unsupervised mask\nproposal networks. Second, visual and textual features are aligned at local\nscale, through a novel context-aware cropping strategy for extracting image\npatches with proper boundaries and introducing RS-specific knowledge to enrich\nthe text inputs. By matching the enhanced text features with mask-guided visual\nfeatures, we enable the mask classification, supporting open-vocabulary\nsemantic segmentation (OVSS). Third, at the global scale, we propose a\nCross-Scale Grad-CAM module to refine Grad-CAM maps using contextual\ninformation from global modifiers. A subsequent mask selection module\nintegrates pixel-level Grad-CAM activations into the mask-level segmentation\noutput, such that accurate and interpretable alignment can be realized across\nglobal and local dimensions for referring expression segmentation (RES).",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00598v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00598v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "extraction_failed",
      "embedding_status": "completed",
      "rlhf_score": 0.351,
      "weak_supervision_score": 0.385,
      "diffusion_reasoning_score": 0.392,
      "distributed_training_score": 0.387,
      "datasets_score": 0.362,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00613",
      "title": "Promptable Longitudinal Lesion Segmentation in Whole-Body CT",
      "authors": [
        "Yannick Kirchhoff",
        "Maximilian Rokuss",
        "Fabian Isensee",
        "Klaus H. Maier-Hein"
      ],
      "categories": [
        "eess.IV (Image and Video Processing)",
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Accurate segmentation of lesions in longitudinal whole-body CT is essential\nfor monitoring disease progression and treatment response. While automated\nmethods benefit from incorporating longitudinal information, they remain\nlimited in their ability to consistently track individual lesions across time.\nTask 2 of the autoPET/CT IV Challenge addresses this by providing lesion\nlocalizations and baseline delineations, framing the problem as longitudinal\npromptable segmentation. In this work, we extend the recently proposed LongiSeg\nframework with promptable capabilities, enabling lesion-specific tracking\nthrough point and mask interactions. To address the limited size of the\nprovided training set, we leverage large-scale pretraining on a synthetic\nlongitudinal CT dataset. Our experiments show that pretraining substantially\nimproves the ability to exploit longitudinal context, yielding an improvement\nof up to 6 Dice points compared to models trained from scratch. These findings\ndemonstrate the effectiveness of combining longitudinal context with\ninteractive prompting for robust lesion tracking. Code is publicly available at\nhttps://github.com/MIC-DKFZ/LongiSeg/tree/autoPET.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00613v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00613v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.309,
      "weak_supervision_score": 0.345,
      "diffusion_reasoning_score": 0.358,
      "distributed_training_score": 0.315,
      "datasets_score": 0.287,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00615",
      "title": "Federated Survival Analysis with Node-Level Differential Privacy:\n  Private Kaplan-Meier Curves",
      "authors": [
        "Narasimha Raghavan Veeraragavan",
        "Jan Franz Nygård"
      ],
      "categories": [
        "cs.CR (Cryptography and Security)",
        "cs.AI (Artificial Intelligence)",
        "cs.DC (Distributed, Parallel, and Cluster Computing)",
        "cs.LG (Machine Learning)"
      ],
      "abstract": "We investigate how to calculate Kaplan-Meier survival curves across multiple\nhealth-care jurisdictions while protecting patient privacy with node-level\ndifferential privacy. Each site discloses its curve only once, adding Laplace\nnoise whose scale is determined by the length of the common time grid; the\nserver then averages the noisy curves, so the overall privacy budget remains\nunchanged. We benchmark four one-shot smoothing techniques: Discrete Cosine\nTransform, Haar Wavelet shrinkage, adaptive Total-Variation denoising, and a\nparametric Weibull fit on the NCCTG lung-cancer cohort under five privacy\nlevels and three partition scenarios (uniform, moderately skewed, highly\nimbalanced). Total-Variation gives the best mean accuracy, whereas the\nfrequency-domain smoothers offer stronger worst-case robustness and the Weibull\nmodel shows the most stable behaviour at the strictest privacy setting. Across\nall methods the released curves keep the empirical log-rank type-I error below\nfifteen percent for privacy budgets of 0.5 and higher, demonstrating that\nclinically useful survival information can be shared without iterative training\nor heavy cryptography.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00615v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00615v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.303,
      "weak_supervision_score": 0.312,
      "diffusion_reasoning_score": 0.317,
      "distributed_training_score": 0.361,
      "datasets_score": 0.296,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00616",
      "title": "TimeCopilot",
      "authors": [
        "Azul Garza",
        "Reneé Rosillo"
      ],
      "categories": [
        "cs.LG (Machine Learning)",
        "cs.AI (Artificial Intelligence)",
        "cs.HC (Human-Computer Interaction)"
      ],
      "abstract": "We introduce TimeCopilot, the first open-source agentic framework for\nforecasting that combines multiple Time Series Foundation Models (TSFMs) with\nLarge Language Models (LLMs) through a single unified API. TimeCopilot\nautomates the forecasting pipeline: feature analysis, model selection,\ncross-validation, and forecast generation, while providing natural language\nexplanations and supporting direct queries about the future. The framework is\nLLM-agnostic, compatible with both commercial and open-source models, and\nsupports ensembles across diverse forecasting families. Results on the\nlarge-scale GIFT-Eval benchmark show that TimeCopilot achieves state-of-the-art\nprobabilistic forecasting performance at low cost. Our framework provides a\npractical foundation for reproducible, explainable, and accessible agentic\nforecasting systems.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00616v2",
      "pdf_url": "http://arxiv.org/pdf/2509.00616v2",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.377,
      "weak_supervision_score": 0.324,
      "diffusion_reasoning_score": 0.371,
      "distributed_training_score": 0.349,
      "datasets_score": 0.308,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00622",
      "title": "BALM-TSF: Balanced Multimodal Alignment for LLM-Based Time Series\n  Forecasting",
      "authors": [
        "Shiqiao Zhou",
        "Holger Schöner",
        "Huanbo Lyu",
        "Edouard Fouché",
        "Shuo Wang"
      ],
      "categories": [
        "cs.AI (Artificial Intelligence)",
        "cs.IR (Information Retrieval)"
      ],
      "abstract": "Time series forecasting is a long-standing and highly challenging research\ntopic. Recently, driven by the rise of large language models (LLMs), research\nhas increasingly shifted from purely time series methods toward harnessing\ntextual modalities to enhance forecasting performance. However, the vast\ndiscrepancy between text and temporal data often leads current multimodal\narchitectures to over-emphasise one modality while neglecting the other,\nresulting in information loss that harms forecasting performance. To address\nthis modality imbalance, we introduce BALM-TSF (Balanced Multimodal Alignment\nfor LLM-Based Time Series Forecasting), a lightweight time series forecasting\nframework that maintains balance between the two modalities. Specifically, raw\ntime series are processed by the time series encoder, while descriptive\nstatistics of raw time series are fed to an LLM with learnable prompt,\nproducing compact textual embeddings. To ensure balanced cross-modal context\nalignment of time series and textual embeddings, a simple yet effective scaling\nstrategy combined with a contrastive objective then maps these textual\nembeddings into the latent space of the time series embeddings. Finally, the\naligned textual semantic embeddings and time series embeddings are together\nintegrated for forecasting. Extensive experiments on standard benchmarks show\nthat, with minimal trainable parameters, BALM-TSF achieves state-of-the-art\nperformance in both long-term and few-shot forecasting, confirming its ability\nto harness complementary information from text and time series. Code is\navailable at https://github.com/ShiqiaoZhou/BALM-TSF.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00622v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00622v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.403,
      "weak_supervision_score": 0.354,
      "diffusion_reasoning_score": 0.391,
      "distributed_training_score": 0.347,
      "datasets_score": 0.333,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper focuses on multimodal alignment for time series forecasting using LLMs, addressing modality imbalance between text and time series data through techniques like scaling and contrastive objectives. It does not involve reinforcement learning, human feedback, reward models, or any mechanism for aligning AI with human preferences, making it unrelated to RLHF.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00623",
      "title": "A Multi-Strategy Approach for AI-Generated Text Detection",
      "authors": [
        "Ali Zain",
        "Sareem Farooqui",
        "Muhammad Rafi"
      ],
      "categories": [
        "cs.CL (Computation and Language)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "This paper presents presents three distinct systems developed for the M-DAIGT\nshared task on detecting AI generated content in news articles and academic\nabstracts. The systems includes: (1) A fine-tuned RoBERTa-base classifier, (2)\nA classical TF-IDF + Support Vector Machine (SVM) classifier , and (3) An\nInnovative ensemble model named Candace, leveraging probabilistic features\nextracted from multiple Llama-3.2 models processed by a customTransformer\nencoder.The RoBERTa-based system emerged as the most performant, achieving\nnear-perfect results on both development and test sets.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00623v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00623v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.395,
      "weak_supervision_score": 0.378,
      "diffusion_reasoning_score": 0.459,
      "distributed_training_score": 0.384,
      "datasets_score": 0.463,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "Tangentially Relevant",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on developing systems for AI-generated text detection using models like RoBERTa, SVM, and an ensemble with Llama-3.2, but it does not involve diffusion models, iterative refinement processes, or multi-step logical reasoning as defined. There is no component related to treating Chain-of-Thought as a holistic entity for correction.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "The paper uses datasets from the M-DAIGT shared task for evaluating its detection systems, mentioning results on development and test sets, but it does not primarily focus on creating, analyzing, benchmarking, or evaluating datasets; instead, it emphasizes model development and performance.",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00625",
      "title": "NetGent: Agent-Based Automation of Network Application Workflows",
      "authors": [
        "Jaber Daneshamooz",
        "Eugene Vuong",
        "Laasya Koduru",
        "Sanjay Chandrasekaran",
        "Arpit Gupta"
      ],
      "categories": [
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "We present NetGent, an AI-agent framework for automating complex application\nworkflows to generate realistic network traffic datasets. Developing\ngeneralizable ML models for networking requires data collection from network\nenvironments with traffic that results from a diverse set of real-world web\napplications. However, using existing browser automation tools that are\ndiverse, repeatable, realistic, and efficient remains fragile and costly.\nNetGent addresses this challenge by allowing users to specify workflows as\nnatural-language rules that define state-dependent actions. These abstract\nspecifications are compiled into nondeterministic finite automata (NFAs), which\na state synthesis component translates into reusable, executable code. This\ndesign enables deterministic replay, reduces redundant LLM calls through state\ncaching, and adapts quickly when application interfaces change. In experiments,\nNetGent automated more than 50+ workflows spanning video-on-demand streaming,\nlive video streaming, video conferencing, social media, and web scraping,\nproducing realistic traffic traces while remaining robust to UI variability. By\ncombining the flexibility of language-based agents with the reliability of\ncompiled execution, NetGent provides a scalable foundation for generating the\ndiverse, repeatable datasets needed to advance ML in networking.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00625v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00625v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.365,
      "weak_supervision_score": 0.376,
      "diffusion_reasoning_score": 0.401,
      "distributed_training_score": 0.371,
      "datasets_score": 0.374,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper introduces NetGent, an AI-agent framework for automating network workflows using natural-language rules compiled into NFAs and executable code. It does not involve diffusion models, iterative refinement processes, or any adaptation of diffusion for logical reasoning tasks. There is no component for multi-step logical reasoning via diffusion, making it unrelated to the topic.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00626",
      "title": "Towards Methane Detection Onboard Satellites",
      "authors": [
        "Maggie Chen",
        "Hala Lambdouar",
        "Luca Marini",
        "Laura Martínez-Ferrer",
        "Chris Bridges",
        "Giacomo Acciarini"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Methane is a potent greenhouse gas and a major driver of climate change,\nmaking its timely detection critical for effective mitigation. Machine learning\n(ML) deployed onboard satellites can enable rapid detection while reducing\ndownlink costs, supporting faster response systems. Conventional methane\ndetection methods often rely on image processing techniques, such as\northorectification to correct geometric distortions and matched filters to\nenhance plume signals. We introduce a novel approach that bypasses these\npreprocessing steps by using \\textit{unorthorectified} data (UnorthoDOS). We\nfind that ML models trained on this dataset achieve performance comparable to\nthose trained on orthorectified data. Moreover, we also train models on an\northorectified dataset, showing that they can outperform the matched filter\nbaseline (mag1c). We release model checkpoints and two ML-ready datasets\ncomprising orthorectified and unorthorectified hyperspectral images from the\nEarth Surface Mineral Dust Source Investigation (EMIT) sensor at\nhttps://huggingface.co/datasets/SpaceML/UnorthoDOS , along with code at\nhttps://github.com/spaceml-org/plume-hunter.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00626v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00626v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.326,
      "weak_supervision_score": 0.378,
      "diffusion_reasoning_score": 0.374,
      "distributed_training_score": 0.366,
      "datasets_score": 0.378,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00631",
      "title": "Forecasting the Ionosphere from Sparse GNSS Data with Temporal-Fusion\n  Transformers",
      "authors": [
        "Giacomo Acciarini",
        "Simone Mestici",
        "Halil Kelebek",
        "Linnea Wolniewicz",
        "Michael Vergalla",
        "Madhulika Guhathakurta",
        "Umaa Rebbapragada",
        "Bala Poduval",
        "Atılım Güneş Baydin",
        "Frank Soboczenski"
      ],
      "categories": [
        "cs.LG (Machine Learning)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "The ionosphere critically influences Global Navigation Satellite Systems\n(GNSS), satellite communications, and Low Earth Orbit (LEO) operations, yet\naccurate prediction of its variability remains challenging due to nonlinear\ncouplings between solar, geomagnetic, and thermospheric drivers. Total Electron\nContent (TEC), a key ionospheric parameter, is derived from GNSS observations,\nbut its reliable forecasting is limited by the sparse nature of global\nmeasurements and the limited accuracy of empirical models, especially during\nstrong space weather conditions. In this work, we present a machine learning\nframework for ionospheric TEC forecasting that leverages Temporal Fusion\nTransformers (TFT) to predict sparse ionosphere data. Our approach accommodates\nheterogeneous input sources, including solar irradiance, geomagnetic indices,\nand GNSS-derived vertical TEC, and applies preprocessing and temporal alignment\nstrategies. Experiments spanning 2010-2025 demonstrate that the model achieves\nrobust predictions up to 24 hours ahead, with root mean square errors as low as\n3.33 TECU. Results highlight that solar EUV irradiance provides the strongest\npredictive signals. Beyond forecasting accuracy, the framework offers\ninterpretability through attention-based analysis, supporting both operational\napplications and scientific discovery. To encourage reproducibility and\ncommunity-driven development, we release the full implementation as the\nopen-source toolkit \\texttt{ionopy}.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00631v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00631v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.314,
      "weak_supervision_score": 0.347,
      "diffusion_reasoning_score": 0.374,
      "distributed_training_score": 0.355,
      "datasets_score": 0.293,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00634",
      "title": "Enabling Trustworthy Federated Learning via Remote Attestation for\n  Mitigating Byzantine Threats",
      "authors": [
        "Chaoyu Zhang",
        "Heng Jin",
        "Shanghao Shi",
        "Hexuan Yu",
        "Sydney Johns",
        "Y. Thomas Hou",
        "Wenjing Lou"
      ],
      "categories": [
        "cs.CR (Cryptography and Security)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Federated Learning (FL) has gained significant attention for its\nprivacy-preserving capabilities, enabling distributed devices to\ncollaboratively train a global model without sharing raw data. However, its\ndistributed nature forces the central server to blindly trust the local\ntraining process and aggregate uncertain model updates, making it susceptible\nto Byzantine attacks from malicious participants, especially in\nmission-critical scenarios. Detecting such attacks is challenging due to the\ndiverse knowledge across clients, where variations in model updates may stem\nfrom benign factors, such as non-IID data, rather than adversarial behavior.\nExisting data-driven defenses struggle to distinguish malicious updates from\nnatural variations, leading to high false positive rates and poor filtering\nperformance.\n  To address this challenge, we propose Sentinel, a remote attestation\n(RA)-based scheme for FL systems that regains client-side transparency and\nmitigates Byzantine attacks from a system security perspective. Our system\nemploys code instrumentation to track control-flow and monitor critical\nvariables in the local training process. Additionally, we utilize a trusted\ntraining recorder within a Trusted Execution Environment (TEE) to generate an\nattestation report, which is cryptographically signed and securely transmitted\nto the server. Upon verification, the server ensures that legitimate client\ntraining processes remain free from program behavior violation or data\nmanipulation, allowing only trusted model updates to be aggregated into the\nglobal model. Experimental results on IoT devices demonstrate that Sentinel\nensures the trustworthiness of the local training integrity with low runtime\nand memory overhead.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00634v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00634v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.373,
      "weak_supervision_score": 0.332,
      "diffusion_reasoning_score": 0.297,
      "distributed_training_score": 0.408,
      "datasets_score": 0.276,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "Moderately Relevant",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "The paper focuses on Federated Learning (FL), a subset of distributed training, where multiple nodes collaboratively train a model. It introduces a security mechanism using remote attestation to mitigate Byzantine attacks, ensuring the integrity of model updates in a distributed setting. While this relates to multi-node machine learning by addressing aggregation and client-server interactions, the primary emphasis is on security enhancements rather than accelerating training through data partitioning, model architecture strategies, or computational efficiency.",
      "datasets_justification": "below_threshold",
      "llm_score_status": "completed",
      "summary": "This paper introduces Sentinel, a remote attestation-based framework designed to enhance the security of Federated Learning (FL) by mitigating Byzantine attacks through verifying the integrity of local training processes on client devices. The methodology involves code instrumentation to track control-flow and monitor critical variables, utilizing a Trusted Execution Environment (TEE) to generate and securely transmit signed attestation reports to the server for verification, ensuring only trustworthy model updates are aggregated; experimental results on IoT devices demonstrate effective defense against attacks with minimal runtime and memory overhead.",
      "novelty_score": "Moderate",
      "novelty_justification": "The paper presents a clever combination of existing technologies like remote attestation and TEE to address Byzantine attacks in FL, offering a notable improvement over data-driven defenses by providing verifiable client-side transparency. While not introducing entirely new concepts, it applies them innovatively to a persistent problem in distributed learning.",
      "impact_score": "Moderate",
      "impact_justification": "The work is likely to influence future research in FL security, particularly in mission-critical applications like IoT and military systems, by providing a robust mechanism for trustworthy model aggregation. However, its impact may be limited to specific subfields rather than broadly transforming AI or security practices.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "The paper delivers a strong, practical contribution to FL security that addresses key vulnerabilities, making it essential for researchers in AI and cryptography to understand and potentially build upon. It is a high-quality work but not groundbreaking enough to be considered must-read for all.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/6854b169116415f0f05d8be1b7a4b5cde85fdcca",
      "total_authors": 7,
      "authors_found": 6,
      "highest_h_index": 10,
      "average_h_index": 4.5,
      "notable_authors_count": 2,
      "author_h_indexes": [
        {
          "name": "Chaoyu Zhang",
          "h_index": 4,
          "profile_url": "https://www.semanticscholar.org/author/2266241708"
        },
        {
          "name": "Heng Jin",
          "h_index": 2,
          "profile_url": "https://www.semanticscholar.org/author/2202851936"
        },
        {
          "name": "Shanghao Shi",
          "h_index": 8,
          "profile_url": "https://www.semanticscholar.org/author/2033471490"
        },
        {
          "name": "Hexuan Yu",
          "h_index": 3,
          "profile_url": "https://www.semanticscholar.org/author/2188148530"
        },
        {
          "name": "Sydney Johns",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2378702138"
        },
        {
          "name": "Y. Thomas Hou",
          "h_index": null,
          "profile_url": null
        },
        {
          "name": "W. Lou",
          "h_index": 10,
          "profile_url": "https://www.semanticscholar.org/author/153502684"
        }
      ]
    },
    {
      "id": "2509.00640",
      "title": "NMR-Solver: Automated Structure Elucidation via Large-Scale Spectral\n  Matching and Physics-Guided Fragment Optimization",
      "authors": [
        "Yongqi Jin",
        "Jun-Jie Wang",
        "Fanjie Xu",
        "Xiaohong Ji",
        "Zhifeng Gao",
        "Linfeng Zhang",
        "Guolin Ke",
        "Rong Zhu",
        "Weinan E"
      ],
      "categories": [
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Nuclear Magnetic Resonance (NMR) spectroscopy is one of the most powerful and\nwidely used tools for molecular structure elucidation in organic chemistry.\nHowever, the interpretation of NMR spectra to determine unknown molecular\nstructures remains a labor-intensive and expertise-dependent process,\nparticularly for complex or novel compounds. Although recent methods have been\nproposed for molecular structure elucidation, they often underperform in\nreal-world applications due to inherent algorithmic limitations and limited\nhigh-quality data. Here, we present NMR-Solver, a practical and interpretable\nframework for the automated determination of small organic molecule structures\nfrom $^1$H and $^{13}$C NMR spectra. Our method introduces an automated\nframework for molecular structure elucidation, integrating large-scale spectral\nmatching with physics-guided fragment-based optimization that exploits\natomic-level structure-spectrum relationships in NMR. We evaluate NMR-Solver on\nsimulated benchmarks, curated experimental data from the literature, and\nreal-world experiments, demonstrating its strong generalization, robustness,\nand practical utility in challenging, real-life scenarios. NMR-Solver unifies\ncomputational NMR analysis, deep learning, and interpretable chemical reasoning\ninto a coherent system. By incorporating the physical principles of NMR into\nmolecular optimization, it enables scalable, automated, and chemically\nmeaningful molecular identification, establishing a generalizable paradigm for\nsolving inverse problems in molecular science.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.00640v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00640v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.267,
      "weak_supervision_score": 0.302,
      "diffusion_reasoning_score": 0.376,
      "distributed_training_score": 0.299,
      "datasets_score": 0.238,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.02607",
      "title": "Towards Digital Twins for Optimal Radioembolization",
      "authors": [
        "Nisanth Kumar Panneerselvam",
        "Guneet Mummaneni",
        "Emilie Roncali"
      ],
      "categories": [
        "eess.IV (Image and Video Processing)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Radioembolization is a localized liver cancer treatment that delivers\nradioactive microspheres (30 micron) to tumors via a catheter inserted in the\nhepatic arterial tree. The goal is to maximize therapeutic efficacy while\nminimizing damage to healthy liver tissue. However, optimization is challenging\ndue to complex hepatic artery anatomy, variable blood flow, and uncertainty in\nmicrosphere transport. The creation of dynamic, patient-specific digital twins\nmay provide a transformative solution to these challenges. This work outlines a\nframework for a liver radioembolization digital twin using high-fidelity\ncomputational fluid dynamics (CFD) and/or recent physics-informed machine\nlearning approaches. The CFD approach involves microsphere transport\ncalculations in the hepatic arterial tree with individual patient data, which\nenables personalized treatment planning. Although accurate, traditional CFD is\ncomputationally expensive and limits clinical applicability.\n  To accelerate simulations, physics-informed neural networks (PINNs) and their\ngenerative extensions play an increasingly important role. PINNs integrate\ngoverning equations, such as the Navier-Stokes equations, directly into the\nneural network training process, enabling mesh-free, data-efficient\napproximation of blood flow and microsphere transport. Physics-informed\ngenerative adversarial networks (PI-GANs), diffusion models (PI-DMs), and\ntransformer-based architectures further enable uncertainty-aware, temporally\nresolved predictions with reduced computational cost. These AI surrogates not\nonly maintain physical fidelity but also support rapid sampling of diverse flow\nscenarios, facilitating real-time decision support.\n  Together, CFD and physics-informed AI methods form the foundation of dynamic,\npatient-specific digital twin to optimize radioembolization planning and\nultimately improve clinical outcomes.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.02607v1",
      "pdf_url": "http://arxiv.org/pdf/2509.02607v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "extraction_failed",
      "embedding_status": "completed",
      "rlhf_score": 0.309,
      "weak_supervision_score": 0.269,
      "diffusion_reasoning_score": 0.347,
      "distributed_training_score": 0.331,
      "datasets_score": 0.266,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.02609",
      "title": "Contrastive clustering based on regular equivalence for influential node\n  identification in complex networks",
      "authors": [
        "Yanmei Hu",
        "Yihang Wu",
        "Bing Sun",
        "Xue Yue",
        "Biao Cai",
        "Xiangtao Li",
        "Yang Chen"
      ],
      "categories": [
        "cs.SI (Social and Information Networks)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Identifying influential nodes in complex networks is a fundamental task in\nnetwork analysis with wide-ranging applications across domains. While deep\nlearning has advanced node influence detection, existing supervised approaches\nremain constrained by their reliance on labeled data, limiting their\napplicability in real-world scenarios where labels are scarce or unavailable.\nWhile contrastive learning demonstrates significant potential for performance\nenhancement, existing approaches predominantly rely on multiple-embedding\ngeneration to construct positive/negative sample pairs. To overcome these\nlimitations, we propose ReCC (\\textit{r}egular \\textit{e}quivalence-based\n\\textit{c}ontrastive \\textit{c}lustering), a novel deep unsupervised framework\nfor influential node identification. We first reformalize influential node\nidentification as a label-free deep clustering problem, then develop a\ncontrastive learning mechanism that leverages regular equivalence-based\nsimilarity, which captures structural similarities between nodes beyond local\nneighborhoods, to generate positive and negative samples. This mechanism is\nintegrated into a graph convolutional network to learn node embeddings that are\nused to differentiate influential from non-influential nodes. ReCC is\npre-trained using network reconstruction loss and fine-tuned with a combined\ncontrastive and clustering loss, with both phases being independent of labeled\ndata. Additionally, ReCC enhances node representations by combining structural\nmetrics with regular equivalence-based similarities. Extensive experiments\ndemonstrate that ReCC outperforms state-of-the-art approaches across several\nbenchmarks.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.02609v1",
      "pdf_url": "http://arxiv.org/pdf/2509.02609v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.352,
      "weak_supervision_score": 0.356,
      "diffusion_reasoning_score": 0.34,
      "distributed_training_score": 0.336,
      "datasets_score": 0.323,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.02610",
      "title": "Resilient Biosecurity in the Era of AI-Enabled Bioweapons",
      "authors": [
        "Jonathan Feldman",
        "Tal Feldman"
      ],
      "categories": [
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Recent advances in generative biology have enabled the design of novel\nproteins, creating significant opportunities for drug discovery while also\nintroducing new risks, including the potential development of synthetic\nbioweapons. Existing biosafety measures primarily rely on inference-time\nfilters such as sequence alignment and protein-protein interaction (PPI)\nprediction to detect dangerous outputs. In this study, we evaluate the\nperformance of three leading PPI prediction tools: AlphaFold 3, AF3Complex, and\nSpatialPPIv2. These models were tested on well-characterized viral-host\ninteractions, such as those involving Hepatitis B and SARS-CoV-2. Despite being\ntrained on many of the same viruses, the models fail to detect a substantial\nnumber of known interactions. Strikingly, none of the tools successfully\nidentify any of the four experimentally validated SARS-CoV-2 mutants with\nconfirmed binding. These findings suggest that current predictive filters are\ninadequate for reliably flagging even known biological threats and are even\nmore unlikely to detect novel ones. We argue for a shift toward\nresponse-oriented infrastructure, including rapid experimental validation,\nadaptable biomanufacturing, and regulatory frameworks capable of operating at\nthe speed of AI-driven developments.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.02610v1",
      "pdf_url": "http://arxiv.org/pdf/2509.02610v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.41,
      "weak_supervision_score": 0.333,
      "diffusion_reasoning_score": 0.355,
      "distributed_training_score": 0.354,
      "datasets_score": 0.299,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper's main contribution is an evaluation of protein-protein interaction prediction tools for biosecurity risks and a proposal for response-oriented infrastructure in AI-enabled bioweapons. It discusses generative AI in biology but does not mention, involve, or relate to reinforcement learning from human feedback (RLHF), which specifically entails training AI models using human-ranked data for alignment with human preferences. There is no discussion of reward models, fine-tuning via reinforcement learning, or human feedback mechanisms.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.02612",
      "title": "Is Synthetic Image Augmentation Useful for Imbalanced Classification\n  Problems? Case-Study on the MIDOG2025 Atypical Cell Detection Competition",
      "authors": [
        "Leire Benito-Del-Valle",
        "Pedro A. Moreno-Sánchez",
        "Itziar Egusquiza",
        "Itsaso Vitoria",
        "Artzai Picón",
        "Cristina López-Saratxaga",
        "Adrian Galdran"
      ],
      "categories": [
        "eess.IV (Image and Video Processing)",
        "cs.AI (Artificial Intelligence)",
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "The MIDOG 2025 challenge extends prior work on mitotic figure detection by\nintroducing a new Track 2 on atypical mitosis classification. This task aims to\ndistinguish normal from atypical mitotic figures in histopathology images, a\nclinically relevant but highly imbalanced and cross-domain problem. We\ninvestigated two complementary backbones: (i) ConvNeXt-Small, pretrained on\nImageNet, and (ii) a histopathology-specific ViT from Lunit trained via\nself-supervision. To address the strong prevalence imbalance (9408 normal vs.\n1741 atypical), we synthesized additional atypical examples to approximate\nclass balance and compared models trained with real-only vs. real+synthetic\ndata. Using five-fold cross-validation, both backbones reached strong\nperformance (mean AUROC approximately 95 percent), with ConvNeXt achieving\nslightly higher peaks while Lunit exhibited greater fold-to-fold stability.\nSynthetic balancing, however, did not lead to consistent improvements. On the\norganizers' preliminary hidden test set, explicitly designed as an\nout-of-distribution debug subset, ConvNeXt attained the highest AUROC (95.4\npercent), whereas Lunit remained competitive on balanced accuracy. These\nfindings suggest that both ImageNet and domain-pretrained backbones are viable\nfor atypical mitosis classification, with domain-pretraining conferring\nrobustness and ImageNet pretraining reaching higher peaks, while naive\nsynthetic balancing has limited benefit. Full hidden test set results will be\nreported upon challenge completion.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.02612v1",
      "pdf_url": "http://arxiv.org/pdf/2509.02612v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.272,
      "weak_supervision_score": 0.369,
      "diffusion_reasoning_score": 0.297,
      "distributed_training_score": 0.324,
      "datasets_score": 0.384,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.04474",
      "title": "Scaling Up, Speeding Up: A Benchmark of Speculative Decoding for\n  Efficient LLM Test-Time Scaling",
      "authors": [
        "Shengyin Sun",
        "Yiming Li",
        "Xing Li",
        "Yingzhao Lian",
        "Weizhe Lin",
        "Hui-Ling Zhen",
        "Zhiyuan Yang",
        "Chen Chen",
        "Xianzhi Yu",
        "Mingxuan Yuan",
        "Chen Ma"
      ],
      "categories": [
        "cs.CL (Computation and Language)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Test-time scaling has emerged as a powerful paradigm for enhancing the\nreasoning capabilities of large language models (LLMs) by allocating additional\ncomputational resources during inference. However, this paradigm is inherently\ninefficient due to the generation of redundant and repetitive reasoning traces,\nleading to significant computational overhead. Speculative decoding offers a\npromising avenue for mitigating this inefficiency, yet its efficacy in the\nstructured, repetition-rich context of test-time scaling remains largely\nunexplored. To bridge this gap, we introduce the first comprehensive benchmark\ndesigned to evaluate speculative decoding methods for accelerating LLM\ntest-time scaling. Our benchmark provides consistent experimental protocols\nacross representative test-time scaling paradigms (e.g., Best-of-N sampling and\nmulti-round thinking), enabling a fair comparison of three major categories of\nspeculative decoding: model-based, training-based, and n-gram-based methods.\nExtensive experiments reveal that simple n-gram-based methods effectively\ncapture repetitive patterns, demonstrating unique potential in accelerating\ntest-time scaling. This phenomenon demonstrates the value of integrating\nn-gram-based methods with model-based or training-based approaches to balance\nacceleration for both repetitive and diverse reasoning in test-time scaling. We\nhope this benchmark spurs further research on speculative decoding for\ntest-time scaling, enabling faster and more practical reasoning in LLMs through\nbetter handling of repetitive and diverse reasoning paths.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.04474v1",
      "pdf_url": "http://arxiv.org/pdf/2509.04474v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.387,
      "weak_supervision_score": 0.375,
      "diffusion_reasoning_score": 0.487,
      "distributed_training_score": 0.451,
      "datasets_score": 0.343,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "Not Relevant",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on benchmarking speculative decoding methods to accelerate test-time scaling in LLMs, emphasizing efficient inference through techniques like n-gram-based predictions. It does not involve diffusion models, iterative refinement processes for noise addition/removal, or treating Chain-of-Thought as a holistic entity for correction, which are core to diffusion-based reasoning.",
      "distributed_training_justification": "The paper is centered on inference-time acceleration techniques for LLMs, such as speculative decoding, and does not address distributed training, parallel computing, or multi-node strategies for accelerating model training through data/model partitioning.",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.04475",
      "title": "ParaThinker: Native Parallel Thinking as a New Paradigm to Scale LLM\n  Test-time Compute",
      "authors": [
        "Hao Wen",
        "Yifan Su",
        "Feifei Zhang",
        "Yunxin Liu",
        "Yunhao Liu",
        "Ya-Qin Zhang",
        "Yuanchun Li"
      ],
      "categories": [
        "cs.CL (Computation and Language)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Recent advances in Large Language Models (LLMs) have been driven by test-time\ncompute scaling - a strategy that improves reasoning by generating longer,\nsequential thought processes. While effective, this approach encounters a\nsignificant bottleneck as computation increases, where further computation\noffers only marginal performance gains. We argue this ceiling is not an\ninherent limit of the model's capability but a flaw in the scaling strategy\nitself, a phenomenon we term \"Tunnel Vision\", where a model's imperfect initial\nsteps lock it into a suboptimal reasoning path. To overcome this, we introduce\na new scaling paradigm: native thought parallelism. We present ParaThinker, an\nend-to-end framework that trains an LLM to generate multiple, diverse reasoning\npaths in parallel and synthesize them into a superior final answer. By\nexploring different lines of thoughts simultaneously, ParaThinker effectively\nsidesteps the Tunnel Vision issue and unlocks the model's latent reasoning\npotential. Our approach demonstrates that scaling compute in parallel (width)\nis a more effective and efficient way to superior reasoning than simply scaling\nsequentially (depth). On challenging reasoning benchmarks, ParaThinker achieves\nsubstantial accuracy improvements over sequential LLMs (12.3% for 1.5B and 7.5%\nfor 7B models on average with 8 parallel paths), while adding only negligible\nlatency overhead (7.1%). This enables smaller models to surpass much larger\ncounterparts and establishes parallel thinking as a critical, efficient\ndimension for scaling future LLMs.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.04475v1",
      "pdf_url": "http://arxiv.org/pdf/2509.04475v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.365,
      "weak_supervision_score": 0.341,
      "diffusion_reasoning_score": 0.534,
      "distributed_training_score": 0.491,
      "datasets_score": 0.3,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "Tangentially Relevant",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper introduces a parallel reasoning framework for LLMs, focusing on generating multiple thought paths simultaneously to improve reasoning accuracy. It does not involve diffusion models, iterative refinement processes, or treating a Chain-of-Thought as a single entity for holistic correction, which are core to diffusion-based reasoning. Thus, there is no connection to this topic.",
      "distributed_training_justification": "The paper discusses parallel computing aspects, such as batching decoding processes for better memory bandwidth utilization during inference, which relates loosely to parallel computing concepts. However, it primarily focuses on test-time parallelism for reasoning in LLMs, not on distributed training techniques like partitioning data or models across nodes for accelerating training.",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.04476",
      "title": "Training Text-to-Molecule Models with Context-Aware Tokenization",
      "authors": [
        "Seojin Kim",
        "Hyeontae Song",
        "Jaehyun Nam",
        "Jinwoo Shin"
      ],
      "categories": [
        "cs.CL (Computation and Language)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Recently, text-to-molecule models have shown great potential across various\nchemical applications, e.g., drug-discovery. These models adapt language models\nto molecular data by representing molecules as sequences of atoms. However,\nthey rely on atom-level tokenizations, which primarily focus on modeling local\nconnectivity, thereby limiting the ability of models to capture the global\nstructural context within molecules. To tackle this issue, we propose a novel\ntext-to-molecule model, coined Context-Aware Molecular T5 (CAMT5). Inspired by\nthe significance of the substructure-level contexts in understanding molecule\nstructures, e.g., ring systems, we introduce substructure-level tokenization\nfor text-to-molecule models. Building on our tokenization scheme, we develop an\nimportance-based training strategy that prioritizes key substructures, enabling\nCAMT5 to better capture the molecular semantics. Extensive experiments verify\nthe superiority of CAMT5 in various text-to-molecule generation tasks.\nIntriguingly, we find that CAMT5 outperforms the state-of-the-art methods using\nonly 2% of training tokens. In addition, we propose a simple yet effective\nensemble strategy that aggregates the outputs of text-to-molecule models to\nfurther boost the generation performance. Code is available at\nhttps://github.com/Songhyeontae/CAMT5.git.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.04476v2",
      "pdf_url": "http://arxiv.org/pdf/2509.04476v2",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.31,
      "weak_supervision_score": 0.308,
      "diffusion_reasoning_score": 0.421,
      "distributed_training_score": 0.341,
      "datasets_score": 0.282,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on text-to-molecule models using context-aware tokenization and importance-based training strategies, primarily adapting language models like T5 for molecular generation tasks. It does not involve diffusion models, iterative refinement for logical reasoning, or any multi-step chain-of-thought processes as described in the topic. Therefore, there is no connection to diffusion-based reasoning.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.04479",
      "title": "No Clustering, No Routing: How Transformers Actually Process Rare Tokens",
      "authors": [
        "Jing Liu"
      ],
      "categories": [
        "cs.CL (Computation and Language)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Large language models struggle with rare token prediction, yet the mechanisms\ndriving their specialization remain unclear. Prior work identified specialized\n``plateau'' neurons for rare tokens following distinctive three-regime\ninfluence patterns \\cite{liu2025emergent}, but their functional organization is\nunknown. We investigate this through neuron influence analyses, graph-based\nclustering, and attention head ablations in GPT-2 XL and Pythia models. Our\nfindings show that: (1) rare token processing requires additional plateau\nneurons beyond the power-law regime sufficient for common tokens, forming dual\ncomputational regimes; (2) plateau neurons are spatially distributed rather\nthan forming modular clusters; and (3) attention mechanisms exhibit no\npreferential routing to specialists. These results demonstrate that rare token\nspecialization arises through distributed, training-driven differentiation\nrather than architectural modularity, preserving context-sensitive flexibility\nwhile achieving adaptive capacity allocation.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.04479v1",
      "pdf_url": "http://arxiv.org/pdf/2509.04479v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.379,
      "weak_supervision_score": 0.37,
      "diffusion_reasoning_score": 0.454,
      "distributed_training_score": 0.449,
      "datasets_score": 0.307,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "Not Relevant",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper examines neuron influence and attention mechanisms in transformers for processing rare tokens, with no mention of diffusion models, iterative refinement processes, or multi-step logical reasoning. It does not involve adapting diffusion for holistic Chain-of-Thought correction.",
      "distributed_training_justification": "The paper discusses the distributed organization of neurons within a trained transformer model, referring to spatial differentiation rather than distributed training techniques, parallel computing, or multi-node systems for accelerating model training.",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.05318",
      "title": "Backdoor Samples Detection Based on Perturbation Discrepancy Consistency\n  in Pre-trained Language Models",
      "authors": [
        "Zuquan Peng",
        "Jianming Fu",
        "Lixin Zou",
        "Li Zheng",
        "Yanzhen Ren",
        "Guojun Peng"
      ],
      "categories": [
        "cs.CR (Cryptography and Security)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "The use of unvetted third-party and internet data renders pre-trained models\nsusceptible to backdoor attacks. Detecting backdoor samples is critical to\nprevent backdoor activation during inference or injection during training.\nHowever, existing detection methods often require the defender to have access\nto the poisoned models, extra clean samples, or significant computational\nresources to detect backdoor samples, limiting their practicality. To address\nthis limitation, we propose a backdoor sample detection method based on\nperturbatio\\textbf{N} discr\\textbf{E}pancy consis\\textbf{T}ency\n\\textbf{E}valuation (\\NETE). This is a novel detection method that can be used\nboth pre-training and post-training phases. In the detection process, it only\nrequires an off-the-shelf pre-trained model to compute the log probability of\nsamples and an automated function based on a mask-filling strategy to generate\nperturbations. Our method is based on the interesting phenomenon that the\nchange in perturbation discrepancy for backdoor samples is smaller than that\nfor clean samples. Based on this phenomenon, we use curvature to measure the\ndiscrepancy in log probabilities between different perturbed samples and input\nsamples, thereby evaluating the consistency of the perturbation discrepancy to\ndetermine whether the input sample is a backdoor sample. Experiments conducted\non four typical backdoor attacks and five types of large language model\nbackdoor attacks demonstrate that our detection strategy outperforms existing\nzero-shot black-box detection methods.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.05318v1",
      "pdf_url": "http://arxiv.org/pdf/2509.05318v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.36,
      "weak_supervision_score": 0.396,
      "diffusion_reasoning_score": 0.4,
      "distributed_training_score": 0.392,
      "datasets_score": 0.321,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper's main contribution is a method for detecting backdoor samples in pre-trained language models using perturbation discrepancy and consistency in log probabilities. It does not involve diffusion models, iterative refinement processes, Chain-of-Thought reasoning, or any adaptation of diffusion for logical tasks. Therefore, it has no connection to the topic.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.05319",
      "title": "Context-Aware Knowledge Distillation with Adaptive Weighting for Image\n  Classification",
      "authors": [
        "Zhengda Li"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Knowledge distillation (KD) is a widely used technique to transfer knowledge\nfrom a large teacher network to a smaller student model. Traditional KD uses a\nfixed balancing factor alpha as a hyperparameter to combine the hard-label\ncross-entropy loss with the soft-label distillation loss. However, a static\nalpha is suboptimal because the optimal trade-off between hard and soft\nsupervision can vary during training.\n  In this work, we propose an Adaptive Knowledge Distillation (AKD) framework.\nFirst we try to make alpha as learnable parameter that can be automatically\nlearned and optimized during training. Then we introduce a formula to reflect\nthe gap between the student and the teacher to compute alpha dynamically,\nguided by student-teacher discrepancies, and further introduce a Context-Aware\nModule (CAM) using MLP + Attention to adaptively reweight class-wise teacher\noutputs. Experiments on CIFAR-10 with ResNet-50 as teacher and ResNet-18 as\nstudent demonstrate that our approach achieves superior accuracy compared to\nfixed-weight KD baselines, and yields more stable convergence.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.05319v1",
      "pdf_url": "http://arxiv.org/pdf/2509.05319v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.371,
      "weak_supervision_score": 0.405,
      "diffusion_reasoning_score": 0.394,
      "distributed_training_score": 0.389,
      "datasets_score": 0.334,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "Not Relevant",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "The paper's main contribution is an adaptive framework for knowledge distillation, which transfers knowledge from a teacher model to a student model using both hard (ground truth) and soft (teacher-derived) labels. This does not involve programmatically generating large quantities of noisy or imprecise labels from high-level sources, which is the core of weak supervision. Instead, it relies on precise training data and a pre-trained teacher, making it unrelated to weak supervision techniques.",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.05321",
      "title": "A Dataset Generation Scheme Based on Video2EEG-SPGN-Diffusion for\n  SEED-VD",
      "authors": [
        "Yunfei Guo",
        "Tao Zhang",
        "Wu Huang",
        "Yao Song"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "This paper introduces an open-source framework, Video2EEG-SPGN-Diffusion,\nthat leverages the SEED-VD dataset to generate a multimodal dataset of EEG\nsignals conditioned on video stimuli. Additionally, we disclose an engineering\npipeline for aligning video and EEG data pairs, facilitating the training of\nmultimodal large models with EEG alignment capabilities. Personalized EEG\nsignals are generated using a self-play graph network (SPGN) integrated with a\ndiffusion model. As a major contribution, we release a new dataset comprising\nover 1000 samples of SEED-VD video stimuli paired with generated 62-channel EEG\nsignals at 200 Hz and emotion labels, enabling video-EEG alignment and\nadvancing multimodal research. This framework offers novel tools for emotion\nanalysis, data augmentation, and brain-computer interface applications, with\nsubstantial research and engineering significance.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.05321v1",
      "pdf_url": "http://arxiv.org/pdf/2509.05321v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.338,
      "weak_supervision_score": 0.369,
      "diffusion_reasoning_score": 0.465,
      "distributed_training_score": 0.364,
      "datasets_score": 0.466,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "Highly Relevant",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper uses a diffusion model for generating EEG signals based on video stimuli, integrated with a self-play graph network. However, it does not involve adapting the diffusion process for multi-step logical reasoning, such as treating a chain-of-thought as a holistic entity for iterative correction. The focus is on data generation for EEG, not on solving complex logical tasks, so it does not meet the topic's criteria.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "The paper's main contribution includes introducing and releasing a new dataset with over 1000 samples of video stimuli paired with generated EEG signals and emotion labels, specifically for multimodal research. This directly aligns with research on creating and curating datasets for AI applications, including data augmentation and benchmarking for EEG-related tasks, fulfilling the topic's focus on dataset introduction and methodologies.",
      "llm_score_status": "completed",
      "summary": "This paper introduces the Video2EEG-SPGN-Diffusion framework, which leverages the SEED-VD dataset to generate synthetic EEG signals conditioned on video stimuli using a self-play graph network (SPGN) integrated with a diffusion model, aiming to address EEG data scarcity and privacy concerns. The methodology involves aligning video and EEG data pairs through an engineering pipeline, resulting in the release of a new open-source dataset comprising over 1000 samples of video segments paired with 62-channel EEG signals and emotion labels, which supports applications in emotion analysis, data augmentation, and brain-computer interfaces.",
      "novelty_score": "High",
      "novelty_justification": "The paper introduces a truly new framework that combines SPGN and diffusion models for generating personalized EEG from video stimuli, advancing the state-of-the-art in EEG data generation and video-EEG alignment. This represents a significant innovation in addressing data scarcity and privacy in brain-computer interface research.",
      "impact_score": "Moderate",
      "impact_justification": "The work is likely to be cited and built upon within subfields like computer vision and artificial intelligence for EEG applications, as it provides a new dataset and tools for multimodal model training. However, its influence may be limited to specific areas such as BCI and emotion analysis rather than broader fields.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "This paper represents a strong, valuable contribution by offering new tools and a dataset for EEG research, making it essential for researchers in AI, computer vision, and neuroscience to be aware of. While not groundbreaking for all audiences, it advances key areas like data privacy and multimodal alignment.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/5bc62eb050b80c8dbdb58a93d31df7f31fd16429",
      "total_authors": 4,
      "authors_found": 4,
      "highest_h_index": 8,
      "average_h_index": 3.0,
      "notable_authors_count": 1,
      "author_h_indexes": [
        {
          "name": "Yunfei Guo",
          "h_index": 3,
          "profile_url": "https://www.semanticscholar.org/author/2035557377"
        },
        {
          "name": "Tao Zhang",
          "h_index": 8,
          "profile_url": "https://www.semanticscholar.org/author/2146342045"
        },
        {
          "name": "Wu Huang",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2352506841"
        },
        {
          "name": "Yao Song",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2379937317"
        }
      ]
    },
    {
      "id": "2509.05322",
      "title": "Application of discrete Ricci curvature in pruning randomly wired neural\n  networks: A case study with chest x-ray classification of COVID-19",
      "authors": [
        "Pavithra Elumalai",
        "Sudharsan Vijayaraghavan",
        "Madhumita Mondal",
        "Areejit Samal"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.LG (Machine Learning)",
        "cs.SI (Social and Information Networks)"
      ],
      "abstract": "Randomly Wired Neural Networks (RWNNs) serve as a valuable testbed for\ninvestigating the impact of network topology in deep learning by capturing how\ndifferent connectivity patterns impact both learning efficiency and model\nperformance. At the same time, they provide a natural framework for exploring\nedge-centric network measures as tools for pruning and optimization. In this\nstudy, we investigate three edge-centric network measures: Forman-Ricci\ncurvature (FRC), Ollivier-Ricci curvature (ORC), and edge betweenness\ncentrality (EBC), to compress RWNNs by selectively retaining important synapses\n(or edges) while pruning the rest. As a baseline, RWNNs are trained for\nCOVID-19 chest x-ray image classification, aiming to reduce network complexity\nwhile preserving performance in terms of accuracy, specificity, and\nsensitivity. We extend prior work on pruning RWNN using ORC by incorporating\ntwo additional edge-centric measures, FRC and EBC, across three network\ngenerators: Erd\\\"{o}s-R\\'{e}nyi (ER) model, Watts-Strogatz (WS) model, and\nBarab\\'{a}si-Albert (BA) model. We provide a comparative analysis of the\npruning performance of the three measures in terms of compression ratio and\ntheoretical speedup. A central focus of our study is to evaluate whether FRC,\nwhich is computationally more efficient than ORC, can achieve comparable\npruning effectiveness. Along with performance evaluation, we further\ninvestigate the structural properties of the pruned networks through modularity\nand global efficiency, offering insights into the trade-off between modular\nsegregation and network efficiency in compressed RWNNs. Our results provide\ninitial evidence that FRC-based pruning can effectively simplify RWNNs,\noffering significant computational advantages while maintaining performance\ncomparable to ORC.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.05322v1",
      "pdf_url": "http://arxiv.org/pdf/2509.05322v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.339,
      "weak_supervision_score": 0.315,
      "diffusion_reasoning_score": 0.349,
      "distributed_training_score": 0.353,
      "datasets_score": 0.296,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.05323",
      "title": "Attention of a Kiss: Exploring Attention Maps in Video Diffusion for\n  XAIxArts",
      "authors": [
        "Adam Cole",
        "Mick Grierson"
      ],
      "categories": [
        "cs.AI (Artificial Intelligence)",
        "cs.MM (Multimedia)"
      ],
      "abstract": "This paper presents an artistic and technical investigation into the\nattention mechanisms of video diffusion transformers. Inspired by early video\nartists who manipulated analog video signals to create new visual aesthetics,\nthis study proposes a method for extracting and visualizing cross-attention\nmaps in generative video models. Built on the open-source Wan model, our tool\nprovides an interpretable window into the temporal and spatial behavior of\nattention in text-to-video generation. Through exploratory probes and an\nartistic case study, we examine the potential of attention maps as both\nanalytical tools and raw artistic material. This work contributes to the\ngrowing field of Explainable AI for the Arts (XAIxArts), inviting artists to\nreclaim the inner workings of AI as a creative medium.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.05323v2",
      "pdf_url": "http://arxiv.org/pdf/2509.05323v2",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.352,
      "weak_supervision_score": 0.291,
      "diffusion_reasoning_score": 0.512,
      "distributed_training_score": 0.288,
      "datasets_score": 0.332,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper's main contribution is the visualization of attention maps in video diffusion models for artistic and interpretability purposes, specifically in the context of XAIxArts. It does not involve adapting the iterative refinement process of diffusion for multi-step logical reasoning, chain-of-thought processes, or solving complex logical tasks. Therefore, it lacks any component related to diffusion-based reasoning as defined.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.05324",
      "title": "Perception Graph for Cognitive Attack Reasoning in Augmented Reality",
      "authors": [
        "Rongqian Chen",
        "Shu Hong",
        "Rifatul Islam",
        "Mahdi Imani",
        "G. Gary Tan",
        "Tian Lan"
      ],
      "categories": [
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Augmented reality (AR) systems are increasingly deployed in tactical\nenvironments, but their reliance on seamless human-computer interaction makes\nthem vulnerable to cognitive attacks that manipulate a user's perception and\nseverely compromise user decision-making. To address this challenge, we\nintroduce the Perception Graph, a novel model designed to reason about human\nperception within these systems. Our model operates by first mimicking the\nhuman process of interpreting key information from an MR environment and then\nrepresenting the outcomes using a semantically meaningful structure. We\ndemonstrate how the model can compute a quantitative score that reflects the\nlevel of perception distortion, providing a robust and measurable method for\ndetecting and analyzing the effects of such cognitive attacks.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.05324v1",
      "pdf_url": "http://arxiv.org/pdf/2509.05324v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.376,
      "weak_supervision_score": 0.307,
      "diffusion_reasoning_score": 0.461,
      "distributed_training_score": 0.272,
      "datasets_score": 0.284,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper introduces a Perception Graph model that uses pre-trained vision language models to mimic human perception and detect cognitive attacks in augmented reality. It focuses on semantic representation and distortion scoring, with no mention of diffusion models, iterative refinement processes, or multi-step logical reasoning as described in the topic. Therefore, there is no clear component aligning with diffusion-based reasoning.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.05325",
      "title": "SynDelay: A Synthetic Dataset for Delivery Delay Prediction",
      "authors": [
        "Liming Xu",
        "Yunbo Long",
        "Alexandra Brintrup"
      ],
      "categories": [
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Artificial intelligence (AI) is transforming supply chain management, yet\nprogress in predictive tasks -- such as delivery delay prediction -- remains\nconstrained by the scarcity of high-quality, openly available datasets.\nExisting datasets are often proprietary, small, or inconsistently maintained,\nhindering reproducibility and benchmarking. We present SynDelay, a synthetic\ndataset designed for delivery delay prediction. Generated using an advanced\ngenerative model trained on real-world data, SynDelay preserves realistic\ndelivery patterns while ensuring privacy. Although not entirely free of noise\nor inconsistencies, it provides a challenging and practical testbed for\nadvancing predictive modelling. To support adoption, we provide baseline\nresults and evaluation metrics as initial benchmarks, serving as reference\npoints rather than state-of-the-art claims. SynDelay is publicly available\nthrough the Supply Chain Data Hub, an open initiative promoting dataset sharing\nand benchmarking in supply chain AI. We encourage the community to contribute\ndatasets, models, and evaluation practices to advance research in this area.\nAll code is openly accessible at https://supplychaindatahub.org.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.05325v1",
      "pdf_url": "http://arxiv.org/pdf/2509.05325v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.335,
      "weak_supervision_score": 0.4,
      "diffusion_reasoning_score": 0.375,
      "distributed_training_score": 0.378,
      "datasets_score": 0.493,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "Tangentially Relevant",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "Highly Relevant",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "The paper introduces a synthetic dataset generated using a generative model trained on real-world data, which might involve programmatically created labels that could be noisy. However, it does not focus on weak supervision as a primary method for training models; instead, it emphasizes dataset creation for benchmarking, making the connection indirect.",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "The paper's main contribution is the creation, curation, and benchmarking of a new synthetic dataset (SynDelay) for delivery delay prediction in AI applications, including discussions on its generation, evaluation metrics, and role as a benchmark, which directly aligns with research on datasets.",
      "llm_score_status": "completed",
      "summary": "The paper introduces SynDelay, a synthetic dataset designed to address the scarcity of high-quality, openly available data for delivery delay prediction in supply chain management. Generated using an advanced generative model trained on real-world data, SynDelay preserves realistic delivery patterns while ensuring privacy, and includes baseline models and evaluation metrics to facilitate reproducible research and benchmarking, encouraging community contributions through the Supply Chain Data Hub.",
      "novelty_score": "Moderate",
      "novelty_justification": "The paper presents a notable improvement by creating a new synthetic dataset for delivery delay prediction, which combines existing generative techniques to address a known data scarcity issue in supply chain AI, though it does not introduce a fundamentally new problem or technique.",
      "impact_score": "Moderate",
      "impact_justification": "The work is likely to be cited and built upon within the supply chain AI subfield by providing a much-needed benchmark dataset, but its influence may be limited to specialized applications rather than broader research or commercial domains.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "This paper represents a strong and valuable contribution by offering a practical resource for advancing research in supply chain AI, making it essential for researchers in this area to be aware of, though not universally critical for all audiences.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/3b30be9dd49f5ec4569c28019ceeb4be73afdd17",
      "total_authors": 3,
      "authors_found": 3,
      "highest_h_index": 8,
      "average_h_index": 5.333333333333333,
      "notable_authors_count": 2,
      "author_h_indexes": [
        {
          "name": "Liming Xu",
          "h_index": 6,
          "profile_url": "https://www.semanticscholar.org/author/2239053851"
        },
        {
          "name": "Yunbo Long",
          "h_index": 2,
          "profile_url": "https://www.semanticscholar.org/author/2323315765"
        },
        {
          "name": "Alexandra Brintrup",
          "h_index": 8,
          "profile_url": "https://www.semanticscholar.org/author/2244621141"
        }
      ]
    },
    {
      "id": "2509.05326",
      "title": "Zero-Knowledge Proofs in Sublinear Space",
      "authors": [
        "Logan Nye"
      ],
      "categories": [
        "cs.CR (Cryptography and Security)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Zero-knowledge proofs allow verification of computations without revealing\nprivate information. However, existing systems require memory proportional to\nthe computation size, which has historically limited use in large-scale\napplications and on mobile and edge devices. We solve this fundamental\nbottleneck by developing, to our knowledge, the first proof system with\nsublinear memory requirements for mainstream cryptographic constructions. Our\napproach processes computations in blocks using a space-efficient tree\nalgorithm, reducing memory from linear scaling to square-root scaling--from\n$\\Theta(T)$ to $O(\\sqrt{T} + \\log T \\log\\log T)$ for computation size\n$T$--while maintaining the same proof generation time through a constant number\nof streaming passes. For widely-used linear polynomial commitment schemes\n(KZG/IPA), our method produces identical proofs and verification when using the\nsame parameters and hashing only aggregate commitments into the challenge\ngeneration, preserving proof size and security. Hash-based systems also achieve\nsquare-root memory scaling though with slightly different proof structures.\nThis advance enables zero-knowledge proofs on everyday devices and makes\npreviously infeasible large computations verifiable, fundamentally\ndemocratizing access to privacy-preserving computation. Space-efficient zero\nknowledge proof systems create opportunities to reshape how trust is\nestablished in digital systems--from enabling widespread participation in\ndecentralized networks to making verifiable scientific computing practical at\nunprecedented scales.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.05326v2",
      "pdf_url": "http://arxiv.org/pdf/2509.05326v2",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.259,
      "weak_supervision_score": 0.298,
      "diffusion_reasoning_score": 0.308,
      "distributed_training_score": 0.356,
      "datasets_score": 0.222,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.08835",
      "title": "Deep opacity and AI: A threat to XAI and to privacy protection\n  mechanisms",
      "authors": [
        "Vincent C. Müller"
      ],
      "categories": [
        "cs.CY (Computers and Society)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "It is known that big data analytics and AI pose a threat to privacy, and that\nsome of this is due to some kind of \"black box problem\" in AI. I explain how\nthis becomes a problem in the context of justification for judgments and\nactions. Furthermore, I suggest distinguishing three kinds of opacity: 1) the\nsubjects do not know what the system does (\"shallow opacity\"), 2) the analysts\ndo not know what the system does (\"standard black box opacity\"), or 3) the\nanalysts cannot possibly know what the system might do (\"deep opacity\"). If the\nagents, data subjects as well as analytics experts, operate under opacity, then\nthese agents cannot provide justifications for judgments that are necessary to\nprotect privacy, e.g., they cannot give \"informed consent\", or guarantee\n\"anonymity\". It follows from these points that agents in big data analytics and\nAI often cannot make the judgments needed to protect privacy. So I conclude\nthat big data analytics makes the privacy problems worse and the remedies less\neffective. As a positive note, I provide a brief outlook on technical ways to\nhandle this situation.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.08835v1",
      "pdf_url": "http://arxiv.org/pdf/2509.08835v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "extraction_failed",
      "embedding_status": "completed",
      "rlhf_score": 0.366,
      "weak_supervision_score": 0.376,
      "diffusion_reasoning_score": 0.357,
      "distributed_training_score": 0.3,
      "datasets_score": 0.346,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.10486",
      "title": "SABR: A Stable Adaptive Bitrate Framework Using Behavior Cloning\n  Pretraining and Reinforcement Learning Fine-Tuning",
      "authors": [
        "Pengcheng Luo",
        "Yunyang Zhao",
        "Bowen Zhang",
        "Genke Yang",
        "Boon-Hee Soong",
        "Chau Yuen"
      ],
      "categories": [
        "cs.NI (Networking and Internet Architecture)",
        "cs.AI (Artificial Intelligence)",
        "cs.LG (Machine Learning)",
        "cs.MM (Multimedia)"
      ],
      "abstract": "With the advent of 5G, the internet has entered a new video-centric era. From\nshort-video platforms like TikTok to long-video platforms like Bilibili, online\nvideo services are reshaping user consumption habits. Adaptive Bitrate (ABR)\ncontrol is widely recognized as a critical factor influencing Quality of\nExperience (QoE). Recent learning-based ABR methods have attracted increasing\nattention. However, most of them rely on limited network trace sets during\ntraining and overlook the wide-distribution characteristics of real-world\nnetwork conditions, resulting in poor generalization in out-of-distribution\n(OOD) scenarios. To address this limitation, we propose SABR, a training\nframework that combines behavior cloning (BC) pretraining with reinforcement\nlearning (RL) fine-tuning. We also introduce benchmarks, ABRBench-3G and\nABRBench-4G+, which provide wide-coverage training traces and dedicated OOD\ntest sets for assessing robustness to unseen network conditions. Experimental\nresults demonstrate that SABR achieves the best average rank compared with\nPensieve, Comyco, and NetLLM across the proposed benchmarks. These results\nindicate that SABR enables more stable learning across wide distributions and\nimproves generalization to unseen network conditions.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.10486v1",
      "pdf_url": "http://arxiv.org/pdf/2509.10486v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.429,
      "weak_supervision_score": 0.382,
      "diffusion_reasoning_score": 0.363,
      "distributed_training_score": 0.417,
      "datasets_score": 0.317,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Tangentially Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "Not Relevant",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper uses RL fine-tuning with PPO, inspired by LLM techniques like RLHF, but it does not involve training a reward model on human-ranked data or explicitly use human feedback. Instead, it focuses on BC pretraining with DPO and RL for ABR optimization, making it only loosely related to RLHF.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "The paper does not discuss distributed training, parallel computing, or multi-node machine learning techniques. It focuses on a two-stage training framework for ABR (BC pretraining and RL fine-tuning) and benchmarks, with no mention of partitioning data or computation across processors.",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.13328",
      "title": "Dual Actor DDPG for Airborne STAR-RIS Assisted Communications",
      "authors": [
        "Danish Rizvi",
        "David Boyle"
      ],
      "categories": [
        "eess.SP (Signal Processing)",
        "cs.AI (Artificial Intelligence)",
        "cs.IT (Information Theory)",
        "cs.NI (Networking and Internet Architecture)",
        "math.IT (Information Theory)"
      ],
      "abstract": "This study departs from the prevailing assumption of independent Transmission\nand Reflection Coefficients (TRC) in Airborne Simultaneous Transmit and Reflect\nReconfigurable Intelligent Surface (STAR-RIS) research. Instead, we explore a\nnovel multi-user downlink communication system that leverages a UAV-mounted\nSTAR-RIS (Aerial-STAR) incorporating a coupled TRC phase shift model. Our key\ncontributions include the joint optimization of UAV trajectory, active\nbeamforming vectors at the base station, and passive RIS TRCs to enhance\ncommunication efficiency, while considering UAV energy constraints. We design\nthe TRC as a combination of discrete and continuous actions, and propose a\nnovel Dual Actor Deep Deterministic Policy Gradient (DA-DDPG) algorithm. The\nalgorithm relies on two separate actor networks for high-dimensional hybrid\naction space. We also propose a novel harmonic mean index (HFI)-based reward\nfunction to ensure communication fairness amongst users. For comprehensive\nanalysis, we study the impact of RIS size on UAV aerodynamics showing that it\nincreases drag and energy demand. Simulation results demonstrate that the\nproposed DA-DDPG algorithm outperforms conventional DDPG and DQN-based\nsolutions by 24% and 97%, respectively, in accumulated reward.\nThree-dimensional UAV trajectory optimization achieves 28% higher communication\nefficiency compared to two-dimensional and altitude optimization. The HFI based\nreward function provides 41% lower QoS denial rates as compared to other\nbenchmarks. The mobile Aerial-STAR system shows superior performance over fixed\ndeployed counterparts, with the coupled phase STAR-RIS outperforming dual\nTransmit/Reflect RIS and conventional RIS setups. These findings highlight the\npotential of Aerial-STAR systems and the effectiveness of our proposed DA-DDPG\napproach in optimizing their performance.",
      "published_date": "2025-08-30",
      "arxiv_url": "http://arxiv.org/abs/2509.13328v1",
      "pdf_url": "http://arxiv.org/pdf/2509.13328v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.42,
      "weak_supervision_score": 0.309,
      "diffusion_reasoning_score": 0.366,
      "distributed_training_score": 0.424,
      "datasets_score": 0.308,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "Not Relevant",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper focuses on a Dual Actor DDPG algorithm for optimizing UAV trajectory and RIS parameters, which is a reinforcement learning approach, but it does not involve human feedback. There is no mention of training a reward model on human-ranked data or aligning the model with human preferences; instead, the reward function is based on simulated metrics like the Harmonic Fairness Index.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "The paper does not address distributed training, parallel computing, or multi-node machine learning. It describes a single-agent reinforcement learning algorithm (DA-DDPG) for optimization in a UAV-assisted communication system, with no discussion of partitioning data, models, or computations across multiple processors or nodes.",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    }
  ],
  "total_papers": 102,
  "date": "2025-08-30"
};
    </script>

    <script>
        // ============================================================================
        // GLOBAL VARIABLES & CONFIGURATION
        // ============================================================================
        
        // Page configuration - get data from embedded PAPER_DATA
        const PAGE_DATE = PAPER_DATA.date;
        const PAPERS_PER_PAGE = 5;
        let currentPage = 1;
        let totalPapers = PAPER_DATA.total_papers;
        let totalPages = 0;
        let allPapers = PAPER_DATA.papers;  // Use embedded papers data
        let filteredSortedPapers = [];  // Store papers after filtering/sorting
        let currentPagePapers = [];  // Store papers for current page display
        let currentSort = 'recommend_best';  // Default sort
        
        // H-Index Filter State Management
        let currentHIndexFilters = {
            found: true,
            notFound: true,
            highestMin: 0,
            highestMax: 1000,
            averageMin: 0,
            averageMax: 1000
        };
        
        let pendingHIndexFilters = { ...currentHIndexFilters };
        
        // Topic Filter State Management
        let currentTopicFilters = {
            rlhf: true,
            weakSupervision: true,
            diffusionReasoning: true,
            distributedTraining: true,
            datasets: true
        };
        
        let pendingTopicFilters = { ...currentTopicFilters };
        
        // Relevance Filter State Management
        let currentRelevanceFilters = {
            highlyRelevant: true,
            moderatelyRelevant: true,
            tangentiallyRelevant: true,
            notRelevant: true
        };
        
        let pendingRelevanceFilters = { ...currentRelevanceFilters };
        
        // Sidebar state variables
        let isMobileSidebarOpen = false;
        let isDesktopSidebarOpen = false;

        // ============================================================================
        // URL PARAMETER UTILITIES
        // ============================================================================
        
        function getUrlParameter(name) {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get(name);
        }
        
        function setUrlParameter(name, value) {
            const url = new URL(window.location.href);
            url.searchParams.set(name, value);
            window.history.pushState(null, '', url.toString());
        }
        
        function updateHIndexFiltersFromURL() {
            // Get H-Index filter parameters from URL
            const hindexFound = getUrlParameter('hindex_found');
            const hindexNotFound = getUrlParameter('hindex_not_found');
            const highestMin = getUrlParameter('highest_min');
            const highestMax = getUrlParameter('highest_max');
            const averageMin = getUrlParameter('average_min');
            const averageMax = getUrlParameter('average_max');
            
            // Update current filters if parameters exist
            if (hindexFound !== null) currentHIndexFilters.found = hindexFound === 'true';
            if (hindexNotFound !== null) currentHIndexFilters.notFound = hindexNotFound === 'true';
            if (highestMin !== null) currentHIndexFilters.highestMin = parseInt(highestMin) || 0;
            if (highestMax !== null) currentHIndexFilters.highestMax = parseInt(highestMax) || 1000;
            if (averageMin !== null) currentHIndexFilters.averageMin = parseInt(averageMin) || 0;
            if (averageMax !== null) currentHIndexFilters.averageMax = parseInt(averageMax) || 1000;
            
            // Sync pending filters
            pendingHIndexFilters = { ...currentHIndexFilters };
            
            // Sync UI and update button text
            syncHIndexUI();
        }
        
        function updateURLWithHIndexFilters() {
            const url = new URL(window.location.href);
            
            // Only set parameters if they differ from defaults
            if (!currentHIndexFilters.found || !currentHIndexFilters.notFound) {
                url.searchParams.set('hindex_found', currentHIndexFilters.found);
                url.searchParams.set('hindex_not_found', currentHIndexFilters.notFound);
            } else {
                url.searchParams.delete('hindex_found');
                url.searchParams.delete('hindex_not_found');
            }
            
            if (currentHIndexFilters.highestMin !== 0 || currentHIndexFilters.highestMax !== 1000) {
                url.searchParams.set('highest_min', currentHIndexFilters.highestMin);
                url.searchParams.set('highest_max', currentHIndexFilters.highestMax);
            } else {
                url.searchParams.delete('highest_min');
                url.searchParams.delete('highest_max');
            }
            
            if (currentHIndexFilters.averageMin !== 0 || currentHIndexFilters.averageMax !== 1000) {
                url.searchParams.set('average_min', currentHIndexFilters.averageMin);
                url.searchParams.set('average_max', currentHIndexFilters.averageMax);
            } else {
                url.searchParams.delete('average_min');
                url.searchParams.delete('average_max');
            }
            
            window.history.pushState(null, '', url.toString());
        }

        // ============================================================================
        // DATE FORMATTING FUNCTIONS
        // ============================================================================
        
        function formatPageDate(dateString) {
            const date = new Date(dateString);
            const options = { day: 'numeric', month: 'long', year: 'numeric' };
            return date.toLocaleDateString('en-GB', options);
        }

        function formatPublicationDate(dateString) {
            const date = new Date(dateString);
            const options = { day: 'numeric', month: 'long', year: 'numeric' };
            return date.toLocaleDateString('en-GB', options);
        }

        // ============================================================================
        // UI UPDATE FUNCTIONS FOR PAGE LOAD
        // ============================================================================
        
        function updatePageTitles(date) {
            const formattedDate = formatPageDate(date);
            const titleText = `Papers Published on ${formattedDate}`;
            
            // Update page title
            document.title = `Research Feed -- ${formattedDate}`;
            
            // Update mobile and desktop headers
            const mobileTitle = document.getElementById('page-title-mobile');
            const desktopTitle = document.getElementById('page-title-desktop');
            
            if (mobileTitle) {
                mobileTitle.textContent = titleText;
            }
            if (desktopTitle) {
                desktopTitle.textContent = titleText;
            }
        }

        function updatePaperCount() {
            const mobileCount = document.getElementById('mobile-paper-count');
            const desktopCount = document.getElementById('desktop-paper-count');
            const mobileMainCount = document.getElementById('mobile-main-paper-count');
            const desktopMainCount = document.getElementById('desktop-main-paper-count');
            
            const showing = filteredSortedPapers.length;
            const sidebarCountText = `Showing: ${showing}/${totalPapers} Papers`;
            const mainCountText = `Showing ${showing} / ${totalPapers} papers`;
            
            // Update sidebar counts
            if (mobileCount) {
                mobileCount.textContent = sidebarCountText;
            }
            if (desktopCount) {
                desktopCount.textContent = sidebarCountText;
            }
            
            // Update main header counts
            if (mobileMainCount) {
                mobileMainCount.textContent = mainCountText;
            }
            if (desktopMainCount) {
                desktopMainCount.textContent = mainCountText;
            }
        }

        // ============================================================================
        // SORTING FUNCTIONS
        // ============================================================================
        
        function calculateRecommendationScore(paper) {
            // Skip calculation if already calculated or if not relevant enough
            if (paper.recommendation_numerical_score !== undefined) {
                return paper.recommendation_numerical_score;
            }
            
            if (paper.llm_score_status === 'not_relevant_enough') {
                paper.recommendation_numerical_score = 0;
                return 0;
            }
            
            let score = 0;
            
            // Recommendation scores (primary)
            const recommendationScores = {
                'Must Read': 40,
                'Should Read': 30,
                'Can Skip': 20,
                'Ignore': 10
            };
            score += recommendationScores[paper.recommendation_score] || 0;
            
            // Novelty scores (first tiebreaker)
            const noveltyScores = {
                'High': 4,
                'Moderate': 3,
                'Low': 2,
                'None': 1
            };
            score += noveltyScores[paper.novelty_score] || 0;
            
            // Impact scores (second tiebreaker)
            const impactScores = {
                'High': 4,
                'Moderate': 3,
                'Low': 2,
                'Negligible': 1
            };
            score += impactScores[paper.impact_score] || 0;
            
            paper.recommendation_numerical_score = score;
            return score;
        }
        
        function getHighestHIndex(paper) {
            // Return the highest H-index value, or -1 if not available (so unavailable papers sort last)
            return paper.highest_h_index !== undefined ? paper.highest_h_index : -1;
        }
        
        function getAverageHIndex(paper) {
            // Return the average H-index value, or -1 if not available (so unavailable papers sort last)
            return paper.average_h_index !== undefined ? paper.average_h_index : -1;
        }
        
        function calculateRelevanceScore(paper) {
            let score = 0;
            
            // Only consider topics that are currently selected/enabled in the topic filter
            const topicsToConsider = [];
            if (currentTopicFilters.rlhf) topicsToConsider.push('rlhf_relevance');
            if (currentTopicFilters.weakSupervision) topicsToConsider.push('weak_supervision_relevance');
            if (currentTopicFilters.diffusionReasoning) topicsToConsider.push('diffusion_reasoning_relevance');
            if (currentTopicFilters.distributedTraining) topicsToConsider.push('distributed_training_relevance');
            if (currentTopicFilters.datasets) topicsToConsider.push('datasets_relevance');
            
            // If no topics are selected, return 0
            if (topicsToConsider.length === 0) return 0;
            
            // Weighted scoring system
            const relevanceWeights = {
                'Highly Relevant': 4,
                'Moderately Relevant': 3,
                'Tangentially Relevant': 2,
                'Not Relevant': 1
            };
            
            // Sum up scores for selected topics only
            for (let topicField of topicsToConsider) {
                const relevance = paper[topicField];
                // Treat "not_validated" same as "Not Relevant"
                const normalizedRelevance = relevance === "not_validated" ? "Not Relevant" : relevance;
                score += relevanceWeights[normalizedRelevance] || 1; // Default to 1 if unknown
            }
            
            return score;
        }
        
        function sortPapers(sortType) {
            switch (sortType) {
                case 'recommend_best':
                    filteredSortedPapers.sort((a, b) => calculateRecommendationScore(b) - calculateRecommendationScore(a));
                    break;
                case 'recommend_worst':
                    filteredSortedPapers.sort((a, b) => calculateRecommendationScore(a) - calculateRecommendationScore(b));
                    break;
                case 'relevance_high':
                    filteredSortedPapers.sort((a, b) => calculateRelevanceScore(b) - calculateRelevanceScore(a));
                    break;
                case 'relevance_low':
                    filteredSortedPapers.sort((a, b) => calculateRelevanceScore(a) - calculateRelevanceScore(b));
                    break;
                case 'highest_hindex_asc':
                    filteredSortedPapers.sort((a, b) => getHighestHIndex(a) - getHighestHIndex(b));
                    break;
                case 'highest_hindex_desc':
                    filteredSortedPapers.sort((a, b) => getHighestHIndex(b) - getHighestHIndex(a));
                    break;
                case 'average_hindex_asc':
                    filteredSortedPapers.sort((a, b) => getAverageHIndex(a) - getAverageHIndex(b));
                    break;
                case 'average_hindex_desc':
                    filteredSortedPapers.sort((a, b) => getAverageHIndex(b) - getAverageHIndex(a));
                    break;
                case 'id_asc':
                    filteredSortedPapers.sort((a, b) => a.id.localeCompare(b.id));
                    break;
                case 'id_desc':
                    filteredSortedPapers.sort((a, b) => b.id.localeCompare(a.id));
                    break;
                case 'title_az':
                    filteredSortedPapers.sort((a, b) => a.title.localeCompare(b.title));
                    break;
                case 'title_za':
                    filteredSortedPapers.sort((a, b) => b.title.localeCompare(a.title));
                    break;
                default:
                    // Default to recommendation best first
                    filteredSortedPapers.sort((a, b) => calculateRecommendationScore(b) - calculateRecommendationScore(a));
            }
        }

        // ============================================================================
        // DROPDOWN DIRECTION FUNCTIONS
        // ============================================================================
        
        function setDropdownDirection(button, dropdown) {
            const buttonRect = button.getBoundingClientRect();
            const sidebar = button.closest('#mobile-sidebar, #desktop-sidebar');
            
            // Get the sidebar content area instead of the entire sidebar
            const sidebarContent = sidebar.querySelector('.flex-1');
            const sidebarContentRect = sidebarContent ? sidebarContent.getBoundingClientRect() : sidebar.getBoundingClientRect();
            
            // Calculate available space within the entire sidebar content area
            const spaceBelow = sidebarContentRect.bottom - buttonRect.bottom;
            const spaceAbove = buttonRect.top - sidebarContentRect.top;
            
            // Estimate dropdown height (roughly 6 items * 40px each)
            const estimatedDropdownHeight = 240;
            
            // Determine direction based on available space in the whole sidebar content
            if (spaceBelow >= estimatedDropdownHeight || spaceBelow >= spaceAbove) {
                // Dropdown goes down
                dropdown.classList.remove('dropdown-up');
                dropdown.classList.add('dropdown-down');
            } else {
                // Dropdown goes up
                dropdown.classList.remove('dropdown-down');
                dropdown.classList.add('dropdown-up');
            }
        }

        // ============================================================================
        // SORTING DROPDOWN FUNCTIONS
        // ============================================================================
        
        function toggleMobileSortDropdown() {
            const button = document.getElementById('mobile-sort-btn');
            const dropdown = document.getElementById('mobile-sort-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                // Set direction before showing
                setDropdownDirection(button, dropdown);
                // Change button to expanded state
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                // Change button back to normal state
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function toggleDesktopSortDropdown() {
            const button = document.getElementById('desktop-sort-btn');
            const dropdown = document.getElementById('desktop-sort-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                // Set direction before showing
                setDropdownDirection(button, dropdown);
                // Change button to expanded state
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                // Change button back to normal state
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function changeSortAndClose(sortType) {
            // Update current sort
            currentSort = sortType;
            
            // Update URL
            setUrlParameter('sort', sortType);
            
            // Update dropdown text
            updateSortDropdownUI();
            
            // Close dropdowns and reset button states
            const mobileDropdown = document.getElementById('mobile-sort-dropdown');
            const desktopDropdown = document.getElementById('desktop-sort-dropdown');
            const mobileButton = document.getElementById('mobile-sort-btn');
            const desktopButton = document.getElementById('desktop-sort-btn');
            
            mobileDropdown.classList.add('hidden');
            desktopDropdown.classList.add('hidden');
            
            // Reset button states to normal
            mobileButton.classList.remove('bg-neutral-600');
            mobileButton.classList.add('bg-neutral-500');
            desktopButton.classList.remove('bg-neutral-600');
            desktopButton.classList.add('bg-neutral-500');
            
            // Close the appropriate sidebar
            if (isMobileSidebarOpen) {
                closeMobileMenu();
            }
            if (isDesktopSidebarOpen) {
                closeDesktopMenu();
            }
            
            // Apply new sorting
            applyFiltersAndSort();
            displayCurrentPage();
        }
        
        function updateSortDropdownUI() {
            const sortNames = {
                'recommend_best': 'Recommendation (Best First)',
                'recommend_worst': 'Recommendation (Worst First)',
                'relevance_high': 'Relevance (Highest to Lowest)',
                'relevance_low': 'Relevance (Lowest to Highest)',
                'highest_hindex_asc': 'Highest H-Index (Ascending)',
                'highest_hindex_desc': 'Highest H-Index (Descending)',
                'average_hindex_asc': 'Average H-Index (Ascending)',
                'average_hindex_desc': 'Average H-Index (Descending)',
                'id_asc': 'arXiv ID (Ascending)',
                'id_desc': 'arXiv ID (Descending)',
                'title_az': 'Title (A-Z)',
                'title_za': 'Title (Z-A)'
            };
            
            const sortName = sortNames[currentSort] || 'Recommendation (Best First)';
            
            const mobileText = document.getElementById('mobile-sort-text');
            const desktopText = document.getElementById('desktop-sort-text');
            
            if (mobileText) {
                mobileText.textContent = sortName;
            }
            if (desktopText) {
                desktopText.textContent = sortName;
            }
        }

        // ============================================================================
        // H-INDEX FILTER DROPDOWN FUNCTIONS
        // ============================================================================
        
        function toggleMobileHIndexDropdown() {
            const button = document.getElementById('mobile-hindex-btn');
            const dropdown = document.getElementById('mobile-hindex-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                // Set direction before showing
                setDropdownDirection(button, dropdown);
                // Change button to expanded state
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                // Change button back to normal state
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function toggleDesktopHIndexDropdown() {
            const button = document.getElementById('desktop-hindex-btn');
            const dropdown = document.getElementById('desktop-hindex-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                // Set direction before showing
                setDropdownDirection(button, dropdown);
                // Change button to expanded state
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                // Change button back to normal state
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function toggleHIndexRanges() {
            const mobileFoundCheckbox = document.getElementById('mobile-hindex-found');
            const desktopFoundCheckbox = document.getElementById('desktop-hindex-found');
            const mobileHighestRange = document.getElementById('mobile-highest-range');
            const mobileAverageRange = document.getElementById('mobile-average-range');
            const desktopHighestRange = document.getElementById('desktop-highest-range');
            const desktopAverageRange = document.getElementById('desktop-average-range');
            
            // Sync the checkboxes
            if (event.target.id === 'mobile-hindex-found') {
                desktopFoundCheckbox.checked = mobileFoundCheckbox.checked;
            } else if (event.target.id === 'desktop-hindex-found') {
                mobileFoundCheckbox.checked = desktopFoundCheckbox.checked;
            }
            
            const isEnabled = mobileFoundCheckbox.checked;
            
            // Update pending filters
            updatePendingHIndexFilters();
            
            // Update button text to reflect current state
            updateHIndexButtonText();
            
            // Toggle disabled state for range sections
            [mobileHighestRange, mobileAverageRange, desktopHighestRange, desktopAverageRange].forEach(range => {
                if (range) {
                    if (isEnabled) {
                        range.classList.remove('disabled');
                        range.querySelectorAll('input').forEach(input => {
                            input.disabled = false;
                        });
                    } else {
                        range.classList.add('disabled');
                        range.querySelectorAll('input').forEach(input => {
                            input.disabled = true;
                        });
                    }
                }
            });
        }
        
        function updatePendingHIndexFilters() {
            // Read current UI state into pending filters
            const mobileFoundCheckbox = document.getElementById('mobile-hindex-found');
            const mobileNotFoundCheckbox = document.getElementById('mobile-hindex-not-found');
            const mobileHighestMin = document.getElementById('mobile-highest-min');
            const mobileHighestMax = document.getElementById('mobile-highest-max');
            const mobileAverageMin = document.getElementById('mobile-average-min');
            const mobileAverageMax = document.getElementById('mobile-average-max');
            
            pendingHIndexFilters = {
                found: mobileFoundCheckbox.checked,
                notFound: mobileNotFoundCheckbox.checked,
                highestMin: parseInt(mobileHighestMin.value) || 0,
                highestMax: parseInt(mobileHighestMax.value) || 1000,
                averageMin: parseInt(mobileAverageMin.value) || 0,
                averageMax: parseInt(mobileAverageMax.value) || 1000
            };
        }
        
        function resetPendingHIndexFilters() {
            // Revert pending filters to current applied filters
            pendingHIndexFilters = { ...currentHIndexFilters };
            
            // Update UI to reflect current filters
            syncHIndexUI();
        }
        
        function resetPendingNoveltyFilters() {
            // Revert pending filters to current applied filters
            pendingNoveltyFilters = { ...currentNoveltyFilters };
            
            // Update UI to reflect current filters
            syncPendingNoveltyUI();
            updateNoveltyButtonText();
        }
        
        function resetPendingImpactFilters() {
            // Revert pending filters to current applied filters
            pendingImpactFilters = { ...currentImpactFilters };
            
            // Update UI to reflect current filters
            syncPendingImpactUI();
            updateImpactButtonText();
        }
        
        function syncHIndexUI() {
            // Update checkboxes
            document.getElementById('mobile-hindex-found').checked = currentHIndexFilters.found;
            document.getElementById('mobile-hindex-not-found').checked = currentHIndexFilters.notFound;
            document.getElementById('desktop-hindex-found').checked = currentHIndexFilters.found;
            document.getElementById('desktop-hindex-not-found').checked = currentHIndexFilters.notFound;
            
            // Update range inputs
            document.getElementById('mobile-highest-min').value = currentHIndexFilters.highestMin;
            document.getElementById('mobile-highest-max').value = currentHIndexFilters.highestMax;
            document.getElementById('mobile-average-min').value = currentHIndexFilters.averageMin;
            document.getElementById('mobile-average-max').value = currentHIndexFilters.averageMax;
            document.getElementById('desktop-highest-min').value = currentHIndexFilters.highestMin;
            document.getElementById('desktop-highest-max').value = currentHIndexFilters.highestMax;
            document.getElementById('desktop-average-min').value = currentHIndexFilters.averageMin;
            document.getElementById('desktop-average-max').value = currentHIndexFilters.averageMax;
            
            // Update disabled states
            toggleHIndexRanges();
            
            // Update button text
            updateHIndexButtonText();
        }
        
        function updateHIndexButtonText() {
            // Read the current checkbox states from the UI
            const foundChecked = document.getElementById('mobile-hindex-found').checked;
            const notFoundChecked = document.getElementById('mobile-hindex-not-found').checked;
            
            let selectionText;
            if (foundChecked && notFoundChecked) {
                selectionText = "All Selected";
            } else if (foundChecked && !notFoundChecked) {
                selectionText = "H-Index Found";
            } else if (!foundChecked && notFoundChecked) {
                selectionText = "H-Index Not Found";
            } else {
                selectionText = "None Selected";
            }
            
            // Update mobile button
            const mobileButton = document.getElementById('mobile-hindex-btn');
            if (mobileButton) {
                mobileButton.innerHTML = `<span class="font-bold">H-Index:</span> <span class="font-normal">${selectionText}</span> <span class="text-base">▼</span>`;
            }
            
            // Update desktop button
            const desktopButton = document.getElementById('desktop-hindex-btn');
            if (desktopButton) {
                desktopButton.innerHTML = `<span class="font-bold">H-Index:</span> <span class="font-normal">${selectionText}</span> <span class="text-sm">▼</span>`;
            }
        }
        
        function applyHIndexFilter() {
            // Update pending filters one final time
            updatePendingHIndexFilters();
            
            // Apply pending filters as current filters
            currentHIndexFilters = { ...pendingHIndexFilters };
            
            // Update URL with new filter state
            updateURLWithHIndexFilters();
            
            // Update button text to reflect applied filters
            updateHIndexButtonText();
            
            // Close both dropdowns
            const mobileDropdown = document.getElementById('mobile-hindex-dropdown');
            const desktopDropdown = document.getElementById('desktop-hindex-dropdown');
            const mobileButton = document.getElementById('mobile-hindex-btn');
            const desktopButton = document.getElementById('desktop-hindex-btn');
            
            mobileDropdown.classList.add('hidden');
            desktopDropdown.classList.add('hidden');
            
            // Reset button states to normal
            mobileButton.classList.remove('bg-neutral-600');
            mobileButton.classList.add('bg-neutral-500');
            desktopButton.classList.remove('bg-neutral-600');
            desktopButton.classList.add('bg-neutral-500');
            
            // Don't close sidebar - just close dropdown
            // (Sidebar should stay open for more filtering)
            
            // Apply new filtering and update display
            applyFiltersAndSort();
            displayCurrentPage();
        }

        // ============================================================================
        // INPUT VALIDATION FOR H-INDEX RANGES
        // ============================================================================
        
        function validateHIndexInput(input) {
            // Allow empty input temporarily (user might be typing)
            if (input.value === '') {
                return;
            }
            
            let value = parseInt(input.value);
            
            // Ensure value is within 0-1000 range
            if (isNaN(value) || value < 0) {
                input.value = 0;
            } else if (value > 1000) {
                input.value = 1000;
            }
            
            // Auto-correct min/max relationships
            enforceMinMaxConstraints(input);
        }
        
        function enforceMinMaxConstraints(changedInput) {
            const inputId = changedInput.id;
            let minInput, maxInput;
            
            // Determine which min/max pair this input belongs to
            if (inputId.includes('highest-min')) {
                minInput = changedInput;
                maxInput = document.getElementById(inputId.replace('min', 'max'));
            } else if (inputId.includes('highest-max')) {
                maxInput = changedInput;
                minInput = document.getElementById(inputId.replace('max', 'min'));
            } else if (inputId.includes('average-min')) {
                minInput = changedInput;
                maxInput = document.getElementById(inputId.replace('min', 'max'));
            } else if (inputId.includes('average-max')) {
                maxInput = changedInput;
                minInput = document.getElementById(inputId.replace('max', 'min'));
            }
            
            if (minInput && maxInput) {
                const minVal = parseInt(minInput.value) || 0;
                const maxVal = parseInt(maxInput.value) || 0;
                
                // If min > max, auto-correct
                if (minVal > maxVal) {
                    if (changedInput === minInput) {
                        // User changed min to be > max, set max = min
                        maxInput.value = minVal;
                    } else {
                        // User changed max to be < min, set min = max
                        minInput.value = maxVal;
                    }
                }
            }
        }
        
        // Add input validation when page loads
        function setupHIndexValidation() {
            const inputs = [
                'mobile-highest-min', 'mobile-highest-max',
                'mobile-average-min', 'mobile-average-max',
                'desktop-highest-min', 'desktop-highest-max',
                'desktop-average-min', 'desktop-average-max'
            ];
            
            inputs.forEach(id => {
                const input = document.getElementById(id);
                if (input) {
                    // Validate on input (while typing) - but allow empty temporarily
                    input.addEventListener('input', () => {
                        validateHIndexInput(input);
                        updatePendingHIndexFilters(); // Update pending filters as user types
                    });
                    
                    // Validate on blur (when user leaves field) - ensure it's not empty
                    input.addEventListener('blur', () => {
                        if (input.value === '') {
                            input.value = 0; // Set default if user leaves it empty
                        }
                        validateHIndexInput(input);
                        updatePendingHIndexFilters(); // Update pending filters
                    });
                    
                    // Prevent non-numeric characters except for selection/deletion
                    input.addEventListener('keydown', (e) => {
                        // Allow: backspace, delete, tab, escape, enter, and numbers
                        if ([8, 9, 27, 13, 46].includes(e.keyCode) || 
                            // Allow Ctrl+A, Ctrl+C, Ctrl+V, Ctrl+X
                            (e.keyCode === 65 && e.ctrlKey) || 
                            (e.keyCode === 67 && e.ctrlKey) || 
                            (e.keyCode === 86 && e.ctrlKey) || 
                            (e.keyCode === 88 && e.ctrlKey) ||
                            // Allow numbers (0-9) on main keyboard and numpad
                            (e.keyCode >= 48 && e.keyCode <= 57) ||
                            (e.keyCode >= 96 && e.keyCode <= 105)) {
                            return;
                        }
                        e.preventDefault();
                    });
                }
            });
            
            // Add event listeners for checkboxes to update pending filters
            document.getElementById('mobile-hindex-not-found').addEventListener('change', () => {
                // Sync desktop checkbox
                document.getElementById('desktop-hindex-not-found').checked = 
                    document.getElementById('mobile-hindex-not-found').checked;
                updatePendingHIndexFilters();
                updateHIndexButtonText();
            });
            
            document.getElementById('desktop-hindex-not-found').addEventListener('change', () => {
                // Sync mobile checkbox
                document.getElementById('mobile-hindex-not-found').checked = 
                    document.getElementById('desktop-hindex-not-found').checked;
                updatePendingHIndexFilters();
                updateHIndexButtonText();
            });
            
            // Add event listeners for scoring checkboxes to update pending filters
            document.getElementById('mobile-scoring-has').addEventListener('change', () => {
                // Sync desktop checkbox
                document.getElementById('desktop-scoring-has').checked = 
                    document.getElementById('mobile-scoring-has').checked;
                updatePendingScoringFilters();
                updateScoringButtonText();
            });
            
            document.getElementById('mobile-scoring-no').addEventListener('change', () => {
                // Sync desktop checkbox
                document.getElementById('desktop-scoring-no').checked = 
                    document.getElementById('mobile-scoring-no').checked;
                updatePendingScoringFilters();
                updateScoringButtonText();
            });
            
            document.getElementById('desktop-scoring-has').addEventListener('change', () => {
                // Sync mobile checkbox
                document.getElementById('mobile-scoring-has').checked = 
                    document.getElementById('desktop-scoring-has').checked;
                updatePendingScoringFilters();
                updateScoringButtonText();
            });
            
            document.getElementById('desktop-scoring-no').addEventListener('change', () => {
                // Sync mobile checkbox
                document.getElementById('mobile-scoring-no').checked = 
                    document.getElementById('desktop-scoring-no').checked;
                updatePendingScoringFilters();
                updateScoringButtonText();
            });
            
            // Add event listeners for scoring checkboxes to update pending filters
            document.getElementById('mobile-scoring-has').addEventListener('change', () => {
                // Sync desktop checkbox
                document.getElementById('desktop-scoring-has').checked = 
                    document.getElementById('mobile-scoring-has').checked;
                updatePendingScoringFilters();
                updateScoringButtonText();
            });
            
            document.getElementById('desktop-scoring-has').addEventListener('change', () => {
                // Sync mobile checkbox
                document.getElementById('mobile-scoring-has').checked = 
                    document.getElementById('desktop-scoring-has').checked;
                updatePendingScoringFilters();
                updateScoringButtonText();
            });
            
            document.getElementById('mobile-scoring-no').addEventListener('change', () => {
                // Sync desktop checkbox
                document.getElementById('desktop-scoring-no').checked = 
                    document.getElementById('mobile-scoring-no').checked;
                updatePendingScoringFilters();
                updateScoringButtonText();
            });
            
            document.getElementById('desktop-scoring-no').addEventListener('change', () => {
                // Sync mobile checkbox
                document.getElementById('mobile-scoring-no').checked = 
                    document.getElementById('desktop-scoring-no').checked;
                updatePendingScoringFilters();
                updateScoringButtonText();
            });
            
            // Add event listeners for recommendation checkboxes to sync between mobile and desktop
            document.getElementById('mobile-recommendation-must').addEventListener('change', () => {
                document.getElementById('desktop-recommendation-must').checked = 
                    document.getElementById('mobile-recommendation-must').checked;
                updatePendingRecommendationFilters();
                updateRecommendationButtonText();
            });
            
            document.getElementById('mobile-recommendation-should').addEventListener('change', () => {
                document.getElementById('desktop-recommendation-should').checked = 
                    document.getElementById('mobile-recommendation-should').checked;
                updatePendingRecommendationFilters();
                updateRecommendationButtonText();
            });
            
            document.getElementById('mobile-recommendation-skip').addEventListener('change', () => {
                document.getElementById('desktop-recommendation-skip').checked = 
                    document.getElementById('mobile-recommendation-skip').checked;
                updatePendingRecommendationFilters();
                updateRecommendationButtonText();
            });
            
            document.getElementById('mobile-recommendation-ignore').addEventListener('change', () => {
                document.getElementById('desktop-recommendation-ignore').checked = 
                    document.getElementById('mobile-recommendation-ignore').checked;
                updatePendingRecommendationFilters();
                updateRecommendationButtonText();
            });
            
            document.getElementById('desktop-recommendation-must').addEventListener('change', () => {
                document.getElementById('mobile-recommendation-must').checked = 
                    document.getElementById('desktop-recommendation-must').checked;
                updatePendingRecommendationFilters();
                updateRecommendationButtonText();
            });
            
            document.getElementById('desktop-recommendation-should').addEventListener('change', () => {
                document.getElementById('mobile-recommendation-should').checked = 
                    document.getElementById('desktop-recommendation-should').checked;
                updatePendingRecommendationFilters();
                updateRecommendationButtonText();
            });
            
            document.getElementById('desktop-recommendation-skip').addEventListener('change', () => {
                document.getElementById('mobile-recommendation-skip').checked = 
                    document.getElementById('desktop-recommendation-skip').checked;
                updatePendingRecommendationFilters();
                updateRecommendationButtonText();
            });
            
            document.getElementById('desktop-recommendation-ignore').addEventListener('change', () => {
                document.getElementById('mobile-recommendation-ignore').checked = 
                    document.getElementById('desktop-recommendation-ignore').checked;
                updatePendingRecommendationFilters();
                updateRecommendationButtonText();
            });
            
            // Add event listeners for novelty checkboxes to sync between mobile and desktop
            document.getElementById('mobile-novelty-high').addEventListener('change', () => {
                document.getElementById('desktop-novelty-high').checked = 
                    document.getElementById('mobile-novelty-high').checked;
                updatePendingNoveltyFilters();
                updateNoveltyButtonText();
            });
            
            document.getElementById('mobile-novelty-moderate').addEventListener('change', () => {
                document.getElementById('desktop-novelty-moderate').checked = 
                    document.getElementById('mobile-novelty-moderate').checked;
                updatePendingNoveltyFilters();
                updateNoveltyButtonText();
            });
            
            document.getElementById('mobile-novelty-low').addEventListener('change', () => {
                document.getElementById('desktop-novelty-low').checked = 
                    document.getElementById('mobile-novelty-low').checked;
                updatePendingNoveltyFilters();
                updateNoveltyButtonText();
            });
            
            document.getElementById('mobile-novelty-none').addEventListener('change', () => {
                document.getElementById('desktop-novelty-none').checked = 
                    document.getElementById('mobile-novelty-none').checked;
                updatePendingNoveltyFilters();
                updateNoveltyButtonText();
            });
            
            document.getElementById('desktop-novelty-high').addEventListener('change', () => {
                document.getElementById('mobile-novelty-high').checked = 
                    document.getElementById('desktop-novelty-high').checked;
                updatePendingNoveltyFilters();
                updateNoveltyButtonText();
            });
            
            document.getElementById('desktop-novelty-moderate').addEventListener('change', () => {
                document.getElementById('mobile-novelty-moderate').checked = 
                    document.getElementById('desktop-novelty-moderate').checked;
                updatePendingNoveltyFilters();
                updateNoveltyButtonText();
            });
            
            document.getElementById('desktop-novelty-low').addEventListener('change', () => {
                document.getElementById('mobile-novelty-low').checked = 
                    document.getElementById('desktop-novelty-low').checked;
                updatePendingNoveltyFilters();
                updateNoveltyButtonText();
            });
            
            document.getElementById('desktop-novelty-none').addEventListener('change', () => {
                document.getElementById('mobile-novelty-none').checked = 
                    document.getElementById('desktop-novelty-none').checked;
                updatePendingNoveltyFilters();
                updateNoveltyButtonText();
            });
            
            // Add event listeners for impact checkboxes to sync between mobile and desktop
            document.getElementById('mobile-impact-high').addEventListener('change', () => {
                document.getElementById('desktop-impact-high').checked = 
                    document.getElementById('mobile-impact-high').checked;
                updatePendingImpactFilters();
                updateImpactButtonText();
            });
            
            document.getElementById('mobile-impact-moderate').addEventListener('change', () => {
                document.getElementById('desktop-impact-moderate').checked = 
                    document.getElementById('mobile-impact-moderate').checked;
                updatePendingImpactFilters();
                updateImpactButtonText();
            });
            
            document.getElementById('mobile-impact-low').addEventListener('change', () => {
                document.getElementById('desktop-impact-low').checked = 
                    document.getElementById('mobile-impact-low').checked;
                updatePendingImpactFilters();
                updateImpactButtonText();
            });
            
            document.getElementById('mobile-impact-negligible').addEventListener('change', () => {
                document.getElementById('desktop-impact-negligible').checked = 
                    document.getElementById('mobile-impact-negligible').checked;
                updatePendingImpactFilters();
                updateImpactButtonText();
            });
            
            document.getElementById('desktop-impact-high').addEventListener('change', () => {
                document.getElementById('mobile-impact-high').checked = 
                    document.getElementById('desktop-impact-high').checked;
                updatePendingImpactFilters();
                updateImpactButtonText();
            });
            
            document.getElementById('desktop-impact-moderate').addEventListener('change', () => {
                document.getElementById('mobile-impact-moderate').checked = 
                    document.getElementById('desktop-impact-moderate').checked;
                updatePendingImpactFilters();
                updateImpactButtonText();
            });
            
            document.getElementById('desktop-impact-low').addEventListener('change', () => {
                document.getElementById('mobile-impact-low').checked = 
                    document.getElementById('desktop-impact-low').checked;
                updatePendingImpactFilters();
                updateImpactButtonText();
            });
            
            document.getElementById('desktop-impact-negligible').addEventListener('change', () => {
                document.getElementById('mobile-impact-negligible').checked = 
                    document.getElementById('desktop-impact-negligible').checked;
                updatePendingImpactFilters();
                updateImpactButtonText();
            });
            
            // Add event listeners for relevance checkboxes to sync between mobile and desktop
            document.getElementById('mobile-relevance-highly').addEventListener('change', () => {
                document.getElementById('desktop-relevance-highly').checked = 
                    document.getElementById('mobile-relevance-highly').checked;
                updatePendingRelevanceFilters();
                updateRelevanceButtonText();
            });
            
            document.getElementById('mobile-relevance-moderately').addEventListener('change', () => {
                document.getElementById('desktop-relevance-moderately').checked = 
                    document.getElementById('mobile-relevance-moderately').checked;
                updatePendingRelevanceFilters();
                updateRelevanceButtonText();
            });
            
            document.getElementById('mobile-relevance-tangentially').addEventListener('change', () => {
                document.getElementById('desktop-relevance-tangentially').checked = 
                    document.getElementById('mobile-relevance-tangentially').checked;
                updatePendingRelevanceFilters();
                updateRelevanceButtonText();
            });
            
            document.getElementById('mobile-relevance-not').addEventListener('change', () => {
                document.getElementById('desktop-relevance-not').checked = 
                    document.getElementById('mobile-relevance-not').checked;
                updatePendingRelevanceFilters();
                updateRelevanceButtonText();
            });
            
            document.getElementById('desktop-relevance-highly').addEventListener('change', () => {
                document.getElementById('mobile-relevance-highly').checked = 
                    document.getElementById('desktop-relevance-highly').checked;
                updatePendingRelevanceFilters();
                updateRelevanceButtonText();
            });
            
            document.getElementById('desktop-relevance-moderately').addEventListener('change', () => {
                document.getElementById('mobile-relevance-moderately').checked = 
                    document.getElementById('desktop-relevance-moderately').checked;
                updatePendingRelevanceFilters();
                updateRelevanceButtonText();
            });
            
            document.getElementById('desktop-relevance-tangentially').addEventListener('change', () => {
                document.getElementById('mobile-relevance-tangentially').checked = 
                    document.getElementById('desktop-relevance-tangentially').checked;
                updatePendingRelevanceFilters();
                updateRelevanceButtonText();
            });
            
            document.getElementById('desktop-relevance-not').addEventListener('change', () => {
                document.getElementById('mobile-relevance-not').checked = 
                    document.getElementById('desktop-relevance-not').checked;
                updatePendingRelevanceFilters();
                updateRelevanceButtonText();
            });
            
            // Add event listeners for topic checkboxes to sync between mobile and desktop
            document.getElementById('mobile-topic-rlhf').addEventListener('change', () => {
                document.getElementById('desktop-topic-rlhf').checked = 
                    document.getElementById('mobile-topic-rlhf').checked;
                updatePendingTopicFilters();
                updateTopicButtonText();
            });
            
            document.getElementById('mobile-topic-weak-supervision').addEventListener('change', () => {
                document.getElementById('desktop-topic-weak-supervision').checked = 
                    document.getElementById('mobile-topic-weak-supervision').checked;
                updatePendingTopicFilters();
                updateTopicButtonText();
            });
            
            document.getElementById('mobile-topic-diffusion-reasoning').addEventListener('change', () => {
                document.getElementById('desktop-topic-diffusion-reasoning').checked = 
                    document.getElementById('mobile-topic-diffusion-reasoning').checked;
                updatePendingTopicFilters();
                updateTopicButtonText();
            });
            
            document.getElementById('mobile-topic-distributed-training').addEventListener('change', () => {
                document.getElementById('desktop-topic-distributed-training').checked = 
                    document.getElementById('mobile-topic-distributed-training').checked;
                updatePendingTopicFilters();
                updateTopicButtonText();
            });
            
            document.getElementById('mobile-topic-datasets').addEventListener('change', () => {
                document.getElementById('desktop-topic-datasets').checked = 
                    document.getElementById('mobile-topic-datasets').checked;
                updatePendingTopicFilters();
                updateTopicButtonText();
            });
            
            document.getElementById('desktop-topic-rlhf').addEventListener('change', () => {
                document.getElementById('mobile-topic-rlhf').checked = 
                    document.getElementById('desktop-topic-rlhf').checked;
                updatePendingTopicFilters();
                updateTopicButtonText();
            });
            
            document.getElementById('desktop-topic-weak-supervision').addEventListener('change', () => {
                document.getElementById('mobile-topic-weak-supervision').checked = 
                    document.getElementById('desktop-topic-weak-supervision').checked;
                updatePendingTopicFilters();
                updateTopicButtonText();
            });
            
            document.getElementById('desktop-topic-diffusion-reasoning').addEventListener('change', () => {
                document.getElementById('mobile-topic-diffusion-reasoning').checked = 
                    document.getElementById('desktop-topic-diffusion-reasoning').checked;
                updatePendingTopicFilters();
                updateTopicButtonText();
            });
            
            document.getElementById('desktop-topic-distributed-training').addEventListener('change', () => {
                document.getElementById('mobile-topic-distributed-training').checked = 
                    document.getElementById('desktop-topic-distributed-training').checked;
                updatePendingTopicFilters();
                updateTopicButtonText();
            });
            
            document.getElementById('desktop-topic-datasets').addEventListener('change', () => {
                document.getElementById('mobile-topic-datasets').checked = 
                    document.getElementById('desktop-topic-datasets').checked;
                updatePendingTopicFilters();
                updateTopicButtonText();
            });
        }

        // ============================================================================
        // SCORING FILTER DROPDOWN FUNCTIONS
        // ============================================================================
        
        // Current and pending scoring filter states
        let currentScoringFilters = {
            hasScoring: true,
            noScoring: true
        };
        
        let pendingScoringFilters = {
            hasScoring: true,
            noScoring: true
        };
        
        function toggleMobileScoringDropdown() {
            const button = document.getElementById('mobile-scoring-btn');
            const dropdown = document.getElementById('mobile-scoring-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                // Set direction before showing
                setDropdownDirection(button, dropdown);
                // Change button to expanded state
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                // Change button back to normal state
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function toggleDesktopScoringDropdown() {
            const button = document.getElementById('desktop-scoring-btn');
            const dropdown = document.getElementById('desktop-scoring-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                // Set direction before showing
                setDropdownDirection(button, dropdown);
                // Change button to expanded state
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                // Change button back to normal state
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        
        function syncPendingScoringUI() {
            // Update all checkboxes to match pending state
            document.getElementById('mobile-scoring-has').checked = pendingScoringFilters.hasScoring;
            document.getElementById('mobile-scoring-no').checked = pendingScoringFilters.noScoring;
            document.getElementById('desktop-scoring-has').checked = pendingScoringFilters.hasScoring;
            document.getElementById('desktop-scoring-no').checked = pendingScoringFilters.noScoring;
        }
        
        function syncScoringUI() {
            // Update checkboxes
            document.getElementById('mobile-scoring-has').checked = currentScoringFilters.hasScoring;
            document.getElementById('mobile-scoring-no').checked = currentScoringFilters.noScoring;
            document.getElementById('desktop-scoring-has').checked = currentScoringFilters.hasScoring;
            document.getElementById('desktop-scoring-no').checked = currentScoringFilters.noScoring;
            
            // Update button text
            updateScoringButtonText();
        }
        
        function updateScoringButtonText() {
            // Read the current checkbox states from the UI
            const hasChecked = document.getElementById('mobile-scoring-has').checked;
            const noChecked = document.getElementById('mobile-scoring-no').checked;
            
            let selectionText;
            if (hasChecked && noChecked) {
                selectionText = "All Selected";
            } else if (hasChecked && !noChecked) {
                selectionText = "Completed";
            } else if (!hasChecked && noChecked) {
                selectionText = "Not relevant enough";
            } else {
                selectionText = "None Selected";
            }
            
            // Update mobile button
            const mobileButton = document.getElementById('mobile-scoring-btn');
            if (mobileButton) {
                mobileButton.innerHTML = `<span class="font-bold">Scoring:</span> <span class="font-normal">${selectionText}</span> <span class="text-base">▼</span>`;
            }
            
            // Update desktop button
            const desktopButton = document.getElementById('desktop-scoring-btn');
            if (desktopButton) {
                desktopButton.innerHTML = `<span class="font-bold">Scoring:</span> <span class="font-normal">${selectionText}</span> <span class="text-sm">▼</span>`;
            }
        }
        
        function applyScoringFilter() {
            // Update pending filters one final time
            updatePendingScoringFilters();
            
            // Apply the pending filters as current filters
            currentScoringFilters = { ...pendingScoringFilters };
            
            // Update UI to reflect current state
            syncScoringUI();
            
            // Update URL with current filters
            updateScoringFiltersInURL();
            
            // Close dropdown and apply filters
            closeMobileScoringDropdown();
            closeDesktopScoringDropdown();
            
            // Update disabled state for advanced filters
            updateAdvancedFiltersDisabledState();
            
            // Apply all filters and redisplay
            applyFiltersAndSort();
        }
        
        function updatePendingScoringFilters() {
            // Read current UI state into pending filters
            const mobileScoringHas = document.getElementById('mobile-scoring-has');
            const mobileScoringNo = document.getElementById('mobile-scoring-no');
            
            if (mobileScoringHas && mobileScoringNo) {
                pendingScoringFilters.hasScoring = mobileScoringHas.checked;
                pendingScoringFilters.noScoring = mobileScoringNo.checked;
            }
        }
        
        function resetPendingScoringFilters() {
            pendingScoringFilters = { ...currentScoringFilters };
            syncPendingScoringUI();
            updateScoringButtonText();
        }
        
        function closeMobileScoringDropdown() {
            const dropdown = document.getElementById('mobile-scoring-dropdown');
            const button = document.getElementById('mobile-scoring-btn');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                dropdown.classList.add('hidden');
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
        }
        
        function closeDesktopScoringDropdown() {
            const dropdown = document.getElementById('desktop-scoring-dropdown');
            const button = document.getElementById('desktop-scoring-btn');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                dropdown.classList.add('hidden');
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
        }
        
        function updateScoringFiltersInURL() {
            const params = new URLSearchParams(window.location.search);
            
            // Add scoring filter parameters
            params.set('scoring_has', currentScoringFilters.hasScoring.toString());
            params.set('scoring_no', currentScoringFilters.noScoring.toString());
            
            // Update URL without reload
            const newURL = `${window.location.pathname}?${params.toString()}`;
            window.history.pushState({}, '', newURL);
        }
        
        function updateScoringFiltersFromURL() {
            const params = new URLSearchParams(window.location.search);
            
            // Read scoring filter parameters from URL
            const hasScoring = params.get('scoring_has');
            const noScoring = params.get('scoring_no');
            
            if (hasScoring !== null) {
                currentScoringFilters.hasScoring = hasScoring === 'true';
                pendingScoringFilters.hasScoring = hasScoring === 'true';
            }
            
            if (noScoring !== null) {
                currentScoringFilters.noScoring = noScoring === 'true';
                pendingScoringFilters.noScoring = noScoring === 'true';
            }
            
            // Update UI to match loaded filters
            syncScoringUI();
            
            // Update disabled state for advanced filters
            updateAdvancedFiltersDisabledState();
        }

        // ============================================================================
        // RECOMMENDATION FILTER DROPDOWN FUNCTIONS
        // ============================================================================
        
        // Current and pending recommendation filter states
        let currentRecommendationFilters = {
            mustRead: true,
            shouldRead: true,
            canSkip: true,
            ignore: true
        };
        
        let pendingRecommendationFilters = {
            mustRead: true,
            shouldRead: true,
            canSkip: true,
            ignore: true
        };
        
        function toggleMobileRecommendationDropdown() {
            const button = document.getElementById('mobile-recommendation-btn');
            const dropdown = document.getElementById('mobile-recommendation-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                setDropdownDirection(button, dropdown);
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function toggleDesktopRecommendationDropdown() {
            const button = document.getElementById('desktop-recommendation-btn');
            const dropdown = document.getElementById('desktop-recommendation-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                setDropdownDirection(button, dropdown);
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function syncPendingRecommendationUI() {
            document.getElementById('mobile-recommendation-must').checked = pendingRecommendationFilters.mustRead;
            document.getElementById('mobile-recommendation-should').checked = pendingRecommendationFilters.shouldRead;
            document.getElementById('mobile-recommendation-skip').checked = pendingRecommendationFilters.canSkip;
            document.getElementById('mobile-recommendation-ignore').checked = pendingRecommendationFilters.ignore;
            document.getElementById('desktop-recommendation-must').checked = pendingRecommendationFilters.mustRead;
            document.getElementById('desktop-recommendation-should').checked = pendingRecommendationFilters.shouldRead;
            document.getElementById('desktop-recommendation-skip').checked = pendingRecommendationFilters.canSkip;
            document.getElementById('desktop-recommendation-ignore').checked = pendingRecommendationFilters.ignore;
        }
        
        function syncRecommendationUI() {
            document.getElementById('mobile-recommendation-must').checked = currentRecommendationFilters.mustRead;
            document.getElementById('mobile-recommendation-should').checked = currentRecommendationFilters.shouldRead;
            document.getElementById('mobile-recommendation-skip').checked = currentRecommendationFilters.canSkip;
            document.getElementById('mobile-recommendation-ignore').checked = currentRecommendationFilters.ignore;
            document.getElementById('desktop-recommendation-must').checked = currentRecommendationFilters.mustRead;
            document.getElementById('desktop-recommendation-should').checked = currentRecommendationFilters.shouldRead;
            document.getElementById('desktop-recommendation-skip').checked = currentRecommendationFilters.canSkip;
            document.getElementById('desktop-recommendation-ignore').checked = currentRecommendationFilters.ignore;
            
            updateRecommendationButtonText();
        }
        
        function updateRecommendationButtonText() {
            const mustChecked = document.getElementById('mobile-recommendation-must').checked;
            const shouldChecked = document.getElementById('mobile-recommendation-should').checked;
            const skipChecked = document.getElementById('mobile-recommendation-skip').checked;
            const ignoreChecked = document.getElementById('mobile-recommendation-ignore').checked;
            
            const checkedCount = [mustChecked, shouldChecked, skipChecked, ignoreChecked].filter(Boolean).length;
            
            let selectionText;
            if (checkedCount === 4) {
                selectionText = "All Selected";
            } else if (checkedCount === 0) {
                selectionText = "None Selected";
            } else {
                selectionText = `${checkedCount} Selected`;
            }
            
            const mobileButton = document.getElementById('mobile-recommendation-btn');
            if (mobileButton) {
                mobileButton.innerHTML = `<span class="font-bold">Recommendation:</span> <span class="font-normal">${selectionText}</span> <span class="text-base">▼</span>`;
            }
            
            const desktopButton = document.getElementById('desktop-recommendation-btn');
            if (desktopButton) {
                desktopButton.innerHTML = `<span class="font-bold">Recommendation:</span> <span class="font-normal">${selectionText}</span> <span class="text-sm">▼</span>`;
            }
        }
        
        function applyRecommendationFilter() {
            updatePendingRecommendationFilters();
            currentRecommendationFilters = { ...pendingRecommendationFilters };
            syncRecommendationUI();
            updateRecommendationFiltersInURL();
            closeMobileRecommendationDropdown();
            closeDesktopRecommendationDropdown();
            applyFiltersAndSort();
        }
        
        function updatePendingRecommendationFilters() {
            pendingRecommendationFilters.mustRead = document.getElementById('mobile-recommendation-must').checked;
            pendingRecommendationFilters.shouldRead = document.getElementById('mobile-recommendation-should').checked;
            pendingRecommendationFilters.canSkip = document.getElementById('mobile-recommendation-skip').checked;
            pendingRecommendationFilters.ignore = document.getElementById('mobile-recommendation-ignore').checked;
        }
        
        function resetPendingRecommendationFilters() {
            pendingRecommendationFilters = { ...currentRecommendationFilters };
            syncPendingRecommendationUI();
            updateRecommendationButtonText();
        }
        
        function closeMobileRecommendationDropdown() {
            const dropdown = document.getElementById('mobile-recommendation-dropdown');
            const button = document.getElementById('mobile-recommendation-btn');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                dropdown.classList.add('hidden');
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
        }
        
        function closeDesktopRecommendationDropdown() {
            const dropdown = document.getElementById('desktop-recommendation-dropdown');
            const button = document.getElementById('desktop-recommendation-btn');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                dropdown.classList.add('hidden');
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
        }
        
        function updateRecommendationFiltersInURL() {
            const params = new URLSearchParams(window.location.search);
            params.set('recommendation_must', currentRecommendationFilters.mustRead.toString());
            params.set('recommendation_should', currentRecommendationFilters.shouldRead.toString());
            params.set('recommendation_skip', currentRecommendationFilters.canSkip.toString());
            params.set('recommendation_ignore', currentRecommendationFilters.ignore.toString());
            const newURL = `${window.location.pathname}?${params.toString()}`;
            window.history.pushState({}, '', newURL);
        }
        
        function updateRecommendationFiltersFromURL() {
            const params = new URLSearchParams(window.location.search);
            
            const mustRead = params.get('recommendation_must');
            const shouldRead = params.get('recommendation_should');
            const canSkip = params.get('recommendation_skip');
            const ignore = params.get('recommendation_ignore');
            
            if (mustRead !== null) {
                currentRecommendationFilters.mustRead = mustRead === 'true';
                pendingRecommendationFilters.mustRead = mustRead === 'true';
            }
            if (shouldRead !== null) {
                currentRecommendationFilters.shouldRead = shouldRead === 'true';
                pendingRecommendationFilters.shouldRead = shouldRead === 'true';
            }
            if (canSkip !== null) {
                currentRecommendationFilters.canSkip = canSkip === 'true';
                pendingRecommendationFilters.canSkip = canSkip === 'true';
            }
            if (ignore !== null) {
                currentRecommendationFilters.ignore = ignore === 'true';
                pendingRecommendationFilters.ignore = ignore === 'true';
            }
            
            syncRecommendationUI();
        }

        // ============================================================================
        // NOVELTY FILTER DROPDOWN FUNCTIONS
        // ============================================================================
        
        // Current and pending novelty filter states
        let currentNoveltyFilters = {
            high: true,
            moderate: true,
            low: true,
            none: true
        };
        
        let pendingNoveltyFilters = {
            high: true,
            moderate: true,
            low: true,
            none: true
        };
        
        function toggleMobileNoveltyDropdown() {
            const button = document.getElementById('mobile-novelty-btn');
            const dropdown = document.getElementById('mobile-novelty-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                setDropdownDirection(button, dropdown);
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function toggleDesktopNoveltyDropdown() {
            const button = document.getElementById('desktop-novelty-btn');
            const dropdown = document.getElementById('desktop-novelty-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                setDropdownDirection(button, dropdown);
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function syncPendingNoveltyUI() {
            document.getElementById('mobile-novelty-high').checked = pendingNoveltyFilters.high;
            document.getElementById('mobile-novelty-moderate').checked = pendingNoveltyFilters.moderate;
            document.getElementById('mobile-novelty-low').checked = pendingNoveltyFilters.low;
            document.getElementById('mobile-novelty-none').checked = pendingNoveltyFilters.none;
            document.getElementById('desktop-novelty-high').checked = pendingNoveltyFilters.high;
            document.getElementById('desktop-novelty-moderate').checked = pendingNoveltyFilters.moderate;
            document.getElementById('desktop-novelty-low').checked = pendingNoveltyFilters.low;
            document.getElementById('desktop-novelty-none').checked = pendingNoveltyFilters.none;
        }
        
        function syncNoveltyUI() {
            document.getElementById('mobile-novelty-high').checked = currentNoveltyFilters.high;
            document.getElementById('mobile-novelty-moderate').checked = currentNoveltyFilters.moderate;
            document.getElementById('mobile-novelty-low').checked = currentNoveltyFilters.low;
            document.getElementById('mobile-novelty-none').checked = currentNoveltyFilters.none;
            document.getElementById('desktop-novelty-high').checked = currentNoveltyFilters.high;
            document.getElementById('desktop-novelty-moderate').checked = currentNoveltyFilters.moderate;
            document.getElementById('desktop-novelty-low').checked = currentNoveltyFilters.low;
            document.getElementById('desktop-novelty-none').checked = currentNoveltyFilters.none;
            
            updateNoveltyButtonText();
        }
        
        function updateNoveltyButtonText() {
            const highChecked = document.getElementById('mobile-novelty-high').checked;
            const moderateChecked = document.getElementById('mobile-novelty-moderate').checked;
            const lowChecked = document.getElementById('mobile-novelty-low').checked;
            const noneChecked = document.getElementById('mobile-novelty-none').checked;
            
            const checkedCount = [highChecked, moderateChecked, lowChecked, noneChecked].filter(Boolean).length;
            
            let selectionText;
            if (checkedCount === 4) {
                selectionText = "All Selected";
            } else if (checkedCount === 0) {
                selectionText = "None Selected";
            } else {
                selectionText = `${checkedCount} Selected`;
            }
            
            const mobileButton = document.getElementById('mobile-novelty-btn');
            if (mobileButton) {
                mobileButton.innerHTML = `<span class="font-bold">Novelty:</span> <span class="font-normal">${selectionText}</span> <span class="text-base">▼</span>`;
            }
            
            const desktopButton = document.getElementById('desktop-novelty-btn');
            if (desktopButton) {
                desktopButton.innerHTML = `<span class="font-bold">Novelty:</span> <span class="font-normal">${selectionText}</span> <span class="text-sm">▼</span>`;
            }
        }
        
        function applyNoveltyFilter() {
            updatePendingNoveltyFilters();
            currentNoveltyFilters = { ...pendingNoveltyFilters };
            syncNoveltyUI();
            updateNoveltyFiltersInURL();
            closeMobileNoveltyDropdown();
            closeDesktopNoveltyDropdown();
            applyFiltersAndSort();
        }
        
        function updatePendingNoveltyFilters() {
            pendingNoveltyFilters.high = document.getElementById('mobile-novelty-high').checked;
            pendingNoveltyFilters.moderate = document.getElementById('mobile-novelty-moderate').checked;
            pendingNoveltyFilters.low = document.getElementById('mobile-novelty-low').checked;
            pendingNoveltyFilters.none = document.getElementById('mobile-novelty-none').checked;
        }
        
        function closeMobileNoveltyDropdown() {
            const dropdown = document.getElementById('mobile-novelty-dropdown');
            const button = document.getElementById('mobile-novelty-btn');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                dropdown.classList.add('hidden');
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
        }
        
        function closeDesktopNoveltyDropdown() {
            const dropdown = document.getElementById('desktop-novelty-dropdown');
            const button = document.getElementById('desktop-novelty-btn');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                dropdown.classList.add('hidden');
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
        }
        
        function updateNoveltyFiltersInURL() {
            const params = new URLSearchParams(window.location.search);
            params.set('novelty_high', currentNoveltyFilters.high.toString());
            params.set('novelty_moderate', currentNoveltyFilters.moderate.toString());
            params.set('novelty_low', currentNoveltyFilters.low.toString());
            params.set('novelty_none', currentNoveltyFilters.none.toString());
            const newURL = `${window.location.pathname}?${params.toString()}`;
            window.history.pushState({}, '', newURL);
        }
        
        function updateNoveltyFiltersFromURL() {
            const params = new URLSearchParams(window.location.search);
            
            const high = params.get('novelty_high');
            const moderate = params.get('novelty_moderate');
            const low = params.get('novelty_low');
            const none = params.get('novelty_none');
            
            if (high !== null) {
                currentNoveltyFilters.high = high === 'true';
                pendingNoveltyFilters.high = high === 'true';
            }
            if (moderate !== null) {
                currentNoveltyFilters.moderate = moderate === 'true';
                pendingNoveltyFilters.moderate = moderate === 'true';
            }
            if (low !== null) {
                currentNoveltyFilters.low = low === 'true';
                pendingNoveltyFilters.low = low === 'true';
            }
            if (none !== null) {
                currentNoveltyFilters.none = none === 'true';
                pendingNoveltyFilters.none = none === 'true';
            }
            
            syncNoveltyUI();
        }

        // ============================================================================
        // POTENTIAL IMPACT FILTER DROPDOWN FUNCTIONS
        // ============================================================================
        
        // Current and pending impact filter states
        let currentImpactFilters = {
            high: true,
            moderate: true,
            low: true,
            negligible: true
        };
        
        let pendingImpactFilters = {
            high: true,
            moderate: true,
            low: true,
            negligible: true
        };
        
        function toggleMobileImpactDropdown() {
            const button = document.getElementById('mobile-impact-btn');
            const dropdown = document.getElementById('mobile-impact-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                setDropdownDirection(button, dropdown);
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function toggleDesktopImpactDropdown() {
            const button = document.getElementById('desktop-impact-btn');
            const dropdown = document.getElementById('desktop-impact-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                setDropdownDirection(button, dropdown);
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function syncPendingImpactUI() {
            document.getElementById('mobile-impact-high').checked = pendingImpactFilters.high;
            document.getElementById('mobile-impact-moderate').checked = pendingImpactFilters.moderate;
            document.getElementById('mobile-impact-low').checked = pendingImpactFilters.low;
            document.getElementById('mobile-impact-negligible').checked = pendingImpactFilters.negligible;
            document.getElementById('desktop-impact-high').checked = pendingImpactFilters.high;
            document.getElementById('desktop-impact-moderate').checked = pendingImpactFilters.moderate;
            document.getElementById('desktop-impact-low').checked = pendingImpactFilters.low;
            document.getElementById('desktop-impact-negligible').checked = pendingImpactFilters.negligible;
        }
        
        function syncImpactUI() {
            document.getElementById('mobile-impact-high').checked = currentImpactFilters.high;
            document.getElementById('mobile-impact-moderate').checked = currentImpactFilters.moderate;
            document.getElementById('mobile-impact-low').checked = currentImpactFilters.low;
            document.getElementById('mobile-impact-negligible').checked = currentImpactFilters.negligible;
            document.getElementById('desktop-impact-high').checked = currentImpactFilters.high;
            document.getElementById('desktop-impact-moderate').checked = currentImpactFilters.moderate;
            document.getElementById('desktop-impact-low').checked = currentImpactFilters.low;
            document.getElementById('desktop-impact-negligible').checked = currentImpactFilters.negligible;
            
            updateImpactButtonText();
        }
        
        function updateImpactButtonText() {
            const highChecked = document.getElementById('mobile-impact-high').checked;
            const moderateChecked = document.getElementById('mobile-impact-moderate').checked;
            const lowChecked = document.getElementById('mobile-impact-low').checked;
            const negligibleChecked = document.getElementById('mobile-impact-negligible').checked;
            
            const checkedCount = [highChecked, moderateChecked, lowChecked, negligibleChecked].filter(Boolean).length;
            
            let selectionText;
            if (checkedCount === 4) {
                selectionText = "All Selected";
            } else if (checkedCount === 0) {
                selectionText = "None Selected";
            } else {
                selectionText = `${checkedCount} Selected`;
            }
            
            const mobileButton = document.getElementById('mobile-impact-btn');
            if (mobileButton) {
                mobileButton.innerHTML = `<span class="font-bold">Potential Impact:</span> <span class="font-normal">${selectionText}</span> <span class="text-base">▼</span>`;
            }
            
            const desktopButton = document.getElementById('desktop-impact-btn');
            if (desktopButton) {
                desktopButton.innerHTML = `<span class="font-bold">Potential Impact:</span> <span class="font-normal">${selectionText}</span> <span class="text-sm">▼</span>`;
            }
        }
        
        function applyImpactFilter() {
            updatePendingImpactFilters();
            currentImpactFilters = { ...pendingImpactFilters };
            syncImpactUI();
            updateImpactFiltersInURL();
            closeMobileImpactDropdown();
            closeDesktopImpactDropdown();
            applyFiltersAndSort();
        }
        
        function updatePendingImpactFilters() {
            pendingImpactFilters.high = document.getElementById('mobile-impact-high').checked;
            pendingImpactFilters.moderate = document.getElementById('mobile-impact-moderate').checked;
            pendingImpactFilters.low = document.getElementById('mobile-impact-low').checked;
            pendingImpactFilters.negligible = document.getElementById('mobile-impact-negligible').checked;
        }
        
        function closeMobileImpactDropdown() {
            const dropdown = document.getElementById('mobile-impact-dropdown');
            const button = document.getElementById('mobile-impact-btn');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                dropdown.classList.add('hidden');
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
        }
        
        function closeDesktopImpactDropdown() {
            const dropdown = document.getElementById('desktop-impact-dropdown');
            const button = document.getElementById('desktop-impact-btn');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                dropdown.classList.add('hidden');
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
        }
        
        function updateImpactFiltersInURL() {
            const params = new URLSearchParams(window.location.search);
            params.set('impact_high', currentImpactFilters.high.toString());
            params.set('impact_moderate', currentImpactFilters.moderate.toString());
            params.set('impact_low', currentImpactFilters.low.toString());
            params.set('impact_negligible', currentImpactFilters.negligible.toString());
            const newURL = `${window.location.pathname}?${params.toString()}`;
            window.history.pushState({}, '', newURL);
        }
        
        function updateImpactFiltersFromURL() {
            const params = new URLSearchParams(window.location.search);
            
            const high = params.get('impact_high');
            const moderate = params.get('impact_moderate');
            const low = params.get('impact_low');
            const negligible = params.get('impact_negligible');
            
            if (high !== null) {
                currentImpactFilters.high = high === 'true';
                pendingImpactFilters.high = high === 'true';
            }
            if (moderate !== null) {
                currentImpactFilters.moderate = moderate === 'true';
                pendingImpactFilters.moderate = moderate === 'true';
            }
            if (low !== null) {
                currentImpactFilters.low = low === 'true';
                pendingImpactFilters.low = low === 'true';
            }
            if (negligible !== null) {
                currentImpactFilters.negligible = negligible === 'true';
                pendingImpactFilters.negligible = negligible === 'true';
            }
            
            syncImpactUI();
        }

        // ============================================================================
        // TOPIC FILTER DROPDOWN FUNCTIONS
        // ============================================================================
        
        function toggleMobileTopicDropdown() {
            const button = document.getElementById('mobile-topic-btn');
            const dropdown = document.getElementById('mobile-topic-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                setDropdownDirection(button, dropdown);
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function toggleDesktopTopicDropdown() {
            const button = document.getElementById('desktop-topic-btn');
            const dropdown = document.getElementById('desktop-topic-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                setDropdownDirection(button, dropdown);
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function syncPendingTopicUI() {
            document.getElementById('mobile-topic-rlhf').checked = pendingTopicFilters.rlhf;
            document.getElementById('mobile-topic-weak-supervision').checked = pendingTopicFilters.weakSupervision;
            document.getElementById('mobile-topic-diffusion-reasoning').checked = pendingTopicFilters.diffusionReasoning;
            document.getElementById('mobile-topic-distributed-training').checked = pendingTopicFilters.distributedTraining;
            document.getElementById('mobile-topic-datasets').checked = pendingTopicFilters.datasets;
            document.getElementById('desktop-topic-rlhf').checked = pendingTopicFilters.rlhf;
            document.getElementById('desktop-topic-weak-supervision').checked = pendingTopicFilters.weakSupervision;
            document.getElementById('desktop-topic-diffusion-reasoning').checked = pendingTopicFilters.diffusionReasoning;
            document.getElementById('desktop-topic-distributed-training').checked = pendingTopicFilters.distributedTraining;
            document.getElementById('desktop-topic-datasets').checked = pendingTopicFilters.datasets;
        }
        
        function syncTopicUI() {
            document.getElementById('mobile-topic-rlhf').checked = currentTopicFilters.rlhf;
            document.getElementById('mobile-topic-weak-supervision').checked = currentTopicFilters.weakSupervision;
            document.getElementById('mobile-topic-diffusion-reasoning').checked = currentTopicFilters.diffusionReasoning;
            document.getElementById('mobile-topic-distributed-training').checked = currentTopicFilters.distributedTraining;
            document.getElementById('mobile-topic-datasets').checked = currentTopicFilters.datasets;
            document.getElementById('desktop-topic-rlhf').checked = currentTopicFilters.rlhf;
            document.getElementById('desktop-topic-weak-supervision').checked = currentTopicFilters.weakSupervision;
            document.getElementById('desktop-topic-diffusion-reasoning').checked = currentTopicFilters.diffusionReasoning;
            document.getElementById('desktop-topic-distributed-training').checked = currentTopicFilters.distributedTraining;
            document.getElementById('desktop-topic-datasets').checked = currentTopicFilters.datasets;
            
            updateTopicButtonText();
        }
        
        function updateTopicButtonText() {
            const rlhfChecked = document.getElementById('mobile-topic-rlhf').checked;
            const weakSupervisionChecked = document.getElementById('mobile-topic-weak-supervision').checked;
            const diffusionReasoningChecked = document.getElementById('mobile-topic-diffusion-reasoning').checked;
            const distributedTrainingChecked = document.getElementById('mobile-topic-distributed-training').checked;
            const datasetsChecked = document.getElementById('mobile-topic-datasets').checked;
            
            const checkedCount = [rlhfChecked, weakSupervisionChecked, diffusionReasoningChecked, distributedTrainingChecked, datasetsChecked].filter(Boolean).length;
            
            let selectionText;
            if (checkedCount === 5) {
                selectionText = "All Selected";
            } else if (checkedCount === 0) {
                selectionText = "None Selected";
            } else {
                selectionText = `${checkedCount} Selected`;
            }
            
            const mobileButton = document.getElementById('mobile-topic-btn');
            if (mobileButton) {
                mobileButton.innerHTML = `<span class="font-bold">Topics:</span> <span class="font-normal">${selectionText}</span> <span class="text-base">▼</span>`;
            }
            
            const desktopButton = document.getElementById('desktop-topic-btn');
            if (desktopButton) {
                desktopButton.innerHTML = `<span class="font-bold">Topics:</span> <span class="font-normal">${selectionText}</span> <span class="text-sm">▼</span>`;
            }
        }
        
        function applyTopicFilter() {
            updatePendingTopicFilters();
            currentTopicFilters = { ...pendingTopicFilters };
            syncTopicUI();
            updateTopicFiltersInURL();
            closeMobileTopicDropdown();
            closeDesktopTopicDropdown();
            updateAllPaperModules();
            applyFiltersAndSort();
        }
        
        function updatePendingTopicFilters() {
            pendingTopicFilters.rlhf = document.getElementById('mobile-topic-rlhf').checked;
            pendingTopicFilters.weakSupervision = document.getElementById('mobile-topic-weak-supervision').checked;
            pendingTopicFilters.diffusionReasoning = document.getElementById('mobile-topic-diffusion-reasoning').checked;
            pendingTopicFilters.distributedTraining = document.getElementById('mobile-topic-distributed-training').checked;
            pendingTopicFilters.datasets = document.getElementById('mobile-topic-datasets').checked;
        }
        
        function resetPendingTopicFilters() {
            pendingTopicFilters = { ...currentTopicFilters };
            syncPendingTopicUI();
            updateTopicButtonText();
        }
        
        function closeMobileTopicDropdown() {
            const dropdown = document.getElementById('mobile-topic-dropdown');
            const button = document.getElementById('mobile-topic-btn');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                dropdown.classList.add('hidden');
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
        }
        
        function closeDesktopTopicDropdown() {
            const dropdown = document.getElementById('desktop-topic-dropdown');
            const button = document.getElementById('desktop-topic-btn');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                dropdown.classList.add('hidden');
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
        }
        
        function updateTopicFiltersInURL() {
            const params = new URLSearchParams(window.location.search);
            params.set('topic_rlhf', currentTopicFilters.rlhf.toString());
            params.set('topic_weak_supervision', currentTopicFilters.weakSupervision.toString());
            params.set('topic_diffusion_reasoning', currentTopicFilters.diffusionReasoning.toString());
            params.set('topic_distributed_training', currentTopicFilters.distributedTraining.toString());
            params.set('topic_datasets', currentTopicFilters.datasets.toString());
            const newURL = `${window.location.pathname}?${params.toString()}`;
            window.history.pushState({}, '', newURL);
        }
        
        function updateTopicFiltersFromURL() {
            const params = new URLSearchParams(window.location.search);
            
            const rlhf = params.get('topic_rlhf');
            const weakSupervision = params.get('topic_weak_supervision');
            const diffusionReasoning = params.get('topic_diffusion_reasoning');
            const distributedTraining = params.get('topic_distributed_training');
            const datasets = params.get('topic_datasets');
            
            if (rlhf !== null) {
                currentTopicFilters.rlhf = rlhf === 'true';
                pendingTopicFilters.rlhf = rlhf === 'true';
            }
            if (weakSupervision !== null) {
                currentTopicFilters.weakSupervision = weakSupervision === 'true';
                pendingTopicFilters.weakSupervision = weakSupervision === 'true';
            }
            if (diffusionReasoning !== null) {
                currentTopicFilters.diffusionReasoning = diffusionReasoning === 'true';
                pendingTopicFilters.diffusionReasoning = diffusionReasoning === 'true';
            }
            if (distributedTraining !== null) {
                currentTopicFilters.distributedTraining = distributedTraining === 'true';
                pendingTopicFilters.distributedTraining = distributedTraining === 'true';
            }
            if (datasets !== null) {
                currentTopicFilters.datasets = datasets === 'true';
                pendingTopicFilters.datasets = datasets === 'true';
            }
            
            syncTopicUI();
        }
        
        function passesTopicFilter(paper) {
            // Topic filter doesn't actually filter papers, it only affects module display
            return true;
        }
        
        function updateAllPaperModules() {
            // Update all similarity and relevance modules when topic filters change
            currentPagePapers.forEach(paper => {
                updateSimilarityModuleTopics(paper.id);
                updateRelevanceModuleTopics(paper.id);
            });
        }

        // ============================================================================
        // RELEVANCE FILTER FUNCTIONS  
        // ============================================================================
        
        function toggleMobileRelevanceDropdown() {
            const button = document.getElementById('mobile-relevance-btn');
            const dropdown = document.getElementById('mobile-relevance-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                setDropdownDirection(button, dropdown);
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function toggleDesktopRelevanceDropdown() {
            const button = document.getElementById('desktop-relevance-btn');
            const dropdown = document.getElementById('desktop-relevance-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                setDropdownDirection(button, dropdown);
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function syncPendingRelevanceUI() {
            document.getElementById('mobile-relevance-highly').checked = pendingRelevanceFilters.highlyRelevant;
            document.getElementById('mobile-relevance-moderately').checked = pendingRelevanceFilters.moderatelyRelevant;
            document.getElementById('mobile-relevance-tangentially').checked = pendingRelevanceFilters.tangentiallyRelevant;
            document.getElementById('mobile-relevance-not').checked = pendingRelevanceFilters.notRelevant;
            document.getElementById('desktop-relevance-highly').checked = pendingRelevanceFilters.highlyRelevant;
            document.getElementById('desktop-relevance-moderately').checked = pendingRelevanceFilters.moderatelyRelevant;
            document.getElementById('desktop-relevance-tangentially').checked = pendingRelevanceFilters.tangentiallyRelevant;
            document.getElementById('desktop-relevance-not').checked = pendingRelevanceFilters.notRelevant;
        }
        
        function syncRelevanceUI() {
            document.getElementById('mobile-relevance-highly').checked = currentRelevanceFilters.highlyRelevant;
            document.getElementById('mobile-relevance-moderately').checked = currentRelevanceFilters.moderatelyRelevant;
            document.getElementById('mobile-relevance-tangentially').checked = currentRelevanceFilters.tangentiallyRelevant;
            document.getElementById('mobile-relevance-not').checked = currentRelevanceFilters.notRelevant;
            document.getElementById('desktop-relevance-highly').checked = currentRelevanceFilters.highlyRelevant;
            document.getElementById('desktop-relevance-moderately').checked = currentRelevanceFilters.moderatelyRelevant;
            document.getElementById('desktop-relevance-tangentially').checked = currentRelevanceFilters.tangentiallyRelevant;
            document.getElementById('desktop-relevance-not').checked = currentRelevanceFilters.notRelevant;
            
            updateRelevanceButtonText();
        }
        
        function updateRelevanceButtonText() {
            // Read the current checkbox states from the UI (like H-Index filter does)
            const highlyRelevantChecked = document.getElementById('mobile-relevance-highly').checked;
            const moderatelyRelevantChecked = document.getElementById('mobile-relevance-moderately').checked;
            const tangentiallyRelevantChecked = document.getElementById('mobile-relevance-tangentially').checked;
            const notRelevantChecked = document.getElementById('mobile-relevance-not').checked;
            
            const selectedOptions = [];
            if (highlyRelevantChecked) selectedOptions.push("Highly Relevant");
            if (moderatelyRelevantChecked) selectedOptions.push("Moderately Relevant");
            if (tangentiallyRelevantChecked) selectedOptions.push("Tangentially Relevant");
            if (notRelevantChecked) selectedOptions.push("Not Relevant");
            
            const selectionText = selectedOptions.length === 4 ? "All Selected" : 
                                selectedOptions.length === 0 ? "None Selected" : 
                                `${selectedOptions.length} Selected`;
            
            const mobileButton = document.getElementById('mobile-relevance-btn');
            if (mobileButton) {
                mobileButton.innerHTML = `<span class="font-bold">Relevance:</span> <span class="font-normal">${selectionText}</span> <span class="text-base">▼</span>`;
            }
            
            const desktopButton = document.getElementById('desktop-relevance-btn');
            if (desktopButton) {
                desktopButton.innerHTML = `<span class="font-bold">Relevance:</span> <span class="font-normal">${selectionText}</span> <span class="text-sm">▼</span>`;
            }
        }
        
        function applyRelevanceFilter() {
            updatePendingRelevanceFilters();
            currentRelevanceFilters = { ...pendingRelevanceFilters };
            syncRelevanceUI();
            updateRelevanceFiltersInURL();
            closeMobileRelevanceDropdown();
            closeDesktopRelevanceDropdown();
            applyFiltersAndSort();
        }
        
        function updatePendingRelevanceFilters() {
            // Get values from mobile (primary source)
            const mobileHighly = document.getElementById('mobile-relevance-highly');
            const mobileModerately = document.getElementById('mobile-relevance-moderately');
            const mobileTangentially = document.getElementById('mobile-relevance-tangentially');
            const mobileNot = document.getElementById('mobile-relevance-not');
            
            // Update pending filters from mobile if available, otherwise from desktop
            pendingRelevanceFilters.highlyRelevant = mobileHighly ? mobileHighly.checked : document.getElementById('desktop-relevance-highly').checked;
            pendingRelevanceFilters.moderatelyRelevant = mobileModerately ? mobileModerately.checked : document.getElementById('desktop-relevance-moderately').checked;
            pendingRelevanceFilters.tangentiallyRelevant = mobileTangentially ? mobileTangentially.checked : document.getElementById('desktop-relevance-tangentially').checked;
            pendingRelevanceFilters.notRelevant = mobileNot ? mobileNot.checked : document.getElementById('desktop-relevance-not').checked;
        }
        
        function resetPendingRelevanceFilters() {
            pendingRelevanceFilters = { ...currentRelevanceFilters };
            syncPendingRelevanceUI();
            updateRelevanceButtonText();
        }
        
        function closeMobileRelevanceDropdown() {
            const dropdown = document.getElementById('mobile-relevance-dropdown');
            const button = document.getElementById('mobile-relevance-btn');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                dropdown.classList.add('hidden');
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
        }
        
        function closeDesktopRelevanceDropdown() {
            const dropdown = document.getElementById('desktop-relevance-dropdown');
            const button = document.getElementById('desktop-relevance-btn');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                dropdown.classList.add('hidden');
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
        }
        
        function updateRelevanceFiltersInURL() {
            const params = new URLSearchParams(window.location.search);
            params.set('relevance_highly', currentRelevanceFilters.highlyRelevant.toString());
            params.set('relevance_moderately', currentRelevanceFilters.moderatelyRelevant.toString());
            params.set('relevance_tangentially', currentRelevanceFilters.tangentiallyRelevant.toString());
            params.set('relevance_not', currentRelevanceFilters.notRelevant.toString());
            window.history.replaceState({}, '', `${window.location.pathname}?${params.toString()}`);
        }
        
        function loadRelevanceFiltersFromURL() {
            const highlyRelevant = getUrlParameter('relevance_highly');
            const moderatelyRelevant = getUrlParameter('relevance_moderately');
            const tangentiallyRelevant = getUrlParameter('relevance_tangentially');
            const notRelevant = getUrlParameter('relevance_not');
            
            if (highlyRelevant !== null) {
                currentRelevanceFilters.highlyRelevant = highlyRelevant === 'true';
                pendingRelevanceFilters.highlyRelevant = highlyRelevant === 'true';
            }
            if (moderatelyRelevant !== null) {
                currentRelevanceFilters.moderatelyRelevant = moderatelyRelevant === 'true';
                pendingRelevanceFilters.moderatelyRelevant = moderatelyRelevant === 'true';
            }
            if (tangentiallyRelevant !== null) {
                currentRelevanceFilters.tangentiallyRelevant = tangentiallyRelevant === 'true';
                pendingRelevanceFilters.tangentiallyRelevant = tangentiallyRelevant === 'true';
            }
            if (notRelevant !== null) {
                currentRelevanceFilters.notRelevant = notRelevant === 'true';
                pendingRelevanceFilters.notRelevant = notRelevant === 'true';
            }
            
            syncRelevanceUI();
        }
        
        function passesRelevanceFilter(paper) {
            // Get selected topics
            const selectedTopics = [];
            if (currentTopicFilters.rlhf) selectedTopics.push('rlhf');
            if (currentTopicFilters.weakSupervision) selectedTopics.push('weak_supervision');
            if (currentTopicFilters.diffusionReasoning) selectedTopics.push('diffusion_reasoning');
            if (currentTopicFilters.distributedTraining) selectedTopics.push('distributed_training');
            if (currentTopicFilters.datasets) selectedTopics.push('datasets');
            
            // If no topics selected, skip relevance filtering
            if (selectedTopics.length === 0) return true;
            
            // Get selected relevance levels
            const selectedRelevanceLevels = [];
            if (currentRelevanceFilters.highlyRelevant) selectedRelevanceLevels.push('Highly Relevant');
            if (currentRelevanceFilters.moderatelyRelevant) selectedRelevanceLevels.push('Moderately Relevant');
            if (currentRelevanceFilters.tangentiallyRelevant) selectedRelevanceLevels.push('Tangentially Relevant');
            if (currentRelevanceFilters.notRelevant) selectedRelevanceLevels.push('Not Relevant');
            
            // If no relevance levels selected, show 0 papers
            if (selectedRelevanceLevels.length === 0) return false;
            
            // Check each selected topic
            for (let topic of selectedTopics) {
                const relevanceField = `${topic}_relevance`;
                const paperRelevance = paper[relevanceField];
                
                // Treat "not_validated" same as "Not Relevant"
                const normalizedRelevance = paperRelevance === "not_validated" ? "Not Relevant" : paperRelevance;
                
                // If this topic's relevance matches any selected relevance level, paper passes
                if (selectedRelevanceLevels.includes(normalizedRelevance)) {
                    return true; // At least one topic matches
                }
            }
            
            // No selected topics had matching relevance levels
            return false;
        }

        // ============================================================================
        // FILTERING AND DISPLAY FUNCTIONS
        // ============================================================================
        
        function shouldDisableAdvancedFilters() {
            return !currentScoringFilters.hasScoring && currentScoringFilters.noScoring;
        }
        
        function updateDropdownDisabledState(buttonId, dropdownId, shouldDisable) {
            const button = document.getElementById(buttonId);
            const dropdown = document.getElementById(dropdownId);
            
            if (button && dropdown) {
                if (shouldDisable) {
                    button.classList.add('opacity-50', 'cursor-not-allowed');
                    button.style.pointerEvents = 'none';
                    dropdown.classList.add('hidden'); // Close if open
                } else {
                    button.classList.remove('opacity-50', 'cursor-not-allowed');
                    button.style.pointerEvents = 'auto';
                }
            }
        }
        
        function updateAdvancedFiltersDisabledState() {
            const shouldDisable = shouldDisableAdvancedFilters();
            
            // Update Recommendation
            updateDropdownDisabledState('mobile-recommendation-btn', 'mobile-recommendation-dropdown', shouldDisable);
            updateDropdownDisabledState('desktop-recommendation-btn', 'desktop-recommendation-dropdown', shouldDisable);
            
            // Update Novelty  
            updateDropdownDisabledState('mobile-novelty-btn', 'mobile-novelty-dropdown', shouldDisable);
            updateDropdownDisabledState('desktop-novelty-btn', 'desktop-novelty-dropdown', shouldDisable);
            
            // Update Impact
            updateDropdownDisabledState('mobile-impact-btn', 'mobile-impact-dropdown', shouldDisable);
            updateDropdownDisabledState('desktop-impact-btn', 'desktop-impact-dropdown', shouldDisable);
            
            // Update Relevance
            updateDropdownDisabledState('mobile-relevance-btn', 'mobile-relevance-dropdown', shouldDisable);
            updateDropdownDisabledState('desktop-relevance-btn', 'desktop-relevance-dropdown', shouldDisable);
        }
        
        function applyFiltersAndSort() {
            // Apply H-Index filtering first
            filteredSortedPapers = allPapers.filter(paper => passesHIndexFilter(paper));
            
            // Apply Scoring filtering
            filteredSortedPapers = filteredSortedPapers.filter(paper => passesScoringFilter(paper));
            
            // Apply Recommendation filtering
            filteredSortedPapers = filteredSortedPapers.filter(paper => passesRecommendationFilter(paper));
            
            // Apply Novelty filtering
            filteredSortedPapers = filteredSortedPapers.filter(paper => passesNoveltyFilter(paper));
            
            // Apply Impact filtering
            filteredSortedPapers = filteredSortedPapers.filter(paper => passesImpactFilter(paper));
            
            // Apply Relevance filtering
            filteredSortedPapers = filteredSortedPapers.filter(paper => passesRelevanceFilter(paper));
            
            // Apply Topic filtering (note: this doesn't filter papers, just affects display)
            filteredSortedPapers = filteredSortedPapers.filter(paper => passesTopicFilter(paper));
            
            // Apply current sorting
            sortPapers(currentSort);
            
            // Calculate pagination
            totalPages = Math.ceil(filteredSortedPapers.length / PAPERS_PER_PAGE);
            currentPage = 1;
            
            updatePaperCount();
            updatePaginationUI();
            displayCurrentPage();
        }
        
        function passesHIndexFilter(paper) {
            const { found, notFound, highestMin, highestMax, averageMin, averageMax } = currentHIndexFilters;
            
            // Check H-Index status
            const hasHIndex = paper.h_index_status === 'completed';
            const noHIndex = paper.h_index_status === 'not_fetched';
            
            // If neither found nor not-found is checked, hide all papers
            if (!found && !notFound) return false;
            
            // Check status inclusion
            if (hasHIndex && !found) return false;
            if (noHIndex && !notFound) return false;
            
            // For papers with H-Index data, check ranges (only if "found" is checked)
            if (hasHIndex && found) {
                // Treat null h-index values as 0
                const paperHighest = paper.highest_h_index || 0;
                const paperAverage = paper.average_h_index || 0;
                
                // Check if paper's H-Index values fall within ranges
                if (paperHighest < highestMin || paperHighest > highestMax) return false;
                if (paperAverage < averageMin || paperAverage > averageMax) return false;
            }
            
            return true;
        }
        
        function passesScoringFilter(paper) {
            const { hasScoring, noScoring } = currentScoringFilters;
            
            // Check scoring status
            const hasLLMScoring = paper.llm_score_status === 'completed';
            const noLLMScoring = paper.llm_score_status === 'not_relevant_enough';
            
            // If neither hasScoring nor noScoring is checked, hide all papers
            if (!hasScoring && !noScoring) return false;
            
            // Check status inclusion
            if (hasLLMScoring && !hasScoring) return false;
            if (noLLMScoring && !noScoring) return false;
            
            // Handle other statuses - if paper has a different status, only show if both filters are enabled
            if (!hasLLMScoring && !noLLMScoring) {
                return hasScoring && noScoring;
            }
            
            return true;
        }
        
        function passesRecommendationFilter(paper) {
            const { mustRead, shouldRead, canSkip, ignore } = currentRecommendationFilters;
            
            // If no filters are selected, hide all papers
            if (!mustRead && !shouldRead && !canSkip && !ignore) return false;
            
            // Check recommendation score
            const score = paper.recommendation_score;
            
            if (score === 'Must Read' && !mustRead) return false;
            if (score === 'Should Read' && !shouldRead) return false;
            if (score === 'Can Skip' && !canSkip) return false;
            if (score === 'Ignore' && !ignore) return false;
            
            // If paper has a different/null score, only show if all filters are enabled
            if (!['Must Read', 'Should Read', 'Can Skip', 'Ignore'].includes(score)) {
                return mustRead && shouldRead && canSkip && ignore;
            }
            
            return true;
        }
        
        function passesNoveltyFilter(paper) {
            const { high, moderate, low, none } = currentNoveltyFilters;
            
            // If no filters are selected, hide all papers
            if (!high && !moderate && !low && !none) return false;
            
            // Check novelty score
            const score = paper.novelty_score;
            
            if (score === 'High' && !high) return false;
            if (score === 'Moderate' && !moderate) return false;
            if (score === 'Low' && !low) return false;
            if ((score === null || score === undefined) && !none) return false;
            
            // If paper has a different score, only show if all filters are enabled
            if (score && !['High', 'Moderate', 'Low'].includes(score)) {
                return high && moderate && low && none;
            }
            
            return true;
        }
        
        function passesImpactFilter(paper) {
            const { high, moderate, low, negligible } = currentImpactFilters;
            
            // If no filters are selected, hide all papers
            if (!high && !moderate && !low && !negligible) return false;
            
            // Check impact score
            const score = paper.impact_score;
            
            if (score === 'High' && !high) return false;
            if (score === 'Moderate' && !moderate) return false;
            if (score === 'Low' && !low) return false;
            if (score === 'Negligible' && !negligible) return false;
            
            // If paper has a different/null score, only show if all filters are enabled
            if (!['High', 'Moderate', 'Low', 'Negligible'].includes(score)) {
                return high && moderate && low && negligible;
            }
            
            return true;
        }
        
        function displayCurrentPage() {
            // Check if there are no papers to display
            if (filteredSortedPapers.length === 0) {
                showNoPapersMessage();
                hidePaginationSections();
                return;
            }
            
            const startIndex = (currentPage - 1) * PAPERS_PER_PAGE;
            const endIndex = startIndex + PAPERS_PER_PAGE;
            currentPagePapers = filteredSortedPapers.slice(startIndex, endIndex);
            
            showPaginationSections();
            populatePaperCards(currentPagePapers, startIndex + 1);
            
            // Re-run truncation after new content is displayed
            setTimeout(() => {
                setupAbstractTruncation();
                setupInitialProgressBars();
            }, 50);
        }

        function populatePaperCards(papers, startIndex = 1) {
            const mobileContainer = document.getElementById('mobile-papers');
            const desktopContainer = document.getElementById('desktop-papers');
            
            const papersHTML = papers.map((paper, index) => createPaperCard(paper, startIndex + index)).join('');
            
            if (mobileContainer) {
                mobileContainer.innerHTML = papersHTML;
            }
            if (desktopContainer) {
                desktopContainer.innerHTML = papersHTML;
            }
        }

        function showNoPapersMessage() {
            const mobileContainer = document.getElementById('mobile-papers');
            const desktopContainer = document.getElementById('desktop-papers');
            
            const noPapersHTML = '<div class="flex items-center justify-center min-h-screen"><h2 class="font-heading text-2xl text-neutral-600">No papers to show</h2></div>';
            
            if (mobileContainer) {
                mobileContainer.innerHTML = noPapersHTML;
            }
            if (desktopContainer) {
                desktopContainer.innerHTML = noPapersHTML;
            }
        }

        function hidePaginationSections() {
            const paginationIds = [
                'mobile-prev-btn', 'mobile-next-btn', 'mobile-pagination-numbers',
                'desktop-prev-btn', 'desktop-next-btn', 'desktop-pagination-numbers',
                'mobile-footer-prev-btn', 'mobile-footer-next-btn', 'mobile-footer-pagination-numbers',
                'desktop-footer-prev-btn', 'desktop-footer-next-btn', 'desktop-footer-pagination-numbers'
            ];
            
            paginationIds.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.style.display = 'none';
                }
            });
        }

        function showPaginationSections() {
            const paginationIds = [
                'mobile-prev-btn', 'mobile-next-btn', 'mobile-pagination-numbers',
                'desktop-prev-btn', 'desktop-next-btn', 'desktop-pagination-numbers',
                'mobile-footer-prev-btn', 'mobile-footer-next-btn', 'mobile-footer-pagination-numbers',
                'desktop-footer-prev-btn', 'desktop-footer-next-btn', 'desktop-footer-pagination-numbers'
            ];
            
            paginationIds.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.style.display = '';
                }
            });
        }

        // ============================================================================
        // PAGINATION FUNCTIONS
        // ============================================================================
        
        function goToPage(page) {
            if (page < 1 || page > totalPages) return;
            currentPage = page;
            updatePaginationUI();
            displayCurrentPage();
        }
        
        function updatePaginationUI() {
            // Update all pagination controls
            updatePaginationButtons();
            updatePaginationNumbers();
        }
        
        function updatePaginationButtons() {
            // Previous buttons
            const prevButtons = ['mobile-prev-btn', 'desktop-prev-btn', 'mobile-footer-prev-btn', 'desktop-footer-prev-btn'];
            prevButtons.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) {
                    if (currentPage <= 1) {
                        btn.classList.add('disabled');
                    } else {
                        btn.classList.remove('disabled');
                    }
                }
            });
            
            // Next buttons
            const nextButtons = ['mobile-next-btn', 'desktop-next-btn', 'mobile-footer-next-btn', 'desktop-footer-next-btn'];
            nextButtons.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) {
                    if (currentPage >= totalPages) {
                        btn.classList.add('disabled');
                    } else {
                        btn.classList.remove('disabled');
                    }
                }
            });
        }
        
        function updatePaginationNumbers() {
            const containers = [
                'mobile-pagination-numbers',
                'desktop-pagination-numbers', 
                'mobile-footer-pagination-numbers',
                'desktop-footer-pagination-numbers'
            ];
            
            containers.forEach(containerId => {
                const container = document.getElementById(containerId);
                if (container) {
                    container.innerHTML = generatePaginationNumbers();
                }
            });
        }
        
        function generatePaginationNumbers() {
            if (totalPages <= 1) return '';
            
            let html = '';
            const maxVisiblePages = 5;
            let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
            let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);
            
            // Adjust if we're near the end
            if (endPage - startPage + 1 < maxVisiblePages) {
                startPage = Math.max(1, endPage - maxVisiblePages + 1);
            }
            
            for (let i = startPage; i <= endPage; i++) {
                const isActive = i === currentPage;
                const activeClass = isActive ? 'bg-neutral-500 text-neutral-10' : 'bg-transparent text-neutral-70 hover:bg-neutral-300';
                html += `<button class="pagination-square w-8 h-8 ${activeClass} flex items-center justify-center cursor-pointer font-heading font-bold text-sm" onclick="goToPage(${i})">${i}</button>`;
            }
            
            return html;
        }

        // ============================================================================
        // HELPER FUNCTIONS FOR STYLING
        // ============================================================================

        function getScoreColor(scoreType, value) {
            const colorMap = {
                recommendation: {
                    'Must Read': 'bg-status-green',      
                    'Should Read': 'bg-status-blue',   
                    'Can Skip': 'bg-status-orange',       
                    'Ignore': 'bg-status-red'          
                },
                novelty: {
                    'High': 'bg-status-green',           
                    'Moderate': 'bg-status-blue',      
                    'Low': 'bg-status-orange',            
                    'None': 'bg-status-red'            
                },
                impact: {
                    'High': 'bg-status-green',           
                    'Moderate': 'bg-status-blue',      
                    'Low': 'bg-status-orange',            
                    'Negligible': 'bg-status-red'      
                }
            };
            
            return colorMap[scoreType][value] || 'bg-neutral-500';  // fallback to neutral-500
        }

        function getRelevanceColor(relevanceValue) {
            const colorMap = {
                'Highly Relevant': 'bg-status-green',      
                'Moderately Relevant': 'bg-status-blue', 
                'Tangentially Relevant': 'bg-status-orange', 
                'Not Relevant': 'bg-status-red',         
                'not_validated': 'bg-status-red'         
            };
            
            return colorMap[relevanceValue] || 'bg-status-red';  // fallback to status-red
        }

        function getRelevanceDisplayText(relevanceValue) {
            if (relevanceValue === 'not_validated') {
                return 'Not Relevant';
            }
            return relevanceValue;
        }

        function getJustificationText(justificationValue) {
            if (justificationValue === 'below_threshold') {
                return "Topic similarity score below 0.4, hence default to 'Not Relevant'.";
            }
            return justificationValue;
        }

        // ============================================================================
        // KATEX RENDERING FUNCTIONS
        // ============================================================================

        function renderKatexInElement(element) {
            if (typeof renderMathInElement !== 'undefined' && element) {
                renderMathInElement(element, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false},
                        {left: '\\(', right: '\\)', display: false},
                        {left: '\\[', right: '\\]', display: true},
                    ],
                    throwOnError: false,
                    trust: true
                });
            }
        }

        // ============================================================================
        // TOPIC VISIBILITY HELPER FUNCTIONS
        // ============================================================================
        
        function getTopicKeyMapping() {
            return {
                'rlhf': 'rlhf',
                'weakSupervision': 'weak_supervision', 
                'diffusionReasoning': 'diffusion_reasoning',
                'distributedTraining': 'distributed_training',
                'datasets': 'datasets'
            };
        }
        
        function getTopicDisplayNames() {
            return {
                'rlhf': 'RLHF',
                'weakSupervision': 'Weak Supervision',
                'diffusionReasoning': 'Diffusion Reasoning', 
                'distributedTraining': 'Distributed Training',
                'datasets': 'Datasets'
            };
        }
        
        function getHiddenTopicsCount() {
            const filters = currentTopicFilters;
            return Object.values(filters).filter(visible => !visible).length;
        }
        
        function getVisibleTopics() {
            const filters = currentTopicFilters;
            return Object.keys(filters).filter(topic => filters[topic]);
        }
        
        function getHiddenTopics() {
            const filters = currentTopicFilters;
            return Object.keys(filters).filter(topic => !filters[topic]);
        }
        
        function generateSimilarityTopicRows(paper) {
            const topicMapping = getTopicKeyMapping();
            const displayNames = getTopicDisplayNames();
            const visibleTopics = getVisibleTopics();
            
            let html = '';
            
            // Add visible topic rows
            visibleTopics.forEach(topic => {
                const dataKey = topicMapping[topic];
                const displayName = displayNames[topic];
                const score = paper[`${dataKey}_score`];
                
                html += `
                    <!-- ${displayName} Score Row -->
                    <div class="flex flex-col topic-row visible-topic" data-topic="${topic}">
                        <div class="text-left">
                            <span class="text-neutral-70 font-heading font-bold text-lg">${displayName}:</span>
                        </div>
                        <div class="bg-neutral-200 relative flex items-center justify-end">
                            <div class="similarity-progress-bar ${dataKey.replace('_', '-')}-progress-bar bg-bar-raw absolute inset-0 z-0" 
                                 data-paper-id="${paper.id}" 
                                 data-topic="${dataKey}">
                            </div>
                            <span class="text-neutral-70 font-heading font-bold text-md py-tag-y px-tag-x relative z-10 ${dataKey.replace('_', '-')}-similarity-score">
                                ${score.toFixed(3)}
                            </span>
                        </div>
                    </div>
                `;
            });
            
            return html;
        }
        
        function generateRelevanceTopicRows(paper) {
            const topicMapping = getTopicKeyMapping();
            const displayNames = getTopicDisplayNames();
            const visibleTopics = getVisibleTopics();
            
            let html = '';
            
            // Add visible topic rows
            visibleTopics.forEach(topic => {
                const dataKey = topicMapping[topic];
                const displayName = displayNames[topic];
                const relevance = paper[`${dataKey}_relevance`];
                
                html += `
                    <!-- ${displayName} Relevance Row -->
                    <div class="flex flex-col topic-row visible-topic" data-topic="${topic}">
                        <div class="text-left">
                            <span class="text-neutral-70 font-heading font-bold text-lg">${displayName}:</span>
                        </div>
                        <div class="w-full text-center py-tag-y font-heading font-bold text-md text-neutral-10 ${getRelevanceColor(relevance)}">
                            ${getRelevanceDisplayText(relevance)}
                        </div>
                    </div>
                `;
            });
            
            return html;
        }
        
        function generateRelevanceJustificationContent(paper, showingHidden = false) {
            const topicMapping = getTopicKeyMapping();
            const displayNames = getTopicDisplayNames();
            const visibleTopics = getVisibleTopics();
            
            let html = '';
            
            // Add justification for visible topics only unless showing hidden topics
            const topicsToShow = showingHidden ? Object.keys(displayNames) : visibleTopics;
            
            topicsToShow.forEach(topic => {
                const dataKey = topicMapping[topic];
                const displayName = displayNames[topic];
                const justification = paper[`${dataKey}_justification`];
                
                html += `
                    <div class="justification-topic-section visible-justification" data-topic="${topic}">
                        <div class="font-heading font-bold">${displayName}:</div>
                        <div>${getJustificationText(justification)}</div>
                    </div>
                `;
            });
            
            return html;
        }
        
        function toggleSimilarityHiddenTopics(paperId) {
            // Find the similarity module specifically
            const containers = document.querySelectorAll(`[data-paper-id="${paperId}"][data-show-hidden-topics]`);
            let container = null;
            
            // Find the similarity container (the one that contains similarity-scores-container)
            // and ensure it's in the currently visible layout (mobile or desktop)
            containers.forEach(cont => {
                if (cont.querySelector('.similarity-scores-container')) {
                    // Check if this container is in a visible layout
                    const mobileLayout = cont.closest('#mobile-main-container');
                    const desktopLayout = cont.closest('.tablet\\:block');
                    
                    if (mobileLayout && getComputedStyle(mobileLayout).display !== 'none') {
                        container = cont;
                    } else if (desktopLayout && getComputedStyle(desktopLayout).display !== 'none') {
                        container = cont;
                    }
                }
            });
            
            if (!container) return;
            
            const isShowingHidden = container.getAttribute('data-show-hidden-topics') === 'true';
            const button = container.querySelector('.show-other-topics-container button');
            const hiddenTopicsContainer = container.querySelector('.hidden-topics-container');
            
            if (!isShowingHidden) {
                // Show hidden topics
                container.setAttribute('data-show-hidden-topics', 'true');
                button.innerHTML = 'Hide Other Topics <span class="text-xs">▲</span>';
                button.className = 'bg-neutral-700 text-neutral-10 font-heading font-bold text-md py-tag-y mt-md w-full text-center hover:bg-neutral-600';
                
                // Show and populate the hidden topics container
                hiddenTopicsContainer.style.display = 'block';
                addHiddenSimilarityTopics(paperId, hiddenTopicsContainer);
            } else {
                // Hide other topics  
                container.setAttribute('data-show-hidden-topics', 'false');
                button.innerHTML = 'Show Other Topics <span class="text-xs">▼</span>';
                button.className = 'bg-neutral-500 text-neutral-10 font-heading font-bold text-md py-tag-y mt-md w-full text-center hover:bg-neutral-600';
                
                // Hide and clear the hidden topics container
                hiddenTopicsContainer.style.display = 'none';
                hiddenTopicsContainer.innerHTML = '';
            }
            
            // Recalculate normalized scores if in normalized mode
            if (container.getAttribute('data-normalized') === 'true') {
                updateNormalizedScores(paperId);
            }
        }
        
        function toggleRelevanceHiddenTopics(paperId) {
            // Find the relevance module specifically (not similarity module)
            const containers = document.querySelectorAll(`[data-paper-id="${paperId}"][data-show-hidden-topics]`);
            let container = null;
            
            // Find the relevance container (the one that contains relevance-scores-container)
            // and ensure it's in the currently visible layout (mobile or desktop)
            containers.forEach(cont => {
                if (cont.querySelector('.relevance-scores-container')) {
                    // Check if this container is in a visible layout
                    const mobileLayout = cont.closest('#mobile-main-container');
                    const desktopLayout = cont.closest('.tablet\\:block');
                    
                    if (mobileLayout && getComputedStyle(mobileLayout).display !== 'none') {
                        container = cont;
                    } else if (desktopLayout && getComputedStyle(desktopLayout).display !== 'none') {
                        container = cont;
                    }
                }
            });
            
            if (!container) return;
            
            const isShowingHidden = container.getAttribute('data-show-hidden-topics') === 'true';
            const button = container.querySelector('.show-other-topics-container button');
            const hiddenTopicsContainer = container.querySelector('.hidden-topics-container');
            
            if (!isShowingHidden) {
                // Show hidden topics
                container.setAttribute('data-show-hidden-topics', 'true');
                button.innerHTML = 'Hide Other Topics <span class="text-xs">▲</span>';
                button.className = 'bg-neutral-700 text-neutral-10 font-heading font-bold text-md py-tag-y mt-md w-full text-center hover:bg-neutral-600';
                
                // Show and populate the hidden topics container
                hiddenTopicsContainer.style.display = 'block';
                addHiddenRelevanceTopics(paperId, hiddenTopicsContainer);
            } else {
                // Hide other topics
                container.setAttribute('data-show-hidden-topics', 'false');
                button.innerHTML = 'Show Other Topics <span class="text-xs">▼</span>';
                button.className = 'bg-neutral-500 text-neutral-10 font-heading font-bold text-md py-tag-y mt-md w-full text-center hover:bg-neutral-600';
                
                // Hide and clear the hidden topics container
                hiddenTopicsContainer.style.display = 'none';
                hiddenTopicsContainer.innerHTML = '';
            }
            
            // Update justification content based on new state
            const justificationContainer = container.querySelector('.relevance-justification-section .justification-text');
            if (justificationContainer) {
                const paper = currentPagePapers.find(p => p.id === paperId);
                if (paper) {
                    const newShowingHidden = container.getAttribute('data-show-hidden-topics') === 'true';
                    justificationContainer.innerHTML = generateRelevanceJustificationContent(paper, newShowingHidden);
                }
            }
            
            // Update justification if it's currently visible
            updateRelevanceJustificationVisibility(paperId);
        }
        
        function addHiddenSimilarityTopics(paperId, container) {
            const paper = currentPagePapers.find(p => p.id === paperId);
            if (!paper) return;
            
            const topicMapping = getTopicKeyMapping();
            const displayNames = getTopicDisplayNames();
            const hiddenTopics = getHiddenTopics();
            
            // Check if the parent container is in normalized mode
            const parentContainer = container.closest('[data-normalized]');
            const isNormalized = parentContainer && parentContainer.getAttribute('data-normalized') === 'true';
            const barColorClass = isNormalized ? 'bg-bar-normalized' : 'bg-bar-raw';
            
            hiddenTopics.forEach(topic => {
                const dataKey = topicMapping[topic];
                const displayName = displayNames[topic];
                const score = paper[`${dataKey}_score`];
                
                const rowHtml = `
                    <div class="flex flex-col topic-row hidden-topic" data-topic="${topic}">
                        <div class="text-left">
                            <span class="text-neutral-70 font-heading font-bold text-lg">${displayName}:</span>
                        </div>
                        <div class="bg-neutral-200 relative flex items-center justify-end">
                            <div class="similarity-progress-bar ${dataKey.replace('_', '-')}-progress-bar ${barColorClass} absolute inset-0 z-0" 
                                 data-paper-id="${paperId}" 
                                 data-topic="${dataKey}">
                            </div>
                            <span class="text-neutral-70 font-heading font-bold text-md py-tag-y px-tag-x relative z-10 ${dataKey.replace('_', '-')}-similarity-score">
                                ${score.toFixed(3)}
                            </span>
                        </div>
                    </div>
                `;
                
                container.insertAdjacentHTML('beforeend', rowHtml);
            });
            
            // Update progress bars for newly added rows with correct values and colors
            setupProgressBarsForPaper(paper);
            
            // If in normalized mode, update all scores including the newly added ones
            if (isNormalized) {
                updateNormalizedScores(paperId);
            }
        }
        
        function addHiddenRelevanceTopics(paperId, container) {
            const paper = currentPagePapers.find(p => p.id === paperId);
            if (!paper) return;
            
            const topicMapping = getTopicKeyMapping();
            const displayNames = getTopicDisplayNames();
            const hiddenTopics = getHiddenTopics();
            
            hiddenTopics.forEach(topic => {
                const dataKey = topicMapping[topic];
                const displayName = displayNames[topic];
                const relevance = paper[`${dataKey}_relevance`];
                
                const rowHtml = `
                    <div class="flex flex-col topic-row hidden-topic" data-topic="${topic}">
                        <div class="text-left">
                            <span class="text-neutral-70 font-heading font-bold text-lg">${displayName}:</span>
                        </div>
                        <div class="w-full text-center py-tag-y font-heading font-bold text-md text-neutral-10 ${getRelevanceColor(relevance)}">
                            ${getRelevanceDisplayText(relevance)}
                        </div>
                    </div>
                `;
                
                container.insertAdjacentHTML('beforeend', rowHtml);
            });
        }
        
        function removeHiddenTopicRows(container) {
            const hiddenRows = container.querySelectorAll('.hidden-topic');
            hiddenRows.forEach(row => row.remove());
        }
        
        function updateSimilarityModuleTopics(paperId) {
            // Find the similarity module specifically
            const containers = document.querySelectorAll(`[data-paper-id="${paperId}"][data-normalized]`);
            let container = null;
            
            // Find the similarity container in the currently visible layout
            containers.forEach(cont => {
                if (cont.querySelector('.similarity-scores-container')) {
                    // Check if this container is in a visible layout
                    const mobileLayout = cont.closest('#mobile-main-container');
                    const desktopLayout = cont.closest('.tablet\\:block');
                    
                    if (mobileLayout && getComputedStyle(mobileLayout).display !== 'none') {
                        container = cont;
                    } else if (desktopLayout && getComputedStyle(desktopLayout).display !== 'none') {
                        container = cont;
                    }
                }
            });
            
            if (!container) return;
            
            const scoresContainer = container.querySelector('.similarity-scores-container');
            const showOtherButton = container.querySelector('.show-other-topics-container');
            
            // Remove all existing topic rows
            scoresContainer.innerHTML = '';
            
            // Regenerate visible topic rows
            const paper = currentPagePapers.find(p => p.id === paperId);
            if (paper) {
                scoresContainer.innerHTML = generateSimilarityTopicRows(paper);
                setupProgressBarsForPaper(paper);
                
                // Update normalized scores if needed
                if (container.getAttribute('data-normalized') === 'true') {
                    updateNormalizedScores(paperId);
                }
            }
            
            // Show/hide the "Show Other Topics" button
            if (getHiddenTopicsCount() > 0) {
                if (showOtherButton) {
                    showOtherButton.style.display = 'block';
                }
            } else {
                if (showOtherButton) {
                    showOtherButton.style.display = 'none';
                }
            }
            
            // Reset the hidden topics state
            container.setAttribute('data-show-hidden-topics', 'false');
            
            // Reset button text if it exists
            const button = showOtherButton?.querySelector('button');
            if (button) {
                button.innerHTML = 'Show Other Topics <span class="text-xs">▼</span>';
            }
        }
        
        function updateRelevanceModuleTopics(paperId) {
            // Find all relevance containers for this paper
            const containers = document.querySelectorAll(`[data-paper-id="${paperId}"][data-show-hidden-topics]`);
            
            containers.forEach(container => {
                const scoresContainer = container.querySelector('.relevance-scores-container');
                if (!scoresContainer) return; // Skip if this is not a relevance container
                
                const showOtherButton = container.querySelector('.show-other-topics-container');
                const justificationContainer = container.querySelector('.relevance-justification-section .justification-text');
                
                // Remove all existing topic rows
                scoresContainer.innerHTML = '';
                
                // Regenerate visible topic rows
                const paper = currentPagePapers.find(p => p.id === paperId);
                if (paper) {
                    scoresContainer.innerHTML = generateRelevanceTopicRows(paper);
                    
                    // Update justification content based on current visibility state
                    if (justificationContainer) {
                        const isShowingHidden = container.getAttribute('data-show-hidden-topics') === 'true';
                        justificationContainer.innerHTML = generateRelevanceJustificationContent(paper, isShowingHidden);
                    }
                }
                
                // Show/hide the "Show Other Topics" button
                if (getHiddenTopicsCount() > 0) {
                    if (showOtherButton) {
                        showOtherButton.style.display = 'block';
                    }
                } else {
                    if (showOtherButton) {
                        showOtherButton.style.display = 'none';
                    }
                }
                
                // Reset the hidden topics state
                container.setAttribute('data-show-hidden-topics', 'false');
                
                // Reset button text if it exists
                const button = showOtherButton?.querySelector('button');
                if (button) {
                    button.innerHTML = 'Show Other Topics <span class="text-xs">▼</span>';
                }
            });
        }
        
        function updateRelevanceJustificationVisibility(paperId) {
            // Find the justification container in the currently visible layout
            const containers = document.querySelectorAll(`.relevance-justification-section[data-paper-id="${paperId}"]`);
            let container = null;
            
            containers.forEach(cont => {
                // Check if this container is in a visible layout
                const mobileLayout = cont.closest('#mobile-main-container');
                const desktopLayout = cont.closest('.tablet\\:block');
                
                if (mobileLayout && getComputedStyle(mobileLayout).display !== 'none') {
                    container = cont;
                } else if (desktopLayout && getComputedStyle(desktopLayout).display !== 'none') {
                    container = cont;
                }
            });
            
            if (!container) return;
            
            const justificationDiv = container.querySelector('.justification-text');
            const isVisible = !justificationDiv.classList.contains('hidden');
            
            if (isVisible) {
                const paper = currentPagePapers.find(p => p.id === paperId);
                const relevanceContainer = container.closest('[data-show-hidden-topics]');
                const isShowingHidden = relevanceContainer && relevanceContainer.getAttribute('data-show-hidden-topics') === 'true';
                
                if (paper) {
                    if (isShowingHidden) {
                        // Show all justifications
                        justificationDiv.innerHTML = generateFullRelevanceJustificationContent(paper);
                    } else {
                        // Show only visible justifications
                        justificationDiv.innerHTML = generateRelevanceJustificationContent(paper);
                    }
                }
            }
        }
        
        function generateFullRelevanceJustificationContent(paper) {
            const allTopics = ['rlhf', 'weakSupervision', 'diffusionReasoning', 'distributedTraining', 'datasets'];
            const topicMapping = getTopicKeyMapping();
            const displayNames = getTopicDisplayNames();
            
            let html = '';
            
            allTopics.forEach(topic => {
                const dataKey = topicMapping[topic];
                const displayName = displayNames[topic];
                const justification = paper[`${dataKey}_justification`];
                const isVisible = currentTopicFilters[topic];
                
                html += `
                    <div class="justification-topic-section ${isVisible ? 'visible-justification' : 'hidden-justification'}" data-topic="${topic}">
                        <div class="font-heading font-bold">${displayName}:</div>
                        <div>${getJustificationText(justification)}</div>
                    </div>
                `;
            });
            
            return html;
        }
        
        function setupProgressBarsForPaper(paper) {
            const topics = ['rlhf', 'weak_supervision', 'diffusion_reasoning', 'distributed_training', 'datasets'];
            
            topics.forEach(topic => {
                const progressBars = document.querySelectorAll(
                    `.similarity-progress-bar[data-paper-id="${paper.id}"][data-topic="${topic}"]`
                );
                
                progressBars.forEach(progressBar => {
                    const score = paper[`${topic}_score`];
                    const percentage = (score * 100);
                    progressBar.style.width = `${percentage}%`;
                });
            });
        }
        
        function updateNormalizedScores(paperId) {
            // Find the normalized similarity container in the currently visible layout
            const containers = document.querySelectorAll(`[data-paper-id="${paperId}"][data-normalized="true"]`);
            let container = null;
            
            containers.forEach(cont => {
                // Check if this container is in a visible layout
                const mobileLayout = cont.closest('#mobile-main-container');
                const desktopLayout = cont.closest('.tablet\\:block');
                
                if (mobileLayout && getComputedStyle(mobileLayout).display !== 'none') {
                    container = cont;
                } else if (desktopLayout && getComputedStyle(desktopLayout).display !== 'none') {
                    container = cont;
                }
            });
            
            if (!container) return;
            
            const paper = currentPagePapers.find(p => p.id === paperId);
            if (!paper) return;
            
            const isShowingHidden = container.getAttribute('data-show-hidden-topics') === 'true';
            const topicsToCalculate = isShowingHidden ? 
                ['rlhf', 'weakSupervision', 'diffusionReasoning', 'distributedTraining', 'datasets'] :
                getVisibleTopics();
                
            const topicMapping = getTopicKeyMapping();
            
            // Calculate total score for normalization
            const totalScore = topicsToCalculate.reduce((sum, topic) => {
                const dataKey = topicMapping[topic];
                return sum + paper[`${dataKey}_score`];
            }, 0);
            
            // Update each visible topic
            topicsToCalculate.forEach(topic => {
                const dataKey = topicMapping[topic];
                const rawScore = paper[`${dataKey}_score`];
                const normalizedScore = (rawScore / totalScore) * 100;
                
                // Update progress bar
                const progressBar = container.querySelector(`.${dataKey.replace('_', '-')}-progress-bar`);
                if (progressBar) {
                    progressBar.style.width = `${normalizedScore}%`;
                }
                
                // Update score text
                const scoreElement = container.querySelector(`.${dataKey.replace('_', '-')}-similarity-score`);
                if (scoreElement) {
                    const sigFigScore = normalizedScore.toPrecision(3);
                    scoreElement.textContent = `${sigFigScore}%`;
                }
            });
        }

        // ============================================================================
        // PAPER CARD CREATION FUNCTIONS
        // ============================================================================
        function createPaperCard(paper, paperNumber) {
            const cardId = `paper-${paperNumber}`;
            
            return `
                <article class="bg-neutral-200" role="article" aria-labelledby="${cardId}">
                    <!-- Title Section -->
                    <div class="p-md">
                        <h2 id="${cardId}" class="text-neutral-70 font-heading font-bold text-2xl">
                            <span class="mr-sm">${paperNumber}.</span><a href="${paper.pdf_url}" 
                               class="paper-title-link" 
                               target="_blank" 
                               rel="noopener noreferrer"
                               aria-label="View paper PDF">${paper.title}</a>
                        </h2>
                    </div>
                    
                    <!-- Paper Info Section -->
                    <div class="grid grid-cols-1 gap-lg pb-xl px-xl">
                        <!-- Row 1: Metadata Module -->
                        <div class="flex flex-col gap-xs">
                            <!-- First row: arXiv ID and Publication Date -->
                            <div class="flex gap-xs">
                                <span class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y">
                                    arXiv ID: <a href="${paper.arxiv_url}" target="_blank" rel="noopener noreferrer" class="text-neutral-10 underline hover:no-underline">${paper.id}</a>
                                </span>
                                <span class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y">
                                    Published: ${formatPublicationDate(paper.published_date)}
                                </span>
                            </div>
                            
                            <!-- Second row: Authors -->
                            <div>
                                <span class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y metadata-tag">
                                    Authors: ${paper.h_index_status === 'completed' && paper.author_h_indexes && paper.author_h_indexes.length > 0 
                                        ? paper.author_h_indexes.map(author => 
                                            author.profile_url && author.profile_url !== null && author.profile_url !== '' 
                                                ? `<a href="${author.profile_url}" target="_blank" rel="noopener noreferrer" class="text-neutral-10 underline hover:no-underline">${author.name}</a>`
                                                : author.name
                                        ).join(', ')
                                        : paper.authors.join(', ')
                                    }
                                </span>
                            </div>
                            
                            <!-- Third row: Categories -->
                            <div>
                                <span class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y metadata-tag">
                                    Categories: ${paper.categories.join(', ')}
                                </span>
                            </div>
                        </div>
                        
                        <!-- Row 2: AI Generated Summary Module -->
                        ${paper.summary && paper.summary.trim() ? `
                        <div class="bg-neutral-300 p-lg">
                            <div class="flex flex-col gap-xs">
                                <h3 class="text-neutral-70 font-heading font-bold text-lg">AI-generated summary</h3>
                                <p class="text-neutral-70 font-body text-md">${paper.summary}</p>
                            </div>
                        </div>
                        ` : ''}
                        
                        <!-- Row 3: Abstract Module -->
                        <div class="bg-neutral-300 p-lg">
                            <div class="flex flex-col gap-xs">
                                <h3 class="text-neutral-70 font-heading font-bold text-lg">Abstract</h3>
                                <div class="abstract-container" data-paper-id="${paper.id}">
                                    <p class="abstract-text text-neutral-70 font-body text-md" 
                                       style="line-height: calc(1.5em);">${paper.abstract}</p>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Row 4: Score Row Section -->
                        ${paper.llm_score_status !== 'not_relevant_enough' ? `
                        <div class="flex flex-col tablet:flex-row gap-lg items-start">
                            <!-- Recommendation Score Module -->
                            <div class="bg-neutral-300 p-lg flex-1 w-full">
                                <div class="flex flex-col gap-xs">
                                    <!-- Score Section -->
                                    <div class="flex">
                                        <span class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y text-center">
                                            Recommendation:
                                        </span>
                                        <span class="text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y text-center ${getScoreColor('recommendation', paper.recommendation_score)}">
                                            ${paper.recommendation_score}
                                        </span>
                                    </div>
                                    
                                    <!-- Justification Section -->
                                    <div class="w-full recommendation-justification-section" data-paper-id="${paper.id}">
                                        <button class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y w-full text-left cursor-pointer border-none transition-opacity duration-200" 
                                                onclick="toggleRecommendationJustification('${paper.id}')">
                                            Show Justification <span class="text-xs">▲</span>
                                        </button>
                                        <div class="justification-text hidden text-neutral-20 font-body text-md px-tag-x py-tag-y bg-neutral-500 transition-all duration-300 ease-in-out">
                                            ${paper.recommendation_justification}
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Novelty Score Module -->
                            <div class="bg-neutral-300 p-lg flex-1 w-full">
                                <div class="flex flex-col gap-xs">
                                    <!-- Score Section -->
                                    <div class="flex">
                                        <span class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y text-center">
                                            Novelty:
                                        </span>
                                        <span class="text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y text-center ${getScoreColor('novelty', paper.novelty_score)}">
                                            ${paper.novelty_score}
                                        </span>
                                    </div>
                                    
                                    <!-- Justification Section -->
                                    <div class="w-full novelty-justification-section" data-paper-id="${paper.id}">
                                        <button class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y w-full text-left cursor-pointer border-none transition-opacity duration-200" 
                                                onclick="toggleNoveltyJustification('${paper.id}')">
                                            Show Justification <span class="text-xs">▲</span>
                                        </button>
                                        <div class="justification-text hidden text-neutral-20 font-body text-md px-tag-x py-tag-y bg-neutral-500 transition-all duration-300 ease-in-out">
                                            ${paper.novelty_justification}
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Potential Impact Score Module -->
                            <div class="bg-neutral-300 p-lg flex-1 w-full">
                                <div class="flex flex-col gap-xs">
                                    <!-- Score Section -->
                                    <div class="flex">
                                        <span class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y text-center">
                                            Potential Impact:
                                        </span>
                                        <span class="text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y text-center ${getScoreColor('impact', paper.impact_score)}">
                                            ${paper.impact_score}
                                        </span>
                                    </div>
                                    
                                    <!-- Justification Section -->
                                    <div class="w-full impact-justification-section" data-paper-id="${paper.id}">
                                        <button class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y w-full text-left cursor-pointer border-none transition-opacity duration-200" 
                                                onclick="toggleImpactJustification('${paper.id}')">
                                            Show Justification <span class="text-xs">▲</span>
                                        </button>
                                        <div class="justification-text hidden text-neutral-20 font-body text-md px-tag-x py-tag-y bg-neutral-500 transition-all duration-300 ease-in-out">
                                            ${paper.impact_justification}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        ` : ''}
                        
                        <!-- Row 5: Similarity, Relevance, H-index Section -->
                        <div class="flex flex-col tablet:flex-row gap-lg items-start">
                            <!-- Similarity Scores Module -->
                            <div class="bg-neutral-300 p-lg flex-1 w-full" data-paper-id="${paper.id}" data-normalized="false" data-show-hidden-topics="false">
                                <div class="flex flex-col gap-xs">
                                    <!-- Title Section -->
                                    <div class="text-center py-tag-y">
                                        <h3 class="text-neutral-70 font-heading font-bold text-xl">Similarity Scores</h3>
                                    </div>
                                    
                                    <!-- Scores Section -->
                                    <div class="flex flex-col gap-xs similarity-scores-container">
                                        ${generateSimilarityTopicRows(paper)}
                                    </div>
                                    
                                    <!-- Show Other Topics Button (conditionally shown) -->
                                    <div class="show-other-topics-container" ${getHiddenTopicsCount() > 0 ? '' : 'style="display: none;"'}>
                                        <button class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md py-tag-y mt-md w-full text-center hover:bg-neutral-600" onclick="toggleSimilarityHiddenTopics('${paper.id}')">
                                            Show Other Topics <span class="text-xs">▼</span>
                                        </button>
                                    </div>
                                    
                                    <!-- Hidden Topics Container (appears after button when toggled) -->
                                    <div class="hidden-topics-container" style="display: none;"></div>
                                    
                                    <!-- Button Section -->
                                    <div>
                                        <button class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md py-tag-y mt-md w-full text-center" onclick="toggleSimilarityScores(this)">
                                            Show Normalized Scores ⇄
                                        </button>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Relevance Module -->
                            <div class="bg-neutral-300 p-lg flex-1 w-full" data-paper-id="${paper.id}" data-show-hidden-topics="false">
                                <div class="flex flex-col gap-xs">
                                    <!-- Title Section -->
                                    <div class="text-center py-tag-y">
                                        <h3 class="text-neutral-70 font-heading font-bold text-xl">Topic Relevance</h3>
                                    </div>
                                    
                                    <!-- Scores Section -->
                                    <div class="flex flex-col gap-xs relevance-scores-container">
                                        ${generateRelevanceTopicRows(paper)}
                                    </div>
                                    
                                    <!-- Show Other Topics Button (conditionally shown) -->
                                    <div class="show-other-topics-container" ${getHiddenTopicsCount() > 0 ? '' : 'style="display: none;"'}>
                                        <button class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md py-tag-y mt-md w-full text-center hover:bg-neutral-600" onclick="toggleRelevanceHiddenTopics('${paper.id}')">
                                            Show Other Topics <span class="text-xs">▼</span>
                                        </button>
                                    </div>
                                    
                                    <!-- Hidden Topics Container (appears after button when toggled) -->
                                    <div class="hidden-topics-container" style="display: none;"></div>
                                    
                                    <!-- Justification Section -->
                                    <div class="w-full relevance-justification-section" data-paper-id="${paper.id}">
                                        <button class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y mt-md w-full text-center cursor-pointer border-none transition-opacity duration-200" 
                                                onclick="toggleRelevanceJustification('${paper.id}')">
                                            Show Justification <span class="text-xs">▲</span>
                                        </button>
                                        <div class="justification-text hidden text-neutral-20 font-mono text-md px-tag-x py-tag-y bg-neutral-500 transition-all duration-300 ease-in-out flex flex-col gap-sm">
                                            ${generateRelevanceJustificationContent(paper)}
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Author H-Index Module -->
                            <div class="bg-neutral-300 p-lg flex-1 w-full">
                                <div class="flex flex-col gap-md">
                                    <!-- Title Section -->
                                    <div class="text-center py-tag-y">
                                        <h3 class="text-neutral-70 font-heading font-bold text-xl">Author H-Index</h3>
                                    </div>
                                    
                                    ${paper.h_index_status === 'not_fetched' || paper.h_index_status === 'failed' ? `
                                        <!-- No Data Available Section -->
                                        <div class="text-center pt-lg pb-sm">
                                            <p class="text-neutral-60 font-heading font-bold text-lg">No H-Index data available</p>
                                        </div>
                                    ` : `
                                        <!-- H-Index Info Section -->
                                        <div class="flex flex-col gap-sm">
                                            <!-- Authors Found Row -->
                                            <div class="flex justify-between items-center">
                                                <span class="text-neutral-60 font-heading font-bold text-xl px-tag-x py-tag-y">Authors found:</span>
                                                <span class="text-neutral-60 font-heading font-bold text-xl px-tag-x py-tag-y">${paper.authors_found}/${paper.total_authors}</span>
                                            </div>
                                            
                                            <!-- Highest H-Index Row -->
                                            <div class="flex justify-between items-center">
                                                <span class="text-neutral-60 font-heading font-bold text-xl px-tag-x py-tag-y">Highest H-Index:</span>
                                                <span class="text-neutral-60 font-heading font-bold text-xl px-tag-x py-tag-y">${paper.highest_h_index || 'N/A'}</span>
                                            </div>
                                            
                                            <!-- Average H-Index Row -->
                                            <div class="flex justify-between items-center">
                                                <span class="text-neutral-60 font-heading font-bold text-xl px-tag-x py-tag-y">Average H-Index:</span>
                                                <span class="text-neutral-60 font-heading font-bold text-xl px-tag-x py-tag-y">${paper.average_h_index ? paper.average_h_index.toFixed(1) : 'N/A'}</span>
                                            </div>
                                            
                                            <!-- Notable Authors Row -->
                                            <div class="flex justify-between items-center">
                                                <span class="text-neutral-60 font-heading font-bold text-xl px-tag-x py-tag-y">Notable (H>5):</span>
                                                <span class="text-neutral-60 font-heading font-bold text-xl px-tag-x py-tag-y">${paper.notable_authors_count || 0}</span>
                                            </div>
                                        </div>
                                        
                                        <!-- Semantic Scholar Button -->
                                        <div>
                                            <button class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md py-tag-y mt-md w-full text-center" 
                                                    onclick="window.open('${paper.semantic_scholar_url}', '_blank')">
                                                Verify source on Semantic Scholar
                                            </button>
                                        </div>
                                        
                                        <!-- Individual H-Indices Section -->
                                        <div class="w-full author-h-index-section" data-paper-id="${paper.id}">
                                            <button class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y w-full text-center cursor-pointer border-none transition-opacity duration-200" 
                                                    onclick="toggleAuthorHIndices('${paper.id}')">
                                                Show Individual H-Indices <span class="text-xs">▼</span>
                                            </button>
                                            <div class="individual-authors-text hidden text-neutral-20 font-mono text-md px-xl py-tag-y bg-neutral-500 transition-all duration-300 ease-in-out">
                                                ${paper.author_h_indexes && paper.author_h_indexes.length > 0 ? 
                                                    paper.author_h_indexes.map(author => `
                                                        <div class="flex justify-between items-center py-xs">
                                                            ${author.profile_url && author.profile_url !== null && author.profile_url !== '' 
                                                                ? `<a href="${author.profile_url}" target="_blank" rel="noopener noreferrer" class="text-neutral-20 font-mono text-md underline hover:no-underline">${author.name}:</a>`
                                                                : `<span class="text-neutral-20 font-mono text-md">${author.name}:</span>`
                                                            }
                                                            <span class="text-neutral-20 font-mono text-md">${author.h_index !== null && author.h_index !== undefined ? author.h_index : 'N/A'}</span>
                                                        </div>
                                                    `).join('') 
                                                    : '<div class="text-center text-neutral-20">No individual author data available</div>'
                                                }
                                            </div>
                                        </div>
                                    `}
                                </div>
                            </div>
                        </div>
                    </div>
                </article>
            `;
        }

        // ============================================================================
        // QUICK FILTER FUNCTIONS
        // ============================================================================


        function applyQuickFilter(filterType) {
            // Build URL parameters based on filter type
            const url = new URL(window.location.href);
            
            // Clear all existing parameters
            url.search = '';
            
            // Set sort to recommendation best first for all filters
            url.searchParams.set('sort', 'recommend_best');
            
            switch(filterType) {
                case 'must-read':
                    // Recommendation: Only Must Read + Scoring: Only Has Scoring
                    url.searchParams.set('recommendation_must', 'true');
                    url.searchParams.set('recommendation_should', 'false');
                    url.searchParams.set('recommendation_skip', 'false');
                    url.searchParams.set('recommendation_ignore', 'false');
                    url.searchParams.set('scoring_has', 'true');
                    url.searchParams.set('scoring_no', 'false');
                    break;
                    
                case 'should-read':
                    // Recommendation: Only Should Read + Scoring: Only Has Scoring
                    url.searchParams.set('recommendation_must', 'false');
                    url.searchParams.set('recommendation_should', 'true');
                    url.searchParams.set('recommendation_skip', 'false');
                    url.searchParams.set('recommendation_ignore', 'false');
                    url.searchParams.set('scoring_has', 'true');
                    url.searchParams.set('scoring_no', 'false');
                    break;
                    
                case 'rlhf':
                    // Topic: Only RLHF + Relevance: Exclude Not Relevant
                    url.searchParams.set('topic_rlhf', 'true');
                    url.searchParams.set('topic_weak_supervision', 'false');
                    url.searchParams.set('topic_diffusion_reasoning', 'false');
                    url.searchParams.set('topic_distributed_training', 'false');
                    url.searchParams.set('topic_datasets', 'false');
                    url.searchParams.set('relevance_highly', 'true');
                    url.searchParams.set('relevance_moderately', 'true');
                    url.searchParams.set('relevance_tangentially', 'true');
                    url.searchParams.set('relevance_not', 'false');
                    break;
                    
                case 'weak-supervision':
                    url.searchParams.set('topic_rlhf', 'false');
                    url.searchParams.set('topic_weak_supervision', 'true');
                    url.searchParams.set('topic_diffusion_reasoning', 'false');
                    url.searchParams.set('topic_distributed_training', 'false');
                    url.searchParams.set('topic_datasets', 'false');
                    url.searchParams.set('relevance_highly', 'true');
                    url.searchParams.set('relevance_moderately', 'true');
                    url.searchParams.set('relevance_tangentially', 'true');
                    url.searchParams.set('relevance_not', 'false');
                    break;
                    
                case 'diffusion-reasoning':
                    url.searchParams.set('topic_rlhf', 'false');
                    url.searchParams.set('topic_weak_supervision', 'false');
                    url.searchParams.set('topic_diffusion_reasoning', 'true');
                    url.searchParams.set('topic_distributed_training', 'false');
                    url.searchParams.set('topic_datasets', 'false');
                    url.searchParams.set('relevance_highly', 'true');
                    url.searchParams.set('relevance_moderately', 'true');
                    url.searchParams.set('relevance_tangentially', 'true');
                    url.searchParams.set('relevance_not', 'false');
                    break;
                    
                case 'distributed-training':
                    url.searchParams.set('topic_rlhf', 'false');
                    url.searchParams.set('topic_weak_supervision', 'false');
                    url.searchParams.set('topic_diffusion_reasoning', 'false');
                    url.searchParams.set('topic_distributed_training', 'true');
                    url.searchParams.set('topic_datasets', 'false');
                    url.searchParams.set('relevance_highly', 'true');
                    url.searchParams.set('relevance_moderately', 'true');
                    url.searchParams.set('relevance_tangentially', 'true');
                    url.searchParams.set('relevance_not', 'false');
                    break;
                    
                case 'datasets':
                    url.searchParams.set('topic_rlhf', 'false');
                    url.searchParams.set('topic_weak_supervision', 'false');
                    url.searchParams.set('topic_diffusion_reasoning', 'false');
                    url.searchParams.set('topic_distributed_training', 'false');
                    url.searchParams.set('topic_datasets', 'true');
                    url.searchParams.set('relevance_highly', 'true');
                    url.searchParams.set('relevance_moderately', 'true');
                    url.searchParams.set('relevance_tangentially', 'true');
                    url.searchParams.set('relevance_not', 'false');
                    break;
                    
                case 'reset':
                    // Clear all parameters, which will reset everything to defaults
                    break;
                    
                default:
                    console.warn('Unknown quick filter type:', filterType);
                    return;
            }
            
            // Navigate to new URL, which will trigger existing URL parsing logic
            window.location.href = url.toString();
        }



        // ============================================================================
        // PAGE INITIALIZATION
        // ============================================================================

        function initializePage() {

            // Get sort parameter from URL, default to 'recommend_best'
            currentSort = getUrlParameter('sort') || 'recommend_best';
            
            // Load H-Index filters from URL
            updateHIndexFiltersFromURL();
            
            // Load Scoring filters from URL
            updateScoringFiltersFromURL();
            
            // Load Recommendation filters from URL
            updateRecommendationFiltersFromURL();
            
            // Load Novelty filters from URL
            updateNoveltyFiltersFromURL();
            
            // Load Impact filters from URL
            updateImpactFiltersFromURL();
            
            // Load Topic filters from URL
            updateTopicFiltersFromURL();
            
            // Load Relevance filters from URL
            loadRelevanceFiltersFromURL();
            
            // Update disabled state for advanced filters after loading scoring filters
            updateAdvancedFiltersDisabledState();
            
            // Update page title and headers based on embedded date
            updatePageTitles(PAGE_DATE);
            
            // Update sort dropdown UI
            updateSortDropdownUI();
            
            // Setup H-Index input validation
            setupHIndexValidation();
            
            // Sync H-Index UI with loaded filters
            syncHIndexUI();
            
            // Apply initial sorting and filtering
            applyFiltersAndSort();
            
            // Display first page
            displayCurrentPage();
            
        }

        // ============================================================================
        // ABSTRACT TRUNCATION LOGIC
        // ============================================================================
        
        let resizeTimer;

        function resetAbstractToOriginal(container) {
            const abstractText = container.querySelector('.abstract-text');
            const originalText = abstractText.getAttribute('data-original-text');
            
            if (originalText) {
                // Reset to clean original text
                abstractText.innerHTML = originalText;
                abstractText.setAttribute('data-expanded', 'false');
                // Clear any existing truncated text to force recalculation
                abstractText.removeAttribute('data-truncated-text');
            }
        }

        function calculateAverageCharWidth(fontStyle, fontSize, fontFamily) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            ctx.font = `${fontStyle} ${fontSize} ${fontFamily}`;
            
            const characterSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 ';
            const totalWidth = ctx.measureText(characterSet).width;
            
            return totalWidth / characterSet.length;
        }

        function getTextContentWidth(element) {
            const computedStyle = getComputedStyle(element);
            return element.clientWidth - 
                parseFloat(computedStyle.paddingLeft) - 
                parseFloat(computedStyle.paddingRight);
        }

        function calculateThreeLineCharLimit(element) {
            const computedStyle = getComputedStyle(element);
            const fontSize = computedStyle.fontSize;
            const fontFamily = computedStyle.fontFamily;
            const fontWeight = computedStyle.fontWeight;
            
            // Get average character width
            const avgCharWidth = calculateAverageCharWidth(fontWeight, fontSize, fontFamily);
            
            // Get content width
            const contentWidth = getTextContentWidth(element);
            
            // Calculate characters per line
            const charsPerLine = Math.floor(contentWidth / avgCharWidth);
            
            // Total characters for 3 lines
            const totalChars = charsPerLine * 3;
            
            // Reserve space for "... [Expand]"
            const expandButtonChars = 30;
            
            return Math.max(0, totalChars - expandButtonChars);
        }

        function toggleAbstract(paperId) {
            const containers = document.querySelectorAll(`.abstract-container[data-paper-id="${paperId}"]`);
            
            containers.forEach(container => {
                const abstractText = container.querySelector('.abstract-text');
                if (!abstractText) return; // Safety check
                
                const isExpanded = abstractText.getAttribute('data-expanded') === 'true';
                
                if (isExpanded) {
                    // Collapse - restore truncated text
                    const truncatedText = abstractText.getAttribute('data-truncated-text');
                    abstractText.innerHTML = truncatedText;
                    abstractText.setAttribute('data-expanded', 'false');
                } else {
                    // Expand - show full text
                    const originalText = abstractText.getAttribute('data-original-text');
                    abstractText.innerHTML = `${originalText} <button class="text-neutral-60 font-body font-bold text-md cursor-pointer bg-transparent border-none p-0 hover:opacity-70 transition-opacity duration-200" onclick="toggleAbstract('${paperId}')">[Collapse]</button>`;
                    abstractText.setAttribute('data-expanded', 'true');
                }
                
                // Re-render KaTeX after content change
                setTimeout(() => renderKatexInElement(abstractText), 50);
            });
        }

        // Function to setup abstract truncation using font metrics and binary search
        function setupAbstractTruncation() {
            document.querySelectorAll('.abstract-container').forEach(container => {
                const abstractText = container.querySelector('.abstract-text');
                const paperId = container.getAttribute('data-paper-id');
                
                // Get original text - only set it if not already stored to prevent corruption
                let originalText = abstractText.getAttribute('data-original-text');
                if (!originalText) {
                    // First time setup - get clean text content
                    originalText = abstractText.textContent;
                    abstractText.setAttribute('data-original-text', originalText);
                } else {
                    // Subsequent calls - reset to clean state first
                    resetAbstractToOriginal(container);
                }
                
                // Always reset to collapsed state
                abstractText.setAttribute('data-expanded', 'false');
                
                // Calculate the rough character limit for 3 lines as starting point
                const roughCharLimit = calculateThreeLineCharLimit(abstractText);
                
                // Check if text needs truncation
                if (originalText.length > roughCharLimit) {
                    // Create expand button template
                    const expandButton = '... <button class="text-neutral-60 font-body font-bold text-md cursor-pointer bg-transparent border-none p-0 hover:opacity-70 transition-opacity duration-200" onclick="toggleAbstract(\'' + paperId + '\')">[Expand]</button>';
                    
                    // Calculate 3-line height for comparison
                    const computedStyle = getComputedStyle(abstractText);
                    const lineHeight = parseFloat(computedStyle.lineHeight);
                    const maxHeight = lineHeight * 3;
                    
                    // Binary search for perfect truncation point
                    let left = 0;
                    let right = Math.min(originalText.length, roughCharLimit + 100); // Use rough estimate + buffer
                    let bestFit = '';
                    let bestLength = 0;
                    
                    // Create temporary element for height testing
                    const testElement = abstractText.cloneNode(true);
                    testElement.style.position = 'absolute';
                    testElement.style.visibility = 'hidden';
                    testElement.style.width = abstractText.offsetWidth + 'px';
                    testElement.style.height = 'auto';
                    testElement.style.maxHeight = 'none';
                    document.body.appendChild(testElement);
                    
                    while (left <= right) {
                        const mid = Math.floor((left + right) / 2);
                        const testText = originalText.substring(0, mid) + expandButton;
                        
                        testElement.innerHTML = testText;
                        
                        if (testElement.offsetHeight <= maxHeight) {
                            // Text fits, try longer
                            bestFit = testText;
                            bestLength = mid;
                            left = mid + 1;
                        } else {
                            // Text too long, trying shorter
                            right = mid - 1;
                        }
                    }
                    
                    // Clean up temporary element
                    document.body.removeChild(testElement);
                    
                    // Apply the best fit result
                    if (bestFit) {
                        abstractText.setAttribute('data-truncated-text', bestFit);
                        abstractText.innerHTML = bestFit;
                    } else {
                        // Fallback to rough estimate if binary search fails
                        const fallbackText = originalText.substring(0, Math.max(0, roughCharLimit - 50)) + expandButton;
                        abstractText.setAttribute('data-truncated-text', fallbackText);
                        abstractText.innerHTML = fallbackText;
                    }
                } else {
                    // Text fits without truncation
                    abstractText.innerHTML = originalText;
                }
            });
        }

        // Function to toggle recommendation justification
        function toggleRecommendationJustification(paperId) {
            const containers = document.querySelectorAll(`.recommendation-justification-section[data-paper-id="${paperId}"]`);
            
            containers.forEach(container => {
                const button = container.querySelector('button');
                const textDiv = container.querySelector('.justification-text');
                const isHidden = textDiv.classList.contains('hidden');
                
                if (isHidden) {
                    // Show justification
                    textDiv.classList.remove('hidden');
                    button.innerHTML = 'Hide Justification <span class="text-xs">▼</span>';
                    button.classList.remove('bg-neutral-500');
                    button.classList.add('bg-neutral-600');
                } else {
                    // Hide justification
                    textDiv.classList.add('hidden');
                    button.innerHTML = 'Show Justification <span class="text-xs">▲</span>';
                    button.classList.remove('bg-neutral-600');
                    button.classList.add('bg-neutral-500');
                }
            });
        }

        // Function to toggle novelty justification
        function toggleNoveltyJustification(paperId) {
            const containers = document.querySelectorAll(`.novelty-justification-section[data-paper-id="${paperId}"]`);
            
            containers.forEach(container => {
                const button = container.querySelector('button');
                const textDiv = container.querySelector('.justification-text');
                const isHidden = textDiv.classList.contains('hidden');
                
                if (isHidden) {
                    // Show justification
                    textDiv.classList.remove('hidden');
                    button.innerHTML = 'Hide Justification <span class="text-xs">▼</span>';
                    button.classList.remove('bg-neutral-500');
                    button.classList.add('bg-neutral-600');
                } else {
                    // Hide justification
                    textDiv.classList.add('hidden');
                    button.innerHTML = 'Show Justification <span class="text-xs">▲</span>';
                    button.classList.remove('bg-neutral-600');
                    button.classList.add('bg-neutral-500');
                }
            });
        }

        // Function to toggle impact justification
        function toggleImpactJustification(paperId) {
            const containers = document.querySelectorAll(`.impact-justification-section[data-paper-id="${paperId}"]`);
            
            containers.forEach(container => {
                const button = container.querySelector('button');
                const textDiv = container.querySelector('.justification-text');
                const isHidden = textDiv.classList.contains('hidden');
                
                if (isHidden) {
                    // Show justification
                    textDiv.classList.remove('hidden');
                    button.innerHTML = 'Hide Justification <span class="text-xs">▼</span>';
                    button.classList.remove('bg-neutral-500');
                    button.classList.add('bg-neutral-600');
                } else {
                    // Hide justification
                    textDiv.classList.add('hidden');
                    button.innerHTML = 'Show Justification <span class="text-xs">▲</span>';
                    button.classList.remove('bg-neutral-600');
                    button.classList.add('bg-neutral-500');
                }
            });
        }

        // Function to toggle relevance justification
        function toggleRelevanceJustification(paperId) {
            const containers = document.querySelectorAll(`.relevance-justification-section[data-paper-id="${paperId}"]`);
            
            containers.forEach(container => {
                const button = container.querySelector('button');
                const textDiv = container.querySelector('.justification-text');
                const isHidden = textDiv.classList.contains('hidden');
                
                if (isHidden) {
                    // Show justification
                    textDiv.classList.remove('hidden');
                    button.innerHTML = 'Hide Justification <span class="text-xs">▼</span>';
                    button.classList.remove('bg-neutral-500');
                    button.classList.add('bg-neutral-600');
                } else {
                    // Hide justification
                    textDiv.classList.add('hidden');
                    button.innerHTML = 'Show Justification <span class="text-xs">▲</span>';
                    button.classList.remove('bg-neutral-600');
                    button.classList.add('bg-neutral-500');
                }
            });
        }

        // Function to toggle author H-indices
        function toggleAuthorHIndices(paperId) {
            const containers = document.querySelectorAll(`.author-h-index-section[data-paper-id="${paperId}"]`);
            
            containers.forEach(container => {
                const button = container.querySelector('button');
                const textDiv = container.querySelector('.individual-authors-text');
                const isHidden = textDiv.classList.contains('hidden');
                
                if (isHidden) {
                    // Show individual H-indices
                    textDiv.classList.remove('hidden');
                    button.innerHTML = 'Hide Individual H-Indices <span class="text-xs">▲</span>';
                    button.classList.remove('bg-neutral-500');
                    button.classList.add('bg-neutral-600');
                } else {
                    // Hide individual H-indices
                    textDiv.classList.add('hidden');
                    button.innerHTML = 'Show Individual H-Indices <span class="text-xs">▼</span>';
                    button.classList.remove('bg-neutral-600');
                    button.classList.add('bg-neutral-500');
                }
            });
        }

        // Function to setup initial similarity progress bars (raw scores only)
        function setupInitialProgressBars() {
            currentPagePapers.forEach(paper => {
                setupProgressBarsForPaper(paper);
            });
        }

        // Function to toggle similarity scores between raw and normalized
        function toggleSimilarityScores(buttonElement) {
            // Find the parent container with data-paper-id
            const container = buttonElement.closest('[data-paper-id]');
            if (!container) return;
            
            const paperId = container.getAttribute('data-paper-id');
            const isNormalized = container.getAttribute('data-normalized') === 'true';
            
            // Find the paper data from current page papers
            const paper = currentPagePapers.find(p => p.id === paperId);
            if (!paper) return;
            
            // Toggle state
            container.setAttribute('data-normalized', (!isNormalized).toString());
            
            // Update button text
            buttonElement.textContent = isNormalized ? 'Show Normalized Scores ⇄' : 'Show Raw Scores ⇄';
            
            if (!isNormalized) {
                // Switch to normalized mode
                updateNormalizedScores(paperId);
                
                // Change all progress bars to normalized color
                const progressBars = container.querySelectorAll('.similarity-progress-bar');
                progressBars.forEach(bar => {
                    bar.classList.remove('bg-bar-raw');
                    bar.classList.add('bg-bar-normalized');
                });
            } else {
                // Switch to raw mode
                const isShowingHidden = container.getAttribute('data-show-hidden-topics') === 'true';
                const topicsToShow = isShowingHidden ? 
                    ['rlhf', 'weakSupervision', 'diffusionReasoning', 'distributedTraining', 'datasets'] :
                    getVisibleTopics();
                    
                const topicMapping = getTopicKeyMapping();
                
                topicsToShow.forEach(topic => {
                    const dataKey = topicMapping[topic];
                    const rawScore = paper[`${dataKey}_score`];
                    
                    // Update progress bar
                    const progressBar = container.querySelector(`.${dataKey.replace('_', '-')}-progress-bar`);
                    if (progressBar) {
                        progressBar.style.width = `${(rawScore * 100)}%`;
                        // Change to raw bar color
                        progressBar.classList.remove('bg-bar-normalized');
                        progressBar.classList.add('bg-bar-raw');
                    }
                    
                    // Update score text
                    const scoreElement = container.querySelector(`.${dataKey.replace('_', '-')}-similarity-score`);
                    if (scoreElement) {
                        scoreElement.textContent = rawScore.toFixed(3);
                    }
                });
            }
        }

        // Pagination functions
        function calculatePaginationWindow(currentPage, totalPages) {
            const windowSize = 5;
            const halfWindow = Math.floor(windowSize / 2);
            
            let start = Math.max(1, currentPage - halfWindow);
            let end = Math.min(totalPages, start + windowSize - 1);
            
            // Adjust start if we can't show a full window at the end
            if (end - start + 1 < windowSize) {
                start = Math.max(1, end - windowSize + 1);
            }
            
            return { start, end };
        }

        function updatePaginationUI() {
            const { start, end } = calculatePaginationWindow(currentPage, totalPages);
            
            // Update mobile pagination
            updatePaginationButtons('mobile', start, end);
            
            // Update desktop pagination
            updatePaginationButtons('desktop', start, end);
            
            // Update footer pagination
            updateFooterPaginationButtons('mobile', start, end);
            updateFooterPaginationButtons('desktop', start, end);
        }

        function updatePaginationButtons(layout, start, end) {
            const container = layout === 'mobile' 
                ? document.getElementById('mobile-pagination-numbers')
                : document.getElementById('desktop-pagination-numbers');
            
            if (!container) return;
            
            // Clear existing buttons
            container.innerHTML = '';
            
            // Create pagination buttons
            for (let i = start; i <= end; i++) {
                const isActive = i === currentPage;
                const buttonClass = isActive 
                    ? 'bg-neutral-900 text-neutral-10' 
                    : 'bg-neutral-300 text-neutral-70 hover:bg-neutral-400 cursor-pointer';
                
                const sizeClasses = layout === 'mobile' 
                    ? 'w-8 h-8' 
                    : 'clamp(1.5rem, 3vw, 1.875rem)';
                
                const button = document.createElement('div');
                button.className = `pagination-square ${buttonClass} flex items-center justify-center`;
                
                if (layout === 'desktop') {
                    button.style.width = sizeClasses;
                    button.style.height = sizeClasses;
                } else {
                    button.className += ` ${sizeClasses}`;
                }
                
                button.innerHTML = `<span class="font-heading font-bold text-${layout === 'mobile' ? 'sm' : 'md'}">${i}</span>`;
                
                if (!isActive) {
                    button.onclick = () => goToPage(i);
                    button.style.cursor = 'pointer';
                }
                
                container.appendChild(button);
            }
            
            // Update arrow button states
            updateArrowButtons(layout);
        }

        function updateFooterPaginationButtons(layout, start, end) {
            const container = layout === 'mobile' 
                ? document.getElementById('mobile-footer-pagination-numbers')
                : document.getElementById('desktop-footer-pagination-numbers');
            
            if (!container) return;
            
            // Clear existing buttons
            container.innerHTML = '';
            
            // Create pagination buttons
            for (let i = start; i <= end; i++) {
                const isActive = i === currentPage;
                const buttonClass = isActive 
                    ? 'bg-neutral-900 text-neutral-10' 
                    : 'bg-neutral-300 text-neutral-70 hover:bg-neutral-400 cursor-pointer';
                
                const sizeClasses = layout === 'mobile' 
                    ? 'w-8 h-8' 
                    : 'clamp(1.5rem, 3vw, 1.875rem)';
                
                const button = document.createElement('div');
                button.className = `pagination-square ${buttonClass} flex items-center justify-center`;
                
                if (layout === 'desktop') {
                    button.style.width = sizeClasses;
                    button.style.height = sizeClasses;
                } else {
                    button.className += ` ${sizeClasses}`;
                }
                
                button.innerHTML = `<span class="font-heading font-bold text-${layout === 'mobile' ? 'sm' : 'md'}">${i}</span>`;
                
                if (!isActive) {
                    button.onclick = () => goToPage(i);
                    button.style.cursor = 'pointer';
                }
                
                container.appendChild(button);
            }
            
            // Update footer arrow button states
            updateFooterArrowButtons(layout);
        }

        function updateArrowButtons(layout) {
            const prevBtn = document.getElementById(`${layout}-prev-btn`);
            const nextBtn = document.getElementById(`${layout}-next-btn`);
            
            // Update previous button
            if (prevBtn) {
                if (currentPage <= 1) {
                    // Show disabled state instead of hiding
                    prevBtn.classList.add('disabled');
                    prevBtn.onclick = null;
                } else {
                    // Show enabled state
                    prevBtn.classList.remove('disabled');
                    prevBtn.onclick = () => goToPage(currentPage - 1);
                }
            }
            
            // Update next button
            if (nextBtn) {
                if (currentPage >= totalPages) {
                    // Show disabled state instead of hiding
                    nextBtn.classList.add('disabled');
                    nextBtn.onclick = null;
                } else {
                    // Show enabled state
                    nextBtn.classList.remove('disabled');
                    nextBtn.onclick = () => goToPage(currentPage + 1);
                }
            }
        }

        function updateFooterArrowButtons(layout) {
            const prevBtn = document.getElementById(`${layout}-footer-prev-btn`);
            const nextBtn = document.getElementById(`${layout}-footer-next-btn`);
            
            // Update previous button
            if (prevBtn) {
                if (currentPage <= 1) {
                    // Show disabled state instead of hiding
                    prevBtn.classList.add('disabled');
                    prevBtn.onclick = null;
                } else {
                    // Show enabled state
                    prevBtn.classList.remove('disabled');
                    prevBtn.onclick = () => goToPage(currentPage - 1);
                }
            }
            
            // Update next button
            if (nextBtn) {
                if (currentPage >= totalPages) {
                    // Show disabled state instead of hiding
                    nextBtn.classList.add('disabled');
                    nextBtn.onclick = null;
                } else {
                    // Show enabled state
                    nextBtn.classList.remove('disabled');
                    nextBtn.onclick = () => goToPage(currentPage + 1);
                }
            }
        }

        function goToPage(page) {
            // Prevent navigation if page is out of bounds or is current page
            if (page === currentPage || page < 1 || page > totalPages) {
                return;
            }
            
            console.log(`Navigating to page ${page}`);
            currentPage = page;
            updatePaginationUI();
            displayCurrentPage();
            
            // Re-run truncation after new content is displayed
            setTimeout(() => {
                setupAbstractTruncation();
                setupInitialProgressBars();
            }, 50);
            
            // Scroll to top after loading new page
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // ============================================================================
        // SCROLL LOCK FUNCTIONS
        // ============================================================================
        
        function lockBodyScroll() {
            // Get the width of the scrollbar
            const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
            document.body.style.paddingRight = `${scrollbarWidth}px`;
            
            // Add the class to prevent scrolling
            document.body.classList.add('no-scroll');
        }

        function unlockBodyScroll() {
            // Remove the inline padding
            document.body.style.paddingRight = '';

            // Remove the class to re-enable scrolling
            document.body.classList.remove('no-scroll');
        }

        // ============================================================================
        // SIDEBAR FUNCTIONS
        // ============================================================================

        function toggleMobileMenu() {
            if (isMobileSidebarOpen) {
                closeMobileMenu();
            } else {
                openMobileMenu();
            }
        }

        function openMobileMenu() {
            const sidebar = document.getElementById('mobile-sidebar');
            const mainContainer = document.getElementById('mobile-main-container');
            
            // Move sidebar into view (full screen width)
            sidebar.style.transform = 'translateX(0)';
            
            // Lock body scrolling with padding compensation
            lockBodyScroll();
            
            isMobileSidebarOpen = true;
        }

        function closeMobileMenu() {
            const sidebar = document.getElementById('mobile-sidebar');
            const mainContainer = document.getElementById('mobile-main-container');
            
            // Move sidebar out of view
            sidebar.style.transform = 'translateX(-100%)';
            
            // Unlock body scrolling
            unlockBodyScroll();
            
            isMobileSidebarOpen = false;
        }

        function toggleDesktopMenu() {
            if (isDesktopSidebarOpen) {
                closeDesktopMenu();
            } else {
                openDesktopMenu();
            }
        }

        function openDesktopMenu() {
            const sidebar = document.getElementById('desktop-sidebar');
            const overlay = document.getElementById('desktop-sidebar-overlay');
            
            // Show sidebar
            sidebar.style.transform = 'translateX(0)';
            
            // Show overlay
            overlay.style.opacity = '1';
            overlay.style.pointerEvents = 'auto';
            
            // Lock body scrolling with padding compensation
            lockBodyScroll();
            
            isDesktopSidebarOpen = true;
        }

        function closeDesktopMenu() {
            const sidebar = document.getElementById('desktop-sidebar');
            const overlay = document.getElementById('desktop-sidebar-overlay');
            
            // Hide sidebar
            sidebar.style.transform = 'translateX(-100%)';
            
            // Hide overlay
            overlay.style.opacity = '0';
            overlay.style.pointerEvents = 'none';
            
            // Unlock body scrolling
            unlockBodyScroll();
            
            isDesktopSidebarOpen = false;
        }

        // Handle window resize to close mobile menu if switching to desktop
        window.addEventListener('resize', function() {
            if (window.innerWidth >= 768 && isMobileSidebarOpen) {
                closeMobileMenu();
            }
            if (window.innerWidth < 768 && isDesktopSidebarOpen) {
                closeDesktopMenu();
            }
        });

        // ============================================================================
        // CLICK OUTSIDE TO CLOSE DROPDOWNS
        // ============================================================================
        
        // Add click outside listener to close dropdowns
        document.addEventListener('click', function(event) {
            // List of all dropdown containers
            const dropdowns = [
                { dropdown: document.getElementById('mobile-sort-dropdown'), button: document.getElementById('mobile-sort-btn') },
                { dropdown: document.getElementById('desktop-sort-dropdown'), button: document.getElementById('desktop-sort-btn') },
                { dropdown: document.getElementById('mobile-hindex-dropdown'), button: document.getElementById('mobile-hindex-btn') },
                { dropdown: document.getElementById('desktop-hindex-dropdown'), button: document.getElementById('desktop-hindex-btn') },
                { dropdown: document.getElementById('mobile-scoring-dropdown'), button: document.getElementById('mobile-scoring-btn') },
                { dropdown: document.getElementById('desktop-scoring-dropdown'), button: document.getElementById('desktop-scoring-btn') },
                { dropdown: document.getElementById('mobile-recommendation-dropdown'), button: document.getElementById('mobile-recommendation-btn') },
                { dropdown: document.getElementById('desktop-recommendation-dropdown'), button: document.getElementById('desktop-recommendation-btn') },
                { dropdown: document.getElementById('mobile-novelty-dropdown'), button: document.getElementById('mobile-novelty-btn') },
                { dropdown: document.getElementById('desktop-novelty-dropdown'), button: document.getElementById('desktop-novelty-btn') },
                { dropdown: document.getElementById('mobile-impact-dropdown'), button: document.getElementById('mobile-impact-btn') },
                { dropdown: document.getElementById('desktop-impact-dropdown'), button: document.getElementById('desktop-impact-btn') },
                { dropdown: document.getElementById('mobile-relevance-dropdown'), button: document.getElementById('mobile-relevance-btn') },
                { dropdown: document.getElementById('desktop-relevance-dropdown'), button: document.getElementById('desktop-relevance-btn') },
                { dropdown: document.getElementById('mobile-topic-dropdown'), button: document.getElementById('mobile-topic-btn') },
                { dropdown: document.getElementById('desktop-topic-dropdown'), button: document.getElementById('desktop-topic-btn') }
            ];
            
            dropdowns.forEach(({ dropdown, button }) => {
                if (!dropdown || !button) return;
                
                // Check if dropdown is open and click is outside
                if (!dropdown.classList.contains('hidden')) {
                    const dropdownContainer = dropdown.parentElement; // The relative container
                    
                    // Check if click is outside the dropdown container
                    if (!dropdownContainer.contains(event.target)) {
                        dropdown.classList.add('hidden');
                        button.classList.remove('bg-neutral-600');
                        button.classList.add('bg-neutral-500');
                        
                        // Reset pending filters for specific dropdown types
                        if (dropdown.id.includes('hindex')) {
                            resetPendingHIndexFilters();
                        } else if (dropdown.id.includes('novelty')) {
                            resetPendingNoveltyFilters();
                        } else if (dropdown.id.includes('impact')) {
                            resetPendingImpactFilters();
                        } else if (dropdown.id.includes('relevance')) {
                            resetPendingRelevanceFilters();
                        } else if (dropdown.id.includes('topic')) {
                            resetPendingTopicFilters();
                        } else if (dropdown.id.includes('recommendation')) {
                            resetPendingRecommendationFilters();
                        } else if (dropdown.id.includes('scoring')) {
                            resetPendingScoringFilters();
                        }
                    }
                }
            });
        });

        // Initialize page on load
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Papers Dashboard loaded successfully');
            initializePage();
        });

        // Setup abstract truncation when everything is fully loaded
        window.addEventListener('load', function() {
            setupAbstractTruncation();
            setupInitialProgressBars();
        });

        // Setup debounced resize handler for truncation
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                setupAbstractTruncation();
            }, 250); // Delay to wait for resize to settle
        });
    </script>

    <!-- KaTeX JavaScript -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js" integrity="sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
    
    <!-- KaTeX Auto-render Configuration -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            // Configure KaTeX auto-render after page content is loaded
            setTimeout(function() {
                renderMathInElement(document.body, {
                    // KaTeX rendering options
                    delimiters: [
                        {left: '$$', right: '$$', display: true},       // Block math
                        {left: '$', right: '$', display: false},        // Inline math
                        {left: '\\(', right: '\\)', display: false},    // Inline math alternative
                        {left: '\\[', right: '\\]', display: true},     // Block math alternative
                        {left: '\\begin{equation}', right: '\\end{equation}', display: true},
                        {left: '\\begin{align}', right: '\\end{align}', display: true},
                        {left: '\\begin{alignat}', right: '\\end{alignat}', display: true},
                        {left: '\\begin{gather}', right: '\\end{gather}', display: true},
                        {left: '\\begin{CD}', right: '\\end{CD}', display: true},
                    ],
                    // Throw errors on unknown commands/symbols
                    throwOnError: false,
                    // Allow HTML in math expressions
                    trust: true,
                    // Ignore certain classes/elements
                    ignoredClasses: [
                        "nokatex", 
                        "katex-ignore"
                    ],
                    // Skip script and style tags
                    ignoredTags: [
                        "script", 
                        "noscript", 
                        "style", 
                        "textarea", 
                        "pre", 
                        "code"
                    ]
                });
            }, 500); // Delay to ensure all content is loaded
        });
    </script>
</body>
</html>
