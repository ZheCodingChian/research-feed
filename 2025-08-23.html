<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Research Feed -- 23 August 2025</title>
    
    <!-- Favicon and Apple Touch Icons -->
    <link rel="icon" type="image/png" href="/favicon.png">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <link rel="apple-touch-icon-precomposed" href="/apple-touch-icon-precomposed.png">
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;700&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- KaTeX CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous">
    
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Custom Tailwind Configuration -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        'heading': ['Space Grotesk', 'Inter', 'system-ui', 'sans-serif'],
                        'body': ['Space Mono', 'Fira Code', 'Consolas', 'monospace'],
                    },
                    
                    fontSize: {
                            // 4px increments with responsive scaling
                            'xs': 'clamp(0.5rem, 1vw, 0.625rem)',     // 8-10px
                            'sm': 'clamp(0.625rem, 1.2vw, 0.75rem)',  // 10-12px
                            'md': 'clamp(0.75rem, 1.4vw, 0.875rem)',  // 12-14px
                            'lg': 'clamp(0.875rem, 1.6vw, 1rem)',     // 14-16px
                            'xl': 'clamp(1rem, 1.8vw, 1.125rem)',     // 16-18px
                            '2xl': 'clamp(1.125rem, 2vw, 1.25rem)',   // 18-20px
                            '3xl': 'clamp(1.25rem, 2.2vw, 1.375rem)', // 20-22px
                            '4xl': 'clamp(1.375rem, 2.4vw, 1.5rem)',  // 22-24px
                            '5xl': 'clamp(1.5rem, 2.6vw, 1.625rem)',  // 24-26px
                            '6xl': 'clamp(1.625rem, 2.8vw, 1.75rem)', // 26-28px
                            '7xl': 'clamp(1.75rem, 3vw, 1.875rem)',   // 28-30px
                            '8xl': 'clamp(1.875rem, 3.2vw, 2rem)',    // 30-32px
                            '9xl': 'clamp(2rem, 3.4vw, 2.125rem)',    // 32-34px
                        },

                    colors: {
                        neutral: {
                            10: '#f5f2e7',
                            20: '#e5e5e5',
                            40: '#a3a3a3',
                            60: '#525252',
                            70: '#404040',
                            90: '#171717',
                            100: '#f5f2e7',
                            200: '#dad7cd',
                            300: '#bebcb3',
                            400: '#a2a199',
                            500: '#86857f',
                            600: '#6b6a65',
                            700: '#4f4e4b',
                            900: '#171717',
                        },
                        // Status colors with 70% opacity
                        status: {
                            green: 'rgba(22, 104, 52, 0.7)',     // #166834 with 70% opacity
                            blue: 'rgba(40, 100, 156, 0.7)',     // #28649C with 70% opacity
                            orange: 'rgba(234, 147, 0, 0.7)',    // #EA9300 with 70% opacity
                            red: 'rgba(129, 12, 12, 0.7)',       // #810C0C with 70% opacity
                        },
                        bar: {
                            raw: 'rgba(107, 106, 101, 0.7)',       // #6B6A65 with 70% opacity
                            normalized: 'rgba(107, 106, 101, 0.7)' // #6B6A65 with 70% opacity
                        }
                    },
                    
                    spacing: {
                        '2xs': 'clamp(0.125rem, 0.5vw, 0.25rem)', // 2-4px
                        'xs': 'clamp(0.25rem, 1vw, 0.5rem)',    // 4-8px
                        'sm': 'clamp(0.5rem, 1.5vw, 0.75rem)',  // 8-12px
                        'md': 'clamp(0.75rem, 2vw, 1rem)',      // 12-16px
                        'lg': 'clamp(1rem, 2.5vw, 1.5rem)',     // 16-24px
                        'xl': 'clamp(1.5rem, 3vw, 2rem)',       // 24-32px
                        '2xl': 'clamp(2rem, 4vw, 3rem)',        // 32-48px
                        '3xl': 'clamp(3rem, 6vw, 4rem)',        // 48-64px
                        '4xl': 'clamp(4rem, 8vw, 5rem)',        // 64-80px
                        '5xl': 'clamp(5rem, 10vw, 6rem)',       // 80-96px
                        '6xl': 'clamp(6rem, 12vw, 7rem)',       // 96-112px
                        
                        // Mobile-specific spacing
                        'mobile-header': '5px',                  // 5px for mobile header padding
                        
                        // Card-specific spacing
                        'card-gap': '20px',                      // 20px gap for card info grid
                        
                        // Tag-specific spacing
                        'tag-x': '8px',                          // 8px horizontal padding for tags
                        'tag-y': '4px',                          // 4px vertical padding for tags
                    },
                    
                    screens: {
                        'mobile': '480px',
                        'tablet': '768px',
                        'desktop': '1024px',
                        'wide': '1440px',
                    },
                }
            }
        }
    </script>
    
    <!-- Custom CSS for additional styles -->
    <style>
        /* Focus states */
        .nav-button:focus-visible {
            outline: 2px solid #86857f;
            outline-offset: 2px;
        }
        
        .pagination-square:focus-visible {
            outline: 2px solid #86857f;
            outline-offset: 2px;
        }
        
        .pagination-arrow:focus-visible {
            outline: 2px solid #86857f;
            outline-offset: 2px;
        }
        
        .pagination-arrow {
            transition: background-color 0.2s ease, opacity 0.2s ease;
        }
        
        .pagination-arrow.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .pagination-arrow.disabled:hover {
            background-color: transparent;
        }
        
        /* Fix for multiline text padding in author and category spans */
        .metadata-tag {
            box-decoration-break: clone;
            -webkit-box-decoration-break: clone;
        }
        
        /* Sidebar styling */
        #mobile-sidebar {
            backdrop-filter: blur(4px);
            /* Move scrollbar to left side */
            direction: rtl;
        }
        
        #mobile-sidebar > div {
            /* Reset text direction inside sidebar */
            direction: ltr;
        }
        
        #desktop-sidebar {
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            /* Move scrollbar to left side */
            direction: rtl;
        }
        
        #desktop-sidebar > div {
            /* Reset text direction inside sidebar */
            direction: ltr;
        }
        
        /* Mobile main container transition */
        #mobile-main-container {
            transition: transform 300ms ease-in-out;
        }
        
        /* Prevent scrolling when any sidebar is open */
        body.no-scroll {
            overflow: hidden;
        }
        
        /* Dropdown positioning */
        .dropdown-up {
            bottom: 100% !important;
            top: auto !important;
        }
        
        .dropdown-down {
            top: 100% !important;
            bottom: auto !important;
        }
        
        /* Mobile active states */
        @media (hover: none) {
            /* Remove button animation */
        }
        
        /* Font fallbacks */
        .font-mono {
            font-family: 'Space Mono', 'Fira Code', 'Consolas', monospace;
        }
        
        /* Paper title link styling */
        .paper-title-link {
            color: inherit;
            text-decoration: none;
            transition: text-decoration 0.2s ease;
        }
        
        .paper-title-link:hover {
            text-decoration: underline;
        }
        
        /* Abstract text styling */
        .abstract-text {
            transition: all 0.3s ease-in-out;
        }

        /* KaTeX styling customization */
        .katex {
            font-size: 1em !important;
            line-height: inherit !important;
        }
        
        /* Inline math styling */
        .katex-display {
            margin: 0.5em 0 !important;
            text-align: left !important;
        }
        
        /* Make KaTeX blend with our color scheme */
        .katex .base {
            color: inherit;
        }
        
        /* Ensure KaTeX math doesn't break responsive design */
        .katex-display > .katex {
            max-width: 100%;
            overflow-x: auto;
            overflow-y: hidden;
        }
        
        /* Prevent double tap to zoom on mobile - Global */
        * {
            touch-action: manipulation;
        }
        
        /* Prevent double tap to zoom on mobile - Specific elements (keeping for compatibility) */
        .button, .interactive-element {
            touch-action: manipulation;
        }
        
        /* Research Feed button hover effect */
        .research-feed-button:hover {
            background-color: #4f4e4b !important; /* bg-neutral-700 */
            color: #f5f2e7 !important; /* text-neutral-10 */
        }
        
        /* Custom checkbox styling */
        .custom-checkbox {
            position: relative;
            display: inline-flex;
            align-items: center;
        }
        
        .custom-checkbox input[type="checkbox"] {
            opacity: 0;
            position: absolute;
            width: 0;
            height: 0;
        }
        
        .custom-checkbox label {
            display: inline-block;
            width: 20px;
            height: 20px;
            background-color: #86857f; /* bg-neutral-500 */
            border: 2px solid #f5f2e7; /* border-neutral-100 */
            border-radius: 4px; /* rounded corners */
            cursor: pointer;
            transition: background-color 0.2s ease, border-color 0.2s ease;
            flex-shrink: 0;
        }
        
        .custom-checkbox input[type="checkbox"]:checked + label {
            background-color: #f5f2e7; /* bg-neutral-100 */
            border-color: #f5f2e7;
        }
        
        .custom-checkbox input[type="checkbox"]:checked + label::after {
            content: '';
            position: absolute;
            left: 6px;
            top: 2px;
            width: 6px;
            height: 10px;
            border: solid #86857f;
            border-width: 0 2px 2px 0;
            transform: rotate(45deg);
        }
        
        /* H-Index range section styling */
        .hindex-range-section {
            transition: opacity 0.2s ease;
        }
        
        .hindex-range-section.disabled {
            opacity: 0.5;
        }
        
        .hindex-range-section.disabled input {
            cursor: not-allowed !important;
        }
        
        .hindex-range-section.disabled input:hover {
            background-color: #6b6a65 !important; /* Keep original bg when disabled */
        }
        
        /* Override any Tailwind hover effects on disabled inputs */
        .hindex-range-section.disabled input.bg-neutral-600:hover {
            background-color: #6b6a65 !important;
        }
        
        /* Advanced filter dropdowns disabled state */
        .opacity-50 {
            opacity: 0.5 !important;
        }
        
        .cursor-not-allowed {
            cursor: not-allowed !important;
        }
    </style>
</head>

<body class="bg-neutral-100 min-h-screen">
    <!-- Mobile Layout (visible < 768px) -->
    <div class="flex flex-col tablet:hidden" id="mobile-main-container">
        <!-- Mobile Header -->
        <header class="bg-neutral-100 w-full flex items-center px-xs pt-xl pb-md relative">
            <!-- Menu Button - Positioned absolutely within header -->
            <button id="mobile-menu-btn" class="absolute top-1/4 left-xs transform -translate-y-1/2 z-10 nav-button w-12 h-12 bg-transparent flex items-center justify-center button" aria-label="Open Menu" onclick="toggleMobileMenu()">
                <svg width="24" height="18" viewBox="0 0 24 18" xmlns="http://www.w3.org/2000/svg">
                    <rect x="0" y="0" width="24" height="5" fill="#4F4E4B"/>
                    <rect x="0" y="6.5" width="24" height="5" fill="#4F4E4B"/>
                    <rect x="0" y="13" width="24" height="5" fill="#4F4E4B"/>
                </svg>
            </button>
            
            <!-- Center: Page info (full width since menu button is positioned absolutely) -->
            <div class="w-full flex flex-col items-center justify-center text-center">
                <h1 class="text-neutral-70 font-heading font-bold text-lg mb-md" id="page-title-mobile">
                    Papers Published on 23 August 2025
                </h1>
                
                <!-- Mobile Pagination -->
                <div class="flex items-center gap-sm mb-md">
                    <!-- Previous Arrow -->
                    <button id="mobile-prev-btn" class="pagination-arrow w-8 h-8 bg-transparent text-neutral-70 flex items-center justify-center hover:bg-neutral-300 cursor-pointer" onclick="goToPage(currentPage - 1)">
                        <span class="font-heading font-bold text-sm">‹</span>
                    </button>
                    
                    <!-- Page Numbers Container -->
                    <div class="flex gap-sm" id="mobile-pagination-numbers">
                        <!-- Page numbers will be populated by JavaScript -->
                    </div>
                    
                    <!-- Next Arrow -->
                    <button id="mobile-next-btn" class="pagination-arrow w-8 h-8 bg-transparent text-neutral-70 flex items-center justify-center hover:bg-neutral-300 cursor-pointer" onclick="goToPage(currentPage + 1)">
                        <span class="font-heading font-bold text-sm">›</span>
                    </button>
                </div>
                
                <!-- Mobile Paper Count -->
                <p id="mobile-main-paper-count" class="text-neutral-60 font-heading font-bold text-lg">
                    Showing 0 / 0 papers
                </p>
            </div>
        </header>
        
        <!-- Mobile Content Area -->
        <main class="bg-neutral-100 min-h-screen">
            <div class="max-w-[500px] mx-auto">
                <!-- Mobile Papers Grid -->
                <div class="flex flex-col gap-3xl" id="mobile-papers">
                    <!-- Paper cards will be populated by JavaScript -->
                </div>
            </div>
        </main>
        
        <!-- Mobile Footer -->
        <footer class="py-xl px-lg bg-neutral-200">
            <div class="flex flex-col items-center justify-center text-center">
                <!-- Mobile Footer Pagination -->
                <div class="flex items-center gap-sm">
                    <!-- Previous Arrow -->
                    <button id="mobile-footer-prev-btn" class="pagination-arrow w-8 h-8 bg-transparent text-neutral-70 flex items-center justify-center hover:bg-neutral-300 cursor-pointer" onclick="goToPage(currentPage - 1)">
                        <span class="font-heading font-bold text-sm">‹</span>
                    </button>
                    
                    <!-- Page Numbers Container -->
                    <div class="flex gap-sm" id="mobile-footer-pagination-numbers">
                        <!-- Page numbers will be populated by JavaScript -->
                    </div>
                    
                    <!-- Next Arrow -->
                    <button id="mobile-footer-next-btn" class="pagination-arrow w-8 h-8 bg-transparent text-neutral-70 flex items-center justify-center hover:bg-neutral-300 cursor-pointer" onclick="goToPage(currentPage + 1)">
                        <span class="font-heading font-bold text-sm">›</span>
                    </button>
                </div>
            </div>
        </footer>
    </div>
    
    <!-- Mobile Sidebar -->
    <div id="mobile-sidebar" class="fixed inset-y-0 left-0 z-50 tablet:hidden bg-neutral-100 transition-transform duration-300 ease-in-out overflow-y-auto" style="width: 100vw; transform: translateX(-100%);">
        <div class="w-full h-full flex flex-col">
            <!-- Mobile Sidebar Header -->
            <div class="flex items-center justify-between pt-lg pr-lg pb-sm pl-lg">
                <!-- Left: Research Feed Home Button -->
                <div>
                    <a href="index.html" class="research-feed-button text-center px-tag-x py-sm bg-neutral-600 transition-colors duration-200">
                        <span class="text-neutral-10 font-heading font-bold text-2xl">Research Feed</span>
                    </a>
                </div>
                
                <!-- Right: Menu Button -->
                <button id="mobile-close-btn" class="nav-button w-12 h-12 bg-transparent flex items-center justify-center button" aria-label="Close Menu" onclick="closeMobileMenu()">
                    <svg width="24" height="18" viewBox="0 0 24 18" xmlns="http://www.w3.org/2000/svg">
                        <rect x="0" y="0" width="24" height="5" fill="#4F4E4B"/>
                        <rect x="0" y="6.5" width="24" height="5" fill="#4F4E4B"/>
                        <rect x="0" y="13" width="24" height="5" fill="#4F4E4B"/>
                    </svg>
                </button>
            </div>
            
            <!-- Mobile Sidebar Content -->
            <div class="flex-1 pt-sm px-lg pb-6xl">
                <div class="flex flex-col gap-lg gap-lg">
                    <!-- Section 1: Paper Count -->
                    <div class="bg-transparent text-left">
                        <span class="text-neutral-70 font-heading font-bold text-2xl" id="mobile-paper-count">
                            Showing: 0/0 Papers
                        </span>
                    </div>
                    
                    <!-- Section 2: Quick Filters -->
                    <div class="flex flex-col gap-sm">
                        <h3 class="text-neutral-60 font-heading font-bold text-2xl text-left bg-transparent">Quick Filters</h3>
                        <button id="mobile-quick-must-read" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('must-read')">Must Read</button>
                        <button id="mobile-quick-should-read" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('should-read')">Should Read</button>
                        <button id="mobile-quick-rlhf" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('rlhf')">RLHF</button>
                        <button id="mobile-quick-weak-supervision" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('weak-supervision')">Weak Supervision</button>
                        <button id="mobile-quick-diffusion-reasoning" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('diffusion-reasoning')">Diffusion Reasoning</button>
                        <button id="mobile-quick-distributed-training" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('distributed-training')">Distributed Training</button>
                        <button id="mobile-quick-datasets" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('datasets')">Datasets</button>
                        <button id="mobile-quick-reset" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('reset')">Reset To Default</button>
                    </div>
                    
                    <!-- Section 3: Advanced Filters -->
                    <div class="flex flex-col gap-sm">
                        <h3 class="text-neutral-60 font-heading font-bold text-2xl text-left bg-transparent">Advanced Filters</h3>
                        <!-- Scoring Filter Dropdown -->
                        <div class="relative">
                            <button id="mobile-scoring-btn" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleMobileScoringDropdown()">
                                <span class="font-bold">Scoring:</span> <span class="font-normal">All Selected</span> <span class="text-base">▼</span>
                            </button>
                            <div id="mobile-scoring-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-md">
                                    <!-- Section 1: Has Scoring and Summary Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-scoring-has" checked>
                                            <label for="mobile-scoring-has"></label>
                                        </div>
                                        <label for="mobile-scoring-has" class="text-neutral-10 text-xl font-heading cursor-pointer">Completed</label>
                                    </div>
                                    
                                    <!-- Section 2: Does not have Scoring and Summary Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-scoring-no" checked>
                                            <label for="mobile-scoring-no"></label>
                                        </div>
                                        <label for="mobile-scoring-no" class="text-neutral-10 text-xl font-heading cursor-pointer">Not relevant enough</label>
                                    </div>
                                    
                                    <!-- Section 3: Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyScoringFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        <!-- Recommendation Filter Dropdown -->
                        <div class="relative">
                            <button id="mobile-recommendation-btn" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleMobileRecommendationDropdown()">
                                <span class="font-bold">Recommendation:</span> <span class="font-normal">All Selected</span> <span class="text-base">▼</span>
                            </button>
                            <div id="mobile-recommendation-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-md">
                                    <!-- Must Read Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-recommendation-must" checked>
                                            <label for="mobile-recommendation-must"></label>
                                        </div>
                                        <label for="mobile-recommendation-must" class="text-neutral-10 text-xl font-heading cursor-pointer">Must Read</label>
                                    </div>
                                    
                                    <!-- Should Read Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-recommendation-should" checked>
                                            <label for="mobile-recommendation-should"></label>
                                        </div>
                                        <label for="mobile-recommendation-should" class="text-neutral-10 text-xl font-heading cursor-pointer">Should Read</label>
                                    </div>
                                    
                                    <!-- Can Skip Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-recommendation-skip" checked>
                                            <label for="mobile-recommendation-skip"></label>
                                        </div>
                                        <label for="mobile-recommendation-skip" class="text-neutral-10 text-xl font-heading cursor-pointer">Can Skip</label>
                                    </div>
                                    
                                    <!-- Ignore Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-recommendation-ignore" checked>
                                            <label for="mobile-recommendation-ignore"></label>
                                        </div>
                                        <label for="mobile-recommendation-ignore" class="text-neutral-10 text-xl font-heading cursor-pointer">Ignore</label>
                                    </div>
                                    
                                    <!-- Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyRecommendationFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        <!-- Novelty Filter Dropdown -->
                        <div class="relative">
                            <button id="mobile-novelty-btn" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleMobileNoveltyDropdown()">
                                <span class="font-bold">Novelty:</span> <span class="font-normal">All Selected</span> <span class="text-base">▼</span>
                            </button>
                            <div id="mobile-novelty-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-md">
                                    <!-- High Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-novelty-high" checked>
                                            <label for="mobile-novelty-high"></label>
                                        </div>
                                        <label for="mobile-novelty-high" class="text-neutral-10 text-xl font-heading cursor-pointer">High</label>
                                    </div>
                                    
                                    <!-- Moderate Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-novelty-moderate" checked>
                                            <label for="mobile-novelty-moderate"></label>
                                        </div>
                                        <label for="mobile-novelty-moderate" class="text-neutral-10 text-xl font-heading cursor-pointer">Moderate</label>
                                    </div>
                                    
                                    <!-- Low Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-novelty-low" checked>
                                            <label for="mobile-novelty-low"></label>
                                        </div>
                                        <label for="mobile-novelty-low" class="text-neutral-10 text-xl font-heading cursor-pointer">Low</label>
                                    </div>
                                    
                                    <!-- None Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-novelty-none" checked>
                                            <label for="mobile-novelty-none"></label>
                                        </div>
                                        <label for="mobile-novelty-none" class="text-neutral-10 text-xl font-heading cursor-pointer">None</label>
                                    </div>
                                    
                                    <!-- Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyNoveltyFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        <!-- Potential Impact Filter Dropdown -->
                        <div class="relative">
                            <button id="mobile-impact-btn" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleMobileImpactDropdown()">
                                <span class="font-bold">Potential Impact:</span> <span class="font-normal">All Selected</span> <span class="text-base">▼</span>
                            </button>
                            <div id="mobile-impact-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-md">
                                    <!-- High Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-impact-high" checked>
                                            <label for="mobile-impact-high"></label>
                                        </div>
                                        <label for="mobile-impact-high" class="text-neutral-10 text-xl font-heading cursor-pointer">High</label>
                                    </div>
                                    
                                    <!-- Moderate Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-impact-moderate" checked>
                                            <label for="mobile-impact-moderate"></label>
                                        </div>
                                        <label for="mobile-impact-moderate" class="text-neutral-10 text-xl font-heading cursor-pointer">Moderate</label>
                                    </div>
                                    
                                    <!-- Low Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-impact-low" checked>
                                            <label for="mobile-impact-low"></label>
                                        </div>
                                        <label for="mobile-impact-low" class="text-neutral-10 text-lg font-heading cursor-pointer">Low</label>
                                    </div>
                                    
                                    <!-- Negligible Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-impact-negligible" checked>
                                            <label for="mobile-impact-negligible"></label>
                                        </div>
                                        <label for="mobile-impact-negligible" class="text-neutral-10 text-xl font-heading cursor-pointer">Negligible</label>
                                    </div>
                                    
                                    <!-- Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyImpactFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        <!-- Relevance Filter Dropdown -->
                        <div class="relative">
                            <button id="mobile-relevance-btn" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleMobileRelevanceDropdown()">
                                <span class="font-bold">Relevance:</span> <span class="font-normal">All Selected</span> <span class="text-base">▼</span>
                            </button>
                            <div id="mobile-relevance-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-md">
                                    <!-- Highly Relevant Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-relevance-highly" checked>
                                            <label for="mobile-relevance-highly"></label>
                                        </div>
                                        <label for="mobile-relevance-highly" class="text-neutral-10 text-xl font-heading cursor-pointer">Highly Relevant</label>
                                    </div>
                                    
                                    <!-- Moderately Relevant Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-relevance-moderately" checked>
                                            <label for="mobile-relevance-moderately"></label>
                                        </div>
                                        <label for="mobile-relevance-moderately" class="text-neutral-10 text-xl font-heading cursor-pointer">Moderately Relevant</label>
                                    </div>
                                    
                                    <!-- Tangentially Relevant Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-relevance-tangentially" checked>
                                            <label for="mobile-relevance-tangentially"></label>
                                        </div>
                                        <label for="mobile-relevance-tangentially" class="text-neutral-10 text-xl font-heading cursor-pointer">Tangentially Relevant</label>
                                    </div>
                                    
                                    <!-- Not Relevant Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-relevance-not" checked>
                                            <label for="mobile-relevance-not"></label>
                                        </div>
                                        <label for="mobile-relevance-not" class="text-neutral-10 text-xl font-heading cursor-pointer">Not Relevant</label>
                                    </div>
                                    
                                    <!-- Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyRelevanceFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Topic Filter Dropdown -->
                        <div class="relative">
                            <button id="mobile-topic-btn" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleMobileTopicDropdown()">
                                <span class="font-bold">Topics:</span> <span class="font-normal">All Selected</span> <span class="text-base">▼</span>
                            </button>
                            <div id="mobile-topic-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-md">
                                    <!-- RLHF Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-topic-rlhf" checked>
                                            <label for="mobile-topic-rlhf"></label>
                                        </div>
                                        <label for="mobile-topic-rlhf" class="text-neutral-10 text-xl font-heading cursor-pointer">RLHF</label>
                                    </div>
                                    
                                    <!-- Weak Supervision Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-topic-weak-supervision" checked>
                                            <label for="mobile-topic-weak-supervision"></label>
                                        </div>
                                        <label for="mobile-topic-weak-supervision" class="text-neutral-10 text-xl font-heading cursor-pointer">Weak Supervision</label>
                                    </div>
                                    
                                    <!-- Diffusion Reasoning Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-topic-diffusion-reasoning" checked>
                                            <label for="mobile-topic-diffusion-reasoning"></label>
                                        </div>
                                        <label for="mobile-topic-diffusion-reasoning" class="text-neutral-10 text-xl font-heading cursor-pointer">Diffusion Reasoning</label>
                                    </div>
                                    
                                    <!-- Distributed Training Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-topic-distributed-training" checked>
                                            <label for="mobile-topic-distributed-training"></label>
                                        </div>
                                        <label for="mobile-topic-distributed-training" class="text-neutral-10 text-xl font-heading cursor-pointer">Distributed Training</label>
                                    </div>
                                    
                                    <!-- Datasets Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-topic-datasets" checked>
                                            <label for="mobile-topic-datasets"></label>
                                        </div>
                                        <label for="mobile-topic-datasets" class="text-neutral-10 text-xl font-heading cursor-pointer">Datasets</label>
                                    </div>
                                    
                                    <!-- Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyTopicFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- H-Index Filter Dropdown -->
                        <div class="relative">
                            <button id="mobile-hindex-btn" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleMobileHIndexDropdown()">
                                H-index: All Selected <span class="text-lg">▼</span>
                            </button>
                            <div id="mobile-hindex-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-lg">
                                    <!-- Section 1: H-Index Found Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-hindex-found" checked onchange="toggleHIndexRanges()">
                                            <label for="mobile-hindex-found"></label>
                                        </div>
                                        <label for="mobile-hindex-found" class="text-neutral-10 text-xl font-heading cursor-pointer">H-Index Found</label>
                                    </div>
                                    
                                    <!-- Section 2: H-Index Not Found Checkbox -->
                                    <div class="flex items-center gap-md">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="mobile-hindex-not-found" checked>
                                            <label for="mobile-hindex-not-found"></label>
                                        </div>
                                        <label for="mobile-hindex-not-found" class="text-neutral-10 text-xl font-heading cursor-pointer">H-Index Not Found</label>
                                    </div>
                                    
                                    <!-- Section 3: Highest H-Index Range -->
                                    <div id="mobile-highest-range" class="hindex-range-section">
                                        <div class="text-neutral-10 text-lg font-heading mb-2xs">Highest H-Index Range:</div>
                                        <div class="flex items-center gap-xs">
                                            <span class="text-neutral-10 text-lg font-heading">Min:</span>
                                            <input type="number" id="mobile-highest-min" min="0" max="1000" value="0" class="bg-neutral-600 text-neutral-10 px-2xs py-2xs text-lg font-heading w-16 rounded">
                                            <span class="text-neutral-10 text-lg font-heading">-</span>
                                            <span class="text-neutral-10 text-lg font-heading">Max:</span>
                                            <input type="number" id="mobile-highest-max" min="0" max="1000" value="1000" class="bg-neutral-600 text-neutral-10 px-2xs py-2xs text-lg font-heading w-16 rounded">
                                        </div>
                                    </div>
                                    
                                    <!-- Section 4: Average H-Index Range -->
                                    <div id="mobile-average-range" class="hindex-range-section">
                                        <div class="text-neutral-10 text-lg font-heading mb-2xs">Average H-Index Range:</div>
                                        <div class="flex items-center gap-xs">
                                            <span class="text-neutral-10 text-lg font-heading">Min:</span>
                                            <input type="number" id="mobile-average-min" min="0" max="1000" value="0" class="bg-neutral-600 text-neutral-10 px-2xs py-2xs text-lg font-heading w-16 rounded">
                                            <span class="text-neutral-10 text-lg font-heading">-</span>
                                            <span class="text-neutral-10 text-lg font-heading">Max:</span>
                                            <input type="number" id="mobile-average-max" min="0" max="1000" value="1000" class="bg-neutral-600 text-neutral-10 px-2xs py-2xs text-lg font-heading w-16 rounded">
                                        </div>
                                    </div>
                                    
                                    <!-- Section 5: Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyHIndexFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Sort By Dropdown -->
                        <div class="relative">
                            <button id="mobile-sort-btn" class="w-full py-tag-y font-heading font-bold text-xl text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleMobileSortDropdown()">
                                <span class="font-bold">Sort By:</span> <span id="mobile-sort-text" class="font-normal">Recommendation (Best First)</span> <span class="text-base">▼</span>
                            </button>
                            <div id="mobile-sort-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 py-xs">
                                <div class="flex flex-col gap-xs">
                                    <button class="w-full py-tag-y font-heading text-xl text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('recommend_best')">Recommendation (Best First)</button>
                                    <button class="w-full py-tag-y font-heading text-xl text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('recommend_worst')">Recommendation (Worst First)</button>
                                    <button class="w-full py-tag-y font-heading text-xl text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('relevance_high')">Relevance (Highest to Lowest)</button>
                                    <button class="w-full py-tag-y font-heading text-xl text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('relevance_low')">Relevance (Lowest to Highest)</button>
                                    <button class="w-full py-tag-y font-heading text-xl text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('highest_hindex_asc')">Highest H-Index (Ascending)</button>
                                    <button class="w-full py-tag-y font-heading text-xl text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('highest_hindex_desc')">Highest H-Index (Descending)</button>
                                    <button class="w-full py-tag-y font-heading text-xl text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('average_hindex_asc')">Average H-Index (Ascending)</button>
                                    <button class="w-full py-tag-y font-heading text-xl text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('average_hindex_desc')">Average H-Index (Descending)</button>
                                    <button class="w-full py-tag-y font-heading text-xl text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('id_asc')">arXiv ID (Ascending)</button>
                                    <button class="w-full py-tag-y font-heading text-xl text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('id_desc')">arXiv ID (Descending)</button>
                                    <button class="w-full py-tag-y font-heading text-xl text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('title_az')">Title (A-Z)</button>
                                    <button class="w-full py-tag-y font-heading text-xl text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('title_za')">Title (Z-A)</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Desktop Sidebar Overlay -->
    <div id="desktop-sidebar-overlay" class="hidden tablet:block fixed inset-0 bg-black bg-opacity-50 z-30 opacity-0 pointer-events-none transition-opacity duration-300 ease-in-out" onclick="closeDesktopMenu()"></div>
    
    <!-- Desktop Sidebar -->
    <div id="desktop-sidebar" class="hidden tablet:block fixed inset-y-0 left-0 z-40 bg-neutral-200 transition-transform duration-300 ease-in-out overflow-y-auto" style="width: 500px; transform: translateX(-100%);">
        <div class="w-full h-full flex flex-col">
            <!-- Desktop Sidebar Header -->
            <div class="flex items-center justify-between pt-lg pr-lg pb-sm pl-lg">
                <!-- Left: Research Feed Home Button -->
                <div>
                    <a href="index.html" class="research-feed-button text-center px-tag-x py-sm bg-neutral-600 transition-colors duration-200">
                        <span class="text-neutral-10 font-heading font-bold text-2xl">Research Feed</span>
                    </a>
                </div>
                
                <!-- Right: Menu Button -->
                <button id="desktop-close-btn" class="nav-button bg-transparent flex items-center justify-center button" 
                        style="width: clamp(3rem, 6vw, 3.125rem); height: clamp(3rem, 6vw, 3.125rem);" 
                        aria-label="Close Menu" onclick="closeDesktopMenu()">
                    <svg width="24" height="18" viewBox="0 0 24 18" xmlns="http://www.w3.org/2000/svg">
                        <rect x="0" y="0" width="24" height="5" fill="#4F4E4B"/>
                        <rect x="0" y="6.5" width="24" height="5" fill="#4F4E4B"/>
                        <rect x="0" y="13" width="24" height="5" fill="#4F4E4B"/>
                    </svg>
                </button>
            </div>
            
            <!-- Desktop Sidebar Content -->
            <div class="flex-1 px-lg pt-lg pb-6xl">
                <div class="flex flex-col gap-lg">
                    <!-- Section 1: Paper Count -->
                    <div class="bg-transparent">
                        <span class="text-neutral-70 font-heading text-xl font-bold" id="desktop-paper-count">
                            Showing: 0/0 Papers
                        </span>
                    </div>
                    
                    <!-- Section 2: Quick Filters -->
                    <div class="flex flex-col gap-xs">
                        <h3 class="text-neutral-60 font-heading font-bold text-2xl text-left bg-transparent">Quick Filters</h3>
                        <button id="desktop-quick-must-read" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('must-read')">Must Read</button>
                        <button id="desktop-quick-should-read" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('should-read')">Should Read</button>
                        <button id="desktop-quick-rlhf" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('rlhf')">RLHF</button>
                        <button id="desktop-quick-weak-supervision" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('weak-supervision')">Weak Supervision</button>
                        <button id="desktop-quick-diffusion-reasoning" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('diffusion-reasoning')">Diffusion Reasoning</button>
                        <button id="desktop-quick-distributed-training" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('distributed-training')">Distributed Training</button>
                        <button id="desktop-quick-datasets" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('datasets')">Datasets</button>
                        <button id="desktop-quick-reset" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 hover:bg-neutral-600" onclick="applyQuickFilter('reset')">Reset To Default</button>
                    </div>
                    
                    <!-- Section 3: Advanced Filters -->
                    <div class="flex flex-col gap-xs">
                        <h3 class="text-neutral-60 font-heading font-bold text-2xl text-left bg-transparent">Advanced Filters</h3>
                        <!-- Scoring Filter Dropdown -->
                        <div class="relative">
                            <button id="desktop-scoring-btn" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleDesktopScoringDropdown()">
                                <span class="font-bold">Scoring:</span> <span class="font-normal">All Selected</span> <span class="text-sm">▼</span>
                            </button>
                            <div id="desktop-scoring-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-xs">
                                    <!-- Section 1: Has Scoring and Summary Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-scoring-has" checked>
                                            <label for="desktop-scoring-has"></label>
                                        </div>
                                        <label for="desktop-scoring-has" class="text-neutral-10 text-lg font-heading cursor-pointer">Completed</label>
                                    </div>
                                    
                                    <!-- Section 2: Does not have Scoring and Summary Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-scoring-no" checked>
                                            <label for="desktop-scoring-no"></label>
                                        </div>
                                        <label for="desktop-scoring-no" class="text-neutral-10 text-lg font-heading cursor-pointer">Not relevant enough</label>
                                    </div>
                                    
                                    <!-- Section 3: Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyScoringFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        <!-- Recommendation Filter Dropdown -->
                        <div class="relative">
                            <button id="desktop-recommendation-btn" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleDesktopRecommendationDropdown()">
                                <span class="font-bold">Recommendation:</span> <span class="font-normal">All Selected</span> <span class="text-sm">▼</span>
                            </button>
                            <div id="desktop-recommendation-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-xs">
                                    <!-- Must Read Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-recommendation-must" checked>
                                            <label for="desktop-recommendation-must"></label>
                                        </div>
                                        <label for="desktop-recommendation-must" class="text-neutral-10 text-lg font-heading cursor-pointer">Must Read</label>
                                    </div>
                                    
                                    <!-- Should Read Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-recommendation-should" checked>
                                            <label for="desktop-recommendation-should"></label>
                                        </div>
                                        <label for="desktop-recommendation-should" class="text-neutral-10 text-lg font-heading cursor-pointer">Should Read</label>
                                    </div>
                                    
                                    <!-- Can Skip Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-recommendation-skip" checked>
                                            <label for="desktop-recommendation-skip"></label>
                                        </div>
                                        <label for="desktop-recommendation-skip" class="text-neutral-10 text-lg font-heading cursor-pointer">Can Skip</label>
                                    </div>
                                    
                                    <!-- Ignore Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-recommendation-ignore" checked>
                                            <label for="desktop-recommendation-ignore"></label>
                                        </div>
                                        <label for="desktop-recommendation-ignore" class="text-neutral-10 text-lg font-heading cursor-pointer">Ignore</label>
                                    </div>
                                    
                                    <!-- Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyRecommendationFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        <!-- Novelty Filter Dropdown -->
                        <div class="relative">
                            <button id="desktop-novelty-btn" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleDesktopNoveltyDropdown()">
                                <span class="font-bold">Novelty:</span> <span class="font-normal">All Selected</span> <span class="text-sm">▼</span>
                            </button>
                            <div id="desktop-novelty-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-xs">
                                    <!-- High Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-novelty-high" checked>
                                            <label for="desktop-novelty-high"></label>
                                        </div>
                                        <label for="desktop-novelty-high" class="text-neutral-10 text-lg font-heading cursor-pointer">High</label>
                                    </div>
                                    
                                    <!-- Moderate Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-novelty-moderate" checked>
                                            <label for="desktop-novelty-moderate"></label>
                                        </div>
                                        <label for="desktop-novelty-moderate" class="text-neutral-10 text-lg font-heading cursor-pointer">Moderate</label>
                                    </div>
                                    
                                    <!-- Low Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-novelty-low" checked>
                                            <label for="desktop-novelty-low"></label>
                                        </div>
                                        <label for="desktop-novelty-low" class="text-neutral-10 text-lg font-heading cursor-pointer">Low</label>
                                    </div>
                                    
                                    <!-- None Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-novelty-none" checked>
                                            <label for="desktop-novelty-none"></label>
                                        </div>
                                        <label for="desktop-novelty-none" class="text-neutral-10 text-lg font-heading cursor-pointer">None</label>
                                    </div>
                                    
                                    <!-- Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyNoveltyFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        <!-- Potential Impact Filter Dropdown -->
                        <div class="relative">
                            <button id="desktop-impact-btn" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleDesktopImpactDropdown()">
                                <span class="font-bold">Potential Impact:</span> <span class="font-normal">All Selected</span> <span class="text-sm">▼</span>
                            </button>
                            <div id="desktop-impact-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-xs">
                                    <!-- High Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-impact-high" checked>
                                            <label for="desktop-impact-high"></label>
                                        </div>
                                        <label for="desktop-impact-high" class="text-neutral-10 text-lg font-heading cursor-pointer">High</label>
                                    </div>
                                    
                                    <!-- Moderate Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-impact-moderate" checked>
                                            <label for="desktop-impact-moderate"></label>
                                        </div>
                                        <label for="desktop-impact-moderate" class="text-neutral-10 text-lg font-heading cursor-pointer">Moderate</label>
                                    </div>
                                    
                                    <!-- Low Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-impact-low" checked>
                                            <label for="desktop-impact-low"></label>
                                        </div>
                                        <label for="desktop-impact-low" class="text-neutral-10 text-lg font-heading cursor-pointer">Low</label>
                                    </div>
                                    
                                    <!-- Negligible Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-impact-negligible" checked>
                                            <label for="desktop-impact-negligible"></label>
                                        </div>
                                        <label for="desktop-impact-negligible" class="text-neutral-10 text-lg font-heading cursor-pointer">Negligible</label>
                                    </div>
                                    
                                    <!-- Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyImpactFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        <!-- Relevance Filter Dropdown -->
                        <div class="relative">
                            <button id="desktop-relevance-btn" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleDesktopRelevanceDropdown()">
                                <span class="font-bold">Relevance:</span> <span class="font-normal">All Selected</span> <span class="text-sm">▼</span>
                            </button>
                            <div id="desktop-relevance-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-xs">
                                    <!-- Highly Relevant Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-relevance-highly" checked>
                                            <label for="desktop-relevance-highly"></label>
                                        </div>
                                        <label for="desktop-relevance-highly" class="text-neutral-10 text-lg font-heading cursor-pointer">Highly Relevant</label>
                                    </div>
                                    
                                    <!-- Moderately Relevant Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-relevance-moderately" checked>
                                            <label for="desktop-relevance-moderately"></label>
                                        </div>
                                        <label for="desktop-relevance-moderately" class="text-neutral-10 text-lg font-heading cursor-pointer">Moderately Relevant</label>
                                    </div>
                                    
                                    <!-- Tangentially Relevant Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-relevance-tangentially" checked>
                                            <label for="desktop-relevance-tangentially"></label>
                                        </div>
                                        <label for="desktop-relevance-tangentially" class="text-neutral-10 text-lg font-heading cursor-pointer">Tangentially Relevant</label>
                                    </div>
                                    
                                    <!-- Not Relevant Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-relevance-not" checked>
                                            <label for="desktop-relevance-not"></label>
                                        </div>
                                        <label for="desktop-relevance-not" class="text-neutral-10 text-lg font-heading cursor-pointer">Not Relevant</label>
                                    </div>
                                    
                                    <!-- Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyRelevanceFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Topic Filter Dropdown -->
                        <div class="relative">
                            <button id="desktop-topic-btn" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleDesktopTopicDropdown()">
                                <span class="font-bold">Topics:</span> <span class="font-normal">All Selected</span> <span class="text-sm">▼</span>
                            </button>
                            <div id="desktop-topic-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-xs">
                                    <!-- RLHF Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-topic-rlhf" checked>
                                            <label for="desktop-topic-rlhf"></label>
                                        </div>
                                        <label for="desktop-topic-rlhf" class="text-neutral-10 text-lg font-heading cursor-pointer">RLHF</label>
                                    </div>
                                    
                                    <!-- Weak Supervision Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-topic-weak-supervision" checked>
                                            <label for="desktop-topic-weak-supervision"></label>
                                        </div>
                                        <label for="desktop-topic-weak-supervision" class="text-neutral-10 text-lg font-heading cursor-pointer">Weak Supervision</label>
                                    </div>
                                    
                                    <!-- Diffusion Reasoning Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-topic-diffusion-reasoning" checked>
                                            <label for="desktop-topic-diffusion-reasoning"></label>
                                        </div>
                                        <label for="desktop-topic-diffusion-reasoning" class="text-neutral-10 text-lg font-heading cursor-pointer">Diffusion Reasoning</label>
                                    </div>
                                    
                                    <!-- Distributed Training Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-topic-distributed-training" checked>
                                            <label for="desktop-topic-distributed-training"></label>
                                        </div>
                                        <label for="desktop-topic-distributed-training" class="text-neutral-10 text-lg font-heading cursor-pointer">Distributed Training</label>
                                    </div>
                                    
                                    <!-- Datasets Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-topic-datasets" checked>
                                            <label for="desktop-topic-datasets"></label>
                                        </div>
                                        <label for="desktop-topic-datasets" class="text-neutral-10 text-lg font-heading cursor-pointer">Datasets</label>
                                    </div>
                                    
                                    <!-- Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyTopicFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- H-Index Filter Dropdown -->
                        <div class="relative">
                            <button id="desktop-hindex-btn" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleDesktopHIndexDropdown()">
                                H-index: All Selected <span class="text-md">▼</span>
                            </button>
                            <div id="desktop-hindex-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50 p-md">
                                <div class="flex flex-col gap-lg">
                                    <!-- Section 1: H-Index Found Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-hindex-found" checked onchange="toggleHIndexRanges()">
                                            <label for="desktop-hindex-found"></label>
                                        </div>
                                        <label for="desktop-hindex-found" class="text-neutral-10 text-lg font-heading cursor-pointer">H-Index Found</label>
                                    </div>
                                    
                                    <!-- Section 2: H-Index Not Found Checkbox -->
                                    <div class="flex items-center gap-xs">
                                        <div class="custom-checkbox">
                                            <input type="checkbox" id="desktop-hindex-not-found" checked>
                                            <label for="desktop-hindex-not-found"></label>
                                        </div>
                                        <label for="desktop-hindex-not-found" class="text-neutral-10 text-lg font-heading cursor-pointer">H-Index Not Found</label>
                                    </div>
                                    
                                    <!-- Section 3: Highest H-Index Range -->
                                    <div id="desktop-highest-range" class="hindex-range-section">
                                        <div class="text-neutral-10 text-lg font-heading mb-2xs">Highest H-Index Range:</div>
                                        <div class="flex items-center gap-xs">
                                            <span class="text-neutral-10 text-lg font-heading">Min:</span>
                                            <input type="number" id="desktop-highest-min" min="0" max="1000" value="0" class="bg-neutral-600 text-neutral-10 px-2xs py-2xs text-lg font-heading w-16 rounded">
                                            <span class="text-neutral-10 text-lg font-heading">-</span>
                                            <span class="text-neutral-10 text-lg font-heading">Max:</span>
                                            <input type="number" id="desktop-highest-max" min="0" max="1000" value="1000" class="bg-neutral-600 text-neutral-10 px-2xs py-2xs text-lg font-heading w-16 rounded">
                                        </div>
                                    </div>
                                    
                                    <!-- Section 4: Average H-Index Range -->
                                    <div id="desktop-average-range" class="hindex-range-section">
                                        <div class="text-neutral-10 text-lg font-heading mb-2xs">Average H-Index Range:</div>
                                        <div class="flex items-center gap-xs">
                                            <span class="text-neutral-10 text-lg font-heading">Min:</span>
                                            <input type="number" id="desktop-average-min" min="0" max="1000" value="0" class="bg-neutral-600 text-neutral-10 px-2xs py-2xs text-lg font-heading w-16 rounded">
                                            <span class="text-neutral-10 text-lg font-heading">-</span>
                                            <span class="text-neutral-10 text-lg font-heading">Max:</span>
                                            <input type="number" id="desktop-average-max" min="0" max="1000" value="1000" class="bg-neutral-600 text-neutral-10 px-2xs py-2xs text-lg font-heading w-16 rounded">
                                        </div>
                                    </div>
                                    
                                    <!-- Section 5: Apply Filter Button -->
                                    <button class="w-full py-tag-y font-heading font-bold text-lg text-neutral-60 bg-neutral-300 hover:bg-neutral-500 hover:text-neutral-10 transition-colors" onclick="applyHIndexFilter()">
                                        Apply Filter
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Sort By Dropdown -->
                        <div class="relative">
                            <button id="desktop-sort-btn" class="w-full py-tag-y font-heading font-bold text-lg text-neutral-10 bg-neutral-500 text-left px-tag-x hover:bg-neutral-600" onclick="toggleDesktopSortDropdown()">
                                <span class="font-bold">Sort By:</span> <span id="desktop-sort-text" class="font-normal">Recommendation (Best First)</span> <span class="text-sm">▼</span>
                            </button>
                            <div id="desktop-sort-dropdown" class="hidden absolute top-full left-0 w-full bg-neutral-700 z-50">
                                <div class="flex flex-col gap-xs">
                                    <button class="w-full py-tag-y font-heading text-lg text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('recommend_best')">Recommendation (Best First)</button>
                                    <button class="w-full py-tag-y font-heading text-lg text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('recommend_worst')">Recommendation (Worst First)</button>
                                    <button class="w-full py-tag-y font-heading text-lg text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('relevance_high')">Relevance (Highest to Lowest)</button>
                                    <button class="w-full py-tag-y font-heading text-lg text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('relevance_low')">Relevance (Lowest to Highest)</button>
                                    <button class="w-full py-tag-y font-heading text-lg text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('highest_hindex_asc')">Highest H-Index (Ascending)</button>
                                    <button class="w-full py-tag-y font-heading text-lg text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('highest_hindex_desc')">Highest H-Index (Descending)</button>
                                    <button class="w-full py-tag-y font-heading text-lg text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('average_hindex_asc')">Average H-Index (Ascending)</button>
                                    <button class="w-full py-tag-y font-heading text-lg text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('average_hindex_desc')">Average H-Index (Descending)</button>
                                    <button class="w-full py-tag-y font-heading text-lg text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('id_asc')">arXiv ID (Ascending)</button>
                                    <button class="w-full py-tag-y font-heading text-lg text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('id_desc')">arXiv ID (Descending)</button>
                                    <button class="w-full py-tag-y font-heading text-lg text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('title_az')">Title (A-Z)</button>
                                    <button class="w-full py-tag-y font-heading text-lg text-neutral-10 hover:bg-neutral-600 text-left px-tag-x" onclick="changeSortAndClose('title_za')">Title (Z-A)</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Desktop Layout (visible ≥ 768px) -->
    <div class="hidden tablet:block">
        <!-- Desktop Header -->
        <header class="bg-neutral-200 w-full flex items-center px-lg pt-xl pb-md relative">
            <!-- Menu Button - Positioned absolutely within header -->
            <button id="desktop-menu-btn" class="absolute top-1/2 left-lg transform -translate-y-1/2 z-10 nav-button bg-transparent flex items-center justify-center button" 
                    style="width: clamp(3rem, 6vw, 3.125rem); height: clamp(3rem, 6vw, 3.125rem);" 
                    aria-label="Open Menu" onclick="toggleDesktopMenu()">
                <svg width="24" height="18" viewBox="0 0 24 18" xmlns="http://www.w3.org/2000/svg">
                    <rect x="0" y="0" width="24" height="5" fill="#4F4E4B"/>
                    <rect x="0" y="6.5" width="24" height="5" fill="#4F4E4B"/>
                    <rect x="0" y="13" width="24" height="5" fill="#4F4E4B"/>
                </svg>
            </button>
            
            <!-- Center: Page info (full width since menu button is positioned absolutely) -->
            <div class="w-full flex flex-col items-center justify-center text-center">
                <h1 class="text-neutral-70 font-heading font-bold text-4xl mb-md" id="page-title-desktop">
                    Papers Published on 23 August 2025
                </h1>
                
                <!-- Desktop Pagination -->
                <div class="flex items-center mb-md" style="gap: clamp(0.5rem, 1vw, 0.75rem);">
                    <!-- Previous Arrow -->
                    <button id="desktop-prev-btn" class="pagination-arrow bg-transparent text-neutral-70 flex items-center justify-center hover:bg-neutral-300 cursor-pointer" 
                            style="width: clamp(1.5rem, 3vw, 1.875rem); height: clamp(1.5rem, 3vw, 1.875rem);" onclick="goToPage(currentPage - 1)">
                        <span class="font-heading font-bold text-md">‹</span>
                    </button>
                    
                    <!-- Page Numbers Container -->
                    <div class="flex" style="gap: clamp(0.5rem, 1vw, 0.75rem);" id="desktop-pagination-numbers">
                        <!-- Page numbers will be populated by JavaScript -->
                    </div>
                    
                    <!-- Next Arrow -->
                    <button id="desktop-next-btn" class="pagination-arrow bg-transparent text-neutral-70 flex items-center justify-center hover:bg-neutral-300 cursor-pointer" 
                            style="width: clamp(1.5rem, 3vw, 1.875rem); height: clamp(1.5rem, 3vw, 1.875rem);" onclick="goToPage(currentPage + 1)">
                        <span class="font-heading font-bold text-md">›</span>
                    </button>
                </div>
                
                <!-- Desktop Paper Count -->
                <p id="desktop-main-paper-count" class="text-neutral-60 font-heading font-bold text-xl">
                    Showing 0 / 0 papers
                </p>
            </div>
        </header>
        
        <!-- Desktop Content Area -->
        <main class="px-xl py-2xl min-h-screen">
            <div class="max-w-[1400px] mx-auto">
                <!-- Desktop Papers Grid -->
                <div class="flex flex-col gap-3xl" id="desktop-papers">
                    <!-- Paper cards will be populated by JavaScript -->
                </div>
            </div>
        </main>
        
        <!-- Desktop Footer -->
        <footer class="py-xl bg-neutral-200">
            <div class="flex flex-col items-center justify-center text-center">
                <!-- Desktop Footer Pagination -->
                <div class="flex items-center" style="gap: clamp(0.5rem, 1vw, 0.75rem);">
                    <!-- Previous Arrow -->
                    <button id="desktop-footer-prev-btn" class="pagination-arrow bg-transparent text-neutral-70 flex items-center justify-center hover:bg-neutral-300 cursor-pointer" 
                            style="width: clamp(1.5rem, 3vw, 1.875rem); height: clamp(1.5rem, 3vw, 1.875rem);" onclick="goToPage(currentPage - 1)">
                        <span class="font-heading font-bold text-md">‹</span>
                    </button>
                    
                    <!-- Page Numbers Container -->
                    <div class="flex" style="gap: clamp(0.5rem, 1vw, 0.75rem);" id="desktop-footer-pagination-numbers">
                        <!-- Page numbers will be populated by JavaScript -->
                    </div>
                    
                    <!-- Next Arrow -->
                    <button id="desktop-footer-next-btn" class="pagination-arrow bg-transparent text-neutral-70 flex items-center justify-center hover:bg-neutral-300 cursor-pointer" 
                            style="width: clamp(1.5rem, 3vw, 1.875rem); height: clamp(1.5rem, 3vw, 1.875rem);" onclick="goToPage(currentPage + 1)">
                        <span class="font-heading font-bold text-md">›</span>
                    </button>
                </div>
            </div>
        </footer>
    </div>

    <!-- Embedded Paper Data - This will be populated by the builder script -->
    <script>
        // This JSON structure will be injected by the builder script
        // Expected structure:
        // {
        //   "papers": [
        //     {
        //       "id": "2407.xxxxx",
        //       "title": "Paper title with possible LaTeX: $\\alpha$ notation",
        //       "authors": ["Author 1", "Author 2"],
        //       "categories": ["cs.LG", "cs.AI"],
        //       "abstract": "Abstract text with possible LaTeX notation",
        //       "published_date": "2025-07-15",
        //       "arxiv_url": "https://arxiv.org/abs/2407.xxxxx",
        //       "pdf_url": "https://arxiv.org/pdf/2407.xxxxx.pdf",
        //       "summary": "AI generated summary",
        //       "recommendation_score": "Must Read",
        //       "recommendation_justification": "Justification text",
        //       "novelty_score": "High",
        //       "novelty_justification": "Novelty justification",
        //       "impact_score": "High", 
        //       "impact_justification": "Impact justification",
        //       "rlhf_score": 0.85,
        //       "weak_supervision_score": 0.72,
        //       "diffusion_reasoning_score": 0.15,
        //       "distributed_training_score": 0.05,
        //       "datasets_score": 0.92,
        //       "rlhf_relevance": "Highly Relevant",
        //       "weak_supervision_relevance": "Moderately Relevant", 
        //       "diffusion_reasoning_relevance": "Not Relevant",
        //       "distributed_training_relevance": "Not Relevant",
        //       "datasets_relevance": "Highly Relevant",
        //       "rlhf_justification": "Relevance justification text",
        //       "weak_supervision_justification": "Relevance justification text",
        //       "diffusion_reasoning_justification": "below_threshold",
        //       "distributed_training_justification": "below_threshold", 
        //       "datasets_justification": "Relevance justification text",
        //       "h_index_status": "completed",
        //       "semantic_scholar_url": "https://www.semanticscholar.org/...",
        //       "total_authors": 3,
        //       "authors_found": 2,
        //       "highest_h_index": 45,
        //       "average_h_index": 28.5,
        //       "notable_authors_count": 2,
        //       "author_h_indexes": [
        //         {"name": "Author 1", "h_index": 45, "profile_url": "https://..."},
        //         {"name": "Author 2", "h_index": 12, "profile_url": "https://..."}
        //       ],
        //       "llm_score_status": "completed" // or "not_relevant_enough"
        //     }
        //   ],
        //   "total_papers": 25,
        //   "date": "2025-07-15"
        // }
        const PAPER_DATA = {
  "papers": [
    {
      "id": "2508.16845",
      "title": "NinA: Normalizing Flows in Action. Training VLA Models with Normalizing\n  Flows",
      "authors": [
        "Denis Tarasov",
        "Alexander Nikulin",
        "Ilya Zisman",
        "Albina Klepach",
        "Nikita Lyubaykin",
        "Andrei Polubarov",
        "Alexander Derevyagin",
        "Vladislav Kurenkov"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.AI (Artificial Intelligence)",
        "cs.LG (Machine Learning)"
      ],
      "abstract": "Recent advances in Vision-Language-Action (VLA) models have established a\ntwo-component architecture, where a pre-trained Vision-Language Model (VLM)\nencodes visual observations and task descriptions, and an action decoder maps\nthese representations to continuous actions. Diffusion models have been widely\nadopted as action decoders due to their ability to model complex, multimodal\naction distributions. However, they require multiple iterative denoising steps\nat inference time or downstream techniques to speed up sampling, limiting their\npracticality in real-world settings where high-frequency control is crucial. In\nthis work, we present NinA (Normalizing Flows in Action), a fast and expressive\nalter- native to diffusion-based decoders for VLAs. NinA replaces the diffusion\naction decoder with a Normalizing Flow (NF) that enables one-shot sampling\nthrough an invertible transformation, significantly reducing inference time. We\nintegrate NinA into the FLOWER VLA architecture and fine-tune on the LIBERO\nbenchmark. Our experiments show that NinA matches the performance of its\ndiffusion-based counterpart under the same training regime, while achieving\nsubstantially faster inference. These results suggest that NinA offers a\npromising path toward efficient, high-frequency VLA control without\ncompromising performance.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16845v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16845v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "extraction_failed",
      "embedding_status": "completed",
      "rlhf_score": 0.347,
      "weak_supervision_score": 0.299,
      "diffusion_reasoning_score": 0.437,
      "distributed_training_score": 0.349,
      "datasets_score": 0.266,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper primarily discusses replacing diffusion models with Normalizing Flows for faster action decoding in Vision-Language-Action (VLA) models, focusing on efficiency in control tasks. It does not involve adapting diffusion for multi-step logical reasoning, Chain-of-Thought processes, or holistic correction of reasoning paths, as defined in the topic. Therefore, there is no clear component of diffusion-based reasoning in the paper.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16846",
      "title": "Quantifying Sycophancy as Deviations from Bayesian Rationality in LLMs",
      "authors": [
        "Katherine Atwell",
        "Pedram Heydari",
        "Anthony Sicilia",
        "Malihe Alikhani"
      ],
      "categories": [
        "cs.AI (Artificial Intelligence)",
        "cs.CL (Computation and Language)"
      ],
      "abstract": "Sycophancy, or overly agreeable or flattering behavior, is a documented issue\nin large language models (LLMs), and is critical to understand in the context\nof human/AI collaboration. Prior works typically quantify sycophancy by\nmeasuring shifts in behavior or impacts on accuracy, but neither metric\ncharacterizes shifts in rationality, and accuracy measures can only be used in\nscenarios with a known ground truth. In this work, we utilize a Bayesian\nframework to quantify sycophancy as deviations from rational behavior when\npresented with user perspectives, thus distinguishing between rational and\nirrational updates based on the introduction of user perspectives. In\ncomparison to other methods, this approach allows us to characterize excessive\nbehavioral shifts, even for tasks that involve inherent uncertainty or do not\nhave a ground truth. We study sycophancy for 3 different tasks, a combination\nof open-source and closed LLMs, and two different methods for probing\nsycophancy. We also experiment with multiple methods for eliciting probability\njudgments from LLMs. We hypothesize that probing LLMs for sycophancy will cause\ndeviations in LLMs' predicted posteriors that will lead to increased Bayesian\nerror. Our findings indicate that: 1) LLMs are not Bayesian rational, 2)\nprobing for sycophancy results in significant increases to the predicted\nposterior in favor of the steered outcome, 3) sycophancy sometimes results in\nincreased Bayesian error, and in a small number of cases actually decreases\nerror, and 4) changes in Bayesian error due to sycophancy are not strongly\ncorrelated in Brier score, suggesting that studying the impact of sycophancy on\nground truth alone does not fully capture errors in reasoning due to\nsycophancy.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16846v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16846v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.462,
      "weak_supervision_score": 0.408,
      "diffusion_reasoning_score": 0.414,
      "distributed_training_score": 0.291,
      "datasets_score": 0.352,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Tangentially Relevant",
      "weak_supervision_relevance": "Not Relevant",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper studies sycophancy in LLMs, which may indirectly relate to RLHF as a potential cause of such behavior due to alignment training with human feedback. However, the paper focuses on evaluating and quantifying sycophancy using a Bayesian framework, without directly involving RLHF methods like reward modeling or fine-tuning. Thus, it is not a core application or advancement of RLHF.",
      "weak_supervision_justification": "The paper does not involve training models with programmatically generated or noisy labels, which is the essence of weak supervision. Instead, it evaluates LLMs' rational behavior in response to user inputs, with no discussion of label generation or supervision techniques.",
      "diffusion_reasoning_justification": "The paper employs a Bayesian framework for analyzing belief updates in LLMs but does not use diffusion models, iterative refinement, or multi-step logical reasoning processes. There is no component involving diffusion-based techniques for reasoning tasks.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16849",
      "title": "RF-PGS: Fully-structured Spatial Wireless Channel Representation with\n  Planar Gaussian Splatting",
      "authors": [
        "Lihao Zhang",
        "Zongtan Li",
        "Haijian Sun"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.NI (Networking and Internet Architecture)"
      ],
      "abstract": "In the 6G era, the demand for higher system throughput and the implementation\nof emerging 6G technologies require large-scale antenna arrays and accurate\nspatial channel state information (Spatial-CSI). Traditional channel modeling\napproaches, such as empirical models, ray tracing, and measurement-based\nmethods, face challenges in spatial resolution, efficiency, and scalability.\nRadiance field-based methods have emerged as promising alternatives but still\nsuffer from geometric inaccuracy and costly supervision. This paper proposes\nRF-PGS, a novel framework that reconstructs high-fidelity radio propagation\npaths from only sparse path loss spectra. By introducing Planar Gaussians as\ngeometry primitives with certain RF-specific optimizations, RF-PGS achieves\ndense, surface-aligned scene reconstruction in the first geometry training\nstage. In the subsequent Radio Frequency (RF) training stage, the proposed\nfully-structured radio radiance, combined with a tailored multi-view loss,\naccurately models radio propagation behavior. Compared to prior radiance field\nmethods, RF-PGS significantly improves reconstruction accuracy, reduces\ntraining costs, and enables efficient representation of wireless channels,\noffering a practical solution for scalable 6G Spatial-CSI modeling.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16849v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16849v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.332,
      "weak_supervision_score": 0.31,
      "diffusion_reasoning_score": 0.37,
      "distributed_training_score": 0.381,
      "datasets_score": 0.277,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16850",
      "title": "RADAR: A Reasoning-Guided Attribution Framework for Explainable Visual\n  Data Analysis",
      "authors": [
        "Anku Rani",
        "Aparna Garimella",
        "Apoorv Saxena",
        "Balaji Vasan Srinivasan",
        "Paul Pu Liang"
      ],
      "categories": [
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Data visualizations like charts are fundamental tools for quantitative\nanalysis and decision-making across fields, requiring accurate interpretation\nand mathematical reasoning. The emergence of Multimodal Large Language Models\n(MLLMs) offers promising capabilities for automated visual data analysis, such\nas processing charts, answering questions, and generating summaries. However,\nthey provide no visibility into which parts of the visual data informed their\nconclusions; this black-box nature poses significant challenges to real-world\ntrust and adoption. In this paper, we take the first major step towards\nevaluating and enhancing the capabilities of MLLMs to attribute their reasoning\nprocess by highlighting the specific regions in charts and graphs that justify\nmodel answers. To this end, we contribute RADAR, a semi-automatic approach to\nobtain a benchmark dataset comprising 17,819 diverse samples with charts,\nquestions, reasoning steps, and attribution annotations. We also introduce a\nmethod that provides attribution for chart-based mathematical reasoning.\nExperimental results demonstrate that our reasoning-guided approach improves\nattribution accuracy by 15% compared to baseline methods, and enhanced\nattribution capabilities translate to stronger answer generation, achieving an\naverage BERTScore of $\\sim$ 0.90, indicating high alignment with ground truth\nresponses. This advancement represents a significant step toward more\ninterpretable and trustworthy chart analysis systems, enabling users to verify\nand understand model decisions through reasoning and attribution.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16850v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16850v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "extraction_failed",
      "embedding_status": "completed",
      "rlhf_score": 0.398,
      "weak_supervision_score": 0.354,
      "diffusion_reasoning_score": 0.498,
      "distributed_training_score": 0.298,
      "datasets_score": 0.391,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper introduces RADAR, a framework for attribution in MLLMs to enhance explainability in visual data analysis, focusing on charts and reasoning steps. It does not involve diffusion models, iterative refinement for logical tasks, or treating a Chain-of-Thought as a single entity for holistic correction. Therefore, it lacks any components related to diffusion-based reasoning.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16852",
      "title": "Gaussian Primitive Optimized Deformable Retinal Image Registration",
      "authors": [
        "Xin Tian",
        "Jiazheng Wang",
        "Yuxi Zhang",
        "Xiang Chen",
        "Renjiu Hu",
        "Gaolei Li",
        "Min Liu",
        "Hang Zhang"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.AI (Artificial Intelligence)",
        "eess.IV (Image and Video Processing)"
      ],
      "abstract": "Deformable retinal image registration is notoriously difficult due to large\nhomogeneous regions and sparse but critical vascular features, which cause\nlimited gradient signals in standard learning-based frameworks. In this paper,\nwe introduce Gaussian Primitive Optimization (GPO), a novel iterative framework\nthat performs structured message passing to overcome these challenges. After an\ninitial coarse alignment, we extract keypoints at salient anatomical structures\n(e.g., major vessels) to serve as a minimal set of descriptor-based control\nnodes (DCN). Each node is modelled as a Gaussian primitive with trainable\nposition, displacement, and radius, thus adapting its spatial influence to\nlocal deformation scales. A K-Nearest Neighbors (KNN) Gaussian interpolation\nthen blends and propagates displacement signals from these information-rich\nnodes to construct a globally coherent displacement field; focusing\ninterpolation on the top (K) neighbors reduces computational overhead while\npreserving local detail. By strategically anchoring nodes in high-gradient\nregions, GPO ensures robust gradient flow, mitigating vanishing gradient signal\nin textureless areas. The framework is optimized end-to-end via a multi-term\nloss that enforces both keypoint consistency and intensity alignment.\nExperiments on the FIRE dataset show that GPO reduces the target registration\nerror from 6.2\\,px to ~2.4\\,px and increases the AUC at 25\\,px from 0.770 to\n0.938, substantially outperforming existing methods. The source code can be\naccessed via https://github.com/xintian-99/GPOreg.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16852v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16852v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "extraction_failed",
      "embedding_status": "completed",
      "rlhf_score": 0.28,
      "weak_supervision_score": 0.259,
      "diffusion_reasoning_score": 0.28,
      "distributed_training_score": 0.3,
      "datasets_score": 0.21,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16853",
      "title": "DevLicOps: A Framework for Mitigating Licensing Risks in AI-Generated\n  Code",
      "authors": [
        "Pratyush Nidhi Sharma",
        "Lauren Wright",
        "Anne Herfurth",
        "Munsif Sokiyna",
        "Pratyaksh Nidhi Sharma",
        "Sethu Das",
        "Mikko Siponen"
      ],
      "categories": [
        "cs.SE (Software Engineering)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Generative AI coding assistants (ACAs) are widely adopted yet pose serious\nlegal and compliance risks. ACAs can generate code governed by restrictive\nopen-source licenses (e.g., GPL), potentially exposing companies to litigation\nor forced open-sourcing. Few developers are trained in these risks, and legal\nstandards vary globally, especially with outsourcing. Our article introduces\nDevLicOps, a practical framework that helps IT leaders manage ACA-related\nlicensing risks through governance, incident response, and informed tradeoffs.\nAs ACA adoption grows and legal frameworks evolve, proactive license compliance\nis essential for responsible, risk-aware software development in the AI era.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16853v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16853v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.377,
      "weak_supervision_score": 0.328,
      "diffusion_reasoning_score": 0.351,
      "distributed_training_score": 0.302,
      "datasets_score": 0.27,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16856",
      "title": "A Workflow for Map Creation in Autonomous Vehicle Simulations",
      "authors": [
        "Zubair Islam",
        "Ahmaad Ansari",
        "George Daoud",
        "Mohamed El-Darieby"
      ],
      "categories": [
        "cs.RO (Robotics)",
        "cs.AI (Artificial Intelligence)",
        "cs.GR (Graphics)"
      ],
      "abstract": "The fast development of technology and artificial intelligence has\nsignificantly advanced Autonomous Vehicle (AV) research, emphasizing the need\nfor extensive simulation testing. Accurate and adaptable maps are critical in\nAV development, serving as the foundation for localization, path planning, and\nscenario testing. However, creating simulation-ready maps is often difficult\nand resource-intensive, especially with simulators like CARLA (CAR Learning to\nAct). Many existing workflows require significant computational resources or\nrely on specific simulators, limiting flexibility for developers. This paper\npresents a custom workflow to streamline map creation for AV development,\ndemonstrated through the generation of a 3D map of a parking lot at Ontario\nTech University. Future work will focus on incorporating SLAM technologies,\noptimizing the workflow for broader simulator compatibility, and exploring more\nflexible handling of latitude and longitude values to enhance map generation\naccuracy.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16856v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16856v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.3,
      "weak_supervision_score": 0.285,
      "diffusion_reasoning_score": 0.32,
      "distributed_training_score": 0.283,
      "datasets_score": 0.319,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16858",
      "title": "WildSpoof Challenge Evaluation Plan",
      "authors": [
        "Yihan Wu",
        "Jee-weon Jung",
        "Hye-jin Shim",
        "Xin Cheng",
        "Xin Wang"
      ],
      "categories": [
        "cs.SD (Sound)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "The WildSpoof Challenge aims to advance the use of in-the-wild data in two\nintertwined speech processing tasks. It consists of two parallel tracks: (1)\nText-to-Speech (TTS) synthesis for generating spoofed speech, and (2)\nSpoofing-robust Automatic Speaker Verification (SASV) for detecting spoofed\nspeech. While the organizers coordinate both tracks and define the data\nprotocols, participants treat them as separate and independent tasks. The\nprimary objectives of the challenge are: (i) to promote the use of in-the-wild\ndata for both TTS and SASV, moving beyond conventional clean and controlled\ndatasets and considering real-world scenarios; and (ii) to encourage\ninterdisciplinary collaboration between the spoofing generation (TTS) and\nspoofing detection (SASV) communities, thereby fostering the development of\nmore integrated, robust, and realistic systems.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16858v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16858v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.298,
      "weak_supervision_score": 0.351,
      "diffusion_reasoning_score": 0.278,
      "distributed_training_score": 0.276,
      "datasets_score": 0.325,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16859",
      "title": "Beyond Emotion Recognition: A Multi-Turn Multimodal Emotion\n  Understanding and Reasoning Benchmark",
      "authors": [
        "Jinpeng Hu",
        "Hongchang Shi",
        "Chongyuan Dai",
        "Zhuo Li",
        "Peipei Song",
        "Meng Wang"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Multimodal large language models (MLLMs) have been widely applied across\nvarious fields due to their powerful perceptual and reasoning capabilities. In\nthe realm of psychology, these models hold promise for a deeper understanding\nof human emotions and behaviors. However, recent research primarily focuses on\nenhancing their emotion recognition abilities, leaving the substantial\npotential in emotion reasoning, which is crucial for improving the naturalness\nand effectiveness of human-machine interactions. Therefore, in this paper, we\nintroduce a multi-turn multimodal emotion understanding and reasoning (MTMEUR)\nbenchmark, which encompasses 1,451 video data from real-life scenarios, along\nwith 5,101 progressive questions. These questions cover various aspects,\nincluding emotion recognition, potential causes of emotions, future action\nprediction, etc. Besides, we propose a multi-agent framework, where each agent\nspecializes in a specific aspect, such as background context, character\ndynamics, and event details, to improve the system's reasoning capabilities.\nFurthermore, we conduct experiments with existing MLLMs and our agent-based\nmethod on the proposed benchmark, revealing that most models face significant\nchallenges with this task.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16859v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16859v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.372,
      "weak_supervision_score": 0.308,
      "diffusion_reasoning_score": 0.459,
      "distributed_training_score": 0.308,
      "datasets_score": 0.413,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "Highly Relevant",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on introducing a multimodal emotion understanding benchmark and a multi-agent framework for MLLMs, but it does not involve diffusion models, iterative refinement processes, or any adaptation of diffusion for logical reasoning tasks. There is no mention of treating a Chain-of-Thought as a single entity for holistic correction, making this topic unrelated.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "The paper's main contribution is the introduction and evaluation of a new benchmark dataset (MTMEUR) with 1,451 videos and 5,101 questions for multimodal emotion understanding and reasoning. It details dataset curation, including real-life scenarios and progressive questions, and conducts benchmarking experiments with MLLMs, directly aligning with research on creating, analyzing, and evaluating datasets for AI applications.",
      "llm_score_status": "completed",
      "summary": "This paper introduces the MTMEUR benchmark, consisting of 1,451 real-life videos and 5,101 progressive questions, to evaluate multimodal large language models (MLLMs) on advanced emotion understanding and reasoning tasks beyond basic recognition, including identifying emotion causes and predicting future actions. It proposes a multi-agent framework with specialized agents for aspects like background context and character dynamics to enhance reasoning capabilities, and experiments demonstrate that existing MLLMs struggle with these tasks, achieving accuracies from 29.10% to 71.19%, while the new method shows improvements.",
      "novelty_score": "High",
      "novelty_justification": "The paper introduces a new benchmark for multi-turn multimodal emotion reasoning and a multi-agent framework, which significantly advances the state-of-the-art by addressing gaps in existing emotion datasets and methods. This represents a truly novel problem setup that goes beyond incremental improvements in emotion recognition.",
      "impact_score": "Moderate",
      "impact_justification": "The work is likely to be cited and built upon in subfields like computer vision and AI psychology, as it enhances MLLMs for more natural human-machine interactions. However, its influence may be limited to specific applications rather than broad commercial or research domains.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "The paper offers a strong, innovative contribution by introducing a new benchmark and framework that addresses key limitations in emotion understanding, making it valuable for researchers in multimodal AI. While not essential for all, it provides important insights that warrant attention in relevant fields.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/1369266ca4e06c998c8859c041102664087c3456",
      "total_authors": 6,
      "authors_found": 6,
      "highest_h_index": 1,
      "average_h_index": 0.16666666666666666,
      "notable_authors_count": 0,
      "author_h_indexes": [
        {
          "name": "Jinpeng Hu",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2310341422"
        },
        {
          "name": "Hongchang Shi",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2375961704"
        },
        {
          "name": "Chongyuan Dai",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2375901809"
        },
        {
          "name": "Zhuo Li",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2376012213"
        },
        {
          "name": "Peipei Song",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2374475374"
        },
        {
          "name": "Meng Wang",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2376119265"
        }
      ]
    },
    {
      "id": "2508.16860",
      "title": "TriagerX: Dual Transformers for Bug Triaging Tasks with Content and\n  Interaction Based Rankings",
      "authors": [
        "Md Afif Al Mamun",
        "Gias Uddin",
        "Lan Xia",
        "Longyu Zhang"
      ],
      "categories": [
        "cs.SE (Software Engineering)",
        "cs.AI (Artificial Intelligence)",
        "cs.LG (Machine Learning)"
      ],
      "abstract": "Pretrained Language Models or PLMs are transformer-based architectures that\ncan be used in bug triaging tasks. PLMs can better capture token semantics than\ntraditional Machine Learning (ML) models that rely on statistical features\n(e.g., TF-IDF, bag of words). However, PLMs may still attend to less relevant\ntokens in a bug report, which can impact their effectiveness. In addition, the\nmodel can be sub-optimal with its recommendations when the interaction history\nof developers around similar bugs is not taken into account. We designed\nTriagerX to address these limitations. First, to assess token semantics more\nreliably, we leverage a dual-transformer architecture. Unlike current\nstate-of-the-art (SOTA) baselines that employ a single transformer\narchitecture, TriagerX collects recommendations from two transformers with each\noffering recommendations via its last three layers. This setup generates a\nrobust content-based ranking of candidate developers. TriagerX then refines\nthis ranking by employing a novel interaction-based ranking methodology, which\nconsiders developers' historical interactions with similar fixed bugs. Across\nfive datasets, TriagerX surpasses all nine transformer-based methods, including\nSOTA baselines, often improving Top-1 and Top-3 developer recommendation\naccuracy by over 10%. We worked with our large industry partner to successfully\ndeploy TriagerX in their development environment. The partner required both\ndeveloper and component recommendations, with components acting as proxies for\nteam assignments-particularly useful in cases of developer turnover or team\nchanges. We trained TriagerX on the partner's dataset for both tasks, and it\noutperformed SOTA baselines by up to 10% for component recommendations and 54%\nfor developer recommendations.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16860v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16860v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.397,
      "weak_supervision_score": 0.358,
      "diffusion_reasoning_score": 0.397,
      "distributed_training_score": 0.395,
      "datasets_score": 0.324,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16863",
      "title": "Delta-SVD: Efficient Compression for Personalized Text-to-Image Models",
      "authors": [
        "Tangyuan Zhang",
        "Shangyu Chen",
        "Qixiang Chen",
        "Jianfei Cai"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Personalized text-to-image models such as DreamBooth require fine-tuning\nlarge-scale diffusion backbones, resulting in significant storage overhead when\nmaintaining many subject-specific models. We present Delta-SVD, a post-hoc,\ntraining-free compression method that targets the parameter weights update\ninduced by DreamBooth fine-tuning. Our key observation is that these delta\nweights exhibit strong low-rank structure due to the sparse and localized\nnature of personalization. Delta-SVD first applies Singular Value Decomposition\n(SVD) to factorize the weight deltas, followed by an energy-based rank\ntruncation strategy to balance compression efficiency and reconstruction\nfidelity. The resulting compressed models are fully plug-and-play and can be\nre-constructed on-the-fly during inference. Notably, the proposed approach is\nsimple, efficient, and preserves the original model architecture. Experiments\non a multiple subject dataset demonstrate that Delta-SVD achieves substantial\ncompression with negligible loss in generation quality measured by CLIP score,\nSSIM and FID. Our method enables scalable and efficient deployment of\npersonalized diffusion models, making it a practical solution for real-world\napplications that require storing and deploying large-scale subject\ncustomizations.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16863v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16863v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.317,
      "weak_supervision_score": 0.314,
      "diffusion_reasoning_score": 0.44,
      "distributed_training_score": 0.407,
      "datasets_score": 0.303,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "Not Relevant",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on compressing personalized text-to-image diffusion models using SVD, specifically for efficient storage and deployment of models like DreamBooth. It does not involve adapting diffusion models for multi-step logical reasoning, iterative refinement of reasoning paths, or solving complex logical tasks, which are the core elements of this topic.",
      "distributed_training_justification": "The paper addresses post-hoc compression of fine-tuned diffusion models to reduce storage overhead, but it does not discuss distributed training techniques, parallel computing, multi-node setups, or strategies for partitioning data, architecture, or computation across processors. The work is centered on model compression, not training acceleration.",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16873",
      "title": "Do Multimodal LLMs See Sentiment?",
      "authors": [
        "Neemias B. da Silva",
        "John Harrison",
        "Rodrigo Minetto",
        "Myriam R. Delgado",
        "Bogdan T. Nassu",
        "Thiago H. Silva"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.SI (Social and Information Networks)"
      ],
      "abstract": "Understanding how visual content communicates sentiment is critical in an era\nwhere online interaction is increasingly dominated by this kind of media on\nsocial platforms. However, this remains a challenging problem, as sentiment\nperception is closely tied to complex, scene-level semantics. In this paper, we\npropose an original framework, MLLMsent, to investigate the sentiment reasoning\ncapabilities of Multimodal Large Language Models (MLLMs) through three\nperspectives: (1) using those MLLMs for direct sentiment classification from\nimages; (2) associating them with pre-trained LLMs for sentiment analysis on\nautomatically generated image descriptions; and (3) fine-tuning the LLMs on\nsentiment-labeled image descriptions. Experiments on a recent and established\nbenchmark demonstrate that our proposal, particularly the fine-tuned approach,\nachieves state-of-the-art results outperforming Lexicon-, CNN-, and\nTransformer-based baselines by up to 30.9%, 64.8%, and 42.4%, respectively,\nacross different levels of evaluators' agreement and sentiment polarity\ncategories. Remarkably, in a cross-dataset test, without any training on these\nnew data, our model still outperforms, by up to 8.26%, the best runner-up,\nwhich has been trained directly on them. These results highlight the potential\nof the proposed visual reasoning scheme for advancing affective computing,\nwhile also establishing new benchmarks for future research.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16873v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16873v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.399,
      "weak_supervision_score": 0.372,
      "diffusion_reasoning_score": 0.444,
      "distributed_training_score": 0.331,
      "datasets_score": 0.413,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "Moderately Relevant",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on evaluating Multimodal Large Language Models (MLLMs) for sentiment analysis from images, including direct classification, description generation, and fine-tuning. It does not mention or involve diffusion models, iterative refinement processes, or multi-step logical reasoning as described in the topic.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "The paper includes the release of generated image captions and fine-tuned models for existing datasets (PerceptSent and DeepSent), which supports benchmarking and future research in AI. While this contributes to dataset curation and evaluation, the primary focus is on sentiment analysis frameworks rather than dataset creation or analysis.",
      "llm_score_status": "completed",
      "summary": "This paper introduces the MLLMsent framework to evaluate the sentiment reasoning capabilities of Multimodal Large Language Models (MLLMs) for image sentiment analysis, addressing how these models can classify sentiment directly from images, analyze sentiment in automatically generated image descriptions using pre-trained LLMs, and improve performance through fine-tuning on sentiment-labeled descriptions. The methodology involves experimenting with various MLLMs and LLMs on established benchmarks, achieving state-of-the-art results that outperform traditional baselines by significant margins, demonstrating strong generalization in cross-dataset evaluations and highlighting the potential for advancing affective computing.",
      "novelty_score": "Moderate",
      "novelty_justification": "The paper presents a clever combination of existing MLLMs and LLMs to address sentiment analysis in images through a new framework, offering a notable improvement over traditional methods but not introducing an entirely new problem or technique.",
      "impact_score": "Moderate",
      "impact_justification": "The work is likely to influence research in affective computing and visual sentiment analysis by providing new benchmarks and demonstrating effective use of MLLMs, though its applicability may be confined to specific subfields like computer vision and social networks.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "This paper delivers high-quality advancements in sentiment analysis using MLLMs, making it a valuable contribution for researchers in relevant areas, though it may not be essential for those outside the field.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/4028336a782a3cfd86a37cf084548890f758952b",
      "total_authors": 6,
      "authors_found": 6,
      "highest_h_index": 11,
      "average_h_index": 2.5,
      "notable_authors_count": 1,
      "author_h_indexes": [
        {
          "name": "Neemias B. da Silva",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2378165704"
        },
        {
          "name": "John Harrison",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2376936158"
        },
        {
          "name": "R. Minetto",
          "h_index": 2,
          "profile_url": "https://www.semanticscholar.org/author/2286444029"
        },
        {
          "name": "Myriam Delgado",
          "h_index": 2,
          "profile_url": "https://www.semanticscholar.org/author/2347053430"
        },
        {
          "name": "B. Nassu",
          "h_index": 11,
          "profile_url": "https://www.semanticscholar.org/author/2434388"
        },
        {
          "name": "Thiago H. Silva",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2378095972"
        }
      ]
    },
    {
      "id": "2508.16874",
      "title": "UM3: Unsupervised Map to Map Matching",
      "authors": [
        "Chaolong Ying",
        "Yinan Zhang",
        "Lei Zhang",
        "Jiazhuang Wang",
        "Shujun Jia",
        "Tianshu Yu"
      ],
      "categories": [
        "cs.LG (Machine Learning)",
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Map-to-map matching is a critical task for aligning spatial data across\nheterogeneous sources, yet it remains challenging due to the lack of ground\ntruth correspondences, sparse node features, and scalability demands. In this\npaper, we propose an unsupervised graph-based framework that addresses these\nchallenges through three key innovations. First, our method is an unsupervised\nlearning approach that requires no training data, which is crucial for\nlarge-scale map data where obtaining labeled training samples is challenging.\nSecond, we introduce pseudo coordinates that capture the relative spatial\nlayout of nodes within each map, which enhances feature discriminability and\nenables scale-invariant learning. Third, we design an mechanism to adaptively\nbalance feature and geometric similarity, as well as a geometric-consistent\nloss function, ensuring robustness to noisy or incomplete coordinate data. At\nthe implementation level, to handle large-scale maps, we develop a tile-based\npost-processing pipeline with overlapping regions and majority voting, which\nenables parallel processing while preserving boundary coherence. Experiments on\nreal-world datasets demonstrate that our method achieves state-of-the-art\naccuracy in matching tasks, surpassing existing methods by a large margin,\nparticularly in high-noise and large-scale scenarios. Our framework provides a\nscalable and practical solution for map alignment, offering a robust and\nefficient alternative to traditional approaches.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16874v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16874v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.3,
      "weak_supervision_score": 0.376,
      "diffusion_reasoning_score": 0.336,
      "distributed_training_score": 0.305,
      "datasets_score": 0.302,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16876",
      "title": "Dream to Chat: Model-based Reinforcement Learning on Dialogues with User\n  Belief Modeling",
      "authors": [
        "Yue Zhao",
        "Xiaoyu Wang",
        "Dan Wang",
        "Zhonglin Jiang",
        "Qingqing Gu",
        "Teng Chen",
        "Ningyuan Xi",
        "Jinxian Qu",
        "Yong Chen",
        "Luo Ji"
      ],
      "categories": [
        "cs.CL (Computation and Language)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "World models have been widely utilized in robotics, gaming, and auto-driving.\nHowever, their applications on natural language tasks are relatively limited.\nIn this paper, we construct the dialogue world model, which could predict the\nuser's emotion, sentiment, and intention, and future utterances. By defining a\nPOMDP, we argue emotion, sentiment and intention can be modeled as the user\nbelief and solved by maximizing the information bottleneck. By this user belief\nmodeling, we apply the model-based reinforcement learning framework to the\ndialogue system, and propose a framework called DreamCUB. Experiments show that\nthe pretrained dialogue world model can achieve state-of-the-art performances\non emotion classification and sentiment identification, while dialogue quality\nis also enhanced by joint training of the policy, critic and dialogue world\nmodel. Further analysis shows that this manner holds a reasonable\nexploration-exploitation balance and also transfers well to out-of-domain\nscenarios such as empathetic dialogues.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16876v2",
      "pdf_url": "http://arxiv.org/pdf/2508.16876v2",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.444,
      "weak_supervision_score": 0.356,
      "diffusion_reasoning_score": 0.442,
      "distributed_training_score": 0.333,
      "datasets_score": 0.291,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Tangentially Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper discusses reinforcement learning in dialogue systems and mentions RLHF in the introduction as a background technique, but its main contribution is a model-based RL framework (DreamCUB) that uses a dialogue world model and user belief modeling, without explicitly relying on human feedback for reward modeling or training. While it addresses RL challenges, it does not center on training with human-ranked data, making it only loosely connected to RLHF.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on model-based reinforcement learning for dialogue systems, including user belief modeling and POMDP, but does not involve diffusion models, iterative refinement processes, or multi-step logical reasoning as described in the topic. There is no mention of adapting diffusion for Chain-of-Thought or similar tasks.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16881",
      "title": "AWM-Fuse: Multi-Modality Image Fusion for Adverse Weather via Global and\n  Local Text Perception",
      "authors": [
        "Xilai Li",
        "Huichun Liu",
        "Xiaosong Li",
        "Tao Ye",
        "Zhenyu Kuang",
        "Huafeng Li"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Multi-modality image fusion (MMIF) in adverse weather aims to address the\nloss of visual information caused by weather-related degradations, providing\nclearer scene representations. Although less studies have attempted to\nincorporate textual information to improve semantic perception, they often lack\neffective categorization and thorough analysis of textual content. In response,\nwe propose AWM-Fuse, a novel fusion method for adverse weather conditions,\ndesigned to handle multiple degradations through global and local text\nperception within a unified, shared weight architecture. In particular, a\nglobal feature perception module leverages BLIP-produced captions to extract\noverall scene features and identify primary degradation types, thus promoting\ngeneralization across various adverse weather conditions. Complementing this,\nthe local module employs detailed scene descriptions produced by ChatGPT to\nconcentrate on specific degradation effects through concrete textual cues,\nthereby capturing finer details. Furthermore, textual descriptions are used to\nconstrain the generation of fusion images, effectively steering the network\nlearning process toward better alignment with real semantic labels, thereby\npromoting the learning of more meaningful visual features. Extensive\nexperiments demonstrate that AWM-Fuse outperforms current state-of-the-art\nmethods in complex weather conditions and downstream tasks. Our code is\navailable at https://github.com/Feecuin/AWM-Fuse.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16881v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16881v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "extraction_failed",
      "embedding_status": "completed",
      "rlhf_score": 0.305,
      "weak_supervision_score": 0.338,
      "diffusion_reasoning_score": 0.419,
      "distributed_training_score": 0.262,
      "datasets_score": 0.289,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper's main contribution is a method for multi-modality image fusion using textual perception from models like BLIP and ChatGPT to handle adverse weather conditions. It does not involve diffusion models, iterative refinement for logical tasks, or any form of multi-step reasoning process as defined in the topic. Therefore, there is no connection to diffusion-based reasoning.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16882",
      "title": "Multimodal Medical Endoscopic Image Analysis via Progressive\n  Disentangle-aware Contrastive Learning",
      "authors": [
        "Junhao Wu",
        "Yun Li",
        "Junhao Li",
        "Jingliang Bian",
        "Xiaomao Fan",
        "Wenbin Lei",
        "Ruxin Wang"
      ],
      "categories": [
        "eess.IV (Image and Video Processing)",
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Accurate segmentation of laryngo-pharyngeal tumors is crucial for precise\ndiagnosis and effective treatment planning. However, traditional\nsingle-modality imaging methods often fall short of capturing the complex\nanatomical and pathological features of these tumors. In this study, we present\nan innovative multi-modality representation learning framework based on the\n`Align-Disentangle-Fusion' mechanism that seamlessly integrates 2D White Light\nImaging (WLI) and Narrow Band Imaging (NBI) pairs to enhance segmentation\nperformance. A cornerstone of our approach is multi-scale distribution\nalignment, which mitigates modality discrepancies by aligning features across\nmultiple transformer layers. Furthermore, a progressive feature disentanglement\nstrategy is developed with the designed preliminary disentanglement and\ndisentangle-aware contrastive learning to effectively separate\nmodality-specific and shared features, enabling robust multimodal contrastive\nlearning and efficient semantic fusion. Comprehensive experiments on multiple\ndatasets demonstrate that our method consistently outperforms state-of-the-art\napproaches, achieving superior accuracy across diverse real clinical scenarios.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16882v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16882v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.319,
      "weak_supervision_score": 0.356,
      "diffusion_reasoning_score": 0.384,
      "distributed_training_score": 0.346,
      "datasets_score": 0.329,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16884",
      "title": "A Lightweight Convolution and Vision Transformer integrated model with\n  Multi-scale Self-attention Mechanism",
      "authors": [
        "Yi Zhang",
        "Lingxiao Wei",
        "Bowei Zhang",
        "Ziwei Liu",
        "Kai Yi",
        "Shu Hu"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.NE (Neural and Evolutionary Computing)"
      ],
      "abstract": "Vision Transformer (ViT) has prevailed in computer vision tasks due to its\nstrong long-range dependency modelling ability. \\textcolor{blue}{However, its\nlarge model size and weak local feature modeling ability hinder its application\nin real scenarios. To balance computation efficiency and performance in\ndownstream vision tasks, we propose an efficient ViT model with sparse\nattention (dubbed SAEViT) and convolution blocks. Specifically, a Sparsely\nAggregated Attention (SAA) module has been proposed to perform adaptive sparse\nsampling and recover the feature map via deconvolution operation,} which\nsignificantly reduces the computational complexity of attention operations. In\naddition, a Channel-Interactive Feed-Forward Network (CIFFN) layer is developed\nto enhance inter-channel information exchange through feature decomposition and\nredistribution, which mitigates the redundancy in traditional feed-forward\nnetworks (FFN). Finally, a hierarchical pyramid structure with embedded\ndepth-wise separable convolutional blocks (DWSConv) is devised to further\nstrengthen convolutional features. Extensive experiments on mainstream datasets\nshow that SAEViT achieves Top-1 accuracies of 76.3\\% and 79.6\\% on the\nImageNet-1K classification task with only 0.8 GFLOPs and 1.3 GFLOPs,\nrespectively, demonstrating a lightweight solution for fundamental vision\ntasks.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16884v2",
      "pdf_url": "http://arxiv.org/pdf/2508.16884v2",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.319,
      "weak_supervision_score": 0.322,
      "diffusion_reasoning_score": 0.406,
      "distributed_training_score": 0.378,
      "datasets_score": 0.325,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper proposes a lightweight Vision Transformer model with sparse attention and convolutional features for computer vision tasks, focusing on efficiency in image classification, detection, and segmentation. It does not involve diffusion models, iterative refinement processes, or multi-step logical reasoning for complex tasks, as defined by the topic. Therefore, there is no connection to diffusion-based reasoning.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16887",
      "title": "MDIQA: Unified Image Quality Assessment for Multi-dimensional Evaluation\n  and Restoration",
      "authors": [
        "Shunyu Yao",
        "Ming Liu",
        "Zhilu Zhang",
        "Zhaolin Wan",
        "Zhilong Ji",
        "Jinfeng Bai",
        "Wangmeng Zuo"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "eess.IV (Image and Video Processing)"
      ],
      "abstract": "Recent advancements in image quality assessment (IQA), driven by\nsophisticated deep neural network designs, have significantly improved the\nability to approach human perceptions. However, most existing methods are\nobsessed with fitting the overall score, neglecting the fact that humans\ntypically evaluate image quality from different dimensions before arriving at\nan overall quality assessment. To overcome this problem, we propose a\nmulti-dimensional image quality assessment (MDIQA) framework. Specifically, we\nmodel image quality across various perceptual dimensions, including five\ntechnical and four aesthetic dimensions, to capture the multifaceted nature of\nhuman visual perception within distinct branches. Each branch of our MDIQA is\ninitially trained under the guidance of a separate dimension, and the\nrespective features are then amalgamated to generate the final IQA score.\nAdditionally, when the MDIQA model is ready, we can deploy it for a flexible\ntraining of image restoration (IR) models, enabling the restoration results to\nbetter align with varying user preferences through the adjustment of perceptual\ndimension weights. Extensive experiments demonstrate that our MDIQA achieves\nsuperior performance and can be effectively and flexibly applied to image\nrestoration tasks. The code is available: https://github.com/YaoShunyu19/MDIQA.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16887v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16887v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.363,
      "weak_supervision_score": 0.337,
      "diffusion_reasoning_score": 0.4,
      "distributed_training_score": 0.31,
      "datasets_score": 0.364,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on a multi-dimensional image quality assessment framework for evaluating and restoring images, using deep neural networks to model perceptual dimensions. It does not involve diffusion models, iterative refinement for logical tasks, or any form of chain-of-thought reasoning. Therefore, it has no connection to diffusion-based reasoning.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16897",
      "title": "Generating Synthetic Contrast-Enhanced Chest CT Images from Non-Contrast\n  Scans Using Slice-Consistent Brownian Bridge Diffusion Network",
      "authors": [
        "Pouya Shiri",
        "Xin Yi",
        "Neel P. Mistry",
        "Samaneh Javadinia",
        "Mohammad Chegini",
        "Seok-Bum Ko",
        "Amirali Baniasadi",
        "Scott J. Adams"
      ],
      "categories": [
        "eess.IV (Image and Video Processing)",
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Contrast-enhanced computed tomography (CT) imaging is essential for\ndiagnosing and monitoring thoracic diseases, including aortic pathologies.\nHowever, contrast agents pose risks such as nephrotoxicity and allergic-like\nreactions. The ability to generate high-fidelity synthetic contrast-enhanced CT\nangiography (CTA) images without contrast administration would be\ntransformative, enhancing patient safety and accessibility while reducing\nhealthcare costs. In this study, we propose the first bridge diffusion-based\nsolution for synthesizing contrast-enhanced CTA images from non-contrast CT\nscans. Our approach builds on the Slice-Consistent Brownian Bridge Diffusion\nModel (SC-BBDM), leveraging its ability to model complex mappings while\nmaintaining consistency across slices. Unlike conventional slice-wise synthesis\nmethods, our framework preserves full 3D anatomical integrity while operating\nin a high-resolution 2D fashion, allowing seamless volumetric interpretation\nunder a low memory budget. To ensure robust spatial alignment, we implement a\ncomprehensive preprocessing pipeline that includes resampling, registration\nusing the Symmetric Normalization method, and a sophisticated dilated\nsegmentation mask to extract the aorta and surrounding structures. We create\ntwo datasets from the Coltea-Lung dataset: one containing only the aorta and\nanother including both the aorta and heart, enabling a detailed analysis of\nanatomical context. We compare our approach against baseline methods on both\ndatasets, demonstrating its effectiveness in preserving vascular structures\nwhile enhancing contrast fidelity.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16897v2",
      "pdf_url": "http://arxiv.org/pdf/2508.16897v2",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.262,
      "weak_supervision_score": 0.331,
      "diffusion_reasoning_score": 0.472,
      "distributed_training_score": 0.303,
      "datasets_score": 0.32,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on using a Slice-Consistent Brownian Bridge Diffusion Model for synthesizing contrast-enhanced CT images from non-contrast scans, emphasizing image generation and anatomical fidelity in medical imaging. It does not involve adapting diffusion models for multi-step logical reasoning, chain-of-thought processes, or solving complex logical tasks. Since the core contribution is generative image synthesis rather than reasoning, it does not align with the topic.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16905",
      "title": "Tri-Accel: Curvature-Aware Precision-Adaptive and Memory-Elastic\n  Optimization for Efficient GPU Usage",
      "authors": [
        "Mohsen Sheibanian",
        "Pouya Shaeri",
        "Alimohammad Beigi",
        "Ryan T. Woo",
        "Aryan Keluskar"
      ],
      "categories": [
        "cs.LG (Machine Learning)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Deep neural networks are increasingly bottlenecked by the cost of\noptimization, both in terms of GPU memory and compute time. Existing\nacceleration techniques, such as mixed precision, second-order methods, and\nbatch size scaling, are typically used in isolation. We present Tri-Accel, a\nunified optimization framework that co-adapts three acceleration strategies\nalong with adaptive parameters during training: (1) Precision-Adaptive Updates\nthat dynamically assign mixed-precision levels to layers based on curvature and\ngradient variance; (2) Sparse Second-Order Signals that exploit Hessian/Fisher\nsparsity patterns to guide precision and step size decisions; and (3)\nMemory-Elastic Batch Scaling that adjusts batch size in real time according to\nVRAM availability. On CIFAR-10 with ResNet-18 and EfficientNet-B0, Tri-Accel\nachieves up to 9.9% reduction in training time and 13.3% lower memory usage,\nwhile improving accuracy by +1.1 percentage points over FP32 baselines. Tested\non CIFAR-10/100, our approach demonstrates adaptive learning behavior, with\nefficiency gradually improving over the course of training as the system learns\nto allocate resources more effectively. Compared to static mixed-precision\ntraining, Tri-Accel maintains 78.1% accuracy while reducing memory footprint\nfrom 0.35GB to 0.31GB on standard hardware. The framework is implemented with\ncustom Triton kernels, whose hardware-aware adaptation enables automatic\noptimization without manual hyperparameter tuning, making it practical for\ndeployment across diverse computational environments. This work demonstrates\nhow algorithmic adaptivity and hardware awareness can be combined to improve\nscalability in resource-constrained settings, paving the way for more efficient\nneural network training on edge devices and cost-sensitive cloud deployments.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16905v2",
      "pdf_url": "http://arxiv.org/pdf/2508.16905v2",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.378,
      "weak_supervision_score": 0.39,
      "diffusion_reasoning_score": 0.363,
      "distributed_training_score": 0.553,
      "datasets_score": 0.327,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "Tangentially Relevant",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "The paper's main contribution is a unified optimization framework for efficient GPU usage on single devices, focusing on adaptive precision, second-order signals, and dynamic batch sizing. While it mentions hardware scalability and references distributed approaches in the background, it does not directly address distributed training, parallel computing across multiple nodes, or strategies for partitioning data/computation. Thus, its relevance is indirect, as efficiency gains could potentially support distributed systems, but it is not the core focus.",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16911",
      "title": "MDD: A Dataset for Text-and-Music Conditioned Duet Dance Generation",
      "authors": [
        "Prerit Gupta",
        "Jason Alexander Fotso-Puepi",
        "Zhengyuan Li",
        "Jay Mehta",
        "Aniket Bera"
      ],
      "categories": [
        "cs.GR (Graphics)",
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.MM (Multimedia)",
        "cs.SD (Sound)"
      ],
      "abstract": "We introduce Multimodal DuetDance (MDD), a diverse multimodal benchmark\ndataset designed for text-controlled and music-conditioned 3D duet dance motion\ngeneration. Our dataset comprises 620 minutes of high-quality motion capture\ndata performed by professional dancers, synchronized with music, and detailed\nwith over 10K fine-grained natural language descriptions. The annotations\ncapture a rich movement vocabulary, detailing spatial relationships, body\nmovements, and rhythm, making MDD the first dataset to seamlessly integrate\nhuman motions, music, and text for duet dance generation. We introduce two\nnovel tasks supported by our dataset: (1) Text-to-Duet, where given music and a\ntextual prompt, both the leader and follower dance motion are generated (2)\nText-to-Dance Accompaniment, where given music, textual prompt, and the\nleader's motion, the follower's motion is generated in a cohesive, text-aligned\nmanner. We include baseline evaluations on both tasks to support future\nresearch.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16911v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16911v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.288,
      "weak_supervision_score": 0.289,
      "diffusion_reasoning_score": 0.369,
      "distributed_training_score": 0.311,
      "datasets_score": 0.448,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "Highly Relevant",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "The paper's main contribution is the introduction of a new dataset, MDD, for AI applications in motion generation. It covers dataset creation through motion capture data collection, curation with over 10K fine-grained annotations, and benchmarking via two novel tasks, directly aligning with research on creating, analyzing, and evaluating datasets for machine learning.",
      "llm_score_status": "completed",
      "summary": "The paper introduces the Multimodal DuetDance (MDD) dataset, which consists of over 620 minutes of high-quality motion capture data from professional dancers, synchronized with music and annotated with more than 10,000 detailed natural language descriptions across 15 dance genres. It aims to advance text-controlled and music-conditioned 3D duet dance generation by supporting two novel tasks—Text-to-Duet, which generates synchronized motions for both dancers from text and music, and Text-to-Dance Accompaniment, which creates the follower's motion based on the leader's motion, text, and music—while providing baseline evaluations to facilitate future research in interactive motion synthesis.",
      "novelty_score": "High",
      "novelty_justification": "The paper introduces a truly new dataset and two novel tasks for duet dance generation, integrating text, music, and motion in a way that significantly advances the state-of-the-art in interactive human motion synthesis.",
      "impact_score": "Moderate",
      "impact_justification": "The work is likely to be cited and built upon within subfields like computer graphics and computer vision, as it provides a specialized benchmark for multi-modal dance generation, though its influence may be limited to niche applications.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "This paper represents a strong contribution by introducing a new dataset and tasks that advance research in dance generation, making it essential for specialists in AI and multimedia to be aware of for potential applications in motion synthesis.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/6d10287a6d2d4eb0d74557121fd624d9e5381c3b",
      "total_authors": 5,
      "authors_found": 5,
      "highest_h_index": 5,
      "average_h_index": 1.8,
      "notable_authors_count": 0,
      "author_h_indexes": [
        {
          "name": "Prerit Gupta",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2232597701"
        },
        {
          "name": "Jason Alexander Fotso-Puepi",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2306785000"
        },
        {
          "name": "Zhengyuan Li",
          "h_index": 2,
          "profile_url": "https://www.semanticscholar.org/author/2328381420"
        },
        {
          "name": "Jay Mehta",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2376532245"
        },
        {
          "name": "Aniket Bera",
          "h_index": 5,
          "profile_url": "https://www.semanticscholar.org/author/2248354403"
        }
      ]
    },
    {
      "id": "2508.16917",
      "title": "Structural Energy-Guided Sampling for View-Consistent Text-to-3D",
      "authors": [
        "Qing Zhang",
        "Jinguang Tong",
        "Jie Hong",
        "Jing Zhang",
        "Xuesong Li"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Text-to-3D generation often suffers from the Janus problem, where objects\nlook correct from the front but collapse into duplicated or distorted geometry\nfrom other angles. We attribute this failure to viewpoint bias in 2D diffusion\npriors, which propagates into 3D optimization. To address this, we propose\nStructural Energy-Guided Sampling (SEGS), a training-free, plug-and-play\nframework that enforces multi-view consistency entirely at sampling time. SEGS\ndefines a structural energy in a PCA subspace of intermediate U-Net features\nand injects its gradients into the denoising trajectory, steering geometry\ntoward the intended viewpoint while preserving appearance fidelity. Integrated\nseamlessly into SDS/VSD pipelines, SEGS significantly reduces Janus artifacts,\nachieving improved geometric alignment and viewpoint consistency without\nretraining or weight modification.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16917v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16917v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "extraction_failed",
      "embedding_status": "completed",
      "rlhf_score": 0.296,
      "weak_supervision_score": 0.322,
      "diffusion_reasoning_score": 0.426,
      "distributed_training_score": 0.303,
      "datasets_score": 0.276,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper's main contribution is a method for improving multi-view consistency in text-to-3D generation using diffusion models, focusing on iterative refinement for geometric alignment. It does not involve adapting diffusion for multi-step logical reasoning, chain-of-thought processes, or solving complex logical tasks, which are required for this topic.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16922",
      "title": "MSPCaps: A Multi-Scale Patchify Capsule Network with Cross-Agreement\n  Routing for Visual Recognition",
      "authors": [
        "Yudong Hu",
        "Yueju Han",
        "Rui Sun",
        "Jinke Ren"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Capsule Network (CapsNet) has demonstrated significant potential in visual\nrecognition by capturing spatial relationships and part-whole hierarchies for\nlearning equivariant feature representations. However, existing CapsNet and\nvariants often rely on a single high-level feature map, overlooking the rich\ncomplementary information from multi-scale features. Furthermore, conventional\nfeature fusion strategies (e.g., addition and concatenation) struggle to\nreconcile multi-scale feature discrepancies, leading to suboptimal\nclassification performance. To address these limitations, we propose the\nMulti-Scale Patchify Capsule Network (MSPCaps), a novel architecture that\nintegrates multi-scale feature learning and efficient capsule routing.\nSpecifically, MSPCaps consists of three key components: a Multi-Scale ResNet\nBackbone (MSRB), a Patchify Capsule Layer (PatchifyCaps), and Cross-Agreement\nRouting (CAR) blocks. First, the MSRB extracts diverse multi-scale feature\nrepresentations from input images, preserving both fine-grained details and\nglobal contextual information. Second, the PatchifyCaps partitions these\nmulti-scale features into primary capsules using a uniform patch size,\nequipping the model with the ability to learn from diverse receptive fields.\nFinally, the CAR block adaptively routes the multi-scale capsules by\nidentifying cross-scale prediction pairs with maximum agreement. Unlike the\nsimple concatenation of multiple self-routing blocks, CAR ensures that only the\nmost coherent capsules contribute to the final voting. Our proposed MSPCaps\nachieves remarkable scalability and superior robustness, consistently\nsurpassing multiple baseline methods in terms of classification accuracy, with\nconfigurations ranging from a highly efficient Tiny model (344.3K parameters)\nto a powerful Large model (10.9M parameters), highlighting its potential in\nadvancing feature representation learning.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16922v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16922v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "extraction_failed",
      "embedding_status": "completed",
      "rlhf_score": 0.257,
      "weak_supervision_score": 0.306,
      "diffusion_reasoning_score": 0.327,
      "distributed_training_score": 0.358,
      "datasets_score": 0.309,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16926",
      "title": "TextOnly: A Unified Function Portal for Text-Related Functions on\n  Smartphones",
      "authors": [
        "Minghao Tu",
        "Chun Yu",
        "Xiyuan Shen",
        "Zhi Zheng",
        "Li Chen",
        "Yuanchun Shi"
      ],
      "categories": [
        "cs.HC (Human-Computer Interaction)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Text boxes serve as portals to diverse functionalities in today's smartphone\napplications. However, when it comes to specific functionalities, users always\nneed to navigate through multiple steps to access particular text boxes for\ninput. We propose TextOnly, a unified function portal that enables users to\naccess text-related functions from various applications by simply inputting\ntext into a sole text box. For instance, entering a restaurant name could\ntrigger a Google Maps search, while a greeting could initiate a conversation in\nWhatsApp. Despite their brevity, TextOnly maximizes the utilization of these\nraw text inputs, which contain rich information, to interpret user intentions\neffectively. TextOnly integrates large language models(LLM) and a BERT model.\nThe LLM consistently provides general knowledge, while the BERT model can\ncontinuously learn user-specific preferences and enable quicker predictions.\nReal-world user studies demonstrated TextOnly's effectiveness with a top-1\naccuracy of 71.35%, and its ability to continuously improve both its accuracy\nand inference speed. Participants perceived TextOnly as having satisfactory\nusability and expressed a preference for TextOnly over manual executions.\nCompared with voice assistants, TextOnly supports a greater range of\ntext-related functions and allows for more concise inputs.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16926v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16926v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.335,
      "weak_supervision_score": 0.349,
      "diffusion_reasoning_score": 0.377,
      "distributed_training_score": 0.285,
      "datasets_score": 0.266,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16927",
      "title": "LGE-Guided Cross-Modality Contrastive Learning for Gadolinium-Free\n  Cardiomyopathy Screening in Cine CMR",
      "authors": [
        "Siqing Yuan",
        "Yulin Wang",
        "Zirui Cao",
        "Yueyan Wang",
        "Zehao Weng",
        "Hui Wang",
        "Lei Xu",
        "Zixian Chen",
        "Lei Chen",
        "Zhong Xue",
        "Dinggang Shen"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Cardiomyopathy, a principal contributor to heart failure and sudden cardiac\nmortality, demands precise early screening. Cardiac Magnetic Resonance (CMR),\nrecognized as the diagnostic 'gold standard' through multiparametric protocols,\nholds the potential to serve as an accurate screening tool. However, its\nreliance on gadolinium contrast and labor-intensive interpretation hinders\npopulation-scale deployment. We propose CC-CMR, a Contrastive Learning and\nCross-Modal alignment framework for gadolinium-free cardiomyopathy screening\nusing cine CMR sequences. By aligning the latent spaces of cine CMR and Late\nGadolinium Enhancement (LGE) sequences, our model encodes fibrosis-specific\npathology into cine CMR embeddings. A Feature Interaction Module concurrently\noptimizes diagnostic precision and cross-modal feature congruence, augmented by\nan uncertainty-guided adaptive training mechanism that dynamically calibrates\ntask-specific objectives to ensure model generalizability. Evaluated on\nmulti-center data from 231 subjects, CC-CMR achieves accuracy of 0.943 (95% CI:\n0.886-0.986), outperforming state-of-the-art cine-CMR-only models by 4.3% while\neliminating gadolinium dependency, demonstrating its clinical viability for\nwide range of populations and healthcare environments.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16927v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16927v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.319,
      "weak_supervision_score": 0.33,
      "diffusion_reasoning_score": 0.368,
      "distributed_training_score": 0.344,
      "datasets_score": 0.31,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16930",
      "title": "HunyuanVideo-Foley: Multimodal Diffusion with Representation Alignment\n  for High-Fidelity Foley Audio Generation",
      "authors": [
        "Sizhe Shan",
        "Qiulin Li",
        "Yutao Cui",
        "Miles Yang",
        "Yuehai Wang",
        "Qun Yang",
        "Jin Zhou",
        "Zhao Zhong"
      ],
      "categories": [
        "eess.AS (Audio and Speech Processing)",
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.SD (Sound)"
      ],
      "abstract": "Recent advances in video generation produce visually realistic content, yet\nthe absence of synchronized audio severely compromises immersion. To address\nkey challenges in video-to-audio generation, including multimodal data\nscarcity, modality imbalance and limited audio quality in existing methods, we\npropose HunyuanVideo-Foley, an end-to-end text-video-to-audio framework that\nsynthesizes high-fidelity audio precisely aligned with visual dynamics and\nsemantic context. Our approach incorporates three core innovations: (1) a\nscalable data pipeline curating 100k-hour multimodal datasets through automated\nannotation; (2) a representation alignment strategy using self-supervised audio\nfeatures to guide latent diffusion training, efficiently improving audio\nquality and generation stability; (3) a novel multimodal diffusion transformer\nresolving modal competition, containing dual-stream audio-video fusion through\njoint attention, and textual semantic injection via cross-attention.\nComprehensive evaluations demonstrate that HunyuanVideo-Foley achieves new\nstate-of-the-art performance across audio fidelity, visual-semantic alignment,\ntemporal alignment and distribution matching. The demo page is available at:\nhttps://szczesnys.github.io/hunyuanvideo-foley/.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16930v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16930v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.384,
      "weak_supervision_score": 0.341,
      "diffusion_reasoning_score": 0.478,
      "distributed_training_score": 0.325,
      "datasets_score": 0.331,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on using diffusion models for multimodal audio generation from text and video inputs, specifically for synthesizing high-fidelity Foley audio. It employs techniques like Multimodal Diffusion Transformer (MMDiT) for generative tasks involving visual and semantic alignment, but does not adapt diffusion for multi-step logical reasoning, Chain-of-Thought processing, or solving complex logical tasks. The core contributions are in audio synthesis and representation alignment, with no components related to holistic correction of reasoning paths.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16931",
      "title": "Degree of Staleness-Aware Data Updating in Federated Learning",
      "authors": [
        "Tao Liu",
        "Xuehe Wang"
      ],
      "categories": [
        "cs.LG (Machine Learning)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Handling data staleness remains a significant challenge in federated learning\nwith highly time-sensitive tasks, where data is generated continuously and data\nstaleness largely affects model performance. Although recent works attempt to\noptimize data staleness by determining local data update frequency or client\nselection strategy, none of them explore taking both data staleness and data\nvolume into consideration. In this paper, we propose DUFL(Data Updating in\nFederated Learning), an incentive mechanism featuring an innovative local data\nupdate scheme manipulated by three knobs: the server's payment, outdated data\nconservation rate, and clients' fresh data collection volume, to coordinate\nstaleness and volume of local data for best utilities. To this end, we\nintroduce a novel metric called DoS(the Degree of Staleness) to quantify data\nstaleness and conduct a theoretic analysis illustrating the quantitative\nrelationship between DoS and model performance. We model DUFL as a two-stage\nStackelberg game with dynamic constraint, deriving the optimal local data\nupdate strategy for each client in closed-form and the approximately optimal\nstrategy for the server. Experimental results on real-world datasets\ndemonstrate the significant performance of our approach.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16931v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16931v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.392,
      "weak_supervision_score": 0.367,
      "diffusion_reasoning_score": 0.328,
      "distributed_training_score": 0.44,
      "datasets_score": 0.343,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "Moderately Relevant",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "The paper focuses on federated learning, which is a subset of distributed training, as it involves training models across multiple clients without centralizing data. However, its main contributions—such as the DUFL mechanism, Degree of Staleness metric, and incentive design—primarily address data staleness and optimization in federated settings rather than core aspects of distributed training like partitioning computation, parallel processing, or accelerating training across nodes. Thus, it is relevant but not central to the broader topic.",
      "datasets_justification": "below_threshold",
      "llm_score_status": "completed",
      "summary": "The paper, titled \"Degree of Staleness-Aware Data Updating in Federated Learning,\" addresses the challenges of data staleness and volume in time-sensitive federated learning tasks by proposing DUFL, an incentive mechanism that incorporates a new metric called Degree of Staleness (DoS) to quantify data freshness. It models the problem as a two-stage Stackelberg game, where the server optimizes payment and data conservation rates while clients determine fresh data collection strategies, ultimately deriving optimal strategies through theoretical analysis and demonstrating significant performance improvements via experiments on real-world datasets.",
      "novelty_score": "Moderate",
      "novelty_justification": "The paper presents a notable improvement by introducing the DoS metric and combining it with an incentive mechanism in federated learning, offering a clever integration of existing ideas to address data staleness and volume more effectively. However, it builds on known problems in federated learning rather than introducing a entirely new paradigm.",
      "impact_score": "Moderate",
      "impact_justification": "The work is likely to be cited and built upon in subfields of federated learning, particularly for time-sensitive applications like IoT and autonomous vehicles, due to its practical framework for handling data staleness. Nonetheless, its influence may be limited to specific scenarios rather than broadly transforming the field.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "This paper represents a strong, valuable contribution to federated learning by addressing key challenges with an innovative mechanism, making it essential for researchers focused on AI and machine learning in time-sensitive contexts. While not groundbreaking enough to be a must-read, it provides useful insights and strategies worth considering.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/5417c521c758043488b94223571d9207137ecee0",
      "total_authors": 2,
      "authors_found": 2,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": [
        {
          "name": "Tao Liu",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2378528267"
        },
        {
          "name": "Xuehe Wang",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2376543548"
        }
      ]
    },
    {
      "id": "2508.16932",
      "title": "Align 3D Representation and Text Embedding for 3D Content\n  Personalization",
      "authors": [
        "Qi Song",
        "Ziyuan Luo",
        "Ka Chun Cheung",
        "Simon See",
        "Renjie Wan"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Recent advances in NeRF and 3DGS have significantly enhanced the efficiency\nand quality of 3D content synthesis. However, efficient personalization of\ngenerated 3D content remains a critical challenge. Current 3D personalization\napproaches predominantly rely on knowledge distillation-based methods, which\nrequire computationally expensive retraining procedures. To address this\nchallenge, we propose \\textbf{Invert3D}, a novel framework for convenient 3D\ncontent personalization. Nowadays, vision-language models such as CLIP enable\ndirect image personalization through aligned vision-text embedding spaces.\nHowever, the inherent structural differences between 3D content and 2D images\npreclude direct application of these techniques to 3D personalization. Our\napproach bridges this gap by establishing alignment between 3D representations\nand text embedding spaces. Specifically, we develop a camera-conditioned\n3D-to-text inverse mechanism that projects 3D contents into a 3D embedding\naligned with text embeddings. This alignment enables efficient manipulation and\npersonalization of 3D content through natural language prompts, eliminating the\nneed for computationally retraining procedures. Extensive experiments\ndemonstrate that Invert3D achieves effective personalization of 3D content. Our\nwork is available at: https://github.com/qsong2001/Invert3D.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16932v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16932v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "extraction_failed",
      "embedding_status": "completed",
      "rlhf_score": 0.374,
      "weak_supervision_score": 0.266,
      "diffusion_reasoning_score": 0.371,
      "distributed_training_score": 0.312,
      "datasets_score": 0.286,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16934",
      "title": "Addressing Annotation Scarcity in Hyperspectral Brain Image Segmentation\n  with Unsupervised Domain Adaptation",
      "authors": [
        "Tim Mach",
        "Daniel Rueckert",
        "Alex Berger",
        "Laurin Lux",
        "Ivan Ezhov"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "This work presents a novel deep learning framework for segmenting cerebral\nvasculature in hyperspectral brain images. We address the critical challenge of\nsevere label scarcity, which impedes conventional supervised training. Our\napproach utilizes a novel unsupervised domain adaptation methodology, using a\nsmall, expert-annotated ground truth alongside unlabeled data. Quantitative and\nqualitative evaluations confirm that our method significantly outperforms\nexisting state-of-the-art approaches, demonstrating the efficacy of domain\nadaptation for label-scarce biomedical imaging tasks.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16934v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16934v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.319,
      "weak_supervision_score": 0.432,
      "diffusion_reasoning_score": 0.367,
      "distributed_training_score": 0.374,
      "datasets_score": 0.373,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "Moderately Relevant",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "The paper addresses annotation scarcity in hyperspectral image segmentation using unsupervised domain adaptation with a small expert-annotated dataset and unlabeled data, which reduces the need for extensive labeled data. This approach shares similarities with weak supervision by leveraging limited or indirect supervision, but it does not involve programmatically generating labels from high-level, noisy, or imprecise sources, focusing instead on domain adaptation techniques.",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "completed",
      "summary": "This paper introduces a novel deep learning framework for segmenting cerebral vasculature in hyperspectral brain images, addressing the challenge of limited annotated data through a novel unsupervised domain adaptation methodology that leverages a small set of expert-annotated samples alongside unlabeled data. The core objectives include improving segmentation accuracy and ensuring structural continuity of blood vessels, with the methodology involving advanced techniques like domain adaptation and dimensionality reduction; key findings show that this approach significantly outperforms existing state-of-the-art methods in quantitative and qualitative evaluations, demonstrating its efficacy for label-scarce biomedical imaging tasks.",
      "novelty_score": "Moderate",
      "novelty_justification": "The paper presents a notable improvement by applying unsupervised domain adaptation to hyperspectral brain image segmentation, cleverly combining existing ideas to address annotation scarcity in a new context. However, it builds on established techniques like domain adaptation rather than introducing a truly groundbreaking problem or architecture.",
      "impact_score": "Moderate",
      "impact_justification": "The work is likely to be cited and built upon in the subfield of medical image segmentation, particularly for hyperspectral imaging in neurosurgery, due to its practical approach to handling data scarcity. While it has potential applications in biomedical tasks, its influence may remain confined to specialized areas rather than broadly affecting general research or commercial fields.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "The paper offers a strong, valuable contribution to computer vision for medical imaging by effectively tackling annotation challenges, making it important for researchers in biomedical AI to be aware of this advancement. It is not essential for all readers but provides significant insights for those working in related domains.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/17776e367bc7dc4f2d7abe76bde8348fe1b16357",
      "total_authors": 5,
      "authors_found": 5,
      "highest_h_index": 8,
      "average_h_index": 5.0,
      "notable_authors_count": 3,
      "author_h_indexes": [
        {
          "name": "Tim Mach",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2376536004"
        },
        {
          "name": "Daniel Rueckert",
          "h_index": 8,
          "profile_url": "https://www.semanticscholar.org/author/2266407006"
        },
        {
          "name": "Alexander H. Berger",
          "h_index": 3,
          "profile_url": "https://www.semanticscholar.org/author/2290766844"
        },
        {
          "name": "Laurin Lux",
          "h_index": 7,
          "profile_url": "https://www.semanticscholar.org/author/1380153270"
        },
        {
          "name": "I. Ezhov",
          "h_index": 7,
          "profile_url": "https://www.semanticscholar.org/author/2249539189"
        }
      ]
    },
    {
      "id": "2508.16936",
      "title": "THEME: Enhancing Thematic Investing with Semantic Stock Representations\n  and Temporal Dynamics",
      "authors": [
        "Hoyoung Lee",
        "Wonbin Ahn",
        "Suhwan Park",
        "Jaehoon Lee",
        "Minjae Kim",
        "Sungdong Yoo",
        "Taeyoon Lim",
        "Woohyung Lim",
        "Yongjae Lee"
      ],
      "categories": [
        "cs.AI (Artificial Intelligence)",
        "cs.CL (Computation and Language)",
        "cs.IR (Information Retrieval)"
      ],
      "abstract": "Thematic investing, which aims to construct portfolios aligned with\nstructural trends, remains a challenging endeavor due to overlapping sector\nboundaries and evolving market dynamics. A promising direction is to build\nsemantic representations of investment themes from textual data. However,\ndespite their power, general-purpose LLM embedding models are not well-suited\nto capture the nuanced characteristics of financial assets, since the semantic\nrepresentation of investment assets may differ fundamentally from that of\ngeneral financial text. To address this, we introduce THEME, a framework that\nfine-tunes embeddings using hierarchical contrastive learning. THEME aligns\nthemes and their constituent stocks using their hierarchical relationship, and\nsubsequently refines these embeddings by incorporating stock returns. This\nprocess yields representations effective for retrieving thematically aligned\nassets with strong return potential. Empirical results demonstrate that THEME\nexcels in two key areas. For thematic asset retrieval, it significantly\noutperforms leading large language models. Furthermore, its constructed\nportfolios demonstrate compelling performance. By jointly modeling thematic\nrelationships from text and market dynamics from returns, THEME generates stock\nembeddings specifically tailored for a wide range of practical investment\napplications.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16936v2",
      "pdf_url": "http://arxiv.org/pdf/2508.16936v2",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.403,
      "weak_supervision_score": 0.351,
      "diffusion_reasoning_score": 0.39,
      "distributed_training_score": 0.345,
      "datasets_score": 0.369,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper introduces THEME, a framework for thematic investing using hierarchical contrastive learning on textual data and stock returns, aimed at improving stock embeddings for financial applications. It does not involve reinforcement learning, human feedback, reward models, or any mechanism for aligning AI with human preferences. Contrastive learning is a self-supervised technique, distinct from reinforcement learning, making the paper unrelated to RLHF.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16937",
      "title": "NAT: Learning to Attack Neurons for Enhanced Adversarial Transferability",
      "authors": [
        "Krishna Kanth Nakka",
        "Alexandre Alahi"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "The generation of transferable adversarial perturbations typically involves\ntraining a generator to maximize embedding separation between clean and\nadversarial images at a single mid-layer of a source model. In this work, we\nbuild on this approach and introduce Neuron Attack for Transferability (NAT), a\nmethod designed to target specific neuron within the embedding. Our approach is\nmotivated by the observation that previous layer-level optimizations often\ndisproportionately focus on a few neurons representing similar concepts,\nleaving other neurons within the attacked layer minimally affected. NAT shifts\nthe focus from embedding-level separation to a more fundamental,\nneuron-specific approach. We find that targeting individual neurons effectively\ndisrupts the core units of the neural network, providing a common basis for\ntransferability across different models. Through extensive experiments on 41\ndiverse ImageNet models and 9 fine-grained models, NAT achieves fooling rates\nthat surpass existing baselines by over 14\\% in cross-model and 4\\% in\ncross-domain settings. Furthermore, by leveraging the complementary attacking\ncapabilities of the trained generators, we achieve impressive fooling rates\nwithin just 10 queries. Our code is available at:\nhttps://krishnakanthnakka.github.io/NAT/",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16937v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16937v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "extraction_failed",
      "embedding_status": "completed",
      "rlhf_score": 0.28,
      "weak_supervision_score": 0.283,
      "diffusion_reasoning_score": 0.335,
      "distributed_training_score": 0.318,
      "datasets_score": 0.266,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16942",
      "title": "HieroAction: Hierarchically Guided VLM for Fine-Grained Action Analysis",
      "authors": [
        "Junhao Wu",
        "Xiuer Gu",
        "Zhiying Li",
        "Yeying Jin",
        "Yunfeng Diao",
        "Zhiyu Li",
        "Zhenbo Song",
        "Xiaomei Zhang",
        "Zhaoxin Fan"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Evaluating human actions with clear and detailed feedback is important in\nareas such as sports, healthcare, and robotics, where decisions rely not only\non final outcomes but also on interpretable reasoning. However, most existing\nmethods provide only a final score without explanation or detailed analysis,\nlimiting their practical applicability. To address this, we introduce\nHieroAction, a vision-language model that delivers accurate and structured\nassessments of human actions. HieroAction builds on two key ideas: (1) Stepwise\nAction Reasoning, a tailored chain of thought process designed specifically for\naction assessment, which guides the model to evaluate actions step by step,\nfrom overall recognition through sub action analysis to final scoring, thus\nenhancing interpretability and structured understanding; and (2) Hierarchical\nPolicy Learning, a reinforcement learning strategy that enables the model to\nlearn fine grained sub action dynamics and align them with high level action\nquality, thereby improving scoring precision. The reasoning pathway structures\nthe evaluation process, while policy learning refines each stage through reward\nbased optimization. Their integration ensures accurate and interpretable\nassessments, as demonstrated by superior performance across multiple benchmark\ndatasets. Code will be released upon acceptance.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16942v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16942v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "extraction_failed",
      "embedding_status": "completed",
      "rlhf_score": 0.41,
      "weak_supervision_score": 0.321,
      "diffusion_reasoning_score": 0.406,
      "distributed_training_score": 0.281,
      "datasets_score": 0.305,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper describes Hierarchical Policy Learning as a reinforcement learning strategy with reward-based optimization for refining action assessments, but it does not mention using human-ranked data to train a reward model or aligning the model with human preferences. Since RLHF specifically requires human feedback, this does not qualify.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper introduces Stepwise Action Reasoning as a chain of thought process for action evaluation, but it does not involve diffusion models, iterative refinement for logical tasks, or treating the reasoning path as a holistically corrected entity over multiple steps. Thus, it lacks the core elements of diffusion-based reasoning.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16943",
      "title": "HumanoidVerse: A Versatile Humanoid for Vision-Language Guided\n  Multi-Object Rearrangement",
      "authors": [
        "Haozhuo Zhang",
        "Jingkai Sun",
        "Michele Caprio",
        "Jian Tang",
        "Shanghang Zhang",
        "Qiang Zhang",
        "Wei Pan"
      ],
      "categories": [
        "cs.RO (Robotics)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "We introduce HumanoidVerse, a novel framework for vision-language guided\nhumanoid control that enables a single physically simulated robot to perform\nlong-horizon, multi-object rearrangement tasks across diverse scenes. Unlike\nprior methods that operate in fixed settings with single-object interactions,\nour approach supports consecutive manipulation of multiple objects, guided only\nby natural language instructions and egocentric camera RGB observations.\nHumanoidVerse is trained via a multi-stage curriculum using a dual-teacher\ndistillation pipeline, enabling fluid transitions between sub-tasks without\nrequiring environment resets. To support this, we construct a large-scale\ndataset comprising 350 multi-object tasks spanning four room layouts. Extensive\nexperiments in the Isaac Gym simulator demonstrate that our method\nsignificantly outperforms prior state-of-the-art in both task success rate and\nspatial precision, and generalizes well to unseen environments and\ninstructions. Our work represents a key step toward robust, general-purpose\nhumanoid agents capable of executing complex, sequential tasks under real-world\nsensory constraints. The video visualization results can be found on the\nproject page: https://haozhuo-zhang.github.io/HumanoidVerse-project-page/.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16943v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16943v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.418,
      "weak_supervision_score": 0.327,
      "diffusion_reasoning_score": 0.397,
      "distributed_training_score": 0.362,
      "datasets_score": 0.349,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper introduces HumanoidVerse, a framework for vision-language guided humanoid control trained using goal-conditioned reinforcement learning with simulated rewards (e.g., adversarial motion and task rewards) and distilled via DAgger for imitation learning. It does not involve human feedback, such as training a reward model on human-ranked data or aligning the model with human preferences, which are core to RLHF. Thus, the paper's methods do not align with the definition of RLHF.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16947",
      "title": "Drive As You Like: Strategy-Level Motion Planning Based on A Multi-Head\n  Diffusion Model",
      "authors": [
        "Fan Ding",
        "Xuewen Luo",
        "Hwa Hui Tew",
        "Ruturaj Reddy",
        "Xikun Wang",
        "Junn Yong Loo"
      ],
      "categories": [
        "cs.RO (Robotics)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Recent advances in motion planning for autonomous driving have led to models\ncapable of generating high-quality trajectories. However, most existing\nplanners tend to fix their policy after supervised training, leading to\nconsistent but rigid driving behaviors. This limits their ability to reflect\nhuman preferences or adapt to dynamic, instruction-driven demands. In this\nwork, we propose a diffusion-based multi-head trajectory planner(M-diffusion\nplanner). During the early training stage, all output heads share weights to\nlearn to generate high-quality trajectories. Leveraging the probabilistic\nnature of diffusion models, we then apply Group Relative Policy Optimization\n(GRPO) to fine-tune the pre-trained model for diverse policy-specific\nbehaviors. At inference time, we incorporate a large language model (LLM) to\nguide strategy selection, enabling dynamic, instruction-aware planning without\nswitching models. Closed-loop simulation demonstrates that our post-trained\nplanner retains strong planning capability while achieving state-of-the-art\n(SOTA) performance on the nuPlan val14 benchmark. Open-loop results further\nshow that the generated trajectories exhibit clear diversity, effectively\nsatisfying multi-modal driving behavior requirements. The code and related\nexperiments will be released upon acceptance of the paper.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16947v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16947v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.467,
      "weak_supervision_score": 0.351,
      "diffusion_reasoning_score": 0.586,
      "distributed_training_score": 0.425,
      "datasets_score": 0.294,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Tangentially Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "Not Relevant",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper uses Group Relative Policy Optimization (GRPO), a reinforcement-based fine-tuning method to align trajectories with preferences, but it does not explicitly involve human feedback, such as ranking data to train a reward model. Instead, it fine-tunes on datasets like NuPlan, making it only loosely connected to RLHF.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper applies diffusion models for trajectory generation in autonomous driving, focusing on iterative refinement of motion plans, but it does not adapt diffusion for multi-step logical reasoning or treat a chain-of-thought as a holistic entity for correction.",
      "distributed_training_justification": "The paper does not discuss distributed training, parallel computing, or strategies for partitioning data/computation across multiple nodes; it focuses on model architecture, fine-tuning, and integration with LLMs for planning.",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16949",
      "title": "Breaking the Exploration Bottleneck: Rubric-Scaffolded Reinforcement\n  Learning for General LLM Reasoning",
      "authors": [
        "Yang Zhou",
        "Sunzhu Li",
        "Shunyu Liu",
        "Wenkai Fang",
        "Jiale Zhao",
        "Jingwen Yang",
        "Jianwei Lv",
        "Kongcheng Zhang",
        "Yihe Zhou",
        "Hengtong Lu",
        "Wei Chen",
        "Yan Xie",
        "Mingli Song"
      ],
      "categories": [
        "cs.LG (Machine Learning)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Recent advances in Large Language Models (LLMs) have underscored the\npotential of Reinforcement Learning (RL) to facilitate the emergence of\nreasoning capabilities. Despite the encouraging results, a fundamental dilemma\npersists as RL improvement relies on learning from high-quality samples, yet\nthe exploration for such samples remains bounded by the inherent limitations of\nLLMs. This, in effect, creates an undesirable cycle in which what cannot be\nexplored cannot be learned. In this work, we propose Rubric-Scaffolded\nReinforcement Learning (RuscaRL), a novel instructional scaffolding framework\ndesigned to break the exploration bottleneck for general LLM reasoning.\nSpecifically, RuscaRL introduces checklist-style rubrics as (1) explicit\nscaffolding for exploration during rollout generation, where different rubrics\nare provided as external guidance within task instructions to steer diverse\nhigh-quality responses. This guidance is gradually decayed over time,\nencouraging the model to internalize the underlying reasoning patterns; (2)\nverifiable rewards for exploitation during model training, where we can obtain\nrobust LLM-as-a-Judge scores using rubrics as references, enabling effective RL\non general reasoning tasks. Extensive experiments demonstrate the superiority\nof the proposed RuscaRL across various benchmarks, effectively expanding\nreasoning boundaries under the best-of-N evaluation. Notably, RuscaRL\nsignificantly boosts Qwen2.5-7B-Instruct from 23.6 to 50.3 on HealthBench-500,\nsurpassing GPT-4.1. Furthermore, our fine-tuned variant on\nQwen3-30B-A3B-Instruct achieves 61.1 on HealthBench-500, outperforming leading\nLLMs including OpenAI-o3. This work is still in progress, and we will release\nthe code, the models, and the datasets soon.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16949v2",
      "pdf_url": "http://arxiv.org/pdf/2508.16949v2",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.469,
      "weak_supervision_score": 0.406,
      "diffusion_reasoning_score": 0.465,
      "distributed_training_score": 0.344,
      "datasets_score": 0.337,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Tangentially Relevant",
      "weak_supervision_relevance": "Moderately Relevant",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper focuses on Reinforcement Learning (RL) for LLMs using rubric-based rewards from LLM-as-a-Judge, which is automated rather than derived from human-ranked data. While it involves RL for model alignment, it does not explicitly use human feedback to train a reward model, making it only loosely related to traditional RLHF.",
      "weak_supervision_justification": "The paper employs rubrics to programmatically generate rewards and evaluations for RL training, which aligns with weak supervision by using high-level, noisy sources (e.g., checklist criteria) instead of precise hand-labeled data. This provides a form of indirect supervision for reasoning tasks, though it's not the primary focus.",
      "diffusion_reasoning_justification": "The paper's main contribution is on rubric-scaffolded RL for LLM reasoning, with no mention of diffusion models, iterative refinement processes, or treating Chain-of-Thought as a holistically corrected entity. It lacks any components related to multi-step logical reasoning via diffusion.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "completed",
      "summary": "The paper introduces RuscaRL, a novel framework that addresses the exploration bottleneck in reinforcement learning for large language models (LLMs) by using checklist-style rubrics as both explicit scaffolding to guide diverse response generation during rollouts and verifiable rewards for model training. Through gradual decay of rubric guidance and rubric-based evaluation, RuscaRL enhances LLM reasoning capabilities, demonstrating superior performance on benchmarks like HealthBench-500, where it improves Qwen2.5-7B-Instruct from 23.6 to 50.3, surpassing GPT-4.1, and enables Qwen3-30B to achieve 61.1, outperforming OpenAI-o3.",
      "novelty_score": "High",
      "novelty_justification": "The paper introduces a truly innovative technique by integrating rubrics as scaffolding in reinforcement learning for LLMs, which significantly advances the state-of-the-art by breaking the exploration bottleneck and enabling better reasoning in open-ended tasks.",
      "impact_score": "High",
      "impact_justification": "The work could broadly influence future RL methods for LLMs in diverse domains, as its demonstrated improvements on benchmarks suggest potential for wider adoption and enhancement of model capabilities in real-world applications.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "This paper presents a high-quality contribution with strong experimental results and innovative ideas that advance LLM reasoning, making it essential for researchers in AI and machine learning to be aware of, though it is still in progress.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/d4fce730c7ceb40d92612f9abd7eb12a6d13a652",
      "total_authors": 13,
      "authors_found": 13,
      "highest_h_index": 10,
      "average_h_index": 1.6923076923076923,
      "notable_authors_count": 1,
      "author_h_indexes": [
        {
          "name": "Yang Zhou",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2334664117"
        },
        {
          "name": "Sunzhu Li",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2378195618"
        },
        {
          "name": "Shunyu Liu",
          "h_index": 10,
          "profile_url": "https://www.semanticscholar.org/author/2128786021"
        },
        {
          "name": "Wenkai Fang",
          "h_index": 3,
          "profile_url": "https://www.semanticscholar.org/author/2312376339"
        },
        {
          "name": "Jiale Zhao",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2376812534"
        },
        {
          "name": "Jingwen Yang",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2377252364"
        },
        {
          "name": "Jianwei Lv",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2378080416"
        },
        {
          "name": "Kongcheng Zhang",
          "h_index": 3,
          "profile_url": "https://www.semanticscholar.org/author/2312343845"
        },
        {
          "name": "Yihe Zhou",
          "h_index": 4,
          "profile_url": "https://www.semanticscholar.org/author/2176029606"
        },
        {
          "name": "Hengtong Lu",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2376797081"
        },
        {
          "name": "Wei Chen",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2377572791"
        },
        {
          "name": "Yan Xie",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2377774457"
        },
        {
          "name": "Mingli Song",
          "h_index": 2,
          "profile_url": "https://www.semanticscholar.org/author/2265590192"
        }
      ]
    },
    {
      "id": "2508.16950",
      "title": "Disentangling Polysemantic Neurons with a Null-Calibrated\n  Polysemanticity Index and Causal Patch Interventions",
      "authors": [
        "Manan Gupta",
        "Dhruv Kumar"
      ],
      "categories": [
        "cs.LG (Machine Learning)",
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Neural networks often contain polysemantic neurons that respond to multiple,\nsometimes unrelated, features, complicating mechanistic interpretability. We\nintroduce the Polysemanticity Index (PSI), a null-calibrated metric that\nquantifies when a neuron's top activations decompose into semantically distinct\nclusters. PSI multiplies three independently calibrated components: geometric\ncluster quality (S), alignment to labeled categories (Q), and open-vocabulary\nsemantic distinctness via CLIP (D). On a pretrained ResNet-50 evaluated with\nTiny-ImageNet images, PSI identifies neurons whose activation sets split into\ncoherent, nameable prototypes, and reveals strong depth trends: later layers\nexhibit substantially higher PSI than earlier layers. We validate our approach\nwith robustness checks (varying hyperparameters, random seeds, and\ncross-encoder text heads), breadth analyses (comparing class-only vs.\nopen-vocabulary concepts), and causal patch-swap interventions. In particular,\naligned patch replacements increase target-neuron activation significantly more\nthan non-aligned, random, shuffled-position, or ablate-elsewhere controls. PSI\nthus offers a principled and practical lever for discovering, quantifying, and\nstudying polysemantic units in neural networks.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16950v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16950v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.338,
      "weak_supervision_score": 0.338,
      "diffusion_reasoning_score": 0.412,
      "distributed_training_score": 0.348,
      "datasets_score": 0.31,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper introduces the Polysemanticity Index (PSI) for analyzing polysemantic neurons in a ResNet-50 model, focusing on interpretability through clustering, alignment, and causal interventions in computer vision. It does not involve diffusion models, iterative refinement processes, or multi-step logical reasoning tasks, making it unrelated to the topic.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16956",
      "title": "RPD-Diff: Region-Adaptive Physics-Guided Diffusion Model for Visibility\n  Enhancement under Dense and Non-Uniform Haze",
      "authors": [
        "Ruicheng Zhang",
        "Puxin Yan",
        "Zeyu Zhang",
        "Yicheng Chang",
        "Hongyi Chen",
        "Zhi Jin"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Single-image dehazing under dense and non-uniform haze conditions remains\nchallenging due to severe information degradation and spatial heterogeneity.\nTraditional diffusion-based dehazing methods struggle with insufficient\ngeneration conditioning and lack of adaptability to spatially varying haze\ndistributions, which leads to suboptimal restoration. To address these\nlimitations, we propose RPD-Diff, a Region-adaptive Physics-guided Dehazing\nDiffusion Model for robust visibility enhancement in complex haze scenarios.\nRPD-Diff introduces a Physics-guided Intermediate State Targeting (PIST)\nstrategy, which leverages physical priors to reformulate the diffusion Markov\nchain by generation target transitions, mitigating the issue of insufficient\nconditioning in dense haze scenarios. Additionally, the Haze-Aware Denoising\nTimestep Predictor (HADTP) dynamically adjusts patch-specific denoising\ntimesteps employing a transmission map cross-attention mechanism, adeptly\nmanaging non-uniform haze distributions. Extensive experiments across four\nreal-world datasets demonstrate that RPD-Diff achieves state-of-the-art\nperformance in challenging dense and non-uniform haze scenarios, delivering\nhigh-quality, haze-free images with superior detail clarity and color fidelity.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16956v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16956v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "extraction_failed",
      "embedding_status": "completed",
      "rlhf_score": 0.32,
      "weak_supervision_score": 0.277,
      "diffusion_reasoning_score": 0.472,
      "distributed_training_score": 0.3,
      "datasets_score": 0.246,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on using diffusion models for image dehazing, specifically adapting them for visibility enhancement in hazy images through techniques like PIST and HADTP. While it involves iterative refinement in diffusion processes, it does not address solving complex logical tasks, treating a 'Chain-of-Thought' as a single entity, or multi-step logical reasoning. Thus, it does not align with the topic's definition.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16962",
      "title": "LLM-based Human-like Traffic Simulation for Self-driving Tests",
      "authors": [
        "Wendi Li",
        "Hao Wu",
        "Han Gao",
        "Bing Mao",
        "Fengyuan Xu",
        "Sheng Zhong"
      ],
      "categories": [
        "cs.RO (Robotics)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Ensuring realistic traffic dynamics is a prerequisite for simulation\nplatforms to evaluate the reliability of self-driving systems before deployment\nin the real world. Because most road users are human drivers, reproducing their\ndiverse behaviors within simulators is vital. Existing solutions, however,\ntypically rely on either handcrafted heuristics or narrow data-driven models,\nwhich capture only fragments of real driving behaviors and offer limited\ndriving style diversity and interpretability. To address this gap, we introduce\nHDSim, an HD traffic generation framework that combines cognitive theory with\nlarge language model (LLM) assistance to produce scalable and realistic traffic\nscenarios within simulation platforms. The framework advances the state of the\nart in two ways: (i) it introduces a hierarchical driver model that represents\ndiverse driving style traits, and (ii) it develops a Perception-Mediated\nBehavior Influence strategy, where LLMs guide perception to indirectly shape\ndriver actions. Experiments reveal that embedding HDSim into simulation\nimproves detection of safety-critical failures in self-driving systems by up to\n68% and yields realism-consistent accident interpretability.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16962v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16962v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.464,
      "weak_supervision_score": 0.356,
      "diffusion_reasoning_score": 0.45,
      "distributed_training_score": 0.374,
      "datasets_score": 0.338,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper focuses on using LLMs for generating realistic traffic simulations via perceptual transformations and cognitive modeling, without any mention of human feedback, reward models, or reinforcement learning to align AI with preferences. There is no training process involving human-ranked data or fine-tuning via RL.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper employs LLMs for program synthesis in simulating driving behaviors but does not involve diffusion models, iterative refinement processes, or multi-step logical reasoning on a Chain-of-Thought. It lacks any components related to adapting diffusion for complex tasks.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16969",
      "title": "Explaining Black-box Language Models with Knowledge Probing Systems: A\n  Post-hoc Explanation Perspective",
      "authors": [
        "Yunxiao Zhao",
        "Hao Xu",
        "Zhiqiang Wang",
        "Xiaoli Li",
        "Jiye Liang",
        "Ru Li"
      ],
      "categories": [
        "cs.CL (Computation and Language)",
        "cs.AI (Artificial Intelligence)",
        "cs.DB (Databases)"
      ],
      "abstract": "Pre-trained Language Models (PLMs) are trained on large amounts of unlabeled\ndata, yet they exhibit remarkable reasoning skills. However, the\ntrustworthiness challenges posed by these black-box models have become\nincreasingly evident in recent years. To alleviate this problem, this paper\nproposes a novel Knowledge-guided Probing approach called KnowProb in a\npost-hoc explanation way, which aims to probe whether black-box PLMs understand\nimplicit knowledge beyond the given text, rather than focusing only on the\nsurface level content of the text. We provide six potential explanations\nderived from the underlying content of the given text, including three\nknowledge-based understanding and three association-based reasoning. In\nexperiments, we validate that current small-scale (or large-scale) PLMs only\nlearn a single distribution of representation, and still face significant\nchallenges in capturing the hidden knowledge behind a given text. Furthermore,\nwe demonstrate that our proposed approach is effective for identifying the\nlimitations of existing black-box models from multiple probing perspectives,\nwhich facilitates researchers to promote the study of detecting black-box\nmodels in an explainable way.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16969v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16969v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.408,
      "weak_supervision_score": 0.379,
      "diffusion_reasoning_score": 0.484,
      "distributed_training_score": 0.311,
      "datasets_score": 0.299,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper focuses on knowledge probing for black-box language models using a method called KnowProb, which involves analyzing implicit knowledge without any incorporation of human feedback, reward models, or reinforcement learning techniques. There is no mention of training or fine-tuning models based on human preferences, making it unrelated to RLHF.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper proposes a knowledge-guided probing approach for understanding hidden knowledge in language models, utilizing FrameNet for entity generation, but it does not involve diffusion models, iterative refinement processes, or multi-step logical reasoning as described in diffusion-based reasoning. It is solely about post-hoc probing, not holistic correction or chain-of-thought refinement.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16970",
      "title": "Local Information Matters: A Rethink of Crowd Counting",
      "authors": [
        "Tianhang Pan",
        "Xiuyi Jia"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "The motivation of this paper originates from rethinking an essential\ncharacteristic of crowd counting: individuals (heads of humans) in the crowd\ncounting task typically occupy a very small portion of the image. This\ncharacteristic has never been the focus of existing works: they typically use\nthe same backbone as other visual tasks and pursue a large receptive field.\nThis drives us to propose a new model design principle of crowd counting:\nemphasizing local modeling capability of the model. We follow the principle and\ndesign a crowd counting model named Local Information Matters Model (LIMM). The\nmain innovation lies in two strategies: a window partitioning design that\napplies grid windows to the model input, and a window-wise contrastive learning\ndesign to enhance the model's ability to distinguish between local density\nlevels. Moreover, a global attention module is applied to the end of the model\nto handle the occasionally occurring large-sized individuals. Extensive\nexperiments on multiple public datasets illustrate that the proposed model\nshows a significant improvement in local modeling capability (8.7\\% in MAE on\nthe JHU-Crowd++ high-density subset for example), without compromising its\nability to count large-sized ones, which achieves state-of-the-art performance.\nCode is available at: https://github.com/tianhangpan/LIMM.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16970v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16970v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "extraction_failed",
      "embedding_status": "completed",
      "rlhf_score": 0.328,
      "weak_supervision_score": 0.312,
      "diffusion_reasoning_score": 0.344,
      "distributed_training_score": 0.32,
      "datasets_score": 0.308,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16972",
      "title": "Robust Diagram Reasoning: A Framework for Enhancing LVLM Performance on\n  Visually Perturbed Scientific Diagrams",
      "authors": [
        "Minghao Zhou",
        "Rafael Souza",
        "Yaqian Hu",
        "Luming Che"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Large Language Models (LLMs) and their multimodal variants (LVLMs) hold\nimmense promise for scientific and engineering applications, particularly in\nprocessing visual information like scientific diagrams. However, their\npractical deployment is hindered by a critical lack of robustness to common\nvisual perturbations such as noise, blur, and occlusions, which are prevalent\nin real-world scientific documents. Existing evaluation benchmarks largely\noverlook this challenge, leaving the robust reasoning capabilities of LVLMs on\nvisually degraded scientific diagrams underexplored. To address this, we\nintroduce the Robust Diagram Reasoning (RDR) framework, a novel approach\ndesigned to enhance and rigorously evaluate LVLMs' performance under such\nconditions. At its core, RDR employs an Adaptive Multi-View & Consistency\nVerification (AMCV) mechanism, which involves generating multiple perturbed\nversions of a diagram, performing parallel inference, and then applying a\nconsistency-based self-correction loop. We also propose two new metrics,\nPerturbation Robustness Score (PRS) and Visual Degradation Consistency (VDC),\nto quantify robustness. Furthermore, we construct SciDiagram-Robust, the first\nlarge-scale scientific diagram question-answering dataset specifically\naugmented with diverse, programmatically generated visual perturbations. Our\nextensive experiments demonstrate that even state-of-the-art closed-source\nLVLMs like GPT-4V exhibit significant performance degradation when faced with\nperturbed inputs (Clean Accuracy 85.2% vs. PRS 72.1%).",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16972v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16972v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.422,
      "weak_supervision_score": 0.418,
      "diffusion_reasoning_score": 0.524,
      "distributed_training_score": 0.377,
      "datasets_score": 0.365,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "Tangentially Relevant",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper focuses on enhancing LVLM robustness through a self-correction mechanism and dataset creation, with no mention of human feedback, reward models, or reinforcement learning techniques.",
      "weak_supervision_justification": "The paper involves programmatically generating visual perturbations for a dataset, which is somewhat related to using noisy or automated data augmentation, but it does not primarily focus on training models with weakly supervised labels from imprecise sources.",
      "diffusion_reasoning_justification": "The paper's AMCV mechanism uses multi-view consistency and self-correction for reasoning, but it does not employ diffusion models or iterative refinement processes for logical tasks as defined.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16973",
      "title": "Balanced Sharpness-Aware Minimization for Imbalanced Regression",
      "authors": [
        "Yahao Liu",
        "Qin Wang",
        "Lixin Duan",
        "Wen Li"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Regression is fundamental in computer vision and is widely used in various\ntasks including age estimation, depth estimation, target localization, \\etc\nHowever, real-world data often exhibits imbalanced distribution, making\nregression models perform poorly especially for target values with rare\nobservations~(known as the imbalanced regression problem). In this paper, we\nreframe imbalanced regression as an imbalanced generalization problem. To\ntackle that, we look into the loss sharpness property for measuring the\ngeneralization ability of regression models in the observation space. Namely,\ngiven a certain perturbation on the model parameters, we check how model\nperformance changes according to the loss values of different target\nobservations. We propose a simple yet effective approach called Balanced\nSharpness-Aware Minimization~(BSAM) to enforce the uniform generalization\nability of regression models for the entire observation space. In particular,\nwe start from the traditional sharpness-aware minimization and then introduce a\nnovel targeted reweighting strategy to homogenize the generalization ability\nacross the observation space, which guarantees a theoretical generalization\nbound. Extensive experiments on multiple vision regression tasks, including age\nand depth estimation, demonstrate that our BSAM method consistently outperforms\nexisting approaches. The code is available\n\\href{https://github.com/manmanjun/BSAM_for_Imbalanced_Regression}{here}.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16973v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16973v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.329,
      "weak_supervision_score": 0.379,
      "diffusion_reasoning_score": 0.332,
      "distributed_training_score": 0.323,
      "datasets_score": 0.303,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16974",
      "title": "Hierarchical Contextual Grounding LVLM: Enhancing Fine-Grained\n  Visual-Language Understanding with Robust Grounding",
      "authors": [
        "Leilei Guo",
        "Antonio Carlos Rivera",
        "Peiyu Tang",
        "Haoxuan Ren",
        "Zheyu Song"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Large Language Models (LLMs) and Vision-Language Large Models (LVLMs) have\nachieved remarkable progress in natural language processing and multimodal\nunderstanding. Despite their impressive generalization capabilities, current\nLVLMs often exhibit insufficient robustness, proneness to hallucination, and\nreasoning errors in complex real-world scenarios, particularly when precise\nimage region localization and fine-grained visual reasoning are required. To\naddress these limitations, we propose the Hierarchical Contextual Grounding\nLVLM (HCG-LVLM), a novel architecture that mimics human coarse-to-fine\ncognitive processing. HCG-LVLM employs a two-layered approach: a Global\nContextual Perception layer for initial broad understanding and a Fine-grained\nLocal Grounding layer. The latter incorporates a Local Detail Enhancement\nModule to extract high-resolution features and a Semantic Consistency Validator\nto ensure accurate, hallucination-free visual-language alignment. Through an\nadaptive fusion mechanism, information from both layers is integrated for\nrobust and precise outputs. Extensive experiments on challenging datasets,\nincluding GQA, A-OKVQA for fine-grained VQA, and RefCOCO/+/g for Referring\nExpression Comprehension, demonstrate that HCG-LVLM consistently outperforms\nstate-of-the-art models such as Flamingo, BLIP-2, and MiniGPT-4. Our model\nachieves superior accuracy and significantly reduces hallucination, validating\nthe effectiveness of its hierarchical design in enhancing fine-grained\nvisual-language understanding and precise grounding capabilities.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16974v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16974v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.442,
      "weak_supervision_score": 0.388,
      "diffusion_reasoning_score": 0.478,
      "distributed_training_score": 0.356,
      "datasets_score": 0.338,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper introduces a hierarchical architecture for vision-language models with fine-tuning on datasets, but it does not mention using human feedback, a reward model, or reinforcement learning techniques for alignment with human preferences. The training described is based on standard pre-training and fine-tuning on image-text pairs and task-specific data.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on a hierarchical LVLM for visual-language understanding with layers for global and fine-grained processing, but it does not involve diffusion models, iterative refinement for logical tasks, or treating reasoning paths as entities for multi-step correction. There is no component for diffusion-based multi-step logical reasoning.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16975",
      "title": "Combating Digitally Altered Images: Deepfake Detection",
      "authors": [
        "Saksham Kumar",
        "Rhythm Narang"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.AI (Artificial Intelligence)",
        "cs.CR (Cryptography and Security)"
      ],
      "abstract": "The rise of Deepfake technology to generate hyper-realistic manipulated\nimages and videos poses a significant challenge to the public and relevant\nauthorities. This study presents a robust Deepfake detection based on a\nmodified Vision Transformer(ViT) model, trained to distinguish between real and\nDeepfake images. The model has been trained on a subset of the OpenForensics\nDataset with multiple augmentation techniques to increase robustness for\ndiverse image manipulations. The class imbalance issues are handled by\noversampling and a train-validation split of the dataset in a stratified\nmanner. Performance is evaluated using the accuracy metric on the training and\ntesting datasets, followed by a prediction score on a random image of people,\nirrespective of their realness. The model demonstrates state-of-the-art results\non the test dataset to meticulously detect Deepfake images.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16975v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16975v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.386,
      "weak_supervision_score": 0.366,
      "diffusion_reasoning_score": 0.406,
      "distributed_training_score": 0.364,
      "datasets_score": 0.427,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "Tangentially Relevant",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on Deepfake detection using a modified Vision Transformer model and does not involve diffusion-based processes, iterative refinement for reasoning, or any multi-step logical reasoning mechanisms.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "The paper uses the OpenForensics Dataset for training and evaluation, including augmentation and splitting techniques, but its main contribution is the Deepfake detection model, not the creation, analysis, or benchmarking of datasets.",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16976",
      "title": "Preserving Domain Generalization in Fine-Tuning via Joint Parameter\n  Selection",
      "authors": [
        "Bin Pan",
        "Shiyu Shen",
        "Zongbin Wang",
        "Zhenwei Shi",
        "Xia Xu"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.LG (Machine Learning)"
      ],
      "abstract": "Domain generalization seeks to develop models trained on a limited set of\nsource domains that are capable of generalizing effectively to unseen target\ndomains. While the predominant approach leverages large-scale pre-trained\nvision models as initialization, recent studies have highlighted that full\nfine-tuning can compromise the intrinsic generalization capabilities of these\nmodels. To address this limitation, parameter-efficient adaptation strategies\nhave emerged, wherein only a subset of model parameters is selectively\nfine-tuned, thereby balancing task adaptation with the preservation of\ngeneralization. Motivated by this paradigm, we introduce Joint Parameter\nSelection (JPS), a novel method that restricts updates to a small, sparse\nsubset of parameters, thereby retaining and harnessing the generalization\nstrength of pre-trained models. Theoretically, we establish a generalization\nerror bound that explicitly accounts for the sparsity of parameter updates,\nthereby providing a principled justification for selective fine-tuning.\nPractically, we design a selection mechanism employing dual operators to\nidentify and update parameters exhibiting consistent and significant gradients\nacross all source domains. Extensive benchmark experiments demonstrate that JPS\nachieves superior performance compared to state-of-the-art domain\ngeneralization methods, substantiating both the efficiency and efficacy of the\nproposed approach.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16976v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16976v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.333,
      "weak_supervision_score": 0.343,
      "diffusion_reasoning_score": 0.374,
      "distributed_training_score": 0.414,
      "datasets_score": 0.301,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "Not Relevant",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "The paper's main contribution is a method for selective parameter fine-tuning in domain generalization, focusing on preserving generalization capabilities in pre-trained models through gradient-based parameter selection and theoretical error bounds. It does not address distributed training concepts such as parallel computing, multi-node setups, or strategies for partitioning data/computation across processors. There is no mention of accelerating training via distribution, making it unrelated to this topic.",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16983",
      "title": "ReFactX: Scalable Reasoning with Reliable Facts via Constrained\n  Generation",
      "authors": [
        "Riccardo Pozzi",
        "Matteo Palmonari",
        "Andrea Coletta",
        "Luigi Bellomarini",
        "Jens Lehmann",
        "Sahar Vahdati"
      ],
      "categories": [
        "cs.CL (Computation and Language)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Knowledge gaps and hallucinations are persistent challenges for Large\nLanguage Models (LLMs), which generate unreliable responses when lacking the\nnecessary information to fulfill user instructions. Existing approaches, such\nas Retrieval-Augmented Generation (RAG) and tool use, aim to address these\nissues by incorporating external knowledge. Yet, they rely on additional models\nor services, resulting in complex pipelines, potential error propagation, and\noften requiring the model to process a large number of tokens. In this paper,\nwe present a scalable method that enables LLMs to access external knowledge\nwithout depending on retrievers or auxiliary models. Our approach uses\nconstrained generation with a pre-built prefix-tree index. Triples from a\nKnowledge Graph are verbalized in textual facts, tokenized, and indexed in a\nprefix tree for efficient access. During inference, to acquire external\nknowledge, the LLM generates facts with constrained generation which allows\nonly sequences of tokens that form an existing fact. We evaluate our proposal\non Question Answering and show that it scales to large knowledge bases (800\nmillion facts), adapts to domain-specific data, and achieves effective results.\nThese gains come with minimal generation-time overhead. ReFactX code is\navailable at https://github.com/rpo19/ReFactX.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16983v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16983v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.412,
      "weak_supervision_score": 0.384,
      "diffusion_reasoning_score": 0.508,
      "distributed_training_score": 0.355,
      "datasets_score": 0.326,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper introduces ReFactX, a method for constrained generation to access external knowledge in LLMs, focusing on inference-time techniques without any mention of human feedback, reward models, or reinforcement learning for model alignment.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper describes a constrained generation approach using prefix trees for fact retrieval in LLMs, but it does not involve diffusion models, iterative refinement processes, or treating Chain-of-Thought as a holistically corrected entity.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16984",
      "title": "HiCache: Training-free Acceleration of Diffusion Models via Hermite\n  Polynomial-based Feature Caching",
      "authors": [
        "Liang Feng",
        "Shikang Zheng",
        "Jiacheng Liu",
        "Yuqi Lin",
        "Qinming Zhou",
        "Peiliang Cai",
        "Xinyu Wang",
        "Junjie Chen",
        "Chang Zou",
        "Yue Ma",
        "Linfeng Zhang"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Diffusion models have achieved remarkable success in content generation but\nsuffer from prohibitive computational costs due to iterative sampling. While\nrecent feature caching methods tend to accelerate inference through temporal\nextrapolation, these methods still suffer from server quality loss due to the\nfailure in modeling the complex dynamics of feature evolution. To solve this\nproblem, this paper presents HiCache, a training-free acceleration framework\nthat fundamentally improves feature prediction by aligning mathematical tools\nwith empirical properties. Our key insight is that feature derivative\napproximations in Diffusion Transformers exhibit multivariate Gaussian\ncharacteristics, motivating the use of Hermite polynomials-the potentially\ntheoretically optimal basis for Gaussian-correlated processes. Besides, We\nfurther introduce a dual-scaling mechanism that ensures numerical stability\nwhile preserving predictive accuracy. Extensive experiments demonstrate\nHiCache's superiority: achieving 6.24x speedup on FLUX.1-dev while exceeding\nbaseline quality, maintaining strong performance across text-to-image, video\ngeneration, and super-resolution tasks. Core implementation is provided in the\nappendix, with complete code to be released upon acceptance.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16984v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16984v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "extraction_failed",
      "embedding_status": "completed",
      "rlhf_score": 0.379,
      "weak_supervision_score": 0.322,
      "diffusion_reasoning_score": 0.51,
      "distributed_training_score": 0.439,
      "datasets_score": 0.3,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "Not Relevant",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on accelerating diffusion models for content generation tasks like image and video creation through feature caching and Hermite polynomials. It does not involve adapting diffusion models for multi-step logical reasoning, Chain-of-Thought processes, or any form of iterative refinement for complex logical tasks.",
      "distributed_training_justification": "The paper introduces a training-free method to speed up inference in diffusion models via feature caching, without discussing distributed training techniques, parallel computing across nodes, or strategies for partitioning data/computation in multi-node environments.",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16986",
      "title": "Complexity in finitary argumentation (extended version)",
      "authors": [
        "Uri Andrews",
        "Luca San Mauro"
      ],
      "categories": [
        "cs.AI (Artificial Intelligence)",
        "math.LO (Logic)"
      ],
      "abstract": "Abstract argumentation frameworks (AFs) provide a formal setting to analyze\nmany forms of reasoning with conflicting information. While the expressiveness\nof general infinite AFs make them a tempting tool for modeling many kinds of\nreasoning scenarios, the computational intractability of solving infinite AFs\nlimit their use, even in many theoretical applications.\n  We investigate the complexity of computational problems related to infinite\nbut finitary argumentations frameworks, that is, infinite AFs where each\nargument is attacked by only finitely many others. Our results reveal a\nsurprising scenario. On one hand, we see that the assumption of being finitary\ndoes not automatically guarantee a drop in complexity. However, for the\nadmissibility-based semantics, we find a remarkable combinatorial constraint\nwhich entails a dramatic decrease in complexity.\n  We conclude that for many forms of reasoning, the finitary infinite AFs\nprovide a natural setting for reasoning which balances well the competing goals\nof being expressive enough to be applied to many reasoning settings while being\ncomputationally tractable enough for the analysis within the framework to be\nuseful.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16986v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16986v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.292,
      "weak_supervision_score": 0.273,
      "diffusion_reasoning_score": 0.356,
      "distributed_training_score": 0.242,
      "datasets_score": 0.248,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16987",
      "title": "WebSight: A Vision-First Architecture for Robust Web Agents",
      "authors": [
        "Tanvir Bhathal",
        "Asanshay Gupta"
      ],
      "categories": [
        "cs.AI (Artificial Intelligence)",
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "We introduce WebSight, a vision-based autonomous web agent, designed to\ninteract with web environments purely through visual perception, eliminating\ndependence on HTML or DOM-based inputs. Central to our approach we introduce\nour new model, WebSight-7B, a fine-tuned vision-language model optimized for UI\nelement interaction, trained using LoRA on a web-focused subset of the\nWave-UI-25K dataset. WebSight integrates this model into a modular multi-agent\narchitecture, comprising planning, reasoning, vision-action, and verification\nagents, coordinated through an episodic memory mechanism.\n  WebSight-7B achieves a top-1 accuracy of 58.84% on the Showdown Clicks\nbenchmark, outperforming several larger generalist models while maintaining\nlower latency. The full WebSight agent achieves a 68.0% success rate on the\nWebVoyager benchmark, surpassing systems from labs such as OpenAI (61.0%) and\nHCompany (Runner H, 67.0%). Among tasks completed, WebSight answers correctly\n97.14% of the time, indicating high precision. Together, WebSight and\nWebSight-7B establish a new standard for interpretable, robust, and efficient\nvisual web navigation.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16987v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16987v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "extraction_failed",
      "embedding_status": "completed",
      "rlhf_score": 0.35,
      "weak_supervision_score": 0.339,
      "diffusion_reasoning_score": 0.364,
      "distributed_training_score": 0.267,
      "datasets_score": 0.313,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16990",
      "title": "Score Matching on Large Geometric Graphs for Cosmology Generation",
      "authors": [
        "Diana-Alexandra Onutu",
        "Yue Zhao",
        "Joaquin Vanschoren",
        "Vlado Menkovski"
      ],
      "categories": [
        "astro-ph.CO (Cosmology and Nongalactic Astrophysics)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Generative models are a promising tool to produce cosmological simulations\nbut face significant challenges in scalability, physical consistency, and\nadherence to domain symmetries, limiting their utility as alternatives to\n$N$-body simulations. To address these limitations, we introduce a score-based\ngenerative model with an equivariant graph neural network that simulates\ngravitational clustering of galaxies across cosmologies starting from an\ninformed prior, respects periodic boundaries, and scales to full galaxy counts\nin simulations. A novel topology-aware noise schedule, crucial for large\ngeometric graphs, is introduced. The proposed equivariant score-based model\nsuccessfully generates full-scale cosmological point clouds of up to 600,000\nhalos, respects periodicity and a uniform prior, and outperforms existing\ndiffusion models in capturing clustering statistics while offering significant\ncomputational advantages. This work advances cosmology by introducing a\ngenerative model designed to closely resemble the underlying gravitational\nclustering of structure formation, moving closer to physically realistic and\nefficient simulators for the evolution of large-scale structures in the\nuniverse.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16990v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16990v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.318,
      "weak_supervision_score": 0.325,
      "diffusion_reasoning_score": 0.451,
      "distributed_training_score": 0.397,
      "datasets_score": 0.332,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper introduces a score-based generative model for cosmological simulations, focusing on generating point clouds of galaxy distributions using equivariant graph neural networks. While score-based models are related to diffusion models in their iterative denoising processes, the paper does not involve adapting diffusion for multi-step logical reasoning, Chain-of-Thought processes, or solving complex logical tasks. Instead, it applies generative techniques to physical simulations in cosmology, with no components dedicated to holistic correction of reasoning paths. Thus, it does not align with the topic's definition.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.16994",
      "title": "GRADE: Generating multi-hop QA and fine-gRAined Difficulty matrix for\n  RAG Evaluation",
      "authors": [
        "Jeongsoo Lee",
        "Daeyong Kwon",
        "Kyohoon Jin"
      ],
      "categories": [
        "cs.CL (Computation and Language)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Retrieval-Augmented Generation (RAG) systems are widely adopted in\nknowledge-intensive NLP tasks, but current evaluations often overlook the\nstructural complexity and multi-step reasoning required in real-world\nscenarios. These benchmarks overlook key factors such as the interaction\nbetween retrieval difficulty and reasoning depth. To address this gap, we\npropose \\textsc{GRADE}, a novel evaluation framework that models task\ndifficulty along two orthogonal dimensions: (1) reasoning depth, defined by the\nnumber of inference steps (hops), and (2) semantic distance between the query\nand its supporting evidence. We construct a synthetic multi-hop QA dataset from\nfactual news articles by extracting knowledge graphs and augmenting them\nthrough semantic clustering to recover missing links, allowing us to generate\ndiverse and difficulty-controlled queries. Central to our framework is a 2D\ndifficulty matrix that combines generator-side and retriever-side difficulty.\nExperiments across multiple domains and models show that error rates strongly\ncorrelate with our difficulty measures, validating their diagnostic utility.\n\\textsc{GRADE} enables fine-grained analysis of RAG performance and provides a\nscalable foundation for evaluating and improving multi-hop reasoning in\nreal-world applications.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.16994v1",
      "pdf_url": "http://arxiv.org/pdf/2508.16994v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.376,
      "weak_supervision_score": 0.376,
      "diffusion_reasoning_score": 0.51,
      "distributed_training_score": 0.361,
      "datasets_score": 0.405,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "Highly Relevant",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on evaluating Retrieval-Augmented Generation (RAG) systems using a framework that involves knowledge graphs and semantic clustering for multi-hop QA, but it does not mention or utilize diffusion models, iterative refinement processes, or treating Chain-of-Thought as a holistic entity for reasoning.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "The paper introduces a synthetic multi-hop QA dataset generated from factual news articles via knowledge graphs and semantic clustering, and it discusses benchmarking and evaluating this dataset for RAG systems, directly aligning with research on dataset creation, curation, and analysis for AI applications.",
      "llm_score_status": "completed",
      "summary": "The paper introduces GRADE, a novel framework for evaluating Retrieval-Augmented Generation (RAG) systems by modeling task difficulty along two dimensions: reasoning depth (number of inference steps) and semantic distance between queries and supporting evidence. Using a synthetic multi-hop QA dataset generated from news articles via knowledge graphs and semantic clustering, the authors create a 2D difficulty matrix to enable fine-grained analysis of RAG performance, with experiments showing that error rates correlate strongly with these difficulty measures, thus validating the framework's utility for diagnosing and improving RAG systems in real-world applications.",
      "novelty_score": "High",
      "novelty_justification": "The paper introduces a truly new evaluation framework that combines reasoning depth and semantic distance for RAG systems, significantly advancing the state-of-the-art by addressing overlooked aspects of structural complexity and multi-step reasoning.",
      "impact_score": "Moderate",
      "impact_justification": "The work is likely to be cited and built upon within the subfield of AI and NLP for RAG evaluations, as it provides a scalable method for fine-grained analysis, though its influence may be limited to specific applications in knowledge-intensive tasks.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "The paper represents a strong and valuable contribution to RAG evaluation methodologies, making it essential for researchers in AI and computational language to be aware of for advancing multi-hop reasoning systems.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/2e85c91896f788296954cd42457b52a625124d25",
      "total_authors": 3,
      "authors_found": 3,
      "highest_h_index": 1,
      "average_h_index": 1.0,
      "notable_authors_count": 0,
      "author_h_indexes": [
        {
          "name": "Jeongsoo Lee",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2355401250"
        },
        {
          "name": "Daeyong Kwon",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2355348473"
        },
        {
          "name": "Kyohoon Jin",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2355348241"
        }
      ]
    },
    {
      "id": "2508.17007",
      "title": "An Efficient Dual-Line Decoder Network with Multi-Scale Convolutional\n  Attention for Multi-organ Segmentation",
      "authors": [
        "Riad Hassan",
        "M. Rubaiyat Hossain Mondal",
        "Sheikh Iqbal Ahamed",
        "Fahad Mostafa",
        "Md Mostafijur Rahman"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Proper segmentation of organs-at-risk is important for radiation therapy,\nsurgical planning, and diagnostic decision-making in medical image analysis.\nWhile deep learning-based segmentation architectures have made significant\nprogress, they often fail to balance segmentation accuracy with computational\nefficiency. Most of the current state-of-the-art methods either prioritize\nperformance at the cost of high computational complexity or compromise accuracy\nfor efficiency. This paper addresses this gap by introducing an efficient\ndual-line decoder segmentation network (EDLDNet). The proposed method features\na noisy decoder, which learns to incorporate structured perturbation at\ntraining time for better model robustness, yet at inference time only the\nnoise-free decoder is executed, leading to lower computational cost.\nMulti-Scale convolutional Attention Modules (MSCAMs), Attention Gates (AGs),\nand Up-Convolution Blocks (UCBs) are further utilized to optimize feature\nrepresentation and boost segmentation performance. By leveraging multi-scale\nsegmentation masks from both decoders, we also utilize a mutation-based loss\nfunction to enhance the model's generalization. Our approach outperforms SOTA\nsegmentation architectures on four publicly available medical imaging datasets.\nEDLDNet achieves SOTA performance with an 84.00% Dice score on the Synapse\ndataset, surpassing baseline model like UNet by 13.89% in Dice score while\nsignificantly reducing Multiply-Accumulate Operations (MACs) by 89.7%. Compared\nto recent approaches like EMCAD, our EDLDNet not only achieves higher Dice\nscore but also maintains comparable computational efficiency. The outstanding\nperformance across diverse datasets establishes EDLDNet's strong\ngeneralization, computational efficiency, and robustness. The source code,\npre-processed data, and pre-trained weights will be available at\nhttps://github.com/riadhassan/EDLDNet .",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.17007v1",
      "pdf_url": "http://arxiv.org/pdf/2508.17007v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "extraction_failed",
      "embedding_status": "completed",
      "rlhf_score": 0.288,
      "weak_supervision_score": 0.309,
      "diffusion_reasoning_score": 0.392,
      "distributed_training_score": 0.362,
      "datasets_score": 0.32,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.17009",
      "title": "Contrastive Prompt Clustering for Weakly Supervised Semantic\n  Segmentation",
      "authors": [
        "Wangyu Wu",
        "Zhenhong Chen",
        "Xiaowen Ma",
        "Wenqiao Zhang",
        "Xianglin Qiu",
        "Siqi Song",
        "Xiaowei Huang",
        "Fei Ma",
        "Jimin Xiao"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Weakly Supervised Semantic Segmentation (WSSS) with image-level labels has\ngained attention for its cost-effectiveness. Most existing methods emphasize\ninter-class separation, often neglecting the shared semantics among related\ncategories and lacking fine-grained discrimination. To address this, we propose\nContrastive Prompt Clustering (CPC), a novel WSSS framework. CPC exploits Large\nLanguage Models (LLMs) to derive category clusters that encode intrinsic\ninter-class relationships, and further introduces a class-aware patch-level\ncontrastive loss to enforce intra-class consistency and inter-class separation.\nThis hierarchical design leverages clusters as coarse-grained semantic priors\nwhile preserving fine-grained boundaries, thereby reducing confusion among\nvisually similar categories. Experiments on PASCAL VOC 2012 and MS COCO 2014\ndemonstrate that CPC surpasses existing state-of-the-art methods in WSSS.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.17009v2",
      "pdf_url": "http://arxiv.org/pdf/2508.17009v2",
      "scraper_status": "successfully_scraped",
      "intro_status": "extraction_failed",
      "embedding_status": "completed",
      "rlhf_score": 0.288,
      "weak_supervision_score": 0.452,
      "diffusion_reasoning_score": 0.313,
      "distributed_training_score": 0.318,
      "datasets_score": 0.305,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "Highly Relevant",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "The paper's main contribution is a framework for Weakly Supervised Semantic Segmentation (WSSS) using image-level labels, which are high-level and imprecise sources, directly aligning with the definition of weak supervision. It trains models without relying on fully hand-labeled data, emphasizing cost-effective label generation and achieving state-of-the-art results.",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "completed",
      "summary": "The paper, titled \"Contrastive Prompt Clustering for Weakly Supervised Semantic Segmentation,\" addresses limitations in existing Weakly Supervised Semantic Segmentation (WSSS) methods by introducing a novel framework called Contrastive Prompt Clustering (CPC). This approach leverages Large Language Models (LLMs) to generate category clusters that capture inter-class relationships, combined with a class-aware patch-level contrastive loss to enhance intra-class consistency and inter-class separation, ultimately improving segmentation accuracy on datasets like PASCAL VOC 2012 and MS COCO 2014, where it outperforms state-of-the-art methods.",
      "novelty_score": "High",
      "novelty_justification": "The paper introduces a truly innovative technique by integrating Large Language Models for category clustering in WSSS, which significantly advances the field by addressing overlooked inter-class relationships and fine-grained discrimination. This represents a substantial departure from existing methods that primarily focus on inter-class separation.",
      "impact_score": "High",
      "impact_justification": "The work has the potential to influence a broad range of future research in computer vision by demonstrating the effectiveness of LLMs in WSSS, likely leading to wider adoption and innovations in semantic segmentation tasks. Its superior performance on benchmark datasets suggests it could drive advancements in both academic and commercial applications.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "This paper offers a high-quality contribution that advances WSSS through innovative use of LLMs, making it valuable for researchers in computer vision to understand emerging techniques. However, while impactful, it may not be essential for those outside the specific subfield of weakly supervised methods.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/4849b881182bcea2b1bb59d0d0393c321c25de0b",
      "total_authors": 9,
      "authors_found": 9,
      "highest_h_index": 8,
      "average_h_index": 4.222222222222222,
      "notable_authors_count": 4,
      "author_h_indexes": [
        {
          "name": "Wangyu Wu",
          "h_index": 7,
          "profile_url": "https://www.semanticscholar.org/author/2258788553"
        },
        {
          "name": "Zhen Chen",
          "h_index": 4,
          "profile_url": "https://www.semanticscholar.org/author/2279081101"
        },
        {
          "name": "Xiaowen Ma",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2376896555"
        },
        {
          "name": "Wenqiao Zhang",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2376825488"
        },
        {
          "name": "Xianglin Qiu",
          "h_index": 3,
          "profile_url": "https://www.semanticscholar.org/author/2336304277"
        },
        {
          "name": "Siqi Song",
          "h_index": 3,
          "profile_url": "https://www.semanticscholar.org/author/2336041351"
        },
        {
          "name": "Xiaowei Huang",
          "h_index": 7,
          "profile_url": "https://www.semanticscholar.org/author/2156551700"
        },
        {
          "name": "Fei Ma",
          "h_index": 6,
          "profile_url": "https://www.semanticscholar.org/author/2258721789"
        },
        {
          "name": "Jimin Xiao",
          "h_index": 8,
          "profile_url": "https://www.semanticscholar.org/author/2258803011"
        }
      ]
    },
    {
      "id": "2508.17011",
      "title": "A Survey of Deep Learning-based Point Cloud Denoising",
      "authors": [
        "Jinxi Wang",
        "Ben Fei",
        "Dasith de Silva Edirimuni",
        "Zheng Liu",
        "Ying He",
        "Xuequan Lu"
      ],
      "categories": [
        "cs.GR (Graphics)",
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Accurate 3D geometry acquisition is essential for a wide range of\napplications, such as computer graphics, autonomous driving, robotics, and\naugmented reality. However, raw point clouds acquired in real-world\nenvironments are often corrupted with noise due to various factors such as\nsensor, lighting, material, environment etc, which reduces geometric fidelity\nand degrades downstream performance. Point cloud denoising is a fundamental\nproblem, aiming to recover clean point sets while preserving underlying\nstructures. Classical optimization-based methods, guided by hand-crafted\nfilters or geometric priors, have been extensively studied but struggle to\nhandle diverse and complex noise patterns. Recent deep learning approaches\nleverage neural network architectures to learn distinctive representations and\ndemonstrate strong outcomes, particularly on complex and large-scale point\nclouds. Provided these significant advances, this survey provides a\ncomprehensive and up-to-date review of deep learning-based point cloud\ndenoising methods up to August 2025. We organize the literature from two\nperspectives: (1) supervision level (supervised vs. unsupervised), and (2)\nmodeling perspective, proposing a functional taxonomy that unifies diverse\napproaches by their denoising principles. We further analyze architectural\ntrends both structurally and chronologically, establish a unified benchmark\nwith consistent training settings, and evaluate methods in terms of denoising\nquality, surface fidelity, point distribution, and computational efficiency.\nFinally, we discuss open challenges and outline directions for future research\nin this rapidly evolving field.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.17011v1",
      "pdf_url": "http://arxiv.org/pdf/2508.17011v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.338,
      "weak_supervision_score": 0.443,
      "diffusion_reasoning_score": 0.357,
      "distributed_training_score": 0.37,
      "datasets_score": 0.363,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "Tangentially Relevant",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "The paper surveys deep learning-based point cloud denoising methods, categorizing them into supervised and unsupervised approaches based on supervision levels. While supervised methods might indirectly include techniques similar to weak supervision (e.g., using noisy or programmatically derived labels), the paper does not specifically discuss or emphasize weak supervision as defined—training models with high-level, noisy, or imprecise labels generated programmatically. Thus, it touches on broader supervision concepts but lacks direct relevance.",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.17012",
      "title": "Fiducial Marker Splatting for High-Fidelity Robotics Simulations",
      "authors": [
        "Diram Tabaa",
        "Gianni Di Caro"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.RO (Robotics)"
      ],
      "abstract": "High-fidelity 3D simulation is critical for training mobile robots, but its\ntraditional reliance on mesh-based representations often struggle in complex\nenvironments, such as densely packed greenhouses featuring occlusions and\nrepetitive structures. Recent neural rendering methods, like Gaussian Splatting\n(GS), achieve remarkable visual realism but lack flexibility to incorporate\nfiducial markers, which are essential for robotic localization and control. We\npropose a hybrid framework that combines the photorealism of GS with structured\nmarker representations. Our core contribution is a novel algorithm for\nefficiently generating GS-based fiducial markers (e.g., AprilTags) within\ncluttered scenes. Experiments show that our approach outperforms traditional\nimage-fitting techniques in both efficiency and pose-estimation accuracy. We\nfurther demonstrate the framework's potential in a greenhouse simulation. This\nagricultural setting serves as a challenging testbed, as its combination of\ndense foliage, similar-looking elements, and occlusions pushes the limits of\nperception, thereby highlighting the framework's value for real-world\napplications.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.17012v1",
      "pdf_url": "http://arxiv.org/pdf/2508.17012v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.309,
      "weak_supervision_score": 0.323,
      "diffusion_reasoning_score": 0.373,
      "distributed_training_score": 0.33,
      "datasets_score": 0.297,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.17017",
      "title": "Dual Orthogonal Guidance for Robust Diffusion-based Handwritten Text\n  Generation",
      "authors": [
        "Konstantina Nikolaidou",
        "George Retsinas",
        "Giorgos Sfikas",
        "Silvia Cascianelli",
        "Rita Cucchiara",
        "Marcus Liwicki"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Diffusion-based Handwritten Text Generation (HTG) approaches achieve\nimpressive results on frequent, in-vocabulary words observed at training time\nand on regular styles. However, they are prone to memorizing training samples\nand often struggle with style variability and generation clarity. In\nparticular, standard diffusion models tend to produce artifacts or distortions\nthat negatively affect the readability of the generated text, especially when\nthe style is hard to produce. To tackle these issues, we propose a novel\nsampling guidance strategy, Dual Orthogonal Guidance (DOG), that leverages an\northogonal projection of a negatively perturbed prompt onto the original\npositive prompt. This approach helps steer the generation away from artifacts\nwhile maintaining the intended content, and encourages more diverse, yet\nplausible, outputs. Unlike standard Classifier-Free Guidance (CFG), which\nrelies on unconditional predictions and produces noise at high guidance scales,\nDOG introduces a more stable, disentangled direction in the latent space. To\ncontrol the strength of the guidance across the denoising process, we apply a\ntriangular schedule: weak at the start and end of denoising, when the process\nis most sensitive, and strongest in the middle steps. Experimental results on\nthe state-of-the-art DiffusionPen and One-DM demonstrate that DOG improves both\ncontent clarity and style variability, even for out-of-vocabulary words and\nchallenging writing styles.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.17017v1",
      "pdf_url": "http://arxiv.org/pdf/2508.17017v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "extraction_failed",
      "embedding_status": "completed",
      "rlhf_score": 0.358,
      "weak_supervision_score": 0.359,
      "diffusion_reasoning_score": 0.549,
      "distributed_training_score": 0.321,
      "datasets_score": 0.296,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper's main contribution is a guidance strategy for diffusion-based handwritten text generation, aimed at improving image quality and style variability. It does not involve adapting diffusion models for multi-step logical reasoning, solving complex logical tasks, or treating a Chain-of-Thought as a single entity for holistic correction, as required by the topic definition.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.17025",
      "title": "Probabilistic Temporal Masked Attention for Cross-view Online Action\n  Detection",
      "authors": [
        "Liping Xie",
        "Yang Tan",
        "Shicheng Jing",
        "Huimin Lu",
        "Kanjian Zhang"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.MM (Multimedia)"
      ],
      "abstract": "As a critical task in video sequence classification within computer vision,\nOnline Action Detection (OAD) has garnered significant attention. The\nsensitivity of mainstream OAD models to varying video viewpoints often hampers\ntheir generalization when confronted with unseen sources. To address this\nlimitation, we propose a novel Probabilistic Temporal Masked Attention (PTMA)\nmodel, which leverages probabilistic modeling to derive latent compressed\nrepresentations of video frames in a cross-view setting. The PTMA model\nincorporates a GRU-based temporal masked attention (TMA) cell, which leverages\nthese representations to effectively query the input video sequence, thereby\nenhancing information interaction and facilitating autoregressive frame-level\nvideo analysis. Additionally, multi-view information can be integrated into the\nprobabilistic modeling to facilitate the extraction of view-invariant features.\nExperiments conducted under three evaluation protocols: cross-subject (cs),\ncross-view (cv), and cross-subject-view (csv) show that PTMA achieves\nstate-of-the-art performance on the DAHLIA, IKEA ASM, and Breakfast datasets.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.17025v1",
      "pdf_url": "http://arxiv.org/pdf/2508.17025v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.309,
      "weak_supervision_score": 0.328,
      "diffusion_reasoning_score": 0.372,
      "distributed_training_score": 0.331,
      "datasets_score": 0.322,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.17029",
      "title": "A Novel Local Focusing Mechanism for Deepfake Detection Generalization",
      "authors": [
        "Mingliang Li",
        "Lin Yuanbo Wu",
        "Changhong Liu",
        "Hanxi Li"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "The rapid advancement of deepfake generation techniques has intensified the\nneed for robust and generalizable detection methods. Existing approaches based\non reconstruction learning typically leverage deep convolutional networks to\nextract differential features. However, these methods show poor generalization\nacross object categories (e.g., from faces to cars) and generation domains\n(e.g., from GANs to Stable Diffusion), due to intrinsic limitations of deep\nCNNs. First, models trained on a specific category tend to overfit to semantic\nfeature distributions, making them less transferable to other categories,\nespecially as network depth increases. Second, Global Average Pooling (GAP)\ncompresses critical local forgery cues into a single vector, thus discarding\ndiscriminative patterns vital for real-fake classification. To address these\nissues, we propose a novel Local Focus Mechanism (LFM) that explicitly attends\nto discriminative local features for differentiating fake from real images. LFM\nintegrates a Salience Network (SNet) with a task-specific Top-K Pooling (TKP)\nmodule to select the K most informative local patterns. To mitigate potential\noverfitting introduced by Top-K pooling, we introduce two regularization\ntechniques: Rank-Based Linear Dropout (RBLD) and Random-K Sampling (RKS), which\nenhance the model's robustness. LFM achieves a 3.7 improvement in accuracy and\na 2.8 increase in average precision over the state-of-the-art Neighboring Pixel\nRelationships (NPR) method, while maintaining exceptional efficiency at 1789\nFPS on a single NVIDIA A6000 GPU. Our approach sets a new benchmark for\ncross-domain deepfake detection. The source code are available in\nhttps://github.com/lmlpy/LFM.git",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.17029v1",
      "pdf_url": "http://arxiv.org/pdf/2508.17029v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.394,
      "weak_supervision_score": 0.377,
      "diffusion_reasoning_score": 0.398,
      "distributed_training_score": 0.378,
      "datasets_score": 0.344,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.17037",
      "title": "F4-ITS: Fine-grained Feature Fusion for Food Image-Text Search",
      "authors": [
        "Raghul Asokan"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "The proliferation of digital food content has intensified the need for robust\nand accurate systems capable of fine-grained visual understanding and\nretrieval. In this work, we address the challenging task of food image-to-text\nmatching, a critical component in applications such as dietary monitoring,\nsmart kitchens, and restaurant automation. We propose F4-ITS: Fine-grained\nFeature Fusion for Food Image-Text Search, a training-free, vision-language\nmodel (VLM)-guided framework that significantly improves retrieval performance\nthrough enhanced multi-modal feature representations. Our approach introduces\ntwo key contributions: (1) a uni-directional(and bi-directional) multi-modal\nfusion strategy that combines image embeddings with VLM-generated textual\ndescriptions to improve query expressiveness, and (2) a novel feature-based\nre-ranking mechanism for top-k retrieval, leveraging predicted food ingredients\nto refine results and boost precision. Leveraging open-source image-text\nencoders, we demonstrate substantial gains over standard baselines - achieving\n~10% and ~7.7% improvements in top-1 retrieval under dense and sparse caption\nscenarios, and a ~28.6% gain in top-k ingredient-level retrieval. Additionally,\nwe show that smaller models (e.g., ViT-B/32) can match or outperform larger\ncounterparts (e.g., ViT-H, ViT-G, ViT-bigG) when augmented with textual fusion,\nhighlighting the effectiveness of our method in resource-constrained settings.\nCode and test datasets will be made publicly available at:\nhttps://github.com/mailcorahul/f4-its",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.17037v1",
      "pdf_url": "http://arxiv.org/pdf/2508.17037v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.364,
      "weak_supervision_score": 0.327,
      "diffusion_reasoning_score": 0.402,
      "distributed_training_score": 0.316,
      "datasets_score": 0.345,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper proposes a framework for food image-text search using feature fusion and vision-language models, focusing on multi-modal embeddings and re-ranking. It does not involve diffusion models, iterative refinement processes, or any adaptation of diffusion for logical reasoning tasks.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.17044",
      "title": "M3DMap: Object-aware Multimodal 3D Mapping for Dynamic Environments",
      "authors": [
        "Dmitry Yudin"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.RO (Robotics)"
      ],
      "abstract": "3D mapping in dynamic environments poses a challenge for modern researchers\nin robotics and autonomous transportation. There are no universal\nrepresentations for dynamic 3D scenes that incorporate multimodal data such as\nimages, point clouds, and text. This article takes a step toward solving this\nproblem. It proposes a taxonomy of methods for constructing multimodal 3D maps,\nclassifying contemporary approaches based on scene types and representations,\nlearning methods, and practical applications. Using this taxonomy, a brief\nstructured analysis of recent methods is provided. The article also describes\nan original modular method called M3DMap, designed for object-aware\nconstruction of multimodal 3D maps for both static and dynamic scenes. It\nconsists of several interconnected components: a neural multimodal object\nsegmentation and tracking module; an odometry estimation module, including\ntrainable algorithms; a module for 3D map construction and updating with\nvarious implementations depending on the desired scene representation; and a\nmultimodal data retrieval module. The article highlights original\nimplementations of these modules and their advantages in solving various\npractical tasks, from 3D object grounding to mobile manipulation. Additionally,\nit presents theoretical propositions demonstrating the positive effect of using\nmultimodal data and modern foundational models in 3D mapping methods. Details\nof the taxonomy and method implementation are available at\nhttps://yuddim.github.io/M3DMap.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.17044v1",
      "pdf_url": "http://arxiv.org/pdf/2508.17044v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.325,
      "weak_supervision_score": 0.325,
      "diffusion_reasoning_score": 0.415,
      "distributed_training_score": 0.336,
      "datasets_score": 0.355,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on multimodal 3D mapping for dynamic environments, including object segmentation, tracking, and map construction using neural models like CLIP and SAM. It does not involve diffusion models, iterative refinement for logical tasks, or any adaptation of diffusion processes for Chain-of-Thought reasoning. Therefore, it lacks any connection to diffusion-based reasoning.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.17045",
      "title": "Styleclone: Face Stylization with Diffusion Based Data Augmentation",
      "authors": [
        "Neeraj Matiyali",
        "Siddharth Srivastava",
        "Gaurav Sharma"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "We present StyleClone, a method for training image-to-image translation\nnetworks to stylize faces in a specific style, even with limited style images.\nOur approach leverages textual inversion and diffusion-based guided image\ngeneration to augment small style datasets. By systematically generating\ndiverse style samples guided by both the original style images and real face\nimages, we significantly enhance the diversity of the style dataset. Using this\naugmented dataset, we train fast image-to-image translation networks that\noutperform diffusion-based methods in speed and quality. Experiments on\nmultiple styles demonstrate that our method improves stylization quality,\nbetter preserves source image content, and significantly accelerates inference.\nAdditionally, we provide a systematic evaluation of the augmentation techniques\nand their impact on stylization performance.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.17045v1",
      "pdf_url": "http://arxiv.org/pdf/2508.17045v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.316,
      "weak_supervision_score": 0.358,
      "diffusion_reasoning_score": 0.479,
      "distributed_training_score": 0.337,
      "datasets_score": 0.318,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper utilizes diffusion models for image generation and data augmentation in face stylization, specifically to create diverse style images for training lightweight networks. It does not involve adapting diffusion for multi-step logical reasoning, Chain-of-Thought processes, or solving complex logical tasks, focusing instead on visual synthesis.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.17050",
      "title": "PVNet: Point-Voxel Interaction LiDAR Scene Upsampling Via Diffusion\n  Models",
      "authors": [
        "Xianjing Cheng",
        "Lintai Wu",
        "Zuowen Wang",
        "Junhui Hou",
        "Jie Wen",
        "Yong Xu"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Accurate 3D scene understanding in outdoor environments heavily relies on\nhigh-quality point clouds. However, LiDAR-scanned data often suffer from\nextreme sparsity, severely hindering downstream 3D perception tasks. Existing\npoint cloud upsampling methods primarily focus on individual objects, thus\ndemonstrating limited generalization capability for complex outdoor scenes. To\naddress this issue, we propose PVNet, a diffusion model-based point-voxel\ninteraction framework to perform LiDAR point cloud upsampling without dense\nsupervision. Specifically, we adopt the classifier-free guidance-based DDPMs to\nguide the generation, in which we employ a sparse point cloud as the guiding\ncondition and the synthesized point clouds derived from its nearby frames as\nthe input. Moreover, we design a voxel completion module to refine and complete\nthe coarse voxel features for enriching the feature representation. In\naddition, we propose a point-voxel interaction module to integrate features\nfrom both points and voxels, which efficiently improves the environmental\nperception capability of each upsampled point. To the best of our knowledge,\nour approach is the first scene-level point cloud upsampling method supporting\narbitrary upsampling rates. Extensive experiments on various benchmarks\ndemonstrate that our method achieves state-of-the-art performance. The source\ncode will be available at https://github.com/chengxianjing/PVNet.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.17050v1",
      "pdf_url": "http://arxiv.org/pdf/2508.17050v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.291,
      "weak_supervision_score": 0.355,
      "diffusion_reasoning_score": 0.444,
      "distributed_training_score": 0.343,
      "datasets_score": 0.3,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on using diffusion models for point cloud upsampling in LiDAR data, employing iterative denoising to generate denser 3D representations. However, it does not involve adapting diffusion for complex logical tasks, multi-step reasoning, or treating a 'Chain-of-Thought' as an entity. The application is purely generative for perceptual tasks, without any logical reasoning components.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.17054",
      "title": "DeltaFlow: An Efficient Multi-frame Scene Flow Estimation Method",
      "authors": [
        "Qingwen Zhang",
        "Xiaomeng Zhu",
        "Yushan Zhang",
        "Yixi Cai",
        "Olov Andersson",
        "Patric Jensfelt"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.RO (Robotics)"
      ],
      "abstract": "Previous dominant methods for scene flow estimation focus mainly on input\nfrom two consecutive frames, neglecting valuable information in the temporal\ndomain. While recent trends shift towards multi-frame reasoning, they suffer\nfrom rapidly escalating computational costs as the number of frames grows. To\nleverage temporal information more efficiently, we propose DeltaFlow\n($\\Delta$Flow), a lightweight 3D framework that captures motion cues via a\n$\\Delta$ scheme, extracting temporal features with minimal computational cost,\nregardless of the number of frames. Additionally, scene flow estimation faces\nchallenges such as imbalanced object class distributions and motion\ninconsistency. To tackle these issues, we introduce a Category-Balanced Loss to\nenhance learning across underrepresented classes and an Instance Consistency\nLoss to enforce coherent object motion, improving flow accuracy. Extensive\nevaluations on the Argoverse 2 and Waymo datasets show that $\\Delta$Flow\nachieves state-of-the-art performance with up to 22% lower error and $2\\times$\nfaster inference compared to the next-best multi-frame supervised method, while\nalso demonstrating a strong cross-domain generalization ability. The code is\nopen-sourced at https://github.com/Kin-Zhang/DeltaFlow along with trained model\nweights.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.17054v1",
      "pdf_url": "http://arxiv.org/pdf/2508.17054v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.308,
      "weak_supervision_score": 0.306,
      "diffusion_reasoning_score": 0.38,
      "distributed_training_score": 0.384,
      "datasets_score": 0.292,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.17056",
      "title": "TabResFlow: A Normalizing Spline Flow Model for Probabilistic Univariate\n  Tabular Regression",
      "authors": [
        "Kiran Madhusudhanan",
        "Vijaya Krishna Yalavarthi",
        "Jonas Sonntag",
        "Maximilian Stubbemann",
        "Lars Schmidt-Thieme"
      ],
      "categories": [
        "cs.LG (Machine Learning)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Tabular regression is a well-studied problem with numerous industrial\napplications, yet most existing approaches focus on point estimation, often\nleading to overconfident predictions. This issue is particularly critical in\nindustrial automation, where trustworthy decision-making is essential.\nProbabilistic regression models address this challenge by modeling prediction\nuncertainty. However, many conventional methods assume a fixed-shape\ndistribution (typically Gaussian), and resort to estimating distribution\nparameters. This assumption is often restrictive, as real-world target\ndistributions can be highly complex. To overcome this limitation, we introduce\nTabResFlow, a Normalizing Spline Flow model designed specifically for\nunivariate tabular regression, where commonly used simple flow networks like\nRealNVP and Masked Autoregressive Flow (MAF) are unsuitable. TabResFlow\nconsists of three key components: (1) An MLP encoder for each numerical\nfeature. (2) A fully connected ResNet backbone for expressive feature\nextraction. (3) A conditional spline-based normalizing flow for flexible and\ntractable density estimation. We evaluate TabResFlow on nine public benchmark\ndatasets, demonstrating that it consistently surpasses existing probabilistic\nregression models on likelihood scores. Our results demonstrate 9.64%\nimprovement compared to the strongest probabilistic regression model\n(TreeFlow), and on average 5.6 times speed-up in inference time compared to the\nstrongest deep learning alternative (NodeFlow). Additionally, we validate the\npractical applicability of TabResFlow in a real-world used car price prediction\ntask under selective regression. To measure performance in this setting, we\nintroduce a novel Area Under Risk Coverage (AURC) metric and show that\nTabResFlow achieves superior results across this metric.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.17056v1",
      "pdf_url": "http://arxiv.org/pdf/2508.17056v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.385,
      "weak_supervision_score": 0.36,
      "diffusion_reasoning_score": 0.411,
      "distributed_training_score": 0.375,
      "datasets_score": 0.298,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper introduces TabResFlow, a normalizing flow model for probabilistic tabular regression, focusing on density estimation and uncertainty modeling using components like MLP encoders and spline-based flows. It does not involve diffusion models, iterative refinement processes, or any adaptation for solving complex logical tasks or Chain-of-Thought reasoning. Therefore, there is no connection to diffusion-based reasoning.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.17061",
      "title": "REGEN: Real-Time Photorealism Enhancement in Games via a Dual-Stage\n  Generative Network Framework",
      "authors": [
        "Stefanos Pasios",
        "Nikos Nikolaidis"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Photorealism is an important aspect of modern video games since it can shape\nthe player experience and simultaneously impact the immersion, narrative\nengagement, and visual fidelity. Although recent hardware technological\nbreakthroughs, along with state-of-the-art rendering technologies, have\nsignificantly improved the visual realism of video games, achieving true\nphotorealism in dynamic environments at real-time frame rates still remains a\nmajor challenge due to the tradeoff between visual quality and performance. In\nthis short paper, we present a novel approach for enhancing the photorealism of\nrendered game frames using generative adversarial networks. To this end, we\npropose Real-time photorealism Enhancement in Games via a dual-stage gEnerative\nNetwork framework (REGEN), which employs a robust unpaired image-to-image\ntranslation model to produce semantically consistent photorealistic frames that\ntransform the problem into a simpler paired image-to-image translation task.\nThis enables training with a lightweight method that can achieve real-time\ninference time without compromising visual quality. We demonstrate the\neffectiveness of our framework on Grand Theft Auto V, showing that the approach\nachieves visual results comparable to the ones produced by the robust unpaired\nIm2Im method while improving inference speed by 32.14 times. Our findings also\nindicate that the results outperform the photorealism-enhanced frames produced\nby directly training a lightweight unpaired Im2Im translation method to\ntranslate the video game frames towards the visual characteristics of\nreal-world images. Code, pre-trained models, and demos for this work are\navailable at: https://github.com/stefanos50/REGEN.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.17061v1",
      "pdf_url": "http://arxiv.org/pdf/2508.17061v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.369,
      "weak_supervision_score": 0.294,
      "diffusion_reasoning_score": 0.422,
      "distributed_training_score": 0.345,
      "datasets_score": 0.292,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper presents a framework using generative adversarial networks (GANs) for image-to-image translation to enhance photorealism in video games. It does not involve diffusion models, iterative refinement for logical tasks, or any multi-step reasoning processes. The core contribution is visual enhancement, not reasoning or chain-of-thought correction.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.17062",
      "title": "SSG-Dit: A Spatial Signal Guided Framework for Controllable Video\n  Generation",
      "authors": [
        "Peng Hu",
        "Yu Gu",
        "Liang Luo",
        "Fuji Ren"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Controllable video generation aims to synthesize video content that aligns\nprecisely with user-provided conditions, such as text descriptions and initial\nimages. However, a significant challenge persists in this domain: existing\nmodels often struggle to maintain strong semantic consistency, frequently\ngenerating videos that deviate from the nuanced details specified in the\nprompts. To address this issue, we propose SSG-DiT (Spatial Signal Guided\nDiffusion Transformer), a novel and efficient framework for high-fidelity\ncontrollable video generation. Our approach introduces a decoupled two-stage\nprocess. The first stage, Spatial Signal Prompting, generates a spatially aware\nvisual prompt by leveraging the rich internal representations of a pre-trained\nmulti-modal model. This prompt, combined with the original text, forms a joint\ncondition that is then injected into a frozen video DiT backbone via our\nlightweight and parameter-efficient SSG-Adapter. This unique design, featuring\na dual-branch attention mechanism, allows the model to simultaneously harness\nits powerful generative priors while being precisely steered by external\nspatial signals. Extensive experiments demonstrate that SSG-DiT achieves\nstate-of-the-art performance, outperforming existing models on multiple key\nmetrics in the VBench benchmark, particularly in spatial relationship control\nand overall consistency.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.17062v1",
      "pdf_url": "http://arxiv.org/pdf/2508.17062v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "extraction_failed",
      "embedding_status": "completed",
      "rlhf_score": 0.359,
      "weak_supervision_score": 0.351,
      "diffusion_reasoning_score": 0.507,
      "distributed_training_score": 0.326,
      "datasets_score": 0.338,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on using a Diffusion Transformer for controllable video generation, emphasizing spatial signal guidance and semantic consistency in visual outputs. It does not involve adapting diffusion processes for multi-step logical reasoning, solving complex logical tasks, or treating a 'Chain-of-Thought' as an entity for holistic correction. Thus, it lacks the core elements of diffusion-based reasoning.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.17069",
      "title": "Optimizing Neural Networks with Learnable Non-Linear Activation\n  Functions via Lookup-Based FPGA Acceleration",
      "authors": [
        "Mengyuan Yin",
        "Benjamin Chen Ming Choong",
        "Chuping Qu",
        "Rick Siow Mong Goh",
        "Weng-Fai Wong",
        "Tao Luo"
      ],
      "categories": [
        "cs.AR (Hardware Architecture)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Learned activation functions in models like Kolmogorov-Arnold Networks (KANs)\noutperform fixed-activation architectures in terms of accuracy and\ninterpretability; however, their computational complexity poses critical\nchallenges for energy-constrained edge AI deployments. Conventional CPUs/GPUs\nincur prohibitive latency and power costs when evaluating higher order\nactivations, limiting deployability under ultra-tight energy budgets. We\naddress this via a reconfigurable lookup architecture with edge FPGAs. By\ncoupling fine-grained quantization with adaptive lookup tables, our design\nminimizes energy-intensive arithmetic operations while preserving activation\nfidelity. FPGA reconfigurability enables dynamic hardware specialization for\nlearned functions, a key advantage for edge systems that require\npost-deployment adaptability. Evaluations using KANs - where unique activation\nfunctions play a critical role - demonstrate that our FPGA-based design\nachieves superior computational speed and over $10^4$ times higher energy\nefficiency compared to edge CPUs and GPUs, while maintaining matching accuracy\nand minimal footprint overhead. This breakthrough positions our approach as a\npractical enabler for energy-critical edge AI, where computational intensity\nand power constraints traditionally preclude the use of adaptive activation\nnetworks.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.17069v1",
      "pdf_url": "http://arxiv.org/pdf/2508.17069v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.345,
      "weak_supervision_score": 0.308,
      "diffusion_reasoning_score": 0.334,
      "distributed_training_score": 0.408,
      "datasets_score": 0.26,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "Not Relevant",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "The paper focuses on accelerating inference for neural networks with learnable activation functions using FPGA-based lookup tables and quantization, specifically for edge deployments. It does not address distributed training, parallel computing across multiple nodes, or strategies for partitioning data/computation during model training. While FPGAs enable parallelism for inference, this is unrelated to multi-node training scenarios.",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.17078",
      "title": "Linguistic Neuron Overlap Patterns to Facilitate Cross-lingual Transfer\n  on Low-resource Languages",
      "authors": [
        "Yuemei Xu",
        "Kexin Xu",
        "Jian Zhou",
        "Ling Hu",
        "Lin Gui"
      ],
      "categories": [
        "cs.CL (Computation and Language)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "The current Large Language Models (LLMs) face significant challenges in\nimproving performance on low-resource languages and urgently need\ndata-efficient methods without costly fine-tuning. From the perspective of\nlanguage-bridge, we propose BridgeX-ICL, a simple yet effective method to\nimprove zero-shot Cross-lingual In-Context Learning (X-ICL) for low-resource\nlanguages. Unlike existing works focusing on language-specific neurons,\nBridgeX-ICL explores whether sharing neurons can improve cross-lingual\nperformance in LLMs or not. We construct neuron probe data from the\nground-truth MUSE bilingual dictionaries, and define a subset of language\noverlap neurons accordingly, to ensure full activation of these anchored\nneurons. Subsequently, we propose an HSIC-based metric to quantify LLMs'\ninternal linguistic spectrum based on overlap neurons, which guides optimal\nbridge selection. The experiments conducted on 2 cross-lingual tasks and 15\nlanguage pairs from 7 diverse families (covering both high-low and moderate-low\npairs) validate the effectiveness of BridgeX-ICL and offer empirical insights\ninto the underlying multilingual mechanisms of LLMs.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.17078v1",
      "pdf_url": "http://arxiv.org/pdf/2508.17078v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.391,
      "weak_supervision_score": 0.397,
      "diffusion_reasoning_score": 0.409,
      "distributed_training_score": 0.4,
      "datasets_score": 0.301,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "Not Relevant",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on improving cross-lingual transfer in LLMs using neuron overlap analysis and BridgeX-ICL for low-resource languages. It does not involve diffusion models, iterative refinement processes, or multi-step logical reasoning on a Chain-of-Thought, making it unrelated to this topic.",
      "distributed_training_justification": "The paper discusses enhancing LLMs' multilingual capabilities through in-context learning and neuron-based methods, without addressing distributed training, parallel computing, multi-node setups, or strategies for partitioning data/computation across processors.",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.17079",
      "title": "Zero-shot Multimodal Document Retrieval via Cross-modal Question\n  Generation",
      "authors": [
        "Yejin Choi",
        "Jaewoo Park",
        "Janghan Yoon",
        "Saejin Kim",
        "Jaehyun Jeon",
        "Youngjae Yu"
      ],
      "categories": [
        "cs.IR (Information Retrieval)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Rapid advances in Multimodal Large Language Models (MLLMs) have expanded\ninformation retrieval beyond purely textual inputs, enabling retrieval from\ncomplex real world documents that combine text and visuals. However, most\ndocuments are private either owned by individuals or confined within corporate\nsilos and current retrievers struggle when faced with unseen domains or\nlanguages. To address this gap, we introduce PREMIR, a simple yet effective\nframework that leverages the broad knowledge of an MLLM to generate cross modal\npre questions (preQs) before retrieval. Unlike earlier multimodal retrievers\nthat compare embeddings in a single vector space, PREMIR leverages preQs from\nmultiple complementary modalities to expand the scope of matching to the token\nlevel. Experiments show that PREMIR achieves state of the art performance on\nout of distribution benchmarks, including closed domain and multilingual\nsettings, outperforming strong baselines across all retrieval metrics. We\nconfirm the contribution of each component through in depth ablation studies,\nand qualitative analyses of the generated preQs further highlight the model's\nrobustness in real world settings.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.17079v1",
      "pdf_url": "http://arxiv.org/pdf/2508.17079v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.359,
      "weak_supervision_score": 0.356,
      "diffusion_reasoning_score": 0.428,
      "distributed_training_score": 0.357,
      "datasets_score": 0.351,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper's main contribution is a framework for zero-shot multimodal document retrieval using cross-modal question generation with MLLMs, focusing on improving retrieval in out-of-distribution scenarios. It does not involve diffusion models, iterative refinement processes, or multi-step logical reasoning for complex tasks, as required for this topic.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.17081",
      "title": "Proximal Vision Transformer: Enhancing Feature Representation through\n  Two-Stage Manifold Geometry",
      "authors": [
        "Haoyu Yun",
        "Hamid Krim"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "The Vision Transformer (ViT) architecture has become widely recognized in\ncomputer vision, leveraging its self-attention mechanism to achieve remarkable\nsuccess across various tasks. Despite its strengths, ViT's optimization remains\nconfined to modeling local relationships within individual images, limiting its\nability to capture the global geometric relationships between data points. To\naddress this limitation, this paper proposes a novel framework that integrates\nViT with the proximal tools, enabling a unified geometric optimization approach\nto enhance feature representation and classification performance. In this\nframework, ViT constructs the tangent bundle of the manifold through its\nself-attention mechanism, where each attention head corresponds to a tangent\nspace, offering geometric representations from diverse local perspectives.\nProximal iterations are then introduced to define sections within the tangent\nbundle and project data from tangent spaces onto the base space, achieving\nglobal feature alignment and optimization. Experimental results confirm that\nthe proposed method outperforms traditional ViT in terms of classification\naccuracy and data distribution.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.17081v1",
      "pdf_url": "http://arxiv.org/pdf/2508.17081v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "extraction_failed",
      "embedding_status": "completed",
      "rlhf_score": 0.313,
      "weak_supervision_score": 0.301,
      "diffusion_reasoning_score": 0.35,
      "distributed_training_score": 0.312,
      "datasets_score": 0.285,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.17082",
      "title": "PD-Loss: Proxy-Decidability for Efficient Metric Learning",
      "authors": [
        "Pedro Silva",
        "Guilherme A. L. Silva",
        "Pablo Coelho",
        "Vander Freitas",
        "Gladston Moreira",
        "David Menotii",
        "Eduardo Luz"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Deep Metric Learning (DML) aims to learn embedding functions that map\nsemantically similar inputs to proximate points in a metric space while\nseparating dissimilar ones. Existing methods, such as pairwise losses, are\nhindered by complex sampling requirements and slow convergence. In contrast,\nproxy-based losses, despite their improved scalability, often fail to optimize\nglobal distribution properties. The Decidability-based Loss (D-Loss) addresses\nthis by targeting the decidability index (d') to enhance distribution\nseparability, but its reliance on large mini-batches imposes significant\ncomputational constraints. We introduce Proxy-Decidability Loss (PD-Loss), a\nnovel objective that integrates learnable proxies with the statistical\nframework of d' to optimize embedding spaces efficiently. By estimating genuine\nand impostor distributions through proxies, PD-Loss combines the computational\nefficiency of proxy-based methods with the principled separability of D-Loss,\noffering a scalable approach to distribution-aware DML. Experiments across\nvarious tasks, including fine-grained classification and face verification,\ndemonstrate that PD-Loss achieves performance comparable to that of\nstate-of-the-art methods while introducing a new perspective on embedding\noptimization, with potential for broader applications.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.17082v1",
      "pdf_url": "http://arxiv.org/pdf/2508.17082v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.36,
      "weak_supervision_score": 0.388,
      "diffusion_reasoning_score": 0.334,
      "distributed_training_score": 0.392,
      "datasets_score": 0.341,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.17087",
      "title": "Solving the Min-Max Multiple Traveling Salesmen Problem via\n  Learning-Based Path Generation and Optimal Splitting",
      "authors": [
        "Wen Wang",
        "Xiangchen Wu",
        "Liang Wang",
        "Hao Hu",
        "Xianping Tao",
        "Linghao Zhang"
      ],
      "categories": [
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "This study addresses the Min-Max Multiple Traveling Salesmen Problem\n($m^3$-TSP), which aims to coordinate tours for multiple salesmen such that the\nlength of the longest tour is minimized. Due to its NP-hard nature, exact\nsolvers become impractical under the assumption that $P \\ne NP$. As a result,\nlearning-based approaches have gained traction for their ability to rapidly\ngenerate high-quality approximate solutions. Among these, two-stage methods\ncombine learning-based components with classical solvers, simplifying the\nlearning objective. However, this decoupling often disrupts consistent\noptimization, potentially degrading solution quality. To address this issue, we\npropose a novel two-stage framework named \\textbf{Generate-and-Split} (GaS),\nwhich integrates reinforcement learning (RL) with an optimal splitting\nalgorithm in a joint training process. The splitting algorithm offers\nnear-linear scalability with respect to the number of cities and guarantees\noptimal splitting in Euclidean space for any given path. To facilitate the\njoint optimization of the RL component with the algorithm, we adopt an\nLSTM-enhanced model architecture to address partial observability. Extensive\nexperiments show that the proposed GaS framework significantly outperforms\nexisting learning-based approaches in both solution quality and\ntransferability.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.17087v1",
      "pdf_url": "http://arxiv.org/pdf/2508.17087v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.326,
      "weak_supervision_score": 0.309,
      "diffusion_reasoning_score": 0.358,
      "distributed_training_score": 0.379,
      "datasets_score": 0.267,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.17092",
      "title": "Enhancing Knowledge Tracing through Leakage-Free and Recency-Aware\n  Embeddings",
      "authors": [
        "Yahya Badran",
        "Christine Preisach"
      ],
      "categories": [
        "cs.CY (Computers and Society)",
        "cs.AI (Artificial Intelligence)",
        "cs.LG (Machine Learning)"
      ],
      "abstract": "Knowledge Tracing (KT) aims to predict a student's future performance based\non their sequence of interactions with learning content. Many KT models rely on\nknowledge concepts (KCs), which represent the skills required for each item.\nHowever, some of these models are vulnerable to label leakage, in which input\ndata inadvertently reveal the correct answer, particularly in datasets with\nmultiple KCs per question.\n  We propose a straightforward yet effective solution to prevent label leakage\nby masking ground-truth labels during input embedding construction in cases\nsusceptible to leakage. To accomplish this, we introduce a dedicated MASK\nlabel, inspired by masked language modeling (e.g., BERT), to replace\nground-truth labels. In addition, we introduce Recency Encoding, which encodes\nthe step-wise distance between the current item and its most recent previous\noccurrence. This distance is important for modeling learning dynamics such as\nforgetting, which is a fundamental aspect of human learning, yet it is often\noverlooked in existing models. Recency Encoding demonstrates improved\nperformance over traditional positional encodings on multiple KT benchmarks.\n  We show that incorporating our embeddings into KT models like DKT, DKT+, AKT,\nand SAKT consistently improves prediction accuracy across multiple benchmarks.\nThe approach is both efficient and widely applicable.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.17092v1",
      "pdf_url": "http://arxiv.org/pdf/2508.17092v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.375,
      "weak_supervision_score": 0.401,
      "diffusion_reasoning_score": 0.394,
      "distributed_training_score": 0.313,
      "datasets_score": 0.333,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "Tangentially Relevant",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "The paper focuses on preventing label leakage in Knowledge Tracing models by masking ground-truth labels, which shares some similarities with weak supervision techniques that handle noisy or imprecise labels (e.g., inspired by masked language modeling). However, it does not primarily involve programmatically generating large quantities of training labels from high-level sources; instead, it aims to enhance model accuracy in educational contexts by ensuring clean training signals and adding recency encoding. Thus, the connection is indirect rather than central.",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.17094",
      "title": "PowerChain: Automating Distribution Grid Analysis with Agentic AI\n  Workflows",
      "authors": [
        "Emmanuel O. Badmus",
        "Peng Sang",
        "Dimitrios Stamoulis",
        "Amritanshu Pandey"
      ],
      "categories": [
        "cs.AI (Artificial Intelligence)",
        "cs.SY (Systems and Control)",
        "eess.SY (Systems and Control)"
      ],
      "abstract": "Due to the rapid pace of electrification and decarbonization, distribution\ngrid (DG) operation and planning are becoming more complex, necessitating\nadvanced computational analyses to ensure grid reliability and resilience.\nState-of-the-art DG analyses rely on disparate workflows of complex models,\nfunctions, and data pipelines, which require expert knowledge and are\nchallenging to automate. Many small-scale utilities and cooperatives lack a\nlarge R&D workforce and therefore cannot use advanced analysis at scale. To\naddress this gap, we develop a novel agentic AI system, PowerChain, to solve\nunseen DG analysis tasks via automated agentic orchestration and large language\nmodels (LLMs) function-calling. Given a natural language query, PowerChain\ndynamically generates and executes an ordered sequence of domain-aware\nfunctions guided by the semantics of an expert-built power systems function\npool and a select reference set of known, expert-generated workflow-query\npairs. Our results show that PowerChain can produce expert-level workflows with\nboth GPT-5 and open-source Qwen models on complex, unseen DG analysis tasks\noperating on real utility data.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.17094v1",
      "pdf_url": "http://arxiv.org/pdf/2508.17094v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.402,
      "weak_supervision_score": 0.371,
      "diffusion_reasoning_score": 0.429,
      "distributed_training_score": 0.408,
      "datasets_score": 0.339,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "Not Relevant",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper focuses on using pre-existing LLMs for workflow automation in power grid analysis via in-context learning and function-calling, without any mention of training a reward model, human-ranked data, or fine-tuning through reinforcement learning. It relies on expert-generated workflow-query pairs for guidance, not RLHF processes.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper describes agentic workflows and iterative methods like Monte Carlo Tree Search for task orchestration, but it does not involve diffusion models or an iterative refinement process for reasoning. There is no evidence of treating a Chain-of-Thought as a holistic entity for multi-step correction using diffusion techniques.",
      "distributed_training_justification": "The paper's main contribution is an agentic AI system for automating grid analysis, not techniques for distributed training, parallel computing, or partitioning data/models across nodes. It mentions deploying on lightweight models but does not discuss accelerating model training through distributed methods.",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.17096",
      "title": "Convolutional Neural Networks for Accurate Measurement of Train Speed",
      "authors": [
        "Haitao Tian",
        "Argyrios Zolotas",
        "Miguel Arana-Catania"
      ],
      "categories": [
        "cs.LG (Machine Learning)",
        "cs.AI (Artificial Intelligence)",
        "cs.SY (Systems and Control)",
        "eess.SY (Systems and Control)"
      ],
      "abstract": "In this study, we explore the use of Convolutional Neural Networks for\nimproving train speed estimation accuracy, addressing the complex challenges of\nmodern railway systems. We investigate three CNN architectures - single-branch\n2D, single-branch 1D, and multiple-branch models - and compare them with the\nAdaptive Kalman Filter. We analyse their performance using simulated train\noperation datasets with and without Wheel Slide Protection activation. Our\nresults reveal that CNN-based approaches, especially the multiple-branch model,\ndemonstrate superior accuracy and robustness compared to traditional methods,\nparticularly under challenging operational conditions. These findings highlight\nthe potential of deep learning techniques to enhance railway safety and\noperational efficiency by more effectively capturing intricate patterns in\ncomplex transportation datasets.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.17096v1",
      "pdf_url": "http://arxiv.org/pdf/2508.17096v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.349,
      "weak_supervision_score": 0.368,
      "diffusion_reasoning_score": 0.378,
      "distributed_training_score": 0.391,
      "datasets_score": 0.335,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.17097",
      "title": "Two Birds with One Stone: Enhancing Uncertainty Quantification and\n  Interpretability with Graph Functional Neural Process",
      "authors": [
        "Lingkai Kong",
        "Haotian Sun",
        "Yuchen Zhuang",
        "Haorui Wang",
        "Wenhao Mu",
        "Chao Zhang"
      ],
      "categories": [
        "cs.LG (Machine Learning)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Graph neural networks (GNNs) are powerful tools on graph data. However, their\npredictions are mis-calibrated and lack interpretability, limiting their\nadoption in critical applications. To address this issue, we propose a new\nuncertainty-aware and interpretable graph classification model that combines\ngraph functional neural process and graph generative model. The core of our\nmethod is to assume a set of latent rationales which can be mapped to a\nprobabilistic embedding space; the predictive distribution of the classifier is\nconditioned on such rationale embeddings by learning a stochastic correlation\nmatrix. The graph generator serves to decode the graph structure of the\nrationales from the embedding space for model interpretability. For efficient\nmodel training, we adopt an alternating optimization procedure which mimics the\nwell known Expectation-Maximization (EM) algorithm. The proposed method is\ngeneral and can be applied to any existing GNN architecture. Extensive\nexperiments on five graph classification datasets demonstrate that our\nframework outperforms state-of-the-art methods in both uncertainty\nquantification and GNN interpretability. We also conduct case studies to show\nthat the decoded rationale structure can provide meaningful explanations.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.17097v1",
      "pdf_url": "http://arxiv.org/pdf/2508.17097v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.36,
      "weak_supervision_score": 0.374,
      "diffusion_reasoning_score": 0.441,
      "distributed_training_score": 0.331,
      "datasets_score": 0.303,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on enhancing uncertainty quantification and interpretability in graph neural networks (GNNs) using graph functional neural processes and graph generative models. It does not involve diffusion models, iterative refinement processes, or multi-step logical reasoning for complex tasks. There is no mention of adapting diffusion mechanisms for reasoning paths, making it unrelated to the topic.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.17102",
      "title": "GRASP: Geospatial pixel Reasoning viA Structured Policy learning",
      "authors": [
        "Chengjie Jiang",
        "Yunqi Zhou",
        "Jiafeng Yan",
        "Jing Li"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Geospatial pixel reasoning is a nascent remote-sensing task that aims to\ngenerate segmentation masks directly from natural-language instructions.\nPrevailing MLLM-based systems co-train a language model and a mask decoder with\ndense pixel supervision, which is expensive and often weak on out-of-domain\n(OOD) data. We introduce GRASP, a structured policy-learning framework. In our\ndesign, a multimodal large language model first emits task-relevant bounding\nboxes and positive points from a vision-language instruction. These outputs are\nthen passed to a pre-trained segmentation model, which consumes them as prompts\nto generate the final mask. Instead of supervised fine-tuning, we optimize the\nsystem purely with reinforcement learning: the model is trained solely with\nGRPO, guided by format rewards and accuracy rewards computed on boxes and\npoints (no mask supervision). This leverages strong priors in foundation\nmodels, minimizes trainable parameters, and enables learning from inexpensive\nannotations. We additionally curate GRASP-1k, which contains\nreasoning-intensive queries, detailed reasoning traces, and fine-grained\nsegmentation annotations. Evaluations on both in-domain and out-of-domain test\nsets show state-of-the-art results: about 4% improvement in-domain and up to\n54% on OOD benchmarks. The experiment results evidence our model's robust\ngeneralization and demonstrate that complex geospatial segmentation behaviors\ncan be learned via RL from weak spatial cues. Code and the dataset will be\nreleased open-source.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.17102v1",
      "pdf_url": "http://arxiv.org/pdf/2508.17102v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.403,
      "weak_supervision_score": 0.426,
      "diffusion_reasoning_score": 0.446,
      "distributed_training_score": 0.35,
      "datasets_score": 0.331,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "Highly Relevant",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper uses reinforcement learning (RL) with GRPO, guided by format and accuracy rewards computed on boxes and points, but does not involve human-ranked data or a separate reward model trained on human feedback. Instead, rewards are likely automated, making this not RLHF.",
      "weak_supervision_justification": "The paper's main contribution involves training the model using inexpensive annotations like bounding boxes and points instead of dense pixel-level supervision, aligning directly with weak supervision by relying on high-level, imprecise signals to optimize via RL.",
      "diffusion_reasoning_justification": "The paper focuses on RL for optimizing geospatial reasoning with an MLLM and segmentation model, with no mention of diffusion models, iterative refinement processes, or multi-step logical reasoning via diffusion.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "completed",
      "summary": "GRASP introduces a structured policy-learning framework for geospatial pixel reasoning, where a multimodal large language model generates bounding boxes and positive points from natural-language instructions, which are then used as prompts for a pre-trained segmentation model to produce masks, optimized solely through reinforcement learning with rewards based on box and point accuracy to minimize annotation costs. The methodology leverages existing foundation models, avoids dense pixel supervision, and is evaluated on a newly curated dataset, GRASP-1k, achieving state-of-the-art results with approximately 4% improvement on in-domain tests and up to 54% on out-of-domain benchmarks, demonstrating robust generalization and the feasibility of learning complex segmentation from weak spatial cues.",
      "novelty_score": "High",
      "novelty_justification": "The paper introduces a novel RL-based framework that combines MLLMs with pre-trained segmentation models for geospatial pixel reasoning, significantly advancing the state-of-the-art by eliminating the need for expensive mask supervision and improving OOD performance. This represents a truly new technique in remote sensing tasks, moving away from traditional supervised fine-tuning approaches.",
      "impact_score": "High",
      "impact_justification": "The work has the potential to influence a wide range of future research in computer vision and remote sensing by demonstrating how RL can reduce annotation costs and enhance generalization, with the open-sourced dataset and code likely to be adopted and built upon. Its substantial improvements on OOD benchmarks could lead to broader commercial applications in areas like environmental monitoring and disaster relief.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "This paper offers a high-quality, innovative contribution with strong empirical results and practical implications for reducing annotation costs in segmentation tasks, making it a valuable read for researchers in computer vision and AI. While not essential for all audiences, it provides significant insights into RL applications in geospatial reasoning.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/ee8a540d0d0eed6c08069cab7c686f1c0ca503fd",
      "total_authors": 4,
      "authors_found": 4,
      "highest_h_index": 1,
      "average_h_index": 0.25,
      "notable_authors_count": 0,
      "author_h_indexes": [
        {
          "name": "Chengjie Jiang",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2312110669"
        },
        {
          "name": "Yunqi Zhou",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2376943275"
        },
        {
          "name": "Jiafeng Yan",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2378671904"
        },
        {
          "name": "Jing Li",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2376977813"
        }
      ]
    },
    {
      "id": "2508.17104",
      "title": "Rethinking How AI Embeds and Adapts to Human Values: Challenges and\n  Opportunities",
      "authors": [
        "Sz-Ting Tzeng",
        "Frank Dignum"
      ],
      "categories": [
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "The concepts of ``human-centered AI'' and ``value-based decision'' have\ngained significant attention in both research and industry. However, many\ncritical aspects remain underexplored and require further investigation. In\nparticular, there is a need to understand how systems incorporate human values,\nhow humans can identify these values within systems, and how to minimize the\nrisks of harm or unintended consequences. In this paper, we highlight the need\nto rethink how we frame value alignment and assert that value alignment should\nmove beyond static and singular conceptions of values. We argue that AI systems\nshould implement long-term reasoning and remain adaptable to evolving values.\nFurthermore, value alignment requires more theories to address the full\nspectrum of human values. Since values often vary among individuals or groups,\nmulti-agent systems provide the right framework for navigating pluralism,\nconflict, and inter-agent reasoning about values. We identify the challenges\nassociated with value alignment and indicate directions for advancing value\nalignment research. In addition, we broadly discuss diverse perspectives of\nvalue alignment, from design methodologies to practical applications.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.17104v1",
      "pdf_url": "http://arxiv.org/pdf/2508.17104v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.538,
      "weak_supervision_score": 0.314,
      "diffusion_reasoning_score": 0.364,
      "distributed_training_score": 0.329,
      "datasets_score": 0.374,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Tangentially Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper focuses on rethinking value alignment in AI, emphasizing challenges, adaptability, and multi-agent systems for incorporating human values, but it does not discuss or reference specific techniques like training reward models with human-ranked data or using reinforcement learning for fine-tuning. While value alignment is a broader goal that RLHF addresses, the paper remains theoretical and does not directly contribute to or engage with RLHF methodologies.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.17107",
      "title": "SugarcaneShuffleNet: A Very Fast, Lightweight Convolutional Neural\n  Network for Diagnosis of 15 Sugarcane Leaf Diseases",
      "authors": [
        "Shifat E. Arman",
        "Hasan Muhammad Abdullah",
        "Syed Nazmus Sakib",
        "RM Saiem",
        "Shamima Nasrin Asha",
        "Md Mehedi Hasan",
        "Shahrear Bin Amin",
        "S M Mahin Abrar"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.LG (Machine Learning)"
      ],
      "abstract": "Despite progress in AI-based plant diagnostics, sugarcane farmers in\nlow-resource regions remain vulnerable to leaf diseases due to the lack of\nscalable, efficient, and interpretable tools. Many deep learning models fail to\ngeneralize under real-world conditions and require substantial computational\nresources, limiting their use in resource-constrained regions. In this paper,\nwe present SugarcaneLD-BD, a curated dataset for sugarcane leaf-disease\nclassification; SugarcaneShuffleNet, an optimized lightweight model for rapid\non-device diagnosis; and SugarcaneAI, a Progressive Web Application for field\ndeployment. SugarcaneLD-BD contains 638 curated images across five classes,\nincluding four major sugarcane diseases, collected in Bangladesh under diverse\nfield conditions and verified by expert pathologists. To enhance diversity, we\ncombined SugarcaneLD-BD with two additional datasets, yielding a larger and\nmore representative corpus. Our optimized model, SugarcaneShuffleNet, offers\nthe best trade-off between speed and accuracy for real-time, on-device\ndiagnosis. This 9.26 MB model achieved 98.02% accuracy, an F1-score of 0.98,\nand an average inference time of 4.14 ms per image. For comparison, we\nfine-tuned five other lightweight convolutional neural networks: MnasNet,\nEdgeNeXt, EfficientNet-Lite, MobileNet, and SqueezeNet via transfer learning\nand Bayesian optimization. MnasNet and EdgeNeXt achieved comparable accuracy to\nSugarcaneShuffleNet, but required significantly more parameters, memory, and\ncomputation, limiting their suitability for low-resource deployment. We\nintegrate SugarcaneShuffleNet into SugarcaneAI, delivering Grad-CAM-based\nexplanations in the field. Together, these contributions offer a diverse\nbenchmark, efficient models for low-resource environments, and a practical tool\nfor sugarcane disease classification. It spans varied lighting, backgrounds and\ndevices used on-farm",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.17107v1",
      "pdf_url": "http://arxiv.org/pdf/2508.17107v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.296,
      "weak_supervision_score": 0.343,
      "diffusion_reasoning_score": 0.305,
      "distributed_training_score": 0.349,
      "datasets_score": 0.353,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.17117",
      "title": "PlantVillageVQA: A Visual Question Answering Dataset for Benchmarking\n  Vision-Language Models in Plant Science",
      "authors": [
        "Syed Nazmus Sakib",
        "Nafiul Haque",
        "Mohammad Zabed Hossain",
        "Shifat E. Arman"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.AI (Artificial Intelligence)",
        "cs.LG (Machine Learning)"
      ],
      "abstract": "PlantVillageVQA is a large-scale visual question answering (VQA) dataset\nderived from the widely used PlantVillage image corpus. It was designed to\nadvance the development and evaluation of vision-language models for\nagricultural decision-making and analysis. The PlantVillageVQA dataset\ncomprises 193,609 high-quality question-answer (QA) pairs grounded over 55,448\nimages spanning 14 crop species and 38 disease conditions. Questions are\norganised into 3 levels of cognitive complexity and 9 distinct categories. Each\nquestion category was phrased manually following expert guidance and generated\nvia an automated two-stage pipeline: (1) template-based QA synthesis from image\nmetadata and (2) multi-stage linguistic re-engineering. The dataset was\niteratively reviewed by domain experts for scientific accuracy and relevancy.\nThe final dataset was evaluated using three state-of-the-art models for quality\nassessment. Our objective remains to provide a publicly available, standardised\nand expert-verified database to enhance diagnostic accuracy for plant disease\nidentifications and advance scientific research in the agricultural domain. Our\ndataset will be open-sourced at\nhttps://huggingface.co/datasets/SyedNazmusSakib/PlantVillageVQA.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.17117v2",
      "pdf_url": "http://arxiv.org/pdf/2508.17117v2",
      "scraper_status": "successfully_scraped",
      "intro_status": "extraction_failed",
      "embedding_status": "completed",
      "rlhf_score": 0.256,
      "weak_supervision_score": 0.285,
      "diffusion_reasoning_score": 0.27,
      "distributed_training_score": 0.245,
      "datasets_score": 0.384,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.17126",
      "title": "Token Homogenization under Positional Bias",
      "authors": [
        "Viacheslav Yusupov",
        "Danil Maksimov",
        "Ameliia Alaeva",
        "Tatiana Zaitceva",
        "Antipina Anna",
        "Anna Vasileva",
        "Chenlin Liu",
        "Rayuth Chheng",
        "Danil Sazanakov",
        "Andrey Chetvergov",
        "Alina Ermilova",
        "Egor Shvetsov"
      ],
      "categories": [
        "cs.CL (Computation and Language)",
        "cs.AI (Artificial Intelligence)",
        "cs.LG (Machine Learning)"
      ],
      "abstract": "This paper investigates token homogenization - the convergence of token\nrepresentations toward uniformity across transformer layers and its\nrelationship to positional bias in large language models. We empirically\nexamine whether homogenization occurs and how positional bias amplifies this\neffect. Through layer-wise similarity analysis and controlled experiments, we\ndemonstrate that tokens systematically lose distinctiveness during processing,\nparticularly when biased toward extremal positions. Our findings confirm both\nthe existence of homogenization and its dependence on positional attention\nmechanisms.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.17126v1",
      "pdf_url": "http://arxiv.org/pdf/2508.17126v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.382,
      "weak_supervision_score": 0.318,
      "diffusion_reasoning_score": 0.414,
      "distributed_training_score": 0.336,
      "datasets_score": 0.304,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper examines token homogenization and positional bias in transformer-based large language models, focusing on representation dynamics and attention mechanisms. It does not involve diffusion models, iterative refinement processes, or any adaptation of diffusion for multi-step logical reasoning tasks. Therefore, there is no connection to the topic of Diffusion-based Reasoning.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.17128",
      "title": "CE-RS-SBCIT A Novel Channel Enhanced Hybrid CNN Transformer with\n  Residual, Spatial, and Boundary-Aware Learning for Brain Tumor MRI Analysis",
      "authors": [
        "Mirza Mumtaz Zahoor",
        "Saddam Hussain Khan"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Brain tumors remain among the most lethal human diseases, where early\ndetection and accurate classification are critical for effective diagnosis and\ntreatment planning. Although deep learning-based computer-aided diagnostic\n(CADx) systems have shown remarkable progress. However, conventional\nconvolutional neural networks (CNNs) and Transformers face persistent\nchallenges, including high computational cost, sensitivity to minor contrast\nvariations, structural heterogeneity, and texture inconsistencies in MRI data.\nTherefore, a novel hybrid framework, CE-RS-SBCIT, is introduced, integrating\nresidual and spatial learning-based CNNs with transformer-driven modules. The\nproposed framework exploits local fine-grained and global contextual cues\nthrough four core innovations: (i) a smoothing and boundary-based\nCNN-integrated Transformer (SBCIT), (ii) tailored residual and spatial learning\nCNNs, (iii) a channel enhancement (CE) strategy, and (iv) a novel spatial\nattention mechanism. The developed SBCIT employs stem convolution and\ncontextual interaction transformer blocks with systematic smoothing and\nboundary operations, enabling efficient global feature modeling. Moreover,\nResidual and spatial CNNs, enhanced by auxiliary transfer-learned feature maps,\nenrich the representation space, while the CE module amplifies discriminative\nchannels and mitigates redundancy. Furthermore, the spatial attention mechanism\nselectively emphasizes subtle contrast and textural variations across tumor\nclasses. Extensive evaluation on challenging MRI datasets from Kaggle and\nFigshare, encompassing glioma, meningioma, pituitary tumors, and healthy\ncontrols, demonstrates superior performance, achieving 98.30% accuracy, 98.08%\nsensitivity, 98.25% F1-score, and 98.43% precision.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.17128v2",
      "pdf_url": "http://arxiv.org/pdf/2508.17128v2",
      "scraper_status": "successfully_scraped",
      "intro_status": "extraction_failed",
      "embedding_status": "completed",
      "rlhf_score": 0.263,
      "weak_supervision_score": 0.287,
      "diffusion_reasoning_score": 0.376,
      "distributed_training_score": 0.331,
      "datasets_score": 0.314,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.17130",
      "title": "Structural Damage Detection Using AI Super Resolution and Visual\n  Language Model",
      "authors": [
        "Catherine Hoier",
        "Khandaker Mamun Ahmed"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Natural disasters pose significant challenges to timely and accurate damage\nassessment due to their sudden onset and the extensive areas they affect.\nTraditional assessment methods are often labor-intensive, costly, and hazardous\nto personnel, making them impractical for rapid response, especially in\nresource-limited settings. This study proposes a novel, cost-effective\nframework that leverages aerial drone footage, an advanced AI-based video\nsuper-resolution model, Video Restoration Transformer (VRT), and Gemma3:27b, a\n27 billion parameter Visual Language Model (VLM). This integrated system is\ndesigned to improve low-resolution disaster footage, identify structural\ndamage, and classify buildings into four damage categories, ranging from\nno/slight damage to total destruction, along with associated risk levels. The\nmethodology was validated using pre- and post-event drone imagery from the 2023\nTurkey earthquakes (courtesy of The Guardian) and satellite data from the 2013\nMoore Tornado (xBD dataset). The framework achieved a classification accuracy\nof 84.5%, demonstrating its ability to provide highly accurate results.\nFurthermore, the system's accessibility allows non-technical users to perform\npreliminary analyses, thereby improving the responsiveness and efficiency of\ndisaster management efforts.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.17130v1",
      "pdf_url": "http://arxiv.org/pdf/2508.17130v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.384,
      "weak_supervision_score": 0.375,
      "diffusion_reasoning_score": 0.401,
      "distributed_training_score": 0.359,
      "datasets_score": 0.383,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on using Video Restoration Transformer (VRT) for super-resolution and Gemma3:27b, a Visual Language Model (VLM), for damage detection and classification. It does not involve diffusion models, iterative refinement processes for logical tasks, or treating a Chain-of-Thought as a single entity for holistic correction. Therefore, there is no component related to diffusion-based reasoning in the paper's methodology or contributions.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.17150",
      "title": "SACA: Selective Attention-Based Clustering Algorithm",
      "authors": [
        "Meysam Shirdel Bilehsavar",
        "Razieh Ghaedi",
        "Samira Seyed Taheri",
        "Xinqi Fan",
        "Christian O'Reilly"
      ],
      "categories": [
        "cs.LG (Machine Learning)",
        "cs.AI (Artificial Intelligence)",
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "Clustering algorithms are widely used in various applications, with\ndensity-based methods such as Density-Based Spatial Clustering of Applications\nwith Noise (DBSCAN) being particularly prominent. These algorithms identify\nclusters in high-density regions while treating sparser areas as noise.\nHowever, reliance on user-defined parameters often poses optimization\nchallenges that require domain expertise. This paper presents a novel\ndensity-based clustering method inspired by the concept of selective attention,\nwhich minimizes the need for user-defined parameters under standard conditions.\nInitially, the algorithm operates without requiring user-defined parameters. If\nparameter adjustment is needed, the method simplifies the process by\nintroducing a single integer parameter that is straightforward to tune. The\napproach computes a threshold to filter out the most sparsely distributed\npoints and outliers, forms a preliminary cluster structure, and then\nreintegrates the excluded points to finalize the results. Experimental\nevaluations on diverse data sets highlight the accessibility and robust\nperformance of the method, providing an effective alternative for density-based\nclustering tasks.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.17150v1",
      "pdf_url": "http://arxiv.org/pdf/2508.17150v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "extraction_failed",
      "embedding_status": "completed",
      "rlhf_score": 0.269,
      "weak_supervision_score": 0.349,
      "diffusion_reasoning_score": 0.294,
      "distributed_training_score": 0.305,
      "datasets_score": 0.329,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.17153",
      "title": "Natural Language Satisfiability: Exploring the Problem Distribution and\n  Evaluating Transformer-based Language Models",
      "authors": [
        "Tharindu Madusanka",
        "Ian Pratt-Hartmann",
        "Riza Batista-Navarro"
      ],
      "categories": [
        "cs.CL (Computation and Language)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Efforts to apply transformer-based language models (TLMs) to the problem of\nreasoning in natural language have enjoyed ever-increasing success in recent\nyears. The most fundamental task in this area to which nearly all others can be\nreduced is that of determining satisfiability. However, from a logical point of\nview, satisfiability problems vary along various dimensions, which may affect\nTLMs' ability to learn how to solve them. The problem instances of\nsatisfiability in natural language can belong to different computational\ncomplexity classes depending on the language fragment in which they are\nexpressed. Although prior research has explored the problem of natural language\nsatisfiability, the above-mentioned point has not been discussed adequately.\nHence, we investigate how problem instances from varying computational\ncomplexity classes and having different grammatical constructs impact TLMs'\nability to learn rules of inference. Furthermore, to faithfully evaluate TLMs,\nwe conduct an empirical study to explore the distribution of satisfiability\nproblems.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.17153v1",
      "pdf_url": "http://arxiv.org/pdf/2508.17153v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.373,
      "weak_supervision_score": 0.348,
      "diffusion_reasoning_score": 0.485,
      "distributed_training_score": 0.339,
      "datasets_score": 0.332,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper primarily investigates transformer-based language models for natural language satisfiability problems, focusing on their ability to handle logical inference across different complexity classes. It does not mention, adapt, or involve diffusion models, iterative refinement processes, or any multi-step reasoning mechanisms characteristic of diffusion-based approaches. Thus, there is no overlap with the topic.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.17155",
      "title": "Mind the Gap: Time-of-Check to Time-of-Use Vulnerabilities in\n  LLM-Enabled Agents",
      "authors": [
        "Derek Lilienthal",
        "Sanghyun Hong"
      ],
      "categories": [
        "cs.CR (Cryptography and Security)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Large Language Model (LLM)-enabled agents are rapidly emerging across a wide\nrange of applications, but their deployment introduces vulnerabilities with\nsecurity implications. While prior work has examined prompt-based attacks\n(e.g., prompt injection) and data-oriented threats (e.g., data exfiltration),\ntime-of-check to time-of-use (TOCTOU) remain largely unexplored in this\ncontext. TOCTOU arises when an agent validates external state (e.g., a file or\nAPI response) that is later modified before use, enabling practical attacks\nsuch as malicious configuration swaps or payload injection. In this work, we\npresent the first study of TOCTOU vulnerabilities in LLM-enabled agents. We\nintroduce TOCTOU-Bench, a benchmark with 66 realistic user tasks designed to\nevaluate this class of vulnerabilities. As countermeasures, we adapt detection\nand mitigation techniques from systems security to this setting and propose\nprompt rewriting, state integrity monitoring, and tool-fusing. Our study\nhighlights challenges unique to agentic workflows, where we achieve up to 25%\ndetection accuracy using automated detection methods, a 3% decrease in\nvulnerable plan generation, and a 95% reduction in the attack window. When\ncombining all three approaches, we reduce the TOCTOU vulnerabilities from an\nexecuted trajectory from 12% to 8%. Our findings open a new research direction\nat the intersection of AI safety and systems security.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.17155v1",
      "pdf_url": "http://arxiv.org/pdf/2508.17155v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.412,
      "weak_supervision_score": 0.381,
      "diffusion_reasoning_score": 0.391,
      "distributed_training_score": 0.332,
      "datasets_score": 0.309,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper focuses on identifying and mitigating TOCTOU vulnerabilities in LLM-enabled agents, including the development of a benchmark and defense techniques like prompt rewriting and state integrity monitoring. It does not involve reinforcement learning, human feedback, reward models, or any process of aligning AI models with human preferences through training on ranked data.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.17160",
      "title": "Beyond Play and Pause: Turning GPT-4o Spatial Weakness into a Strength\n  for In-Depth Interactive Video Learning",
      "authors": [
        "Sajad Goudarzi",
        "Samaneh Zamanifard"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Traditional video-based learning remains passive, offering limited\nopportunities for users to engage dynamically with content. While current\nAI-powered tools offer transcription and summarization, they lack real-time,\nregion-specific interaction capabilities. This paper introduces Untwist, an\nAI-driven system that enables interactive video learning by allowing users to\nask questions about the entire video or specific regions using a bounding box,\nreceiving context-aware, multimodal responses. By integrating GPT APIs with\nComputer Vision techniques, Untwist extracts, processes, and structures video\ncontent to enhance comprehension. Our approach addresses GPT-4o spatial\nweakness by leveraging annotated frames instead of raw coordinate data,\nsignificantly improving accuracy in localizing and interpreting video content.\nThis paper describes the system architecture, including video pre-processing\nand real-time interaction, and outlines how Untwist can transform passive video\nconsumption into an interactive, AI-driven learning experience with the\npotential to enhance engagement and comprehension.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.17160v1",
      "pdf_url": "http://arxiv.org/pdf/2508.17160v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.411,
      "weak_supervision_score": 0.401,
      "diffusion_reasoning_score": 0.449,
      "distributed_training_score": 0.351,
      "datasets_score": 0.326,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "Not Relevant",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper focuses on an interactive video learning system using GPT APIs and Computer Vision, with no mention of training AI models via human feedback, reward models, or reinforcement learning techniques.",
      "weak_supervision_justification": "The paper describes processing and annotating video content using GPT and Computer Vision, but it does not involve training models with programmatically generated noisy labels or weak supervision methods; it relies on existing APIs without addressing model training.",
      "diffusion_reasoning_justification": "The paper utilizes GPT-4o for interactive responses and addresses spatial weaknesses with annotated frames, but it does not employ diffusion models, iterative refinement for logical tasks, or multi-step reasoning processes as defined.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.17167",
      "title": "Error analysis for the deep Kolmogorov method",
      "authors": [
        "Iulian Cîmpean",
        "Thang Do",
        "Lukas Gonon",
        "Arnulf Jentzen",
        "Ionel Popescu"
      ],
      "categories": [
        "math.NA (Numerical Analysis)",
        "cs.AI (Artificial Intelligence)",
        "cs.NA (Numerical Analysis)",
        "math.AP (Analysis of PDEs)"
      ],
      "abstract": "The deep Kolmogorov method is a simple and popular deep learning based method\nfor approximating solutions of partial differential equations (PDEs) of the\nKolmogorov type. In this work we provide an error analysis for the deep\nKolmogorov method for heat PDEs. Specifically, we reveal convergence with\nconvergence rates for the overall mean square distance between the exact\nsolution of the heat PDE and the realization function of the approximating deep\nneural network (DNN) associated with a stochastic optimization algorithm in\nterms of the size of the architecture (the depth/number of hidden layers and\nthe width of the hidden layers) of the approximating DNN, in terms of the\nnumber of random sample points used in the loss function (the number of\ninput-output data pairs used in the loss function), and in terms of the size of\nthe optimization error made by the employed stochastic optimization method.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.17167v1",
      "pdf_url": "http://arxiv.org/pdf/2508.17167v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.31,
      "weak_supervision_score": 0.329,
      "diffusion_reasoning_score": 0.373,
      "distributed_training_score": 0.339,
      "datasets_score": 0.237,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.18304",
      "title": "scI2CL: Effectively Integrating Single-cell Multi-omics by Intra- and\n  Inter-omics Contrastive Learning",
      "authors": [
        "Wuchao Liu",
        "Han Peng",
        "Wengen Li",
        "Yichao Zhang",
        "Jihong Guan",
        "Shuigeng Zhou"
      ],
      "categories": [
        "cs.AI (Artificial Intelligence)",
        "cs.LG (Machine Learning)"
      ],
      "abstract": "Single-cell multi-omics data contain huge information of cellular states, and\nanalyzing these data can reveal valuable insights into cellular heterogeneity,\ndiseases, and biological processes. However, as cell differentiation \\&\ndevelopment is a continuous and dynamic process, it remains challenging to\ncomputationally model and infer cell interaction patterns based on single-cell\nmulti-omics data. This paper presents scI2CL, a new single-cell multi-omics\nfusion framework based on intra- and inter-omics contrastive learning, to learn\ncomprehensive and discriminative cellular representations from complementary\nmulti-omics data for various downstream tasks. Extensive experiments of four\ndownstream tasks validate the effectiveness of scI2CL and its superiority over\nexisting peers. Concretely, in cell clustering, scI2CL surpasses eight\nstate-of-the-art methods on four widely-used real-world datasets. In cell\nsubtyping, scI2CL effectively distinguishes three latent monocyte cell\nsubpopulations, which are not discovered by existing methods. Simultaneously,\nscI2CL is the only method that correctly constructs the cell developmental\ntrajectory from hematopoietic stem and progenitor cells to Memory B cells. In\naddition, scI2CL resolves the misclassification of cell types between two\nsubpopulations of CD4+ T cells, while existing methods fail to precisely\ndistinguish the mixed cells. In summary, scI2CL can accurately characterize\ncross-omics relationships among cells, thus effectively fuses multi-omics data\nand learns discriminative cellular representations to support various\ndownstream analysis tasks.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.18304v1",
      "pdf_url": "http://arxiv.org/pdf/2508.18304v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.31,
      "weak_supervision_score": 0.346,
      "diffusion_reasoning_score": 0.34,
      "distributed_training_score": 0.361,
      "datasets_score": 0.345,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.18306",
      "title": "SALMAN: Stability Analysis of Language Models Through the Maps Between\n  Graph-based Manifolds",
      "authors": [
        "Wuxinlin Cheng",
        "Yupeng Cao",
        "Jinwen Wu",
        "Koduvayur Subbalakshmi",
        "Tian Han",
        "Zhuo Feng"
      ],
      "categories": [
        "cs.LG (Machine Learning)",
        "cs.AI (Artificial Intelligence)",
        "cs.CL (Computation and Language)"
      ],
      "abstract": "Recent strides in pretrained transformer-based language models have propelled\nstate-of-the-art performance in numerous NLP tasks. Yet, as these models grow\nin size and deployment, their robustness under input perturbations becomes an\nincreasingly urgent question. Existing robustness methods often diverge between\nsmall-parameter and large-scale models (LLMs), and they typically rely on\nlabor-intensive, sample-specific adversarial designs. In this paper, we propose\na unified, local (sample-level) robustness framework (SALMAN) that evaluates\nmodel stability without modifying internal parameters or resorting to complex\nperturbation heuristics. Central to our approach is a novel Distance Mapping\nDistortion (DMD) measure, which ranks each sample's susceptibility by comparing\ninput-to-output distance mappings in a near-linear complexity manner. By\ndemonstrating significant gains in attack efficiency and robust training, we\nposition our framework as a practical, model-agnostic tool for advancing the\nreliability of transformer-based NLP systems.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.18306v1",
      "pdf_url": "http://arxiv.org/pdf/2508.18306v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.398,
      "weak_supervision_score": 0.392,
      "diffusion_reasoning_score": 0.427,
      "distributed_training_score": 0.374,
      "datasets_score": 0.333,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper's main contribution is a framework for evaluating the stability and robustness of language models using distance mapping distortion on graph-based manifolds, focusing on perturbations and adversarial attacks. It does not involve diffusion models, iterative refinement processes, or multi-step logical reasoning as described in the topic. Therefore, there is no connection to diffusion-based reasoning.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.18308",
      "title": "CoPE: A Lightweight Complex Positional Encoding",
      "authors": [
        "Avinash Amballa"
      ],
      "categories": [
        "cs.LG (Machine Learning)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Recent studies have demonstrated the effectiveness of position encoding in\ntransformer architectures. By incorporating positional information, this\napproach provides essential guidance for modeling dependencies between elements\nacross different sequence positions. We introduce CoPE (a lightweight Complex\nPositional Encoding), a novel architecture that leverages complex-valued\nencoding to encode both content and positional information. Our approach\nreplaces traditional positional encodings with complex embeddings where the\nreal part captures semantic content and the imaginary part encodes positional\ninformation. We introduce phase-aware attention in the first layer of the\ntransformer model to capture position-dependent patterns, followed by standard\nattention layers for higher-levels. We show that CoPE doesn't exhibit long term\ndecay and is compatible with linear attention. Experimental evaluation on the\nGLUE benchmark suggest that our approach achieves superior performance with\nless computational complexity, compared to RoPE, Sinusoidal and Learned\npositional encodings.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.18308v1",
      "pdf_url": "http://arxiv.org/pdf/2508.18308v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.32,
      "weak_supervision_score": 0.289,
      "diffusion_reasoning_score": 0.386,
      "distributed_training_score": 0.316,
      "datasets_score": 0.262,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.18312",
      "title": "What Matters in Data for DPO?",
      "authors": [
        "Yu Pan",
        "Zhongze Cai",
        "Guanting Chen",
        "Huaiyang Zhong",
        "Chonghuan Wang"
      ],
      "categories": [
        "cs.LG (Machine Learning)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Direct Preference Optimization (DPO) has emerged as a simple and effective\napproach for aligning large language models (LLMs) with human preferences,\nbypassing the need for a learned reward model. Despite its growing adoption, a\nfundamental question remains open: what characteristics of preference data are\nmost critical for DPO performance? In this work, we provide a systematic study\nof how preference data distribution influences DPO, from both theoretical and\nempirical perspectives. We show that the quality of chosen responses plays a\ndominant role in optimizing the DPO objective, while the quality of rejected\nresponses may have relatively limited impact. Our theoretical analysis\ncharacterizes the optimal response distribution under DPO and reveals how\ncontrastiveness between responses helps primarily by improving the chosen\nsamples. We further study an online DPO setting and show it effectively reduces\nto supervised fine-tuning on the chosen responses. Extensive experiments across\ndiverse tasks confirm our findings: improving the quality of chosen responses\nconsistently boosts performance regardless of the quality of the rejected\nresponses. We also investigate the benefit of mixing the on-policy data. Our\nresults interpret the mechanism behind some widely adopted strategies and offer\npractical insights for constructing high-impact preference datasets for LLM\nalignment.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.18312v1",
      "pdf_url": "http://arxiv.org/pdf/2508.18312v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.525,
      "weak_supervision_score": 0.416,
      "diffusion_reasoning_score": 0.381,
      "distributed_training_score": 0.404,
      "datasets_score": 0.41,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Highly Relevant",
      "weak_supervision_relevance": "Not Relevant",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "Not Relevant",
      "datasets_relevance": "Highly Relevant",
      "rlhf_justification": "The paper directly compares DPO to RLHF as alignment methods for LLMs, analyzes preference data central to RLHF, and provides insights that could apply to RLHF practices, making it highly pertinent to the topic.",
      "weak_supervision_justification": "The paper focuses on analyzing preference data for DPO without discussing programmatic label generation, noisy sources, or weak supervision techniques, so it does not align with this topic.",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "The paper does not address parallel computing, multi-node training, or any aspects of distributed systems; it solely examines data characteristics for DPO.",
      "datasets_justification": "The paper systematically analyzes, evaluates, and provides insights on constructing preference datasets for LLM alignment, including empirical studies on data quality and distribution, which directly relates to dataset research.",
      "llm_score_status": "completed",
      "summary": "This paper investigates the critical characteristics of preference data for Direct Preference Optimization (DPO) in aligning large language models with human preferences, emphasizing the dominant role of chosen response quality over rejected ones. Through theoretical analysis, it characterizes the optimal response distribution and shows that contrastiveness primarily enhances chosen samples, while empirical experiments across various tasks confirm that improving chosen response quality consistently boosts DPO performance, offering practical insights for dataset construction.",
      "novelty_score": "Moderate",
      "novelty_justification": "The paper presents a notable improvement by providing a systematic theoretical and empirical analysis of preference data's role in DPO, which advances understanding of an underexplored aspect of existing alignment techniques.",
      "impact_score": "Moderate",
      "impact_justification": "The work is likely to influence future research in LLM alignment by guiding the creation of more effective preference datasets, though its applicability is mainly within the subfield of DPO and related AI methods.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "This paper delivers high-quality insights into DPO data dynamics, making it essential for researchers in AI alignment to understand and build upon its findings.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/c05fddaa0451cf5cfe2e09e7631005f350f49b13",
      "total_authors": 5,
      "authors_found": 5,
      "highest_h_index": 2,
      "average_h_index": 0.6,
      "notable_authors_count": 0,
      "author_h_indexes": [
        {
          "name": "Yu Pan",
          "h_index": 2,
          "profile_url": "https://www.semanticscholar.org/author/2298714472"
        },
        {
          "name": "Zhongze Cai",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2378094209"
        },
        {
          "name": "Guanting Chen",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2366092157"
        },
        {
          "name": "Huaiyang Zhong",
          "h_index": 1,
          "profile_url": "https://www.semanticscholar.org/author/2292260938"
        },
        {
          "name": "Chonghuan Wang",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2365991814"
        }
      ]
    },
    {
      "id": "2508.18313",
      "title": "ProtoEHR: Hierarchical Prototype Learning for EHR-based Healthcare\n  Predictions",
      "authors": [
        "Zi Cai",
        "Yu Liu",
        "Zhiyao Luo",
        "Tingting Zhu"
      ],
      "categories": [
        "cs.LG (Machine Learning)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Digital healthcare systems have enabled the collection of mass healthcare\ndata in electronic healthcare records (EHRs), allowing artificial intelligence\nsolutions for various healthcare prediction tasks. However, existing studies\noften focus on isolated components of EHR data, limiting their predictive\nperformance and interpretability. To address this gap, we propose ProtoEHR, an\ninterpretable hierarchical prototype learning framework that fully exploits the\nrich, multi-level structure of EHR data to enhance healthcare predictions. More\nspecifically, ProtoEHR models relationships within and across three\nhierarchical levels of EHRs: medical codes, hospital visits, and patients. We\nfirst leverage large language models to extract semantic relationships among\nmedical codes and construct a medical knowledge graph as the knowledge source.\nBuilding on this, we design a hierarchical representation learning framework\nthat captures contextualized representations across three levels, while\nincorporating prototype information within each level to capture intrinsic\nsimilarities and improve generalization. To perform a comprehensive assessment,\nwe evaluate ProtoEHR in two public datasets on five clinically significant\ntasks, including prediction of mortality, prediction of readmission, prediction\nof length of stay, drug recommendation, and prediction of phenotype. The\nresults demonstrate the ability of ProtoEHR to make accurate, robust, and\ninterpretable predictions compared to baselines in the literature. Furthermore,\nProtoEHR offers interpretable insights on code, visit, and patient levels to\naid in healthcare prediction.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.18313v1",
      "pdf_url": "http://arxiv.org/pdf/2508.18313v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.388,
      "weak_supervision_score": 0.348,
      "diffusion_reasoning_score": 0.325,
      "distributed_training_score": 0.337,
      "datasets_score": 0.344,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.18314",
      "title": "SERES: Semantic-aware neural reconstruction from sparse views",
      "authors": [
        "Bo Xu",
        "Yuhu Guo",
        "Yuchao Wang",
        "Wenting Wang",
        "Yeung Yam",
        "Charlie C. L. Wang",
        "Xinyi Le"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "We propose a semantic-aware neural reconstruction method to generate 3D\nhigh-fidelity models from sparse images. To tackle the challenge of severe\nradiance ambiguity caused by mismatched features in sparse input, we enrich\nneural implicit representations by adding patch-based semantic logits that are\noptimized together with the signed distance field and the radiance field. A\nnovel regularization based on the geometric primitive masks is introduced to\nmitigate shape ambiguity. The performance of our approach has been verified in\nexperimental evaluation. The average chamfer distances of our reconstruction on\nthe DTU dataset can be reduced by 44% for SparseNeuS and 20% for VolRecon. When\nworking as a plugin for those dense reconstruction baselines such as NeuS and\nNeuralangelo, the average error on the DTU dataset can be reduced by 69% and\n68% respectively.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.18314v1",
      "pdf_url": "http://arxiv.org/pdf/2508.18314v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.329,
      "weak_supervision_score": 0.374,
      "diffusion_reasoning_score": 0.395,
      "distributed_training_score": 0.339,
      "datasets_score": 0.332,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.18315",
      "title": "Automated Landfill Detection Using Deep Learning: A Comparative Study of\n  Lightweight and Custom Architectures with the AerialWaste Dataset",
      "authors": [
        "Nowshin Sharmily",
        "Rusab Sarmun",
        "Muhammad E. H. Chowdhury",
        "Mir Hamidul Hussain",
        "Saad Bin Abul Kashem",
        "Molla E Majid",
        "Amith Khandakar"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "Illegal landfills are posing as a hazardous threat to people all over the\nworld. Due to the arduous nature of manually identifying the location of\nlandfill, many landfills go unnoticed by authorities and later cause dangerous\nharm to people and environment. Deep learning can play a significant role in\nidentifying these landfills while saving valuable time, manpower and resources.\nDespite being a burning concern, good quality publicly released datasets for\nillegal landfill detection are hard to find due to security concerns. However,\nAerialWaste Dataset is a large collection of 10434 images of Lombardy region of\nItaly. The images are of varying qualities, collected from three different\nsources: AGEA Orthophotos, WorldView-3, and Google Earth. The dataset contains\nprofessionally curated, diverse and high-quality images which makes it\nparticularly suitable for scalable and impactful research. As we trained\nseveral models to compare results, we found complex and heavy models to be\nprone to overfitting and memorizing training data instead of learning patterns.\nTherefore, we chose lightweight simpler models which could leverage general\nfeatures from the dataset. In this study, Mobilenetv2, Googlenet, Densenet,\nMobileVit and other lightweight deep learning models were used to train and\nvalidate the dataset as they achieved significant success with less\noverfitting. As we saw substantial improvement in the performance using some of\nthese models, we combined the best performing models and came up with an\nensemble model. With the help of ensemble and fusion technique, binary\nclassification could be performed on this dataset with 92.33% accuracy, 92.67%\nprecision, 92.33% sensitivity, 92.41% F1 score and 92.71% specificity.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.18315v1",
      "pdf_url": "http://arxiv.org/pdf/2508.18315v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "extraction_failed",
      "embedding_status": "completed",
      "rlhf_score": 0.321,
      "weak_supervision_score": 0.38,
      "diffusion_reasoning_score": 0.28,
      "distributed_training_score": 0.327,
      "datasets_score": 0.411,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "Highly Relevant",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "The paper's main contribution includes introducing and describing the AerialWaste Dataset, a large collection of 10,434 images from multiple sources, which aligns with dataset creation and introduction. It discusses dataset curation methodologies, such as professional curation and diversity from sources like AGEA Orthophotos and WorldView-3, and evaluates the dataset through benchmarking with various deep learning models, demonstrating its suitability for AI applications. This directly matches the topic's focus on creating, analyzing, benchmarking, and evaluating datasets.",
      "llm_score_status": "completed",
      "summary": "This paper investigates the automated detection of illegal landfills using deep learning on the AerialWaste Dataset, which comprises 10,434 diverse aerial images from sources like AGEA Orthophotos and Google Earth, aiming to address the challenges of manual identification and resource constraints. The methodology involves training and comparing lightweight models such as MobileNetV2, GoogleNet, and DenseNet, with an ensemble approach ultimately achieving high performance metrics including 92.33% accuracy, 92.67% precision, and 92.41% F1 score, highlighting the benefits of these models in avoiding overfitting.",
      "novelty_score": "Moderate",
      "novelty_justification": "The paper presents a notable improvement by applying lightweight deep learning models to landfill detection using a specific dataset, offering a clever combination of existing techniques for a practical environmental problem. However, it does not introduce a entirely new architecture or problem, making it an incremental advancement rather than a groundbreaking one.",
      "impact_score": "Moderate",
      "impact_justification": "The work could influence future research in AI for environmental monitoring and waste management by demonstrating effective use of lightweight models on aerial datasets, potentially leading to citations in subfields like computer vision. Nonetheless, its applicability is somewhat niche, limiting broader commercial or widespread academic impact.",
      "recommendation_score": "Should Read",
      "recommendation_justification": "This paper offers a strong, practical contribution to computer vision and AI applications in environmental issues, with solid methodology and results that are valuable for researchers in the field. While not essential for all, it provides useful insights into lightweight models for real-world problems, making it worth reading for those interested in the area.",
      "h_index_status": "completed",
      "semantic_scholar_url": "https://www.semanticscholar.org/paper/9256c792d7716afc12bf948629b7383e1a34808a",
      "total_authors": 7,
      "authors_found": 7,
      "highest_h_index": 37,
      "average_h_index": 10.857142857142858,
      "notable_authors_count": 4,
      "author_h_indexes": [
        {
          "name": "Nowshin Sharmily",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2377309687"
        },
        {
          "name": "Rusab Sarmun",
          "h_index": 2,
          "profile_url": "https://www.semanticscholar.org/author/2336431921"
        },
        {
          "name": "M. Chowdhury",
          "h_index": 22,
          "profile_url": "https://www.semanticscholar.org/author/2054444928"
        },
        {
          "name": "Mir Hamidul Hussain",
          "h_index": 0,
          "profile_url": "https://www.semanticscholar.org/author/2377534851"
        },
        {
          "name": "S. Kashem",
          "h_index": 9,
          "profile_url": "https://www.semanticscholar.org/author/2066338720"
        },
        {
          "name": "M. Majid",
          "h_index": 6,
          "profile_url": "https://www.semanticscholar.org/author/134428038"
        },
        {
          "name": "A. Khandakar",
          "h_index": 37,
          "profile_url": "https://www.semanticscholar.org/author/2319383"
        }
      ]
    },
    {
      "id": "2508.18316",
      "title": "Evaluating Federated Learning for At-Risk Student Prediction: A\n  Comparative Analysis of Model Complexity and Data Balancing",
      "authors": [
        "Rodrigo Tertulino"
      ],
      "categories": [
        "cs.LG (Machine Learning)",
        "cs.AI (Artificial Intelligence)",
        "cs.CY (Computers and Society)"
      ],
      "abstract": "High dropout and failure rates in distance education pose a significant\nchallenge for academic institutions, making the proactive identification of\nat-risk students crucial for providing timely support. This study develops and\nevaluates a machine learning model based on early academic performance and\ndigital engagement patterns from the large-scale OULAD dataset to predict\nstudent risk at a UK university. To address the practical challenges of data\nprivacy and institutional silos that often hinder such initiatives, we\nimplement the model using a Federated Learning (FL) framework. We compare model\ncomplexity (Logistic Regression vs. a Deep Neural Network) and data balancing.\nThe final federated model demonstrates strong predictive capability, achieving\nan ROC AUC score of approximately 85% in identifying at-risk students. Our\nfindings show that this federated approach provides a practical and scalable\nsolution for institutions to build effective early-warning systems, enabling\nproactive student support while inherently respecting data privacy.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.18316v1",
      "pdf_url": "http://arxiv.org/pdf/2508.18316v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "extraction_failed",
      "embedding_status": "completed",
      "rlhf_score": 0.396,
      "weak_supervision_score": 0.362,
      "diffusion_reasoning_score": 0.308,
      "distributed_training_score": 0.397,
      "datasets_score": 0.369,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.18317",
      "title": "Does Calibration Affect Human Actions?",
      "authors": [
        "Meir Nizri",
        "Amos Azaria",
        "Chirag Gupta",
        "Noam Hazon"
      ],
      "categories": [
        "cs.HC (Human-Computer Interaction)",
        "cs.AI (Artificial Intelligence)",
        "cs.LG (Machine Learning)"
      ],
      "abstract": "Calibration has been proposed as a way to enhance the reliability and\nadoption of machine learning classifiers. We study a particular aspect of this\nproposal: how does calibrating a classification model affect the decisions made\nby non-expert humans consuming the model's predictions? We perform a\nHuman-Computer-Interaction (HCI) experiment to ascertain the effect of\ncalibration on (i) trust in the model, and (ii) the correlation between\ndecisions and predictions. We also propose further corrections to the reported\ncalibrated scores based on Kahneman and Tversky's prospect theory from\nbehavioral economics, and study the effect of these corrections on trust and\ndecision-making. We find that calibration is not sufficient on its own; the\nprospect theory correction is crucial for increasing the correlation between\nhuman decisions and the model's predictions. While this increased correlation\nsuggests higher trust in the model, responses to ``Do you trust the model\nmore?\" are unaffected by the method used.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.18317v1",
      "pdf_url": "http://arxiv.org/pdf/2508.18317v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.442,
      "weak_supervision_score": 0.362,
      "diffusion_reasoning_score": 0.349,
      "distributed_training_score": 0.264,
      "datasets_score": 0.285,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper focuses on calibrating machine learning classifiers and evaluating human trust and decision-making through HCI experiments, incorporating prospect theory. It does not involve training a reward model on human-ranked data or using reinforcement learning to fine-tune an AI model based on human preferences, which are core to RLHF. The human feedback in the paper is used solely for evaluation, not for model alignment or training.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.19277",
      "title": "POT: Inducing Overthinking in LLMs via Black-Box Iterative Optimization",
      "authors": [
        "Xinyu Li",
        "Tianjin Huang",
        "Ronghui Mu",
        "Xiaowei Huang",
        "Gaojie Jin"
      ],
      "categories": [
        "cs.LG (Machine Learning)",
        "cs.AI (Artificial Intelligence)",
        "cs.CR (Cryptography and Security)"
      ],
      "abstract": "Recent advances in Chain-of-Thought (CoT) prompting have substantially\nenhanced the reasoning capabilities of large language models (LLMs), enabling\nsophisticated problem-solving through explicit multi-step reasoning traces.\nHowever, these enhanced reasoning processes introduce novel attack surfaces,\nparticularly vulnerabilities to computational inefficiency through\nunnecessarily verbose reasoning chains that consume excessive resources without\ncorresponding performance gains. Prior overthinking attacks typically require\nrestrictive conditions including access to external knowledge sources for data\npoisoning, reliance on retrievable poisoned content, and structurally obvious\ntemplates that limit practical applicability in real-world scenarios. To\naddress these limitations, we propose POT (Prompt-Only OverThinking), a novel\nblack-box attack framework that employs LLM-based iterative optimization to\ngenerate covert and semantically natural adversarial prompts, eliminating\ndependence on external data access and model retrieval. Extensive experiments\nacross diverse model architectures and datasets demonstrate that POT achieves\nsuperior performance compared to other methods.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.19277v1",
      "pdf_url": "http://arxiv.org/pdf/2508.19277v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.393,
      "weak_supervision_score": 0.358,
      "diffusion_reasoning_score": 0.498,
      "distributed_training_score": 0.326,
      "datasets_score": 0.265,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper introduces POT, a framework for inducing overthinking in LLMs through iterative prompt optimization, focusing on adversarial attacks rather than reasoning models. It does not mention or adapt diffusion models, nor does it treat Chain-of-Thought as a single entity for iterative refinement in logical tasks as defined in the topic.",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2508.19278",
      "title": "Towards Production-Worthy Simulation for Autonomous Cyber Operations",
      "authors": [
        "Konur Tholl",
        "Mariam El Mezouar",
        "Ranwa Al Mallah"
      ],
      "categories": [
        "cs.CR (Cryptography and Security)",
        "cs.AI (Artificial Intelligence)",
        "cs.LG (Machine Learning)"
      ],
      "abstract": "Simulated environments have proven invaluable in Autonomous Cyber Operations\n(ACO) where Reinforcement Learning (RL) agents can be trained without the\ncomputational overhead of emulation. These environments must accurately\nrepresent cybersecurity scenarios while producing the necessary signals to\nsupport RL training. In this study, we present a framework where we first\nextend CybORG's Cage Challenge 2 environment by implementing three new actions:\nPatch, Isolate, and Unisolate, to better represent the capabilities available\nto human operators in real-world settings. We then propose a design for agent\ndevelopment where we modify the reward signals and the agent's feature space to\nenhance training performance. To validate these modifications, we train DQN and\nPPO agents in the updated environment. Our study demonstrates that CybORG can\nbe extended with additional realistic functionality, while maintaining its\nability to generate informative training signals for RL agents.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2508.19278v1",
      "pdf_url": "http://arxiv.org/pdf/2508.19278v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.429,
      "weak_supervision_score": 0.365,
      "diffusion_reasoning_score": 0.357,
      "distributed_training_score": 0.361,
      "datasets_score": 0.321,
      "llm_validation_status": "completed",
      "rlhf_relevance": "Not Relevant",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "The paper focuses on extending a simulated environment for Reinforcement Learning (RL) in Autonomous Cyber Operations, including adding new actions and optimizing reward signals for training agents like DQN and PPO. It does not involve human feedback, such as training a reward model on human-ranked data or fine-tuning models based on human preferences, which are core to RLHF. Therefore, the paper's contributions are unrelated to RLHF.",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00039",
      "title": "AMMKD: Adaptive Multimodal Multi-teacher Distillation for Lightweight\n  Vision-Language Models",
      "authors": [
        "Yuqi Li",
        "Chuanguang Yang",
        "Junhao Dong",
        "Zhengtao Yao",
        "Haoyan Xu",
        "Zeyu Dong",
        "Hansheng Zeng",
        "Zhulin An",
        "Yingli Tian"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)"
      ],
      "abstract": "The success of large-scale visual language pretraining (VLP) models has\ndriven widespread adoption of image-text retrieval tasks. However, their\ndeployment on mobile devices remains limited due to large model sizes and\ncomputational complexity. We propose Adaptive Multi-Modal Multi-Teacher\nKnowledge Distillation (AMMKD), a novel framework that integrates multi-modal\nfeature fusion, multi-teacher distillation, and adaptive optimization to\ndeliver lightweight yet effective retrieval models. Specifically, our method\nbegins with a feature fusion network that extracts and merges discriminative\nfeatures from both the image and text modalities. To reduce model parameters\nand further improve performance, we design a multi-teacher knowledge\ndistillation framework to pre-train two CLIP teacher models. We decouple\nmodalities by pre-computing and storing text features as class vectors via the\nteacher text encoder to enhance efficiency. To better align teacher and student\noutputs, we apply KL scatter for probability distribution matching. Finally, we\ndesign an adaptive dynamic weighting scheme that treats multi-teacher\ndistillation as a multi-objective optimization problem. By leveraging gradient\nspace diversity, we dynamically adjust the influence of each teacher, reducing\nconflicts and guiding the student toward more optimal learning directions.\nExtensive experiments on three benchmark datasets demonstrate that AMMKD\nachieves superior performance while significantly reducing model complexity,\nvalidating its effectiveness and flexibility.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2509.00039v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00039v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.349,
      "weak_supervision_score": 0.365,
      "diffusion_reasoning_score": 0.438,
      "distributed_training_score": 0.406,
      "datasets_score": 0.345,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "Not Relevant",
      "distributed_training_relevance": "Not Relevant",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "The paper focuses on adaptive multimodal multi-teacher knowledge distillation for vision-language models, emphasizing feature fusion and optimization for lightweight models. It does not involve diffusion models, iterative refinement processes, or multi-step logical reasoning for complex tasks.",
      "distributed_training_justification": "The paper discusses knowledge distillation techniques with multiple teachers but does not address distributed training, parallel computing, or strategies for partitioning data/computation across multiple nodes or processors.",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.00042",
      "title": "ARTPS: Depth-Enhanced Hybrid Anomaly Detection and Learnable Curiosity\n  Score for Autonomous Rover Target Prioritization",
      "authors": [
        "Poyraz Baydemir"
      ],
      "categories": [
        "cs.CV (Computer Vision and Pattern Recognition)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "We present ARTPS (Autonomous Rover Target Prioritization System), a novel\nhybrid AI system that combines depth estimation, anomaly detection, and\nlearnable curiosity scoring for autonomous exploration of planetary surfaces.\nOur approach integrates monocular depth estimation using Vision Transformers\nwith multi-component anomaly detection and a weighted curiosity score that\nbalances known value, anomaly signals, depth variance, and surface roughness.\nThe system achieves state-of-the-art performance with AUROC of 0.94, AUPRC of\n0.89, and F1-Score of 0.87 on Mars rover datasets. We demonstrate significant\nimprovements in target prioritization accuracy through ablation studies and\nprovide comprehensive analysis of component contributions. The hybrid fusion\napproach reduces false positives by 23% while maintaining high detection\nsensitivity across diverse terrain types.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2509.00042v1",
      "pdf_url": "http://arxiv.org/pdf/2509.00042v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "extraction_failed",
      "embedding_status": "completed",
      "rlhf_score": 0.398,
      "weak_supervision_score": 0.334,
      "diffusion_reasoning_score": 0.371,
      "distributed_training_score": 0.345,
      "datasets_score": 0.388,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.06967",
      "title": "Cross-field SNR Analysis and Tensor Channel Estimation for Multi-UAV\n  Near-field Communications",
      "authors": [
        "Tianyu Huo",
        "Jian Xiong",
        "Yiyan Wu",
        "Songjie Yang",
        "Bo Liu",
        "Wenjun Zhang"
      ],
      "categories": [
        "eess.SP (Signal Processing)",
        "cs.AI (Artificial Intelligence)",
        "cs.IT (Information Theory)",
        "math.IT (Information Theory)"
      ],
      "abstract": "Extremely large antenna array (ELAA) is key to enhancing spectral efficiency\nin 6G networks. Leveraging the distributed nature of multi-unmanned aerial\nvehicle (UAV) systems enables the formation of distributed ELAA, which often\noperate in the near-field region with spatial sparsity, rendering the\nconventional far-field plane wave assumption invalid. This paper investigates\nchannel estimation for distributed near-field multi-UAV communication systems.\nWe first derive closed-form signal-to-noise ratio (SNR) expressions under the\nplane wave model (PWM), spherical wave model (SWM), and a hybrid\nspherical-plane wave model (HSPWM), also referred to as the cross-field model,\nwithin a distributed uniform planar array (UPA) scenario. The analysis shows\nthat HSPWM achieves a good balance between modeling accuracy and analytical\ntractability. Based on this, we propose two channel estimation algorithms: the\nspherical-domain orthogonal matching pursuit (SD-OMP) and the tensor-OMP. The\nSD-OMP generalizes the polar domain to jointly consider elevation, azimuth, and\nrange. Under the HSPWM, the channel is naturally formulated as a tensor,\nenabling the use of tensor-OMP. Simulation results demonstrate that tensor-OMP\nachieves normalized mean square error (NMSE) performance comparable to SD-OMP,\nwhile offering reduced computational complexity and improved scalability.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2509.06967v1",
      "pdf_url": "http://arxiv.org/pdf/2509.06967v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.279,
      "weak_supervision_score": 0.293,
      "diffusion_reasoning_score": 0.262,
      "distributed_training_score": 0.342,
      "datasets_score": 0.252,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "not_validated",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "not_validated",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "below_threshold",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "below_threshold",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    },
    {
      "id": "2509.06968",
      "title": "Deep Learning-based Techniques for Integrated Sensing and Communication\n  Systems: State-of-the-Art, Challenges, and Opportunities",
      "authors": [
        "Murat Temiz",
        "Yongwei Zhang",
        "Yanwei Fu",
        "Chi Zhang",
        "Chenfeng Meng",
        "Orhan Kaplan",
        "Christos Masouros"
      ],
      "categories": [
        "eess.SP (Signal Processing)",
        "cs.AI (Artificial Intelligence)"
      ],
      "abstract": "This article comprehensively reviews recent developments and research on deep\nlearning-based (DL-based) techniques for integrated sensing and communication\n(ISAC) systems. ISAC, which combines sensing and communication functionalities,\nis regarded as a key enabler for 6G and beyond networks, as many emerging\napplications, such as vehicular networks and industrial robotics, necessitate\nboth sensing and communication capabilities for effective operation. A unified\nplatform that provides both functions can reduce hardware complexity, alleviate\nfrequency spectrum congestion, and improve energy efficiency. However,\nintegrating these functionalities on the same hardware requires highly\noptimized signal processing and system design, introducing significant\ncomputational complexity when relying on conventional iterative or\noptimization-based techniques. As an alternative to conventional techniques,\nDL-based techniques offer efficient and near-optimal solutions with reduced\ncomputational complexity. Hence, such techniques are well-suited for operating\nunder limited computational resources and low latency requirements in real-time\nsystems. DL-based techniques can swiftly and effectively yield near-optimal\nsolutions for a wide range of sophisticated ISAC-related tasks, including\nwaveform design, channel estimation, sensing signal processing, data\ndemodulation, and interference mitigation. Therefore, motivated by these\nadvantages, recent studies have proposed various DL-based approaches for ISAC\nsystem design. After briefly introducing DL architectures and ISAC\nfundamentals, this survey presents a comprehensive and categorized review of\nstate-of-the-art DL-based techniques for ISAC, highlights their key advantages\nand major challenges, and outlines potential directions for future research.",
      "published_date": "2025-08-23",
      "arxiv_url": "http://arxiv.org/abs/2509.06968v1",
      "pdf_url": "http://arxiv.org/pdf/2509.06968v1",
      "scraper_status": "successfully_scraped",
      "intro_status": "intro_successful",
      "embedding_status": "completed",
      "rlhf_score": 0.399,
      "weak_supervision_score": 0.4,
      "diffusion_reasoning_score": 0.388,
      "distributed_training_score": 0.433,
      "datasets_score": 0.371,
      "llm_validation_status": "completed",
      "rlhf_relevance": "not_validated",
      "weak_supervision_relevance": "Not Relevant",
      "diffusion_reasoning_relevance": "not_validated",
      "distributed_training_relevance": "Tangentially Relevant",
      "datasets_relevance": "not_validated",
      "rlhf_justification": "below_threshold",
      "weak_supervision_justification": "The paper focuses on reviewing deep learning-based techniques for ISAC systems, including applications like waveform design and channel estimation, but does not discuss or mention weak supervision methods, such as programmatically generating labels from noisy sources. There is no indication of alternative labeling approaches in training DL models.",
      "diffusion_reasoning_justification": "below_threshold",
      "distributed_training_justification": "The paper briefly mentions distributed learning in the context of networking problems and lists Federated Learning (FL) in the acronyms, indicating a peripheral awareness of distributed techniques for communication networks. However, it does not delve into distributed training methods, parallel computing, or multi-node strategies as a core focus, which are central to ISAC applications discussed.",
      "datasets_justification": "below_threshold",
      "llm_score_status": "not_relevant_enough",
      "summary": null,
      "novelty_score": null,
      "novelty_justification": null,
      "impact_score": null,
      "impact_justification": null,
      "recommendation_score": null,
      "recommendation_justification": null,
      "h_index_status": "not_fetched",
      "semantic_scholar_url": null,
      "total_authors": 0,
      "authors_found": 0,
      "highest_h_index": 0,
      "average_h_index": 0.0,
      "notable_authors_count": 0,
      "author_h_indexes": []
    }
  ],
  "total_papers": 103,
  "date": "2025-08-23"
};
    </script>

    <script>
        // ============================================================================
        // GLOBAL VARIABLES & CONFIGURATION
        // ============================================================================
        
        // Page configuration - get data from embedded PAPER_DATA
        const PAGE_DATE = PAPER_DATA.date;
        const PAPERS_PER_PAGE = 5;
        let currentPage = 1;
        let totalPapers = PAPER_DATA.total_papers;
        let totalPages = 0;
        let allPapers = PAPER_DATA.papers;  // Use embedded papers data
        let filteredSortedPapers = [];  // Store papers after filtering/sorting
        let currentPagePapers = [];  // Store papers for current page display
        let currentSort = 'recommend_best';  // Default sort
        
        // H-Index Filter State Management
        let currentHIndexFilters = {
            found: true,
            notFound: true,
            highestMin: 0,
            highestMax: 1000,
            averageMin: 0,
            averageMax: 1000
        };
        
        let pendingHIndexFilters = { ...currentHIndexFilters };
        
        // Topic Filter State Management
        let currentTopicFilters = {
            rlhf: true,
            weakSupervision: true,
            diffusionReasoning: true,
            distributedTraining: true,
            datasets: true
        };
        
        let pendingTopicFilters = { ...currentTopicFilters };
        
        // Relevance Filter State Management
        let currentRelevanceFilters = {
            highlyRelevant: true,
            moderatelyRelevant: true,
            tangentiallyRelevant: true,
            notRelevant: true
        };
        
        let pendingRelevanceFilters = { ...currentRelevanceFilters };
        
        // Sidebar state variables
        let isMobileSidebarOpen = false;
        let isDesktopSidebarOpen = false;

        // ============================================================================
        // URL PARAMETER UTILITIES
        // ============================================================================
        
        function getUrlParameter(name) {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get(name);
        }
        
        function setUrlParameter(name, value) {
            const url = new URL(window.location.href);
            url.searchParams.set(name, value);
            window.history.pushState(null, '', url.toString());
        }
        
        function updateHIndexFiltersFromURL() {
            // Get H-Index filter parameters from URL
            const hindexFound = getUrlParameter('hindex_found');
            const hindexNotFound = getUrlParameter('hindex_not_found');
            const highestMin = getUrlParameter('highest_min');
            const highestMax = getUrlParameter('highest_max');
            const averageMin = getUrlParameter('average_min');
            const averageMax = getUrlParameter('average_max');
            
            // Update current filters if parameters exist
            if (hindexFound !== null) currentHIndexFilters.found = hindexFound === 'true';
            if (hindexNotFound !== null) currentHIndexFilters.notFound = hindexNotFound === 'true';
            if (highestMin !== null) currentHIndexFilters.highestMin = parseInt(highestMin) || 0;
            if (highestMax !== null) currentHIndexFilters.highestMax = parseInt(highestMax) || 1000;
            if (averageMin !== null) currentHIndexFilters.averageMin = parseInt(averageMin) || 0;
            if (averageMax !== null) currentHIndexFilters.averageMax = parseInt(averageMax) || 1000;
            
            // Sync pending filters
            pendingHIndexFilters = { ...currentHIndexFilters };
            
            // Sync UI and update button text
            syncHIndexUI();
        }
        
        function updateURLWithHIndexFilters() {
            const url = new URL(window.location.href);
            
            // Only set parameters if they differ from defaults
            if (!currentHIndexFilters.found || !currentHIndexFilters.notFound) {
                url.searchParams.set('hindex_found', currentHIndexFilters.found);
                url.searchParams.set('hindex_not_found', currentHIndexFilters.notFound);
            } else {
                url.searchParams.delete('hindex_found');
                url.searchParams.delete('hindex_not_found');
            }
            
            if (currentHIndexFilters.highestMin !== 0 || currentHIndexFilters.highestMax !== 1000) {
                url.searchParams.set('highest_min', currentHIndexFilters.highestMin);
                url.searchParams.set('highest_max', currentHIndexFilters.highestMax);
            } else {
                url.searchParams.delete('highest_min');
                url.searchParams.delete('highest_max');
            }
            
            if (currentHIndexFilters.averageMin !== 0 || currentHIndexFilters.averageMax !== 1000) {
                url.searchParams.set('average_min', currentHIndexFilters.averageMin);
                url.searchParams.set('average_max', currentHIndexFilters.averageMax);
            } else {
                url.searchParams.delete('average_min');
                url.searchParams.delete('average_max');
            }
            
            window.history.pushState(null, '', url.toString());
        }

        // ============================================================================
        // DATE FORMATTING FUNCTIONS
        // ============================================================================
        
        function formatPageDate(dateString) {
            const date = new Date(dateString);
            const options = { day: 'numeric', month: 'long', year: 'numeric' };
            return date.toLocaleDateString('en-GB', options);
        }

        function formatPublicationDate(dateString) {
            const date = new Date(dateString);
            const options = { day: 'numeric', month: 'long', year: 'numeric' };
            return date.toLocaleDateString('en-GB', options);
        }

        // ============================================================================
        // UI UPDATE FUNCTIONS FOR PAGE LOAD
        // ============================================================================
        
        function updatePageTitles(date) {
            const formattedDate = formatPageDate(date);
            const titleText = `Papers Published on ${formattedDate}`;
            
            // Update page title
            document.title = `Research Feed -- ${formattedDate}`;
            
            // Update mobile and desktop headers
            const mobileTitle = document.getElementById('page-title-mobile');
            const desktopTitle = document.getElementById('page-title-desktop');
            
            if (mobileTitle) {
                mobileTitle.textContent = titleText;
            }
            if (desktopTitle) {
                desktopTitle.textContent = titleText;
            }
        }

        function updatePaperCount() {
            const mobileCount = document.getElementById('mobile-paper-count');
            const desktopCount = document.getElementById('desktop-paper-count');
            const mobileMainCount = document.getElementById('mobile-main-paper-count');
            const desktopMainCount = document.getElementById('desktop-main-paper-count');
            
            const showing = filteredSortedPapers.length;
            const sidebarCountText = `Showing: ${showing}/${totalPapers} Papers`;
            const mainCountText = `Showing ${showing} / ${totalPapers} papers`;
            
            // Update sidebar counts
            if (mobileCount) {
                mobileCount.textContent = sidebarCountText;
            }
            if (desktopCount) {
                desktopCount.textContent = sidebarCountText;
            }
            
            // Update main header counts
            if (mobileMainCount) {
                mobileMainCount.textContent = mainCountText;
            }
            if (desktopMainCount) {
                desktopMainCount.textContent = mainCountText;
            }
        }

        // ============================================================================
        // SORTING FUNCTIONS
        // ============================================================================
        
        function calculateRecommendationScore(paper) {
            // Skip calculation if already calculated or if not relevant enough
            if (paper.recommendation_numerical_score !== undefined) {
                return paper.recommendation_numerical_score;
            }
            
            if (paper.llm_score_status === 'not_relevant_enough') {
                paper.recommendation_numerical_score = 0;
                return 0;
            }
            
            let score = 0;
            
            // Recommendation scores (primary)
            const recommendationScores = {
                'Must Read': 40,
                'Should Read': 30,
                'Can Skip': 20,
                'Ignore': 10
            };
            score += recommendationScores[paper.recommendation_score] || 0;
            
            // Novelty scores (first tiebreaker)
            const noveltyScores = {
                'High': 4,
                'Moderate': 3,
                'Low': 2,
                'None': 1
            };
            score += noveltyScores[paper.novelty_score] || 0;
            
            // Impact scores (second tiebreaker)
            const impactScores = {
                'High': 4,
                'Moderate': 3,
                'Low': 2,
                'Negligible': 1
            };
            score += impactScores[paper.impact_score] || 0;
            
            paper.recommendation_numerical_score = score;
            return score;
        }
        
        function getHighestHIndex(paper) {
            // Return the highest H-index value, or -1 if not available (so unavailable papers sort last)
            return paper.highest_h_index !== undefined ? paper.highest_h_index : -1;
        }
        
        function getAverageHIndex(paper) {
            // Return the average H-index value, or -1 if not available (so unavailable papers sort last)
            return paper.average_h_index !== undefined ? paper.average_h_index : -1;
        }
        
        function calculateRelevanceScore(paper) {
            let score = 0;
            
            // Only consider topics that are currently selected/enabled in the topic filter
            const topicsToConsider = [];
            if (currentTopicFilters.rlhf) topicsToConsider.push('rlhf_relevance');
            if (currentTopicFilters.weakSupervision) topicsToConsider.push('weak_supervision_relevance');
            if (currentTopicFilters.diffusionReasoning) topicsToConsider.push('diffusion_reasoning_relevance');
            if (currentTopicFilters.distributedTraining) topicsToConsider.push('distributed_training_relevance');
            if (currentTopicFilters.datasets) topicsToConsider.push('datasets_relevance');
            
            // If no topics are selected, return 0
            if (topicsToConsider.length === 0) return 0;
            
            // Weighted scoring system
            const relevanceWeights = {
                'Highly Relevant': 4,
                'Moderately Relevant': 3,
                'Tangentially Relevant': 2,
                'Not Relevant': 1
            };
            
            // Sum up scores for selected topics only
            for (let topicField of topicsToConsider) {
                const relevance = paper[topicField];
                // Treat "not_validated" same as "Not Relevant"
                const normalizedRelevance = relevance === "not_validated" ? "Not Relevant" : relevance;
                score += relevanceWeights[normalizedRelevance] || 1; // Default to 1 if unknown
            }
            
            return score;
        }
        
        function sortPapers(sortType) {
            switch (sortType) {
                case 'recommend_best':
                    filteredSortedPapers.sort((a, b) => calculateRecommendationScore(b) - calculateRecommendationScore(a));
                    break;
                case 'recommend_worst':
                    filteredSortedPapers.sort((a, b) => calculateRecommendationScore(a) - calculateRecommendationScore(b));
                    break;
                case 'relevance_high':
                    filteredSortedPapers.sort((a, b) => calculateRelevanceScore(b) - calculateRelevanceScore(a));
                    break;
                case 'relevance_low':
                    filteredSortedPapers.sort((a, b) => calculateRelevanceScore(a) - calculateRelevanceScore(b));
                    break;
                case 'highest_hindex_asc':
                    filteredSortedPapers.sort((a, b) => getHighestHIndex(a) - getHighestHIndex(b));
                    break;
                case 'highest_hindex_desc':
                    filteredSortedPapers.sort((a, b) => getHighestHIndex(b) - getHighestHIndex(a));
                    break;
                case 'average_hindex_asc':
                    filteredSortedPapers.sort((a, b) => getAverageHIndex(a) - getAverageHIndex(b));
                    break;
                case 'average_hindex_desc':
                    filteredSortedPapers.sort((a, b) => getAverageHIndex(b) - getAverageHIndex(a));
                    break;
                case 'id_asc':
                    filteredSortedPapers.sort((a, b) => a.id.localeCompare(b.id));
                    break;
                case 'id_desc':
                    filteredSortedPapers.sort((a, b) => b.id.localeCompare(a.id));
                    break;
                case 'title_az':
                    filteredSortedPapers.sort((a, b) => a.title.localeCompare(b.title));
                    break;
                case 'title_za':
                    filteredSortedPapers.sort((a, b) => b.title.localeCompare(a.title));
                    break;
                default:
                    // Default to recommendation best first
                    filteredSortedPapers.sort((a, b) => calculateRecommendationScore(b) - calculateRecommendationScore(a));
            }
        }

        // ============================================================================
        // DROPDOWN DIRECTION FUNCTIONS
        // ============================================================================
        
        function setDropdownDirection(button, dropdown) {
            const buttonRect = button.getBoundingClientRect();
            const sidebar = button.closest('#mobile-sidebar, #desktop-sidebar');
            
            // Get the sidebar content area instead of the entire sidebar
            const sidebarContent = sidebar.querySelector('.flex-1');
            const sidebarContentRect = sidebarContent ? sidebarContent.getBoundingClientRect() : sidebar.getBoundingClientRect();
            
            // Calculate available space within the entire sidebar content area
            const spaceBelow = sidebarContentRect.bottom - buttonRect.bottom;
            const spaceAbove = buttonRect.top - sidebarContentRect.top;
            
            // Estimate dropdown height (roughly 6 items * 40px each)
            const estimatedDropdownHeight = 240;
            
            // Determine direction based on available space in the whole sidebar content
            if (spaceBelow >= estimatedDropdownHeight || spaceBelow >= spaceAbove) {
                // Dropdown goes down
                dropdown.classList.remove('dropdown-up');
                dropdown.classList.add('dropdown-down');
            } else {
                // Dropdown goes up
                dropdown.classList.remove('dropdown-down');
                dropdown.classList.add('dropdown-up');
            }
        }

        // ============================================================================
        // SORTING DROPDOWN FUNCTIONS
        // ============================================================================
        
        function toggleMobileSortDropdown() {
            const button = document.getElementById('mobile-sort-btn');
            const dropdown = document.getElementById('mobile-sort-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                // Set direction before showing
                setDropdownDirection(button, dropdown);
                // Change button to expanded state
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                // Change button back to normal state
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function toggleDesktopSortDropdown() {
            const button = document.getElementById('desktop-sort-btn');
            const dropdown = document.getElementById('desktop-sort-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                // Set direction before showing
                setDropdownDirection(button, dropdown);
                // Change button to expanded state
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                // Change button back to normal state
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function changeSortAndClose(sortType) {
            // Update current sort
            currentSort = sortType;
            
            // Update URL
            setUrlParameter('sort', sortType);
            
            // Update dropdown text
            updateSortDropdownUI();
            
            // Close dropdowns and reset button states
            const mobileDropdown = document.getElementById('mobile-sort-dropdown');
            const desktopDropdown = document.getElementById('desktop-sort-dropdown');
            const mobileButton = document.getElementById('mobile-sort-btn');
            const desktopButton = document.getElementById('desktop-sort-btn');
            
            mobileDropdown.classList.add('hidden');
            desktopDropdown.classList.add('hidden');
            
            // Reset button states to normal
            mobileButton.classList.remove('bg-neutral-600');
            mobileButton.classList.add('bg-neutral-500');
            desktopButton.classList.remove('bg-neutral-600');
            desktopButton.classList.add('bg-neutral-500');
            
            // Close the appropriate sidebar
            if (isMobileSidebarOpen) {
                closeMobileMenu();
            }
            if (isDesktopSidebarOpen) {
                closeDesktopMenu();
            }
            
            // Apply new sorting
            applyFiltersAndSort();
            displayCurrentPage();
        }
        
        function updateSortDropdownUI() {
            const sortNames = {
                'recommend_best': 'Recommendation (Best First)',
                'recommend_worst': 'Recommendation (Worst First)',
                'relevance_high': 'Relevance (Highest to Lowest)',
                'relevance_low': 'Relevance (Lowest to Highest)',
                'highest_hindex_asc': 'Highest H-Index (Ascending)',
                'highest_hindex_desc': 'Highest H-Index (Descending)',
                'average_hindex_asc': 'Average H-Index (Ascending)',
                'average_hindex_desc': 'Average H-Index (Descending)',
                'id_asc': 'arXiv ID (Ascending)',
                'id_desc': 'arXiv ID (Descending)',
                'title_az': 'Title (A-Z)',
                'title_za': 'Title (Z-A)'
            };
            
            const sortName = sortNames[currentSort] || 'Recommendation (Best First)';
            
            const mobileText = document.getElementById('mobile-sort-text');
            const desktopText = document.getElementById('desktop-sort-text');
            
            if (mobileText) {
                mobileText.textContent = sortName;
            }
            if (desktopText) {
                desktopText.textContent = sortName;
            }
        }

        // ============================================================================
        // H-INDEX FILTER DROPDOWN FUNCTIONS
        // ============================================================================
        
        function toggleMobileHIndexDropdown() {
            const button = document.getElementById('mobile-hindex-btn');
            const dropdown = document.getElementById('mobile-hindex-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                // Set direction before showing
                setDropdownDirection(button, dropdown);
                // Change button to expanded state
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                // Change button back to normal state
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function toggleDesktopHIndexDropdown() {
            const button = document.getElementById('desktop-hindex-btn');
            const dropdown = document.getElementById('desktop-hindex-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                // Set direction before showing
                setDropdownDirection(button, dropdown);
                // Change button to expanded state
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                // Change button back to normal state
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function toggleHIndexRanges() {
            const mobileFoundCheckbox = document.getElementById('mobile-hindex-found');
            const desktopFoundCheckbox = document.getElementById('desktop-hindex-found');
            const mobileHighestRange = document.getElementById('mobile-highest-range');
            const mobileAverageRange = document.getElementById('mobile-average-range');
            const desktopHighestRange = document.getElementById('desktop-highest-range');
            const desktopAverageRange = document.getElementById('desktop-average-range');
            
            // Sync the checkboxes
            if (event.target.id === 'mobile-hindex-found') {
                desktopFoundCheckbox.checked = mobileFoundCheckbox.checked;
            } else if (event.target.id === 'desktop-hindex-found') {
                mobileFoundCheckbox.checked = desktopFoundCheckbox.checked;
            }
            
            const isEnabled = mobileFoundCheckbox.checked;
            
            // Update pending filters
            updatePendingHIndexFilters();
            
            // Update button text to reflect current state
            updateHIndexButtonText();
            
            // Toggle disabled state for range sections
            [mobileHighestRange, mobileAverageRange, desktopHighestRange, desktopAverageRange].forEach(range => {
                if (range) {
                    if (isEnabled) {
                        range.classList.remove('disabled');
                        range.querySelectorAll('input').forEach(input => {
                            input.disabled = false;
                        });
                    } else {
                        range.classList.add('disabled');
                        range.querySelectorAll('input').forEach(input => {
                            input.disabled = true;
                        });
                    }
                }
            });
        }
        
        function updatePendingHIndexFilters() {
            // Read current UI state into pending filters
            const mobileFoundCheckbox = document.getElementById('mobile-hindex-found');
            const mobileNotFoundCheckbox = document.getElementById('mobile-hindex-not-found');
            const mobileHighestMin = document.getElementById('mobile-highest-min');
            const mobileHighestMax = document.getElementById('mobile-highest-max');
            const mobileAverageMin = document.getElementById('mobile-average-min');
            const mobileAverageMax = document.getElementById('mobile-average-max');
            
            pendingHIndexFilters = {
                found: mobileFoundCheckbox.checked,
                notFound: mobileNotFoundCheckbox.checked,
                highestMin: parseInt(mobileHighestMin.value) || 0,
                highestMax: parseInt(mobileHighestMax.value) || 1000,
                averageMin: parseInt(mobileAverageMin.value) || 0,
                averageMax: parseInt(mobileAverageMax.value) || 1000
            };
        }
        
        function resetPendingHIndexFilters() {
            // Revert pending filters to current applied filters
            pendingHIndexFilters = { ...currentHIndexFilters };
            
            // Update UI to reflect current filters
            syncHIndexUI();
        }
        
        function resetPendingNoveltyFilters() {
            // Revert pending filters to current applied filters
            pendingNoveltyFilters = { ...currentNoveltyFilters };
            
            // Update UI to reflect current filters
            syncPendingNoveltyUI();
            updateNoveltyButtonText();
        }
        
        function resetPendingImpactFilters() {
            // Revert pending filters to current applied filters
            pendingImpactFilters = { ...currentImpactFilters };
            
            // Update UI to reflect current filters
            syncPendingImpactUI();
            updateImpactButtonText();
        }
        
        function syncHIndexUI() {
            // Update checkboxes
            document.getElementById('mobile-hindex-found').checked = currentHIndexFilters.found;
            document.getElementById('mobile-hindex-not-found').checked = currentHIndexFilters.notFound;
            document.getElementById('desktop-hindex-found').checked = currentHIndexFilters.found;
            document.getElementById('desktop-hindex-not-found').checked = currentHIndexFilters.notFound;
            
            // Update range inputs
            document.getElementById('mobile-highest-min').value = currentHIndexFilters.highestMin;
            document.getElementById('mobile-highest-max').value = currentHIndexFilters.highestMax;
            document.getElementById('mobile-average-min').value = currentHIndexFilters.averageMin;
            document.getElementById('mobile-average-max').value = currentHIndexFilters.averageMax;
            document.getElementById('desktop-highest-min').value = currentHIndexFilters.highestMin;
            document.getElementById('desktop-highest-max').value = currentHIndexFilters.highestMax;
            document.getElementById('desktop-average-min').value = currentHIndexFilters.averageMin;
            document.getElementById('desktop-average-max').value = currentHIndexFilters.averageMax;
            
            // Update disabled states
            toggleHIndexRanges();
            
            // Update button text
            updateHIndexButtonText();
        }
        
        function updateHIndexButtonText() {
            // Read the current checkbox states from the UI
            const foundChecked = document.getElementById('mobile-hindex-found').checked;
            const notFoundChecked = document.getElementById('mobile-hindex-not-found').checked;
            
            let selectionText;
            if (foundChecked && notFoundChecked) {
                selectionText = "All Selected";
            } else if (foundChecked && !notFoundChecked) {
                selectionText = "H-Index Found";
            } else if (!foundChecked && notFoundChecked) {
                selectionText = "H-Index Not Found";
            } else {
                selectionText = "None Selected";
            }
            
            // Update mobile button
            const mobileButton = document.getElementById('mobile-hindex-btn');
            if (mobileButton) {
                mobileButton.innerHTML = `<span class="font-bold">H-Index:</span> <span class="font-normal">${selectionText}</span> <span class="text-base">▼</span>`;
            }
            
            // Update desktop button
            const desktopButton = document.getElementById('desktop-hindex-btn');
            if (desktopButton) {
                desktopButton.innerHTML = `<span class="font-bold">H-Index:</span> <span class="font-normal">${selectionText}</span> <span class="text-sm">▼</span>`;
            }
        }
        
        function applyHIndexFilter() {
            // Update pending filters one final time
            updatePendingHIndexFilters();
            
            // Apply pending filters as current filters
            currentHIndexFilters = { ...pendingHIndexFilters };
            
            // Update URL with new filter state
            updateURLWithHIndexFilters();
            
            // Update button text to reflect applied filters
            updateHIndexButtonText();
            
            // Close both dropdowns
            const mobileDropdown = document.getElementById('mobile-hindex-dropdown');
            const desktopDropdown = document.getElementById('desktop-hindex-dropdown');
            const mobileButton = document.getElementById('mobile-hindex-btn');
            const desktopButton = document.getElementById('desktop-hindex-btn');
            
            mobileDropdown.classList.add('hidden');
            desktopDropdown.classList.add('hidden');
            
            // Reset button states to normal
            mobileButton.classList.remove('bg-neutral-600');
            mobileButton.classList.add('bg-neutral-500');
            desktopButton.classList.remove('bg-neutral-600');
            desktopButton.classList.add('bg-neutral-500');
            
            // Don't close sidebar - just close dropdown
            // (Sidebar should stay open for more filtering)
            
            // Apply new filtering and update display
            applyFiltersAndSort();
            displayCurrentPage();
        }

        // ============================================================================
        // INPUT VALIDATION FOR H-INDEX RANGES
        // ============================================================================
        
        function validateHIndexInput(input) {
            // Allow empty input temporarily (user might be typing)
            if (input.value === '') {
                return;
            }
            
            let value = parseInt(input.value);
            
            // Ensure value is within 0-1000 range
            if (isNaN(value) || value < 0) {
                input.value = 0;
            } else if (value > 1000) {
                input.value = 1000;
            }
            
            // Auto-correct min/max relationships
            enforceMinMaxConstraints(input);
        }
        
        function enforceMinMaxConstraints(changedInput) {
            const inputId = changedInput.id;
            let minInput, maxInput;
            
            // Determine which min/max pair this input belongs to
            if (inputId.includes('highest-min')) {
                minInput = changedInput;
                maxInput = document.getElementById(inputId.replace('min', 'max'));
            } else if (inputId.includes('highest-max')) {
                maxInput = changedInput;
                minInput = document.getElementById(inputId.replace('max', 'min'));
            } else if (inputId.includes('average-min')) {
                minInput = changedInput;
                maxInput = document.getElementById(inputId.replace('min', 'max'));
            } else if (inputId.includes('average-max')) {
                maxInput = changedInput;
                minInput = document.getElementById(inputId.replace('max', 'min'));
            }
            
            if (minInput && maxInput) {
                const minVal = parseInt(minInput.value) || 0;
                const maxVal = parseInt(maxInput.value) || 0;
                
                // If min > max, auto-correct
                if (minVal > maxVal) {
                    if (changedInput === minInput) {
                        // User changed min to be > max, set max = min
                        maxInput.value = minVal;
                    } else {
                        // User changed max to be < min, set min = max
                        minInput.value = maxVal;
                    }
                }
            }
        }
        
        // Add input validation when page loads
        function setupHIndexValidation() {
            const inputs = [
                'mobile-highest-min', 'mobile-highest-max',
                'mobile-average-min', 'mobile-average-max',
                'desktop-highest-min', 'desktop-highest-max',
                'desktop-average-min', 'desktop-average-max'
            ];
            
            inputs.forEach(id => {
                const input = document.getElementById(id);
                if (input) {
                    // Validate on input (while typing) - but allow empty temporarily
                    input.addEventListener('input', () => {
                        validateHIndexInput(input);
                        updatePendingHIndexFilters(); // Update pending filters as user types
                    });
                    
                    // Validate on blur (when user leaves field) - ensure it's not empty
                    input.addEventListener('blur', () => {
                        if (input.value === '') {
                            input.value = 0; // Set default if user leaves it empty
                        }
                        validateHIndexInput(input);
                        updatePendingHIndexFilters(); // Update pending filters
                    });
                    
                    // Prevent non-numeric characters except for selection/deletion
                    input.addEventListener('keydown', (e) => {
                        // Allow: backspace, delete, tab, escape, enter, and numbers
                        if ([8, 9, 27, 13, 46].includes(e.keyCode) || 
                            // Allow Ctrl+A, Ctrl+C, Ctrl+V, Ctrl+X
                            (e.keyCode === 65 && e.ctrlKey) || 
                            (e.keyCode === 67 && e.ctrlKey) || 
                            (e.keyCode === 86 && e.ctrlKey) || 
                            (e.keyCode === 88 && e.ctrlKey) ||
                            // Allow numbers (0-9) on main keyboard and numpad
                            (e.keyCode >= 48 && e.keyCode <= 57) ||
                            (e.keyCode >= 96 && e.keyCode <= 105)) {
                            return;
                        }
                        e.preventDefault();
                    });
                }
            });
            
            // Add event listeners for checkboxes to update pending filters
            document.getElementById('mobile-hindex-not-found').addEventListener('change', () => {
                // Sync desktop checkbox
                document.getElementById('desktop-hindex-not-found').checked = 
                    document.getElementById('mobile-hindex-not-found').checked;
                updatePendingHIndexFilters();
                updateHIndexButtonText();
            });
            
            document.getElementById('desktop-hindex-not-found').addEventListener('change', () => {
                // Sync mobile checkbox
                document.getElementById('mobile-hindex-not-found').checked = 
                    document.getElementById('desktop-hindex-not-found').checked;
                updatePendingHIndexFilters();
                updateHIndexButtonText();
            });
            
            // Add event listeners for scoring checkboxes to update pending filters
            document.getElementById('mobile-scoring-has').addEventListener('change', () => {
                // Sync desktop checkbox
                document.getElementById('desktop-scoring-has').checked = 
                    document.getElementById('mobile-scoring-has').checked;
                updatePendingScoringFilters();
                updateScoringButtonText();
            });
            
            document.getElementById('mobile-scoring-no').addEventListener('change', () => {
                // Sync desktop checkbox
                document.getElementById('desktop-scoring-no').checked = 
                    document.getElementById('mobile-scoring-no').checked;
                updatePendingScoringFilters();
                updateScoringButtonText();
            });
            
            document.getElementById('desktop-scoring-has').addEventListener('change', () => {
                // Sync mobile checkbox
                document.getElementById('mobile-scoring-has').checked = 
                    document.getElementById('desktop-scoring-has').checked;
                updatePendingScoringFilters();
                updateScoringButtonText();
            });
            
            document.getElementById('desktop-scoring-no').addEventListener('change', () => {
                // Sync mobile checkbox
                document.getElementById('mobile-scoring-no').checked = 
                    document.getElementById('desktop-scoring-no').checked;
                updatePendingScoringFilters();
                updateScoringButtonText();
            });
            
            // Add event listeners for scoring checkboxes to update pending filters
            document.getElementById('mobile-scoring-has').addEventListener('change', () => {
                // Sync desktop checkbox
                document.getElementById('desktop-scoring-has').checked = 
                    document.getElementById('mobile-scoring-has').checked;
                updatePendingScoringFilters();
                updateScoringButtonText();
            });
            
            document.getElementById('desktop-scoring-has').addEventListener('change', () => {
                // Sync mobile checkbox
                document.getElementById('mobile-scoring-has').checked = 
                    document.getElementById('desktop-scoring-has').checked;
                updatePendingScoringFilters();
                updateScoringButtonText();
            });
            
            document.getElementById('mobile-scoring-no').addEventListener('change', () => {
                // Sync desktop checkbox
                document.getElementById('desktop-scoring-no').checked = 
                    document.getElementById('mobile-scoring-no').checked;
                updatePendingScoringFilters();
                updateScoringButtonText();
            });
            
            document.getElementById('desktop-scoring-no').addEventListener('change', () => {
                // Sync mobile checkbox
                document.getElementById('mobile-scoring-no').checked = 
                    document.getElementById('desktop-scoring-no').checked;
                updatePendingScoringFilters();
                updateScoringButtonText();
            });
            
            // Add event listeners for recommendation checkboxes to sync between mobile and desktop
            document.getElementById('mobile-recommendation-must').addEventListener('change', () => {
                document.getElementById('desktop-recommendation-must').checked = 
                    document.getElementById('mobile-recommendation-must').checked;
                updatePendingRecommendationFilters();
                updateRecommendationButtonText();
            });
            
            document.getElementById('mobile-recommendation-should').addEventListener('change', () => {
                document.getElementById('desktop-recommendation-should').checked = 
                    document.getElementById('mobile-recommendation-should').checked;
                updatePendingRecommendationFilters();
                updateRecommendationButtonText();
            });
            
            document.getElementById('mobile-recommendation-skip').addEventListener('change', () => {
                document.getElementById('desktop-recommendation-skip').checked = 
                    document.getElementById('mobile-recommendation-skip').checked;
                updatePendingRecommendationFilters();
                updateRecommendationButtonText();
            });
            
            document.getElementById('mobile-recommendation-ignore').addEventListener('change', () => {
                document.getElementById('desktop-recommendation-ignore').checked = 
                    document.getElementById('mobile-recommendation-ignore').checked;
                updatePendingRecommendationFilters();
                updateRecommendationButtonText();
            });
            
            document.getElementById('desktop-recommendation-must').addEventListener('change', () => {
                document.getElementById('mobile-recommendation-must').checked = 
                    document.getElementById('desktop-recommendation-must').checked;
                updatePendingRecommendationFilters();
                updateRecommendationButtonText();
            });
            
            document.getElementById('desktop-recommendation-should').addEventListener('change', () => {
                document.getElementById('mobile-recommendation-should').checked = 
                    document.getElementById('desktop-recommendation-should').checked;
                updatePendingRecommendationFilters();
                updateRecommendationButtonText();
            });
            
            document.getElementById('desktop-recommendation-skip').addEventListener('change', () => {
                document.getElementById('mobile-recommendation-skip').checked = 
                    document.getElementById('desktop-recommendation-skip').checked;
                updatePendingRecommendationFilters();
                updateRecommendationButtonText();
            });
            
            document.getElementById('desktop-recommendation-ignore').addEventListener('change', () => {
                document.getElementById('mobile-recommendation-ignore').checked = 
                    document.getElementById('desktop-recommendation-ignore').checked;
                updatePendingRecommendationFilters();
                updateRecommendationButtonText();
            });
            
            // Add event listeners for novelty checkboxes to sync between mobile and desktop
            document.getElementById('mobile-novelty-high').addEventListener('change', () => {
                document.getElementById('desktop-novelty-high').checked = 
                    document.getElementById('mobile-novelty-high').checked;
                updatePendingNoveltyFilters();
                updateNoveltyButtonText();
            });
            
            document.getElementById('mobile-novelty-moderate').addEventListener('change', () => {
                document.getElementById('desktop-novelty-moderate').checked = 
                    document.getElementById('mobile-novelty-moderate').checked;
                updatePendingNoveltyFilters();
                updateNoveltyButtonText();
            });
            
            document.getElementById('mobile-novelty-low').addEventListener('change', () => {
                document.getElementById('desktop-novelty-low').checked = 
                    document.getElementById('mobile-novelty-low').checked;
                updatePendingNoveltyFilters();
                updateNoveltyButtonText();
            });
            
            document.getElementById('mobile-novelty-none').addEventListener('change', () => {
                document.getElementById('desktop-novelty-none').checked = 
                    document.getElementById('mobile-novelty-none').checked;
                updatePendingNoveltyFilters();
                updateNoveltyButtonText();
            });
            
            document.getElementById('desktop-novelty-high').addEventListener('change', () => {
                document.getElementById('mobile-novelty-high').checked = 
                    document.getElementById('desktop-novelty-high').checked;
                updatePendingNoveltyFilters();
                updateNoveltyButtonText();
            });
            
            document.getElementById('desktop-novelty-moderate').addEventListener('change', () => {
                document.getElementById('mobile-novelty-moderate').checked = 
                    document.getElementById('desktop-novelty-moderate').checked;
                updatePendingNoveltyFilters();
                updateNoveltyButtonText();
            });
            
            document.getElementById('desktop-novelty-low').addEventListener('change', () => {
                document.getElementById('mobile-novelty-low').checked = 
                    document.getElementById('desktop-novelty-low').checked;
                updatePendingNoveltyFilters();
                updateNoveltyButtonText();
            });
            
            document.getElementById('desktop-novelty-none').addEventListener('change', () => {
                document.getElementById('mobile-novelty-none').checked = 
                    document.getElementById('desktop-novelty-none').checked;
                updatePendingNoveltyFilters();
                updateNoveltyButtonText();
            });
            
            // Add event listeners for impact checkboxes to sync between mobile and desktop
            document.getElementById('mobile-impact-high').addEventListener('change', () => {
                document.getElementById('desktop-impact-high').checked = 
                    document.getElementById('mobile-impact-high').checked;
                updatePendingImpactFilters();
                updateImpactButtonText();
            });
            
            document.getElementById('mobile-impact-moderate').addEventListener('change', () => {
                document.getElementById('desktop-impact-moderate').checked = 
                    document.getElementById('mobile-impact-moderate').checked;
                updatePendingImpactFilters();
                updateImpactButtonText();
            });
            
            document.getElementById('mobile-impact-low').addEventListener('change', () => {
                document.getElementById('desktop-impact-low').checked = 
                    document.getElementById('mobile-impact-low').checked;
                updatePendingImpactFilters();
                updateImpactButtonText();
            });
            
            document.getElementById('mobile-impact-negligible').addEventListener('change', () => {
                document.getElementById('desktop-impact-negligible').checked = 
                    document.getElementById('mobile-impact-negligible').checked;
                updatePendingImpactFilters();
                updateImpactButtonText();
            });
            
            document.getElementById('desktop-impact-high').addEventListener('change', () => {
                document.getElementById('mobile-impact-high').checked = 
                    document.getElementById('desktop-impact-high').checked;
                updatePendingImpactFilters();
                updateImpactButtonText();
            });
            
            document.getElementById('desktop-impact-moderate').addEventListener('change', () => {
                document.getElementById('mobile-impact-moderate').checked = 
                    document.getElementById('desktop-impact-moderate').checked;
                updatePendingImpactFilters();
                updateImpactButtonText();
            });
            
            document.getElementById('desktop-impact-low').addEventListener('change', () => {
                document.getElementById('mobile-impact-low').checked = 
                    document.getElementById('desktop-impact-low').checked;
                updatePendingImpactFilters();
                updateImpactButtonText();
            });
            
            document.getElementById('desktop-impact-negligible').addEventListener('change', () => {
                document.getElementById('mobile-impact-negligible').checked = 
                    document.getElementById('desktop-impact-negligible').checked;
                updatePendingImpactFilters();
                updateImpactButtonText();
            });
            
            // Add event listeners for relevance checkboxes to sync between mobile and desktop
            document.getElementById('mobile-relevance-highly').addEventListener('change', () => {
                document.getElementById('desktop-relevance-highly').checked = 
                    document.getElementById('mobile-relevance-highly').checked;
                updatePendingRelevanceFilters();
                updateRelevanceButtonText();
            });
            
            document.getElementById('mobile-relevance-moderately').addEventListener('change', () => {
                document.getElementById('desktop-relevance-moderately').checked = 
                    document.getElementById('mobile-relevance-moderately').checked;
                updatePendingRelevanceFilters();
                updateRelevanceButtonText();
            });
            
            document.getElementById('mobile-relevance-tangentially').addEventListener('change', () => {
                document.getElementById('desktop-relevance-tangentially').checked = 
                    document.getElementById('mobile-relevance-tangentially').checked;
                updatePendingRelevanceFilters();
                updateRelevanceButtonText();
            });
            
            document.getElementById('mobile-relevance-not').addEventListener('change', () => {
                document.getElementById('desktop-relevance-not').checked = 
                    document.getElementById('mobile-relevance-not').checked;
                updatePendingRelevanceFilters();
                updateRelevanceButtonText();
            });
            
            document.getElementById('desktop-relevance-highly').addEventListener('change', () => {
                document.getElementById('mobile-relevance-highly').checked = 
                    document.getElementById('desktop-relevance-highly').checked;
                updatePendingRelevanceFilters();
                updateRelevanceButtonText();
            });
            
            document.getElementById('desktop-relevance-moderately').addEventListener('change', () => {
                document.getElementById('mobile-relevance-moderately').checked = 
                    document.getElementById('desktop-relevance-moderately').checked;
                updatePendingRelevanceFilters();
                updateRelevanceButtonText();
            });
            
            document.getElementById('desktop-relevance-tangentially').addEventListener('change', () => {
                document.getElementById('mobile-relevance-tangentially').checked = 
                    document.getElementById('desktop-relevance-tangentially').checked;
                updatePendingRelevanceFilters();
                updateRelevanceButtonText();
            });
            
            document.getElementById('desktop-relevance-not').addEventListener('change', () => {
                document.getElementById('mobile-relevance-not').checked = 
                    document.getElementById('desktop-relevance-not').checked;
                updatePendingRelevanceFilters();
                updateRelevanceButtonText();
            });
            
            // Add event listeners for topic checkboxes to sync between mobile and desktop
            document.getElementById('mobile-topic-rlhf').addEventListener('change', () => {
                document.getElementById('desktop-topic-rlhf').checked = 
                    document.getElementById('mobile-topic-rlhf').checked;
                updatePendingTopicFilters();
                updateTopicButtonText();
            });
            
            document.getElementById('mobile-topic-weak-supervision').addEventListener('change', () => {
                document.getElementById('desktop-topic-weak-supervision').checked = 
                    document.getElementById('mobile-topic-weak-supervision').checked;
                updatePendingTopicFilters();
                updateTopicButtonText();
            });
            
            document.getElementById('mobile-topic-diffusion-reasoning').addEventListener('change', () => {
                document.getElementById('desktop-topic-diffusion-reasoning').checked = 
                    document.getElementById('mobile-topic-diffusion-reasoning').checked;
                updatePendingTopicFilters();
                updateTopicButtonText();
            });
            
            document.getElementById('mobile-topic-distributed-training').addEventListener('change', () => {
                document.getElementById('desktop-topic-distributed-training').checked = 
                    document.getElementById('mobile-topic-distributed-training').checked;
                updatePendingTopicFilters();
                updateTopicButtonText();
            });
            
            document.getElementById('mobile-topic-datasets').addEventListener('change', () => {
                document.getElementById('desktop-topic-datasets').checked = 
                    document.getElementById('mobile-topic-datasets').checked;
                updatePendingTopicFilters();
                updateTopicButtonText();
            });
            
            document.getElementById('desktop-topic-rlhf').addEventListener('change', () => {
                document.getElementById('mobile-topic-rlhf').checked = 
                    document.getElementById('desktop-topic-rlhf').checked;
                updatePendingTopicFilters();
                updateTopicButtonText();
            });
            
            document.getElementById('desktop-topic-weak-supervision').addEventListener('change', () => {
                document.getElementById('mobile-topic-weak-supervision').checked = 
                    document.getElementById('desktop-topic-weak-supervision').checked;
                updatePendingTopicFilters();
                updateTopicButtonText();
            });
            
            document.getElementById('desktop-topic-diffusion-reasoning').addEventListener('change', () => {
                document.getElementById('mobile-topic-diffusion-reasoning').checked = 
                    document.getElementById('desktop-topic-diffusion-reasoning').checked;
                updatePendingTopicFilters();
                updateTopicButtonText();
            });
            
            document.getElementById('desktop-topic-distributed-training').addEventListener('change', () => {
                document.getElementById('mobile-topic-distributed-training').checked = 
                    document.getElementById('desktop-topic-distributed-training').checked;
                updatePendingTopicFilters();
                updateTopicButtonText();
            });
            
            document.getElementById('desktop-topic-datasets').addEventListener('change', () => {
                document.getElementById('mobile-topic-datasets').checked = 
                    document.getElementById('desktop-topic-datasets').checked;
                updatePendingTopicFilters();
                updateTopicButtonText();
            });
        }

        // ============================================================================
        // SCORING FILTER DROPDOWN FUNCTIONS
        // ============================================================================
        
        // Current and pending scoring filter states
        let currentScoringFilters = {
            hasScoring: true,
            noScoring: true
        };
        
        let pendingScoringFilters = {
            hasScoring: true,
            noScoring: true
        };
        
        function toggleMobileScoringDropdown() {
            const button = document.getElementById('mobile-scoring-btn');
            const dropdown = document.getElementById('mobile-scoring-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                // Set direction before showing
                setDropdownDirection(button, dropdown);
                // Change button to expanded state
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                // Change button back to normal state
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function toggleDesktopScoringDropdown() {
            const button = document.getElementById('desktop-scoring-btn');
            const dropdown = document.getElementById('desktop-scoring-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                // Set direction before showing
                setDropdownDirection(button, dropdown);
                // Change button to expanded state
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                // Change button back to normal state
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        
        function syncPendingScoringUI() {
            // Update all checkboxes to match pending state
            document.getElementById('mobile-scoring-has').checked = pendingScoringFilters.hasScoring;
            document.getElementById('mobile-scoring-no').checked = pendingScoringFilters.noScoring;
            document.getElementById('desktop-scoring-has').checked = pendingScoringFilters.hasScoring;
            document.getElementById('desktop-scoring-no').checked = pendingScoringFilters.noScoring;
        }
        
        function syncScoringUI() {
            // Update checkboxes
            document.getElementById('mobile-scoring-has').checked = currentScoringFilters.hasScoring;
            document.getElementById('mobile-scoring-no').checked = currentScoringFilters.noScoring;
            document.getElementById('desktop-scoring-has').checked = currentScoringFilters.hasScoring;
            document.getElementById('desktop-scoring-no').checked = currentScoringFilters.noScoring;
            
            // Update button text
            updateScoringButtonText();
        }
        
        function updateScoringButtonText() {
            // Read the current checkbox states from the UI
            const hasChecked = document.getElementById('mobile-scoring-has').checked;
            const noChecked = document.getElementById('mobile-scoring-no').checked;
            
            let selectionText;
            if (hasChecked && noChecked) {
                selectionText = "All Selected";
            } else if (hasChecked && !noChecked) {
                selectionText = "Completed";
            } else if (!hasChecked && noChecked) {
                selectionText = "Not relevant enough";
            } else {
                selectionText = "None Selected";
            }
            
            // Update mobile button
            const mobileButton = document.getElementById('mobile-scoring-btn');
            if (mobileButton) {
                mobileButton.innerHTML = `<span class="font-bold">Scoring:</span> <span class="font-normal">${selectionText}</span> <span class="text-base">▼</span>`;
            }
            
            // Update desktop button
            const desktopButton = document.getElementById('desktop-scoring-btn');
            if (desktopButton) {
                desktopButton.innerHTML = `<span class="font-bold">Scoring:</span> <span class="font-normal">${selectionText}</span> <span class="text-sm">▼</span>`;
            }
        }
        
        function applyScoringFilter() {
            // Update pending filters one final time
            updatePendingScoringFilters();
            
            // Apply the pending filters as current filters
            currentScoringFilters = { ...pendingScoringFilters };
            
            // Update UI to reflect current state
            syncScoringUI();
            
            // Update URL with current filters
            updateScoringFiltersInURL();
            
            // Close dropdown and apply filters
            closeMobileScoringDropdown();
            closeDesktopScoringDropdown();
            
            // Update disabled state for advanced filters
            updateAdvancedFiltersDisabledState();
            
            // Apply all filters and redisplay
            applyFiltersAndSort();
        }
        
        function updatePendingScoringFilters() {
            // Read current UI state into pending filters
            const mobileScoringHas = document.getElementById('mobile-scoring-has');
            const mobileScoringNo = document.getElementById('mobile-scoring-no');
            
            if (mobileScoringHas && mobileScoringNo) {
                pendingScoringFilters.hasScoring = mobileScoringHas.checked;
                pendingScoringFilters.noScoring = mobileScoringNo.checked;
            }
        }
        
        function resetPendingScoringFilters() {
            pendingScoringFilters = { ...currentScoringFilters };
            syncPendingScoringUI();
            updateScoringButtonText();
        }
        
        function closeMobileScoringDropdown() {
            const dropdown = document.getElementById('mobile-scoring-dropdown');
            const button = document.getElementById('mobile-scoring-btn');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                dropdown.classList.add('hidden');
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
        }
        
        function closeDesktopScoringDropdown() {
            const dropdown = document.getElementById('desktop-scoring-dropdown');
            const button = document.getElementById('desktop-scoring-btn');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                dropdown.classList.add('hidden');
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
        }
        
        function updateScoringFiltersInURL() {
            const params = new URLSearchParams(window.location.search);
            
            // Add scoring filter parameters
            params.set('scoring_has', currentScoringFilters.hasScoring.toString());
            params.set('scoring_no', currentScoringFilters.noScoring.toString());
            
            // Update URL without reload
            const newURL = `${window.location.pathname}?${params.toString()}`;
            window.history.pushState({}, '', newURL);
        }
        
        function updateScoringFiltersFromURL() {
            const params = new URLSearchParams(window.location.search);
            
            // Read scoring filter parameters from URL
            const hasScoring = params.get('scoring_has');
            const noScoring = params.get('scoring_no');
            
            if (hasScoring !== null) {
                currentScoringFilters.hasScoring = hasScoring === 'true';
                pendingScoringFilters.hasScoring = hasScoring === 'true';
            }
            
            if (noScoring !== null) {
                currentScoringFilters.noScoring = noScoring === 'true';
                pendingScoringFilters.noScoring = noScoring === 'true';
            }
            
            // Update UI to match loaded filters
            syncScoringUI();
            
            // Update disabled state for advanced filters
            updateAdvancedFiltersDisabledState();
        }

        // ============================================================================
        // RECOMMENDATION FILTER DROPDOWN FUNCTIONS
        // ============================================================================
        
        // Current and pending recommendation filter states
        let currentRecommendationFilters = {
            mustRead: true,
            shouldRead: true,
            canSkip: true,
            ignore: true
        };
        
        let pendingRecommendationFilters = {
            mustRead: true,
            shouldRead: true,
            canSkip: true,
            ignore: true
        };
        
        function toggleMobileRecommendationDropdown() {
            const button = document.getElementById('mobile-recommendation-btn');
            const dropdown = document.getElementById('mobile-recommendation-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                setDropdownDirection(button, dropdown);
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function toggleDesktopRecommendationDropdown() {
            const button = document.getElementById('desktop-recommendation-btn');
            const dropdown = document.getElementById('desktop-recommendation-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                setDropdownDirection(button, dropdown);
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function syncPendingRecommendationUI() {
            document.getElementById('mobile-recommendation-must').checked = pendingRecommendationFilters.mustRead;
            document.getElementById('mobile-recommendation-should').checked = pendingRecommendationFilters.shouldRead;
            document.getElementById('mobile-recommendation-skip').checked = pendingRecommendationFilters.canSkip;
            document.getElementById('mobile-recommendation-ignore').checked = pendingRecommendationFilters.ignore;
            document.getElementById('desktop-recommendation-must').checked = pendingRecommendationFilters.mustRead;
            document.getElementById('desktop-recommendation-should').checked = pendingRecommendationFilters.shouldRead;
            document.getElementById('desktop-recommendation-skip').checked = pendingRecommendationFilters.canSkip;
            document.getElementById('desktop-recommendation-ignore').checked = pendingRecommendationFilters.ignore;
        }
        
        function syncRecommendationUI() {
            document.getElementById('mobile-recommendation-must').checked = currentRecommendationFilters.mustRead;
            document.getElementById('mobile-recommendation-should').checked = currentRecommendationFilters.shouldRead;
            document.getElementById('mobile-recommendation-skip').checked = currentRecommendationFilters.canSkip;
            document.getElementById('mobile-recommendation-ignore').checked = currentRecommendationFilters.ignore;
            document.getElementById('desktop-recommendation-must').checked = currentRecommendationFilters.mustRead;
            document.getElementById('desktop-recommendation-should').checked = currentRecommendationFilters.shouldRead;
            document.getElementById('desktop-recommendation-skip').checked = currentRecommendationFilters.canSkip;
            document.getElementById('desktop-recommendation-ignore').checked = currentRecommendationFilters.ignore;
            
            updateRecommendationButtonText();
        }
        
        function updateRecommendationButtonText() {
            const mustChecked = document.getElementById('mobile-recommendation-must').checked;
            const shouldChecked = document.getElementById('mobile-recommendation-should').checked;
            const skipChecked = document.getElementById('mobile-recommendation-skip').checked;
            const ignoreChecked = document.getElementById('mobile-recommendation-ignore').checked;
            
            const checkedCount = [mustChecked, shouldChecked, skipChecked, ignoreChecked].filter(Boolean).length;
            
            let selectionText;
            if (checkedCount === 4) {
                selectionText = "All Selected";
            } else if (checkedCount === 0) {
                selectionText = "None Selected";
            } else {
                selectionText = `${checkedCount} Selected`;
            }
            
            const mobileButton = document.getElementById('mobile-recommendation-btn');
            if (mobileButton) {
                mobileButton.innerHTML = `<span class="font-bold">Recommendation:</span> <span class="font-normal">${selectionText}</span> <span class="text-base">▼</span>`;
            }
            
            const desktopButton = document.getElementById('desktop-recommendation-btn');
            if (desktopButton) {
                desktopButton.innerHTML = `<span class="font-bold">Recommendation:</span> <span class="font-normal">${selectionText}</span> <span class="text-sm">▼</span>`;
            }
        }
        
        function applyRecommendationFilter() {
            updatePendingRecommendationFilters();
            currentRecommendationFilters = { ...pendingRecommendationFilters };
            syncRecommendationUI();
            updateRecommendationFiltersInURL();
            closeMobileRecommendationDropdown();
            closeDesktopRecommendationDropdown();
            applyFiltersAndSort();
        }
        
        function updatePendingRecommendationFilters() {
            pendingRecommendationFilters.mustRead = document.getElementById('mobile-recommendation-must').checked;
            pendingRecommendationFilters.shouldRead = document.getElementById('mobile-recommendation-should').checked;
            pendingRecommendationFilters.canSkip = document.getElementById('mobile-recommendation-skip').checked;
            pendingRecommendationFilters.ignore = document.getElementById('mobile-recommendation-ignore').checked;
        }
        
        function resetPendingRecommendationFilters() {
            pendingRecommendationFilters = { ...currentRecommendationFilters };
            syncPendingRecommendationUI();
            updateRecommendationButtonText();
        }
        
        function closeMobileRecommendationDropdown() {
            const dropdown = document.getElementById('mobile-recommendation-dropdown');
            const button = document.getElementById('mobile-recommendation-btn');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                dropdown.classList.add('hidden');
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
        }
        
        function closeDesktopRecommendationDropdown() {
            const dropdown = document.getElementById('desktop-recommendation-dropdown');
            const button = document.getElementById('desktop-recommendation-btn');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                dropdown.classList.add('hidden');
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
        }
        
        function updateRecommendationFiltersInURL() {
            const params = new URLSearchParams(window.location.search);
            params.set('recommendation_must', currentRecommendationFilters.mustRead.toString());
            params.set('recommendation_should', currentRecommendationFilters.shouldRead.toString());
            params.set('recommendation_skip', currentRecommendationFilters.canSkip.toString());
            params.set('recommendation_ignore', currentRecommendationFilters.ignore.toString());
            const newURL = `${window.location.pathname}?${params.toString()}`;
            window.history.pushState({}, '', newURL);
        }
        
        function updateRecommendationFiltersFromURL() {
            const params = new URLSearchParams(window.location.search);
            
            const mustRead = params.get('recommendation_must');
            const shouldRead = params.get('recommendation_should');
            const canSkip = params.get('recommendation_skip');
            const ignore = params.get('recommendation_ignore');
            
            if (mustRead !== null) {
                currentRecommendationFilters.mustRead = mustRead === 'true';
                pendingRecommendationFilters.mustRead = mustRead === 'true';
            }
            if (shouldRead !== null) {
                currentRecommendationFilters.shouldRead = shouldRead === 'true';
                pendingRecommendationFilters.shouldRead = shouldRead === 'true';
            }
            if (canSkip !== null) {
                currentRecommendationFilters.canSkip = canSkip === 'true';
                pendingRecommendationFilters.canSkip = canSkip === 'true';
            }
            if (ignore !== null) {
                currentRecommendationFilters.ignore = ignore === 'true';
                pendingRecommendationFilters.ignore = ignore === 'true';
            }
            
            syncRecommendationUI();
        }

        // ============================================================================
        // NOVELTY FILTER DROPDOWN FUNCTIONS
        // ============================================================================
        
        // Current and pending novelty filter states
        let currentNoveltyFilters = {
            high: true,
            moderate: true,
            low: true,
            none: true
        };
        
        let pendingNoveltyFilters = {
            high: true,
            moderate: true,
            low: true,
            none: true
        };
        
        function toggleMobileNoveltyDropdown() {
            const button = document.getElementById('mobile-novelty-btn');
            const dropdown = document.getElementById('mobile-novelty-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                setDropdownDirection(button, dropdown);
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function toggleDesktopNoveltyDropdown() {
            const button = document.getElementById('desktop-novelty-btn');
            const dropdown = document.getElementById('desktop-novelty-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                setDropdownDirection(button, dropdown);
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function syncPendingNoveltyUI() {
            document.getElementById('mobile-novelty-high').checked = pendingNoveltyFilters.high;
            document.getElementById('mobile-novelty-moderate').checked = pendingNoveltyFilters.moderate;
            document.getElementById('mobile-novelty-low').checked = pendingNoveltyFilters.low;
            document.getElementById('mobile-novelty-none').checked = pendingNoveltyFilters.none;
            document.getElementById('desktop-novelty-high').checked = pendingNoveltyFilters.high;
            document.getElementById('desktop-novelty-moderate').checked = pendingNoveltyFilters.moderate;
            document.getElementById('desktop-novelty-low').checked = pendingNoveltyFilters.low;
            document.getElementById('desktop-novelty-none').checked = pendingNoveltyFilters.none;
        }
        
        function syncNoveltyUI() {
            document.getElementById('mobile-novelty-high').checked = currentNoveltyFilters.high;
            document.getElementById('mobile-novelty-moderate').checked = currentNoveltyFilters.moderate;
            document.getElementById('mobile-novelty-low').checked = currentNoveltyFilters.low;
            document.getElementById('mobile-novelty-none').checked = currentNoveltyFilters.none;
            document.getElementById('desktop-novelty-high').checked = currentNoveltyFilters.high;
            document.getElementById('desktop-novelty-moderate').checked = currentNoveltyFilters.moderate;
            document.getElementById('desktop-novelty-low').checked = currentNoveltyFilters.low;
            document.getElementById('desktop-novelty-none').checked = currentNoveltyFilters.none;
            
            updateNoveltyButtonText();
        }
        
        function updateNoveltyButtonText() {
            const highChecked = document.getElementById('mobile-novelty-high').checked;
            const moderateChecked = document.getElementById('mobile-novelty-moderate').checked;
            const lowChecked = document.getElementById('mobile-novelty-low').checked;
            const noneChecked = document.getElementById('mobile-novelty-none').checked;
            
            const checkedCount = [highChecked, moderateChecked, lowChecked, noneChecked].filter(Boolean).length;
            
            let selectionText;
            if (checkedCount === 4) {
                selectionText = "All Selected";
            } else if (checkedCount === 0) {
                selectionText = "None Selected";
            } else {
                selectionText = `${checkedCount} Selected`;
            }
            
            const mobileButton = document.getElementById('mobile-novelty-btn');
            if (mobileButton) {
                mobileButton.innerHTML = `<span class="font-bold">Novelty:</span> <span class="font-normal">${selectionText}</span> <span class="text-base">▼</span>`;
            }
            
            const desktopButton = document.getElementById('desktop-novelty-btn');
            if (desktopButton) {
                desktopButton.innerHTML = `<span class="font-bold">Novelty:</span> <span class="font-normal">${selectionText}</span> <span class="text-sm">▼</span>`;
            }
        }
        
        function applyNoveltyFilter() {
            updatePendingNoveltyFilters();
            currentNoveltyFilters = { ...pendingNoveltyFilters };
            syncNoveltyUI();
            updateNoveltyFiltersInURL();
            closeMobileNoveltyDropdown();
            closeDesktopNoveltyDropdown();
            applyFiltersAndSort();
        }
        
        function updatePendingNoveltyFilters() {
            pendingNoveltyFilters.high = document.getElementById('mobile-novelty-high').checked;
            pendingNoveltyFilters.moderate = document.getElementById('mobile-novelty-moderate').checked;
            pendingNoveltyFilters.low = document.getElementById('mobile-novelty-low').checked;
            pendingNoveltyFilters.none = document.getElementById('mobile-novelty-none').checked;
        }
        
        function closeMobileNoveltyDropdown() {
            const dropdown = document.getElementById('mobile-novelty-dropdown');
            const button = document.getElementById('mobile-novelty-btn');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                dropdown.classList.add('hidden');
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
        }
        
        function closeDesktopNoveltyDropdown() {
            const dropdown = document.getElementById('desktop-novelty-dropdown');
            const button = document.getElementById('desktop-novelty-btn');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                dropdown.classList.add('hidden');
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
        }
        
        function updateNoveltyFiltersInURL() {
            const params = new URLSearchParams(window.location.search);
            params.set('novelty_high', currentNoveltyFilters.high.toString());
            params.set('novelty_moderate', currentNoveltyFilters.moderate.toString());
            params.set('novelty_low', currentNoveltyFilters.low.toString());
            params.set('novelty_none', currentNoveltyFilters.none.toString());
            const newURL = `${window.location.pathname}?${params.toString()}`;
            window.history.pushState({}, '', newURL);
        }
        
        function updateNoveltyFiltersFromURL() {
            const params = new URLSearchParams(window.location.search);
            
            const high = params.get('novelty_high');
            const moderate = params.get('novelty_moderate');
            const low = params.get('novelty_low');
            const none = params.get('novelty_none');
            
            if (high !== null) {
                currentNoveltyFilters.high = high === 'true';
                pendingNoveltyFilters.high = high === 'true';
            }
            if (moderate !== null) {
                currentNoveltyFilters.moderate = moderate === 'true';
                pendingNoveltyFilters.moderate = moderate === 'true';
            }
            if (low !== null) {
                currentNoveltyFilters.low = low === 'true';
                pendingNoveltyFilters.low = low === 'true';
            }
            if (none !== null) {
                currentNoveltyFilters.none = none === 'true';
                pendingNoveltyFilters.none = none === 'true';
            }
            
            syncNoveltyUI();
        }

        // ============================================================================
        // POTENTIAL IMPACT FILTER DROPDOWN FUNCTIONS
        // ============================================================================
        
        // Current and pending impact filter states
        let currentImpactFilters = {
            high: true,
            moderate: true,
            low: true,
            negligible: true
        };
        
        let pendingImpactFilters = {
            high: true,
            moderate: true,
            low: true,
            negligible: true
        };
        
        function toggleMobileImpactDropdown() {
            const button = document.getElementById('mobile-impact-btn');
            const dropdown = document.getElementById('mobile-impact-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                setDropdownDirection(button, dropdown);
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function toggleDesktopImpactDropdown() {
            const button = document.getElementById('desktop-impact-btn');
            const dropdown = document.getElementById('desktop-impact-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                setDropdownDirection(button, dropdown);
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function syncPendingImpactUI() {
            document.getElementById('mobile-impact-high').checked = pendingImpactFilters.high;
            document.getElementById('mobile-impact-moderate').checked = pendingImpactFilters.moderate;
            document.getElementById('mobile-impact-low').checked = pendingImpactFilters.low;
            document.getElementById('mobile-impact-negligible').checked = pendingImpactFilters.negligible;
            document.getElementById('desktop-impact-high').checked = pendingImpactFilters.high;
            document.getElementById('desktop-impact-moderate').checked = pendingImpactFilters.moderate;
            document.getElementById('desktop-impact-low').checked = pendingImpactFilters.low;
            document.getElementById('desktop-impact-negligible').checked = pendingImpactFilters.negligible;
        }
        
        function syncImpactUI() {
            document.getElementById('mobile-impact-high').checked = currentImpactFilters.high;
            document.getElementById('mobile-impact-moderate').checked = currentImpactFilters.moderate;
            document.getElementById('mobile-impact-low').checked = currentImpactFilters.low;
            document.getElementById('mobile-impact-negligible').checked = currentImpactFilters.negligible;
            document.getElementById('desktop-impact-high').checked = currentImpactFilters.high;
            document.getElementById('desktop-impact-moderate').checked = currentImpactFilters.moderate;
            document.getElementById('desktop-impact-low').checked = currentImpactFilters.low;
            document.getElementById('desktop-impact-negligible').checked = currentImpactFilters.negligible;
            
            updateImpactButtonText();
        }
        
        function updateImpactButtonText() {
            const highChecked = document.getElementById('mobile-impact-high').checked;
            const moderateChecked = document.getElementById('mobile-impact-moderate').checked;
            const lowChecked = document.getElementById('mobile-impact-low').checked;
            const negligibleChecked = document.getElementById('mobile-impact-negligible').checked;
            
            const checkedCount = [highChecked, moderateChecked, lowChecked, negligibleChecked].filter(Boolean).length;
            
            let selectionText;
            if (checkedCount === 4) {
                selectionText = "All Selected";
            } else if (checkedCount === 0) {
                selectionText = "None Selected";
            } else {
                selectionText = `${checkedCount} Selected`;
            }
            
            const mobileButton = document.getElementById('mobile-impact-btn');
            if (mobileButton) {
                mobileButton.innerHTML = `<span class="font-bold">Potential Impact:</span> <span class="font-normal">${selectionText}</span> <span class="text-base">▼</span>`;
            }
            
            const desktopButton = document.getElementById('desktop-impact-btn');
            if (desktopButton) {
                desktopButton.innerHTML = `<span class="font-bold">Potential Impact:</span> <span class="font-normal">${selectionText}</span> <span class="text-sm">▼</span>`;
            }
        }
        
        function applyImpactFilter() {
            updatePendingImpactFilters();
            currentImpactFilters = { ...pendingImpactFilters };
            syncImpactUI();
            updateImpactFiltersInURL();
            closeMobileImpactDropdown();
            closeDesktopImpactDropdown();
            applyFiltersAndSort();
        }
        
        function updatePendingImpactFilters() {
            pendingImpactFilters.high = document.getElementById('mobile-impact-high').checked;
            pendingImpactFilters.moderate = document.getElementById('mobile-impact-moderate').checked;
            pendingImpactFilters.low = document.getElementById('mobile-impact-low').checked;
            pendingImpactFilters.negligible = document.getElementById('mobile-impact-negligible').checked;
        }
        
        function closeMobileImpactDropdown() {
            const dropdown = document.getElementById('mobile-impact-dropdown');
            const button = document.getElementById('mobile-impact-btn');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                dropdown.classList.add('hidden');
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
        }
        
        function closeDesktopImpactDropdown() {
            const dropdown = document.getElementById('desktop-impact-dropdown');
            const button = document.getElementById('desktop-impact-btn');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                dropdown.classList.add('hidden');
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
        }
        
        function updateImpactFiltersInURL() {
            const params = new URLSearchParams(window.location.search);
            params.set('impact_high', currentImpactFilters.high.toString());
            params.set('impact_moderate', currentImpactFilters.moderate.toString());
            params.set('impact_low', currentImpactFilters.low.toString());
            params.set('impact_negligible', currentImpactFilters.negligible.toString());
            const newURL = `${window.location.pathname}?${params.toString()}`;
            window.history.pushState({}, '', newURL);
        }
        
        function updateImpactFiltersFromURL() {
            const params = new URLSearchParams(window.location.search);
            
            const high = params.get('impact_high');
            const moderate = params.get('impact_moderate');
            const low = params.get('impact_low');
            const negligible = params.get('impact_negligible');
            
            if (high !== null) {
                currentImpactFilters.high = high === 'true';
                pendingImpactFilters.high = high === 'true';
            }
            if (moderate !== null) {
                currentImpactFilters.moderate = moderate === 'true';
                pendingImpactFilters.moderate = moderate === 'true';
            }
            if (low !== null) {
                currentImpactFilters.low = low === 'true';
                pendingImpactFilters.low = low === 'true';
            }
            if (negligible !== null) {
                currentImpactFilters.negligible = negligible === 'true';
                pendingImpactFilters.negligible = negligible === 'true';
            }
            
            syncImpactUI();
        }

        // ============================================================================
        // TOPIC FILTER DROPDOWN FUNCTIONS
        // ============================================================================
        
        function toggleMobileTopicDropdown() {
            const button = document.getElementById('mobile-topic-btn');
            const dropdown = document.getElementById('mobile-topic-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                setDropdownDirection(button, dropdown);
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function toggleDesktopTopicDropdown() {
            const button = document.getElementById('desktop-topic-btn');
            const dropdown = document.getElementById('desktop-topic-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                setDropdownDirection(button, dropdown);
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function syncPendingTopicUI() {
            document.getElementById('mobile-topic-rlhf').checked = pendingTopicFilters.rlhf;
            document.getElementById('mobile-topic-weak-supervision').checked = pendingTopicFilters.weakSupervision;
            document.getElementById('mobile-topic-diffusion-reasoning').checked = pendingTopicFilters.diffusionReasoning;
            document.getElementById('mobile-topic-distributed-training').checked = pendingTopicFilters.distributedTraining;
            document.getElementById('mobile-topic-datasets').checked = pendingTopicFilters.datasets;
            document.getElementById('desktop-topic-rlhf').checked = pendingTopicFilters.rlhf;
            document.getElementById('desktop-topic-weak-supervision').checked = pendingTopicFilters.weakSupervision;
            document.getElementById('desktop-topic-diffusion-reasoning').checked = pendingTopicFilters.diffusionReasoning;
            document.getElementById('desktop-topic-distributed-training').checked = pendingTopicFilters.distributedTraining;
            document.getElementById('desktop-topic-datasets').checked = pendingTopicFilters.datasets;
        }
        
        function syncTopicUI() {
            document.getElementById('mobile-topic-rlhf').checked = currentTopicFilters.rlhf;
            document.getElementById('mobile-topic-weak-supervision').checked = currentTopicFilters.weakSupervision;
            document.getElementById('mobile-topic-diffusion-reasoning').checked = currentTopicFilters.diffusionReasoning;
            document.getElementById('mobile-topic-distributed-training').checked = currentTopicFilters.distributedTraining;
            document.getElementById('mobile-topic-datasets').checked = currentTopicFilters.datasets;
            document.getElementById('desktop-topic-rlhf').checked = currentTopicFilters.rlhf;
            document.getElementById('desktop-topic-weak-supervision').checked = currentTopicFilters.weakSupervision;
            document.getElementById('desktop-topic-diffusion-reasoning').checked = currentTopicFilters.diffusionReasoning;
            document.getElementById('desktop-topic-distributed-training').checked = currentTopicFilters.distributedTraining;
            document.getElementById('desktop-topic-datasets').checked = currentTopicFilters.datasets;
            
            updateTopicButtonText();
        }
        
        function updateTopicButtonText() {
            const rlhfChecked = document.getElementById('mobile-topic-rlhf').checked;
            const weakSupervisionChecked = document.getElementById('mobile-topic-weak-supervision').checked;
            const diffusionReasoningChecked = document.getElementById('mobile-topic-diffusion-reasoning').checked;
            const distributedTrainingChecked = document.getElementById('mobile-topic-distributed-training').checked;
            const datasetsChecked = document.getElementById('mobile-topic-datasets').checked;
            
            const checkedCount = [rlhfChecked, weakSupervisionChecked, diffusionReasoningChecked, distributedTrainingChecked, datasetsChecked].filter(Boolean).length;
            
            let selectionText;
            if (checkedCount === 5) {
                selectionText = "All Selected";
            } else if (checkedCount === 0) {
                selectionText = "None Selected";
            } else {
                selectionText = `${checkedCount} Selected`;
            }
            
            const mobileButton = document.getElementById('mobile-topic-btn');
            if (mobileButton) {
                mobileButton.innerHTML = `<span class="font-bold">Topics:</span> <span class="font-normal">${selectionText}</span> <span class="text-base">▼</span>`;
            }
            
            const desktopButton = document.getElementById('desktop-topic-btn');
            if (desktopButton) {
                desktopButton.innerHTML = `<span class="font-bold">Topics:</span> <span class="font-normal">${selectionText}</span> <span class="text-sm">▼</span>`;
            }
        }
        
        function applyTopicFilter() {
            updatePendingTopicFilters();
            currentTopicFilters = { ...pendingTopicFilters };
            syncTopicUI();
            updateTopicFiltersInURL();
            closeMobileTopicDropdown();
            closeDesktopTopicDropdown();
            updateAllPaperModules();
            applyFiltersAndSort();
        }
        
        function updatePendingTopicFilters() {
            pendingTopicFilters.rlhf = document.getElementById('mobile-topic-rlhf').checked;
            pendingTopicFilters.weakSupervision = document.getElementById('mobile-topic-weak-supervision').checked;
            pendingTopicFilters.diffusionReasoning = document.getElementById('mobile-topic-diffusion-reasoning').checked;
            pendingTopicFilters.distributedTraining = document.getElementById('mobile-topic-distributed-training').checked;
            pendingTopicFilters.datasets = document.getElementById('mobile-topic-datasets').checked;
        }
        
        function resetPendingTopicFilters() {
            pendingTopicFilters = { ...currentTopicFilters };
            syncPendingTopicUI();
            updateTopicButtonText();
        }
        
        function closeMobileTopicDropdown() {
            const dropdown = document.getElementById('mobile-topic-dropdown');
            const button = document.getElementById('mobile-topic-btn');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                dropdown.classList.add('hidden');
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
        }
        
        function closeDesktopTopicDropdown() {
            const dropdown = document.getElementById('desktop-topic-dropdown');
            const button = document.getElementById('desktop-topic-btn');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                dropdown.classList.add('hidden');
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
        }
        
        function updateTopicFiltersInURL() {
            const params = new URLSearchParams(window.location.search);
            params.set('topic_rlhf', currentTopicFilters.rlhf.toString());
            params.set('topic_weak_supervision', currentTopicFilters.weakSupervision.toString());
            params.set('topic_diffusion_reasoning', currentTopicFilters.diffusionReasoning.toString());
            params.set('topic_distributed_training', currentTopicFilters.distributedTraining.toString());
            params.set('topic_datasets', currentTopicFilters.datasets.toString());
            const newURL = `${window.location.pathname}?${params.toString()}`;
            window.history.pushState({}, '', newURL);
        }
        
        function updateTopicFiltersFromURL() {
            const params = new URLSearchParams(window.location.search);
            
            const rlhf = params.get('topic_rlhf');
            const weakSupervision = params.get('topic_weak_supervision');
            const diffusionReasoning = params.get('topic_diffusion_reasoning');
            const distributedTraining = params.get('topic_distributed_training');
            const datasets = params.get('topic_datasets');
            
            if (rlhf !== null) {
                currentTopicFilters.rlhf = rlhf === 'true';
                pendingTopicFilters.rlhf = rlhf === 'true';
            }
            if (weakSupervision !== null) {
                currentTopicFilters.weakSupervision = weakSupervision === 'true';
                pendingTopicFilters.weakSupervision = weakSupervision === 'true';
            }
            if (diffusionReasoning !== null) {
                currentTopicFilters.diffusionReasoning = diffusionReasoning === 'true';
                pendingTopicFilters.diffusionReasoning = diffusionReasoning === 'true';
            }
            if (distributedTraining !== null) {
                currentTopicFilters.distributedTraining = distributedTraining === 'true';
                pendingTopicFilters.distributedTraining = distributedTraining === 'true';
            }
            if (datasets !== null) {
                currentTopicFilters.datasets = datasets === 'true';
                pendingTopicFilters.datasets = datasets === 'true';
            }
            
            syncTopicUI();
        }
        
        function passesTopicFilter(paper) {
            // Topic filter doesn't actually filter papers, it only affects module display
            return true;
        }
        
        function updateAllPaperModules() {
            // Update all similarity and relevance modules when topic filters change
            currentPagePapers.forEach(paper => {
                updateSimilarityModuleTopics(paper.id);
                updateRelevanceModuleTopics(paper.id);
            });
        }

        // ============================================================================
        // RELEVANCE FILTER FUNCTIONS  
        // ============================================================================
        
        function toggleMobileRelevanceDropdown() {
            const button = document.getElementById('mobile-relevance-btn');
            const dropdown = document.getElementById('mobile-relevance-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                setDropdownDirection(button, dropdown);
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function toggleDesktopRelevanceDropdown() {
            const button = document.getElementById('desktop-relevance-btn');
            const dropdown = document.getElementById('desktop-relevance-dropdown');
            
            if (dropdown.classList.contains('hidden')) {
                setDropdownDirection(button, dropdown);
                button.classList.remove('bg-neutral-500');
                button.classList.add('bg-neutral-600');
            } else {
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
            
            dropdown.classList.toggle('hidden');
        }
        
        function syncPendingRelevanceUI() {
            document.getElementById('mobile-relevance-highly').checked = pendingRelevanceFilters.highlyRelevant;
            document.getElementById('mobile-relevance-moderately').checked = pendingRelevanceFilters.moderatelyRelevant;
            document.getElementById('mobile-relevance-tangentially').checked = pendingRelevanceFilters.tangentiallyRelevant;
            document.getElementById('mobile-relevance-not').checked = pendingRelevanceFilters.notRelevant;
            document.getElementById('desktop-relevance-highly').checked = pendingRelevanceFilters.highlyRelevant;
            document.getElementById('desktop-relevance-moderately').checked = pendingRelevanceFilters.moderatelyRelevant;
            document.getElementById('desktop-relevance-tangentially').checked = pendingRelevanceFilters.tangentiallyRelevant;
            document.getElementById('desktop-relevance-not').checked = pendingRelevanceFilters.notRelevant;
        }
        
        function syncRelevanceUI() {
            document.getElementById('mobile-relevance-highly').checked = currentRelevanceFilters.highlyRelevant;
            document.getElementById('mobile-relevance-moderately').checked = currentRelevanceFilters.moderatelyRelevant;
            document.getElementById('mobile-relevance-tangentially').checked = currentRelevanceFilters.tangentiallyRelevant;
            document.getElementById('mobile-relevance-not').checked = currentRelevanceFilters.notRelevant;
            document.getElementById('desktop-relevance-highly').checked = currentRelevanceFilters.highlyRelevant;
            document.getElementById('desktop-relevance-moderately').checked = currentRelevanceFilters.moderatelyRelevant;
            document.getElementById('desktop-relevance-tangentially').checked = currentRelevanceFilters.tangentiallyRelevant;
            document.getElementById('desktop-relevance-not').checked = currentRelevanceFilters.notRelevant;
            
            updateRelevanceButtonText();
        }
        
        function updateRelevanceButtonText() {
            // Read the current checkbox states from the UI (like H-Index filter does)
            const highlyRelevantChecked = document.getElementById('mobile-relevance-highly').checked;
            const moderatelyRelevantChecked = document.getElementById('mobile-relevance-moderately').checked;
            const tangentiallyRelevantChecked = document.getElementById('mobile-relevance-tangentially').checked;
            const notRelevantChecked = document.getElementById('mobile-relevance-not').checked;
            
            const selectedOptions = [];
            if (highlyRelevantChecked) selectedOptions.push("Highly Relevant");
            if (moderatelyRelevantChecked) selectedOptions.push("Moderately Relevant");
            if (tangentiallyRelevantChecked) selectedOptions.push("Tangentially Relevant");
            if (notRelevantChecked) selectedOptions.push("Not Relevant");
            
            const selectionText = selectedOptions.length === 4 ? "All Selected" : 
                                selectedOptions.length === 0 ? "None Selected" : 
                                `${selectedOptions.length} Selected`;
            
            const mobileButton = document.getElementById('mobile-relevance-btn');
            if (mobileButton) {
                mobileButton.innerHTML = `<span class="font-bold">Relevance:</span> <span class="font-normal">${selectionText}</span> <span class="text-base">▼</span>`;
            }
            
            const desktopButton = document.getElementById('desktop-relevance-btn');
            if (desktopButton) {
                desktopButton.innerHTML = `<span class="font-bold">Relevance:</span> <span class="font-normal">${selectionText}</span> <span class="text-sm">▼</span>`;
            }
        }
        
        function applyRelevanceFilter() {
            updatePendingRelevanceFilters();
            currentRelevanceFilters = { ...pendingRelevanceFilters };
            syncRelevanceUI();
            updateRelevanceFiltersInURL();
            closeMobileRelevanceDropdown();
            closeDesktopRelevanceDropdown();
            applyFiltersAndSort();
        }
        
        function updatePendingRelevanceFilters() {
            // Get values from mobile (primary source)
            const mobileHighly = document.getElementById('mobile-relevance-highly');
            const mobileModerately = document.getElementById('mobile-relevance-moderately');
            const mobileTangentially = document.getElementById('mobile-relevance-tangentially');
            const mobileNot = document.getElementById('mobile-relevance-not');
            
            // Update pending filters from mobile if available, otherwise from desktop
            pendingRelevanceFilters.highlyRelevant = mobileHighly ? mobileHighly.checked : document.getElementById('desktop-relevance-highly').checked;
            pendingRelevanceFilters.moderatelyRelevant = mobileModerately ? mobileModerately.checked : document.getElementById('desktop-relevance-moderately').checked;
            pendingRelevanceFilters.tangentiallyRelevant = mobileTangentially ? mobileTangentially.checked : document.getElementById('desktop-relevance-tangentially').checked;
            pendingRelevanceFilters.notRelevant = mobileNot ? mobileNot.checked : document.getElementById('desktop-relevance-not').checked;
        }
        
        function resetPendingRelevanceFilters() {
            pendingRelevanceFilters = { ...currentRelevanceFilters };
            syncPendingRelevanceUI();
            updateRelevanceButtonText();
        }
        
        function closeMobileRelevanceDropdown() {
            const dropdown = document.getElementById('mobile-relevance-dropdown');
            const button = document.getElementById('mobile-relevance-btn');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                dropdown.classList.add('hidden');
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
        }
        
        function closeDesktopRelevanceDropdown() {
            const dropdown = document.getElementById('desktop-relevance-dropdown');
            const button = document.getElementById('desktop-relevance-btn');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                dropdown.classList.add('hidden');
                button.classList.remove('bg-neutral-600');
                button.classList.add('bg-neutral-500');
            }
        }
        
        function updateRelevanceFiltersInURL() {
            const params = new URLSearchParams(window.location.search);
            params.set('relevance_highly', currentRelevanceFilters.highlyRelevant.toString());
            params.set('relevance_moderately', currentRelevanceFilters.moderatelyRelevant.toString());
            params.set('relevance_tangentially', currentRelevanceFilters.tangentiallyRelevant.toString());
            params.set('relevance_not', currentRelevanceFilters.notRelevant.toString());
            window.history.replaceState({}, '', `${window.location.pathname}?${params.toString()}`);
        }
        
        function loadRelevanceFiltersFromURL() {
            const highlyRelevant = getUrlParameter('relevance_highly');
            const moderatelyRelevant = getUrlParameter('relevance_moderately');
            const tangentiallyRelevant = getUrlParameter('relevance_tangentially');
            const notRelevant = getUrlParameter('relevance_not');
            
            if (highlyRelevant !== null) {
                currentRelevanceFilters.highlyRelevant = highlyRelevant === 'true';
                pendingRelevanceFilters.highlyRelevant = highlyRelevant === 'true';
            }
            if (moderatelyRelevant !== null) {
                currentRelevanceFilters.moderatelyRelevant = moderatelyRelevant === 'true';
                pendingRelevanceFilters.moderatelyRelevant = moderatelyRelevant === 'true';
            }
            if (tangentiallyRelevant !== null) {
                currentRelevanceFilters.tangentiallyRelevant = tangentiallyRelevant === 'true';
                pendingRelevanceFilters.tangentiallyRelevant = tangentiallyRelevant === 'true';
            }
            if (notRelevant !== null) {
                currentRelevanceFilters.notRelevant = notRelevant === 'true';
                pendingRelevanceFilters.notRelevant = notRelevant === 'true';
            }
            
            syncRelevanceUI();
        }
        
        function passesRelevanceFilter(paper) {
            // Get selected topics
            const selectedTopics = [];
            if (currentTopicFilters.rlhf) selectedTopics.push('rlhf');
            if (currentTopicFilters.weakSupervision) selectedTopics.push('weak_supervision');
            if (currentTopicFilters.diffusionReasoning) selectedTopics.push('diffusion_reasoning');
            if (currentTopicFilters.distributedTraining) selectedTopics.push('distributed_training');
            if (currentTopicFilters.datasets) selectedTopics.push('datasets');
            
            // If no topics selected, skip relevance filtering
            if (selectedTopics.length === 0) return true;
            
            // Get selected relevance levels
            const selectedRelevanceLevels = [];
            if (currentRelevanceFilters.highlyRelevant) selectedRelevanceLevels.push('Highly Relevant');
            if (currentRelevanceFilters.moderatelyRelevant) selectedRelevanceLevels.push('Moderately Relevant');
            if (currentRelevanceFilters.tangentiallyRelevant) selectedRelevanceLevels.push('Tangentially Relevant');
            if (currentRelevanceFilters.notRelevant) selectedRelevanceLevels.push('Not Relevant');
            
            // If no relevance levels selected, show 0 papers
            if (selectedRelevanceLevels.length === 0) return false;
            
            // Check each selected topic
            for (let topic of selectedTopics) {
                const relevanceField = `${topic}_relevance`;
                const paperRelevance = paper[relevanceField];
                
                // Treat "not_validated" same as "Not Relevant"
                const normalizedRelevance = paperRelevance === "not_validated" ? "Not Relevant" : paperRelevance;
                
                // If this topic's relevance matches any selected relevance level, paper passes
                if (selectedRelevanceLevels.includes(normalizedRelevance)) {
                    return true; // At least one topic matches
                }
            }
            
            // No selected topics had matching relevance levels
            return false;
        }

        // ============================================================================
        // FILTERING AND DISPLAY FUNCTIONS
        // ============================================================================
        
        function shouldDisableAdvancedFilters() {
            return !currentScoringFilters.hasScoring && currentScoringFilters.noScoring;
        }
        
        function updateDropdownDisabledState(buttonId, dropdownId, shouldDisable) {
            const button = document.getElementById(buttonId);
            const dropdown = document.getElementById(dropdownId);
            
            if (button && dropdown) {
                if (shouldDisable) {
                    button.classList.add('opacity-50', 'cursor-not-allowed');
                    button.style.pointerEvents = 'none';
                    dropdown.classList.add('hidden'); // Close if open
                } else {
                    button.classList.remove('opacity-50', 'cursor-not-allowed');
                    button.style.pointerEvents = 'auto';
                }
            }
        }
        
        function updateAdvancedFiltersDisabledState() {
            const shouldDisable = shouldDisableAdvancedFilters();
            
            // Update Recommendation
            updateDropdownDisabledState('mobile-recommendation-btn', 'mobile-recommendation-dropdown', shouldDisable);
            updateDropdownDisabledState('desktop-recommendation-btn', 'desktop-recommendation-dropdown', shouldDisable);
            
            // Update Novelty  
            updateDropdownDisabledState('mobile-novelty-btn', 'mobile-novelty-dropdown', shouldDisable);
            updateDropdownDisabledState('desktop-novelty-btn', 'desktop-novelty-dropdown', shouldDisable);
            
            // Update Impact
            updateDropdownDisabledState('mobile-impact-btn', 'mobile-impact-dropdown', shouldDisable);
            updateDropdownDisabledState('desktop-impact-btn', 'desktop-impact-dropdown', shouldDisable);
            
            // Update Relevance
            updateDropdownDisabledState('mobile-relevance-btn', 'mobile-relevance-dropdown', shouldDisable);
            updateDropdownDisabledState('desktop-relevance-btn', 'desktop-relevance-dropdown', shouldDisable);
        }
        
        function applyFiltersAndSort() {
            // Apply H-Index filtering first
            filteredSortedPapers = allPapers.filter(paper => passesHIndexFilter(paper));
            
            // Apply Scoring filtering
            filteredSortedPapers = filteredSortedPapers.filter(paper => passesScoringFilter(paper));
            
            // Apply Recommendation filtering
            filteredSortedPapers = filteredSortedPapers.filter(paper => passesRecommendationFilter(paper));
            
            // Apply Novelty filtering
            filteredSortedPapers = filteredSortedPapers.filter(paper => passesNoveltyFilter(paper));
            
            // Apply Impact filtering
            filteredSortedPapers = filteredSortedPapers.filter(paper => passesImpactFilter(paper));
            
            // Apply Relevance filtering
            filteredSortedPapers = filteredSortedPapers.filter(paper => passesRelevanceFilter(paper));
            
            // Apply Topic filtering (note: this doesn't filter papers, just affects display)
            filteredSortedPapers = filteredSortedPapers.filter(paper => passesTopicFilter(paper));
            
            // Apply current sorting
            sortPapers(currentSort);
            
            // Calculate pagination
            totalPages = Math.ceil(filteredSortedPapers.length / PAPERS_PER_PAGE);
            currentPage = 1;
            
            updatePaperCount();
            updatePaginationUI();
            displayCurrentPage();
        }
        
        function passesHIndexFilter(paper) {
            const { found, notFound, highestMin, highestMax, averageMin, averageMax } = currentHIndexFilters;
            
            // Check H-Index status
            const hasHIndex = paper.h_index_status === 'completed';
            const noHIndex = paper.h_index_status === 'not_fetched';
            
            // If neither found nor not-found is checked, hide all papers
            if (!found && !notFound) return false;
            
            // Check status inclusion
            if (hasHIndex && !found) return false;
            if (noHIndex && !notFound) return false;
            
            // For papers with H-Index data, check ranges (only if "found" is checked)
            if (hasHIndex && found) {
                // Treat null h-index values as 0
                const paperHighest = paper.highest_h_index || 0;
                const paperAverage = paper.average_h_index || 0;
                
                // Check if paper's H-Index values fall within ranges
                if (paperHighest < highestMin || paperHighest > highestMax) return false;
                if (paperAverage < averageMin || paperAverage > averageMax) return false;
            }
            
            return true;
        }
        
        function passesScoringFilter(paper) {
            const { hasScoring, noScoring } = currentScoringFilters;
            
            // Check scoring status
            const hasLLMScoring = paper.llm_score_status === 'completed';
            const noLLMScoring = paper.llm_score_status === 'not_relevant_enough';
            
            // If neither hasScoring nor noScoring is checked, hide all papers
            if (!hasScoring && !noScoring) return false;
            
            // Check status inclusion
            if (hasLLMScoring && !hasScoring) return false;
            if (noLLMScoring && !noScoring) return false;
            
            // Handle other statuses - if paper has a different status, only show if both filters are enabled
            if (!hasLLMScoring && !noLLMScoring) {
                return hasScoring && noScoring;
            }
            
            return true;
        }
        
        function passesRecommendationFilter(paper) {
            const { mustRead, shouldRead, canSkip, ignore } = currentRecommendationFilters;
            
            // If no filters are selected, hide all papers
            if (!mustRead && !shouldRead && !canSkip && !ignore) return false;
            
            // Check recommendation score
            const score = paper.recommendation_score;
            
            if (score === 'Must Read' && !mustRead) return false;
            if (score === 'Should Read' && !shouldRead) return false;
            if (score === 'Can Skip' && !canSkip) return false;
            if (score === 'Ignore' && !ignore) return false;
            
            // If paper has a different/null score, only show if all filters are enabled
            if (!['Must Read', 'Should Read', 'Can Skip', 'Ignore'].includes(score)) {
                return mustRead && shouldRead && canSkip && ignore;
            }
            
            return true;
        }
        
        function passesNoveltyFilter(paper) {
            const { high, moderate, low, none } = currentNoveltyFilters;
            
            // If no filters are selected, hide all papers
            if (!high && !moderate && !low && !none) return false;
            
            // Check novelty score
            const score = paper.novelty_score;
            
            if (score === 'High' && !high) return false;
            if (score === 'Moderate' && !moderate) return false;
            if (score === 'Low' && !low) return false;
            if ((score === null || score === undefined) && !none) return false;
            
            // If paper has a different score, only show if all filters are enabled
            if (score && !['High', 'Moderate', 'Low'].includes(score)) {
                return high && moderate && low && none;
            }
            
            return true;
        }
        
        function passesImpactFilter(paper) {
            const { high, moderate, low, negligible } = currentImpactFilters;
            
            // If no filters are selected, hide all papers
            if (!high && !moderate && !low && !negligible) return false;
            
            // Check impact score
            const score = paper.impact_score;
            
            if (score === 'High' && !high) return false;
            if (score === 'Moderate' && !moderate) return false;
            if (score === 'Low' && !low) return false;
            if (score === 'Negligible' && !negligible) return false;
            
            // If paper has a different/null score, only show if all filters are enabled
            if (!['High', 'Moderate', 'Low', 'Negligible'].includes(score)) {
                return high && moderate && low && negligible;
            }
            
            return true;
        }
        
        function displayCurrentPage() {
            // Check if there are no papers to display
            if (filteredSortedPapers.length === 0) {
                showNoPapersMessage();
                hidePaginationSections();
                return;
            }
            
            const startIndex = (currentPage - 1) * PAPERS_PER_PAGE;
            const endIndex = startIndex + PAPERS_PER_PAGE;
            currentPagePapers = filteredSortedPapers.slice(startIndex, endIndex);
            
            showPaginationSections();
            populatePaperCards(currentPagePapers, startIndex + 1);
            
            // Re-run truncation after new content is displayed
            setTimeout(() => {
                setupAbstractTruncation();
                setupInitialProgressBars();
            }, 50);
        }

        function populatePaperCards(papers, startIndex = 1) {
            const mobileContainer = document.getElementById('mobile-papers');
            const desktopContainer = document.getElementById('desktop-papers');
            
            const papersHTML = papers.map((paper, index) => createPaperCard(paper, startIndex + index)).join('');
            
            if (mobileContainer) {
                mobileContainer.innerHTML = papersHTML;
            }
            if (desktopContainer) {
                desktopContainer.innerHTML = papersHTML;
            }
        }

        function showNoPapersMessage() {
            const mobileContainer = document.getElementById('mobile-papers');
            const desktopContainer = document.getElementById('desktop-papers');
            
            const noPapersHTML = '<div class="flex items-center justify-center min-h-screen"><h2 class="font-heading text-2xl text-neutral-600">No papers to show</h2></div>';
            
            if (mobileContainer) {
                mobileContainer.innerHTML = noPapersHTML;
            }
            if (desktopContainer) {
                desktopContainer.innerHTML = noPapersHTML;
            }
        }

        function hidePaginationSections() {
            const paginationIds = [
                'mobile-prev-btn', 'mobile-next-btn', 'mobile-pagination-numbers',
                'desktop-prev-btn', 'desktop-next-btn', 'desktop-pagination-numbers',
                'mobile-footer-prev-btn', 'mobile-footer-next-btn', 'mobile-footer-pagination-numbers',
                'desktop-footer-prev-btn', 'desktop-footer-next-btn', 'desktop-footer-pagination-numbers'
            ];
            
            paginationIds.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.style.display = 'none';
                }
            });
        }

        function showPaginationSections() {
            const paginationIds = [
                'mobile-prev-btn', 'mobile-next-btn', 'mobile-pagination-numbers',
                'desktop-prev-btn', 'desktop-next-btn', 'desktop-pagination-numbers',
                'mobile-footer-prev-btn', 'mobile-footer-next-btn', 'mobile-footer-pagination-numbers',
                'desktop-footer-prev-btn', 'desktop-footer-next-btn', 'desktop-footer-pagination-numbers'
            ];
            
            paginationIds.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.style.display = '';
                }
            });
        }

        // ============================================================================
        // PAGINATION FUNCTIONS
        // ============================================================================
        
        function goToPage(page) {
            if (page < 1 || page > totalPages) return;
            currentPage = page;
            updatePaginationUI();
            displayCurrentPage();
        }
        
        function updatePaginationUI() {
            // Update all pagination controls
            updatePaginationButtons();
            updatePaginationNumbers();
        }
        
        function updatePaginationButtons() {
            // Previous buttons
            const prevButtons = ['mobile-prev-btn', 'desktop-prev-btn', 'mobile-footer-prev-btn', 'desktop-footer-prev-btn'];
            prevButtons.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) {
                    if (currentPage <= 1) {
                        btn.classList.add('disabled');
                    } else {
                        btn.classList.remove('disabled');
                    }
                }
            });
            
            // Next buttons
            const nextButtons = ['mobile-next-btn', 'desktop-next-btn', 'mobile-footer-next-btn', 'desktop-footer-next-btn'];
            nextButtons.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) {
                    if (currentPage >= totalPages) {
                        btn.classList.add('disabled');
                    } else {
                        btn.classList.remove('disabled');
                    }
                }
            });
        }
        
        function updatePaginationNumbers() {
            const containers = [
                'mobile-pagination-numbers',
                'desktop-pagination-numbers', 
                'mobile-footer-pagination-numbers',
                'desktop-footer-pagination-numbers'
            ];
            
            containers.forEach(containerId => {
                const container = document.getElementById(containerId);
                if (container) {
                    container.innerHTML = generatePaginationNumbers();
                }
            });
        }
        
        function generatePaginationNumbers() {
            if (totalPages <= 1) return '';
            
            let html = '';
            const maxVisiblePages = 5;
            let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
            let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);
            
            // Adjust if we're near the end
            if (endPage - startPage + 1 < maxVisiblePages) {
                startPage = Math.max(1, endPage - maxVisiblePages + 1);
            }
            
            for (let i = startPage; i <= endPage; i++) {
                const isActive = i === currentPage;
                const activeClass = isActive ? 'bg-neutral-500 text-neutral-10' : 'bg-transparent text-neutral-70 hover:bg-neutral-300';
                html += `<button class="pagination-square w-8 h-8 ${activeClass} flex items-center justify-center cursor-pointer font-heading font-bold text-sm" onclick="goToPage(${i})">${i}</button>`;
            }
            
            return html;
        }

        // ============================================================================
        // HELPER FUNCTIONS FOR STYLING
        // ============================================================================

        function getScoreColor(scoreType, value) {
            const colorMap = {
                recommendation: {
                    'Must Read': 'bg-status-green',      
                    'Should Read': 'bg-status-blue',   
                    'Can Skip': 'bg-status-orange',       
                    'Ignore': 'bg-status-red'          
                },
                novelty: {
                    'High': 'bg-status-green',           
                    'Moderate': 'bg-status-blue',      
                    'Low': 'bg-status-orange',            
                    'None': 'bg-status-red'            
                },
                impact: {
                    'High': 'bg-status-green',           
                    'Moderate': 'bg-status-blue',      
                    'Low': 'bg-status-orange',            
                    'Negligible': 'bg-status-red'      
                }
            };
            
            return colorMap[scoreType][value] || 'bg-neutral-500';  // fallback to neutral-500
        }

        function getRelevanceColor(relevanceValue) {
            const colorMap = {
                'Highly Relevant': 'bg-status-green',      
                'Moderately Relevant': 'bg-status-blue', 
                'Tangentially Relevant': 'bg-status-orange', 
                'Not Relevant': 'bg-status-red',         
                'not_validated': 'bg-status-red'         
            };
            
            return colorMap[relevanceValue] || 'bg-status-red';  // fallback to status-red
        }

        function getRelevanceDisplayText(relevanceValue) {
            if (relevanceValue === 'not_validated') {
                return 'Not Relevant';
            }
            return relevanceValue;
        }

        function getJustificationText(justificationValue) {
            if (justificationValue === 'below_threshold') {
                return "Topic similarity score below 0.4, hence default to 'Not Relevant'.";
            }
            return justificationValue;
        }

        // ============================================================================
        // KATEX RENDERING FUNCTIONS
        // ============================================================================

        function renderKatexInElement(element) {
            if (typeof renderMathInElement !== 'undefined' && element) {
                renderMathInElement(element, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false},
                        {left: '\\(', right: '\\)', display: false},
                        {left: '\\[', right: '\\]', display: true},
                    ],
                    throwOnError: false,
                    trust: true
                });
            }
        }

        // ============================================================================
        // TOPIC VISIBILITY HELPER FUNCTIONS
        // ============================================================================
        
        function getTopicKeyMapping() {
            return {
                'rlhf': 'rlhf',
                'weakSupervision': 'weak_supervision', 
                'diffusionReasoning': 'diffusion_reasoning',
                'distributedTraining': 'distributed_training',
                'datasets': 'datasets'
            };
        }
        
        function getTopicDisplayNames() {
            return {
                'rlhf': 'RLHF',
                'weakSupervision': 'Weak Supervision',
                'diffusionReasoning': 'Diffusion Reasoning', 
                'distributedTraining': 'Distributed Training',
                'datasets': 'Datasets'
            };
        }
        
        function getHiddenTopicsCount() {
            const filters = currentTopicFilters;
            return Object.values(filters).filter(visible => !visible).length;
        }
        
        function getVisibleTopics() {
            const filters = currentTopicFilters;
            return Object.keys(filters).filter(topic => filters[topic]);
        }
        
        function getHiddenTopics() {
            const filters = currentTopicFilters;
            return Object.keys(filters).filter(topic => !filters[topic]);
        }
        
        function generateSimilarityTopicRows(paper) {
            const topicMapping = getTopicKeyMapping();
            const displayNames = getTopicDisplayNames();
            const visibleTopics = getVisibleTopics();
            
            let html = '';
            
            // Add visible topic rows
            visibleTopics.forEach(topic => {
                const dataKey = topicMapping[topic];
                const displayName = displayNames[topic];
                const score = paper[`${dataKey}_score`];
                
                html += `
                    <!-- ${displayName} Score Row -->
                    <div class="flex flex-col topic-row visible-topic" data-topic="${topic}">
                        <div class="text-left">
                            <span class="text-neutral-70 font-heading font-bold text-lg">${displayName}:</span>
                        </div>
                        <div class="bg-neutral-200 relative flex items-center justify-end">
                            <div class="similarity-progress-bar ${dataKey.replace('_', '-')}-progress-bar bg-bar-raw absolute inset-0 z-0" 
                                 data-paper-id="${paper.id}" 
                                 data-topic="${dataKey}">
                            </div>
                            <span class="text-neutral-70 font-heading font-bold text-md py-tag-y px-tag-x relative z-10 ${dataKey.replace('_', '-')}-similarity-score">
                                ${score.toFixed(3)}
                            </span>
                        </div>
                    </div>
                `;
            });
            
            return html;
        }
        
        function generateRelevanceTopicRows(paper) {
            const topicMapping = getTopicKeyMapping();
            const displayNames = getTopicDisplayNames();
            const visibleTopics = getVisibleTopics();
            
            let html = '';
            
            // Add visible topic rows
            visibleTopics.forEach(topic => {
                const dataKey = topicMapping[topic];
                const displayName = displayNames[topic];
                const relevance = paper[`${dataKey}_relevance`];
                
                html += `
                    <!-- ${displayName} Relevance Row -->
                    <div class="flex flex-col topic-row visible-topic" data-topic="${topic}">
                        <div class="text-left">
                            <span class="text-neutral-70 font-heading font-bold text-lg">${displayName}:</span>
                        </div>
                        <div class="w-full text-center py-tag-y font-heading font-bold text-md text-neutral-10 ${getRelevanceColor(relevance)}">
                            ${getRelevanceDisplayText(relevance)}
                        </div>
                    </div>
                `;
            });
            
            return html;
        }
        
        function generateRelevanceJustificationContent(paper, showingHidden = false) {
            const topicMapping = getTopicKeyMapping();
            const displayNames = getTopicDisplayNames();
            const visibleTopics = getVisibleTopics();
            
            let html = '';
            
            // Add justification for visible topics only unless showing hidden topics
            const topicsToShow = showingHidden ? Object.keys(displayNames) : visibleTopics;
            
            topicsToShow.forEach(topic => {
                const dataKey = topicMapping[topic];
                const displayName = displayNames[topic];
                const justification = paper[`${dataKey}_justification`];
                
                html += `
                    <div class="justification-topic-section visible-justification" data-topic="${topic}">
                        <div class="font-heading font-bold">${displayName}:</div>
                        <div>${getJustificationText(justification)}</div>
                    </div>
                `;
            });
            
            return html;
        }
        
        function toggleSimilarityHiddenTopics(paperId) {
            // Find the similarity module specifically
            const containers = document.querySelectorAll(`[data-paper-id="${paperId}"][data-show-hidden-topics]`);
            let container = null;
            
            // Find the similarity container (the one that contains similarity-scores-container)
            // and ensure it's in the currently visible layout (mobile or desktop)
            containers.forEach(cont => {
                if (cont.querySelector('.similarity-scores-container')) {
                    // Check if this container is in a visible layout
                    const mobileLayout = cont.closest('#mobile-main-container');
                    const desktopLayout = cont.closest('.tablet\\:block');
                    
                    if (mobileLayout && getComputedStyle(mobileLayout).display !== 'none') {
                        container = cont;
                    } else if (desktopLayout && getComputedStyle(desktopLayout).display !== 'none') {
                        container = cont;
                    }
                }
            });
            
            if (!container) return;
            
            const isShowingHidden = container.getAttribute('data-show-hidden-topics') === 'true';
            const button = container.querySelector('.show-other-topics-container button');
            const hiddenTopicsContainer = container.querySelector('.hidden-topics-container');
            
            if (!isShowingHidden) {
                // Show hidden topics
                container.setAttribute('data-show-hidden-topics', 'true');
                button.innerHTML = 'Hide Other Topics <span class="text-xs">▲</span>';
                button.className = 'bg-neutral-700 text-neutral-10 font-heading font-bold text-md py-tag-y mt-md w-full text-center hover:bg-neutral-600';
                
                // Show and populate the hidden topics container
                hiddenTopicsContainer.style.display = 'block';
                addHiddenSimilarityTopics(paperId, hiddenTopicsContainer);
            } else {
                // Hide other topics  
                container.setAttribute('data-show-hidden-topics', 'false');
                button.innerHTML = 'Show Other Topics <span class="text-xs">▼</span>';
                button.className = 'bg-neutral-500 text-neutral-10 font-heading font-bold text-md py-tag-y mt-md w-full text-center hover:bg-neutral-600';
                
                // Hide and clear the hidden topics container
                hiddenTopicsContainer.style.display = 'none';
                hiddenTopicsContainer.innerHTML = '';
            }
            
            // Recalculate normalized scores if in normalized mode
            if (container.getAttribute('data-normalized') === 'true') {
                updateNormalizedScores(paperId);
            }
        }
        
        function toggleRelevanceHiddenTopics(paperId) {
            // Find the relevance module specifically (not similarity module)
            const containers = document.querySelectorAll(`[data-paper-id="${paperId}"][data-show-hidden-topics]`);
            let container = null;
            
            // Find the relevance container (the one that contains relevance-scores-container)
            // and ensure it's in the currently visible layout (mobile or desktop)
            containers.forEach(cont => {
                if (cont.querySelector('.relevance-scores-container')) {
                    // Check if this container is in a visible layout
                    const mobileLayout = cont.closest('#mobile-main-container');
                    const desktopLayout = cont.closest('.tablet\\:block');
                    
                    if (mobileLayout && getComputedStyle(mobileLayout).display !== 'none') {
                        container = cont;
                    } else if (desktopLayout && getComputedStyle(desktopLayout).display !== 'none') {
                        container = cont;
                    }
                }
            });
            
            if (!container) return;
            
            const isShowingHidden = container.getAttribute('data-show-hidden-topics') === 'true';
            const button = container.querySelector('.show-other-topics-container button');
            const hiddenTopicsContainer = container.querySelector('.hidden-topics-container');
            
            if (!isShowingHidden) {
                // Show hidden topics
                container.setAttribute('data-show-hidden-topics', 'true');
                button.innerHTML = 'Hide Other Topics <span class="text-xs">▲</span>';
                button.className = 'bg-neutral-700 text-neutral-10 font-heading font-bold text-md py-tag-y mt-md w-full text-center hover:bg-neutral-600';
                
                // Show and populate the hidden topics container
                hiddenTopicsContainer.style.display = 'block';
                addHiddenRelevanceTopics(paperId, hiddenTopicsContainer);
            } else {
                // Hide other topics
                container.setAttribute('data-show-hidden-topics', 'false');
                button.innerHTML = 'Show Other Topics <span class="text-xs">▼</span>';
                button.className = 'bg-neutral-500 text-neutral-10 font-heading font-bold text-md py-tag-y mt-md w-full text-center hover:bg-neutral-600';
                
                // Hide and clear the hidden topics container
                hiddenTopicsContainer.style.display = 'none';
                hiddenTopicsContainer.innerHTML = '';
            }
            
            // Update justification content based on new state
            const justificationContainer = container.querySelector('.relevance-justification-section .justification-text');
            if (justificationContainer) {
                const paper = currentPagePapers.find(p => p.id === paperId);
                if (paper) {
                    const newShowingHidden = container.getAttribute('data-show-hidden-topics') === 'true';
                    justificationContainer.innerHTML = generateRelevanceJustificationContent(paper, newShowingHidden);
                }
            }
            
            // Update justification if it's currently visible
            updateRelevanceJustificationVisibility(paperId);
        }
        
        function addHiddenSimilarityTopics(paperId, container) {
            const paper = currentPagePapers.find(p => p.id === paperId);
            if (!paper) return;
            
            const topicMapping = getTopicKeyMapping();
            const displayNames = getTopicDisplayNames();
            const hiddenTopics = getHiddenTopics();
            
            // Check if the parent container is in normalized mode
            const parentContainer = container.closest('[data-normalized]');
            const isNormalized = parentContainer && parentContainer.getAttribute('data-normalized') === 'true';
            const barColorClass = isNormalized ? 'bg-bar-normalized' : 'bg-bar-raw';
            
            hiddenTopics.forEach(topic => {
                const dataKey = topicMapping[topic];
                const displayName = displayNames[topic];
                const score = paper[`${dataKey}_score`];
                
                const rowHtml = `
                    <div class="flex flex-col topic-row hidden-topic" data-topic="${topic}">
                        <div class="text-left">
                            <span class="text-neutral-70 font-heading font-bold text-lg">${displayName}:</span>
                        </div>
                        <div class="bg-neutral-200 relative flex items-center justify-end">
                            <div class="similarity-progress-bar ${dataKey.replace('_', '-')}-progress-bar ${barColorClass} absolute inset-0 z-0" 
                                 data-paper-id="${paperId}" 
                                 data-topic="${dataKey}">
                            </div>
                            <span class="text-neutral-70 font-heading font-bold text-md py-tag-y px-tag-x relative z-10 ${dataKey.replace('_', '-')}-similarity-score">
                                ${score.toFixed(3)}
                            </span>
                        </div>
                    </div>
                `;
                
                container.insertAdjacentHTML('beforeend', rowHtml);
            });
            
            // Update progress bars for newly added rows with correct values and colors
            setupProgressBarsForPaper(paper);
            
            // If in normalized mode, update all scores including the newly added ones
            if (isNormalized) {
                updateNormalizedScores(paperId);
            }
        }
        
        function addHiddenRelevanceTopics(paperId, container) {
            const paper = currentPagePapers.find(p => p.id === paperId);
            if (!paper) return;
            
            const topicMapping = getTopicKeyMapping();
            const displayNames = getTopicDisplayNames();
            const hiddenTopics = getHiddenTopics();
            
            hiddenTopics.forEach(topic => {
                const dataKey = topicMapping[topic];
                const displayName = displayNames[topic];
                const relevance = paper[`${dataKey}_relevance`];
                
                const rowHtml = `
                    <div class="flex flex-col topic-row hidden-topic" data-topic="${topic}">
                        <div class="text-left">
                            <span class="text-neutral-70 font-heading font-bold text-lg">${displayName}:</span>
                        </div>
                        <div class="w-full text-center py-tag-y font-heading font-bold text-md text-neutral-10 ${getRelevanceColor(relevance)}">
                            ${getRelevanceDisplayText(relevance)}
                        </div>
                    </div>
                `;
                
                container.insertAdjacentHTML('beforeend', rowHtml);
            });
        }
        
        function removeHiddenTopicRows(container) {
            const hiddenRows = container.querySelectorAll('.hidden-topic');
            hiddenRows.forEach(row => row.remove());
        }
        
        function updateSimilarityModuleTopics(paperId) {
            // Find the similarity module specifically
            const containers = document.querySelectorAll(`[data-paper-id="${paperId}"][data-normalized]`);
            let container = null;
            
            // Find the similarity container in the currently visible layout
            containers.forEach(cont => {
                if (cont.querySelector('.similarity-scores-container')) {
                    // Check if this container is in a visible layout
                    const mobileLayout = cont.closest('#mobile-main-container');
                    const desktopLayout = cont.closest('.tablet\\:block');
                    
                    if (mobileLayout && getComputedStyle(mobileLayout).display !== 'none') {
                        container = cont;
                    } else if (desktopLayout && getComputedStyle(desktopLayout).display !== 'none') {
                        container = cont;
                    }
                }
            });
            
            if (!container) return;
            
            const scoresContainer = container.querySelector('.similarity-scores-container');
            const showOtherButton = container.querySelector('.show-other-topics-container');
            
            // Remove all existing topic rows
            scoresContainer.innerHTML = '';
            
            // Regenerate visible topic rows
            const paper = currentPagePapers.find(p => p.id === paperId);
            if (paper) {
                scoresContainer.innerHTML = generateSimilarityTopicRows(paper);
                setupProgressBarsForPaper(paper);
                
                // Update normalized scores if needed
                if (container.getAttribute('data-normalized') === 'true') {
                    updateNormalizedScores(paperId);
                }
            }
            
            // Show/hide the "Show Other Topics" button
            if (getHiddenTopicsCount() > 0) {
                if (showOtherButton) {
                    showOtherButton.style.display = 'block';
                }
            } else {
                if (showOtherButton) {
                    showOtherButton.style.display = 'none';
                }
            }
            
            // Reset the hidden topics state
            container.setAttribute('data-show-hidden-topics', 'false');
            
            // Reset button text if it exists
            const button = showOtherButton?.querySelector('button');
            if (button) {
                button.innerHTML = 'Show Other Topics <span class="text-xs">▼</span>';
            }
        }
        
        function updateRelevanceModuleTopics(paperId) {
            // Find all relevance containers for this paper
            const containers = document.querySelectorAll(`[data-paper-id="${paperId}"][data-show-hidden-topics]`);
            
            containers.forEach(container => {
                const scoresContainer = container.querySelector('.relevance-scores-container');
                if (!scoresContainer) return; // Skip if this is not a relevance container
                
                const showOtherButton = container.querySelector('.show-other-topics-container');
                const justificationContainer = container.querySelector('.relevance-justification-section .justification-text');
                
                // Remove all existing topic rows
                scoresContainer.innerHTML = '';
                
                // Regenerate visible topic rows
                const paper = currentPagePapers.find(p => p.id === paperId);
                if (paper) {
                    scoresContainer.innerHTML = generateRelevanceTopicRows(paper);
                    
                    // Update justification content based on current visibility state
                    if (justificationContainer) {
                        const isShowingHidden = container.getAttribute('data-show-hidden-topics') === 'true';
                        justificationContainer.innerHTML = generateRelevanceJustificationContent(paper, isShowingHidden);
                    }
                }
                
                // Show/hide the "Show Other Topics" button
                if (getHiddenTopicsCount() > 0) {
                    if (showOtherButton) {
                        showOtherButton.style.display = 'block';
                    }
                } else {
                    if (showOtherButton) {
                        showOtherButton.style.display = 'none';
                    }
                }
                
                // Reset the hidden topics state
                container.setAttribute('data-show-hidden-topics', 'false');
                
                // Reset button text if it exists
                const button = showOtherButton?.querySelector('button');
                if (button) {
                    button.innerHTML = 'Show Other Topics <span class="text-xs">▼</span>';
                }
            });
        }
        
        function updateRelevanceJustificationVisibility(paperId) {
            // Find the justification container in the currently visible layout
            const containers = document.querySelectorAll(`.relevance-justification-section[data-paper-id="${paperId}"]`);
            let container = null;
            
            containers.forEach(cont => {
                // Check if this container is in a visible layout
                const mobileLayout = cont.closest('#mobile-main-container');
                const desktopLayout = cont.closest('.tablet\\:block');
                
                if (mobileLayout && getComputedStyle(mobileLayout).display !== 'none') {
                    container = cont;
                } else if (desktopLayout && getComputedStyle(desktopLayout).display !== 'none') {
                    container = cont;
                }
            });
            
            if (!container) return;
            
            const justificationDiv = container.querySelector('.justification-text');
            const isVisible = !justificationDiv.classList.contains('hidden');
            
            if (isVisible) {
                const paper = currentPagePapers.find(p => p.id === paperId);
                const relevanceContainer = container.closest('[data-show-hidden-topics]');
                const isShowingHidden = relevanceContainer && relevanceContainer.getAttribute('data-show-hidden-topics') === 'true';
                
                if (paper) {
                    if (isShowingHidden) {
                        // Show all justifications
                        justificationDiv.innerHTML = generateFullRelevanceJustificationContent(paper);
                    } else {
                        // Show only visible justifications
                        justificationDiv.innerHTML = generateRelevanceJustificationContent(paper);
                    }
                }
            }
        }
        
        function generateFullRelevanceJustificationContent(paper) {
            const allTopics = ['rlhf', 'weakSupervision', 'diffusionReasoning', 'distributedTraining', 'datasets'];
            const topicMapping = getTopicKeyMapping();
            const displayNames = getTopicDisplayNames();
            
            let html = '';
            
            allTopics.forEach(topic => {
                const dataKey = topicMapping[topic];
                const displayName = displayNames[topic];
                const justification = paper[`${dataKey}_justification`];
                const isVisible = currentTopicFilters[topic];
                
                html += `
                    <div class="justification-topic-section ${isVisible ? 'visible-justification' : 'hidden-justification'}" data-topic="${topic}">
                        <div class="font-heading font-bold">${displayName}:</div>
                        <div>${getJustificationText(justification)}</div>
                    </div>
                `;
            });
            
            return html;
        }
        
        function setupProgressBarsForPaper(paper) {
            const topics = ['rlhf', 'weak_supervision', 'diffusion_reasoning', 'distributed_training', 'datasets'];
            
            topics.forEach(topic => {
                const progressBars = document.querySelectorAll(
                    `.similarity-progress-bar[data-paper-id="${paper.id}"][data-topic="${topic}"]`
                );
                
                progressBars.forEach(progressBar => {
                    const score = paper[`${topic}_score`];
                    const percentage = (score * 100);
                    progressBar.style.width = `${percentage}%`;
                });
            });
        }
        
        function updateNormalizedScores(paperId) {
            // Find the normalized similarity container in the currently visible layout
            const containers = document.querySelectorAll(`[data-paper-id="${paperId}"][data-normalized="true"]`);
            let container = null;
            
            containers.forEach(cont => {
                // Check if this container is in a visible layout
                const mobileLayout = cont.closest('#mobile-main-container');
                const desktopLayout = cont.closest('.tablet\\:block');
                
                if (mobileLayout && getComputedStyle(mobileLayout).display !== 'none') {
                    container = cont;
                } else if (desktopLayout && getComputedStyle(desktopLayout).display !== 'none') {
                    container = cont;
                }
            });
            
            if (!container) return;
            
            const paper = currentPagePapers.find(p => p.id === paperId);
            if (!paper) return;
            
            const isShowingHidden = container.getAttribute('data-show-hidden-topics') === 'true';
            const topicsToCalculate = isShowingHidden ? 
                ['rlhf', 'weakSupervision', 'diffusionReasoning', 'distributedTraining', 'datasets'] :
                getVisibleTopics();
                
            const topicMapping = getTopicKeyMapping();
            
            // Calculate total score for normalization
            const totalScore = topicsToCalculate.reduce((sum, topic) => {
                const dataKey = topicMapping[topic];
                return sum + paper[`${dataKey}_score`];
            }, 0);
            
            // Update each visible topic
            topicsToCalculate.forEach(topic => {
                const dataKey = topicMapping[topic];
                const rawScore = paper[`${dataKey}_score`];
                const normalizedScore = (rawScore / totalScore) * 100;
                
                // Update progress bar
                const progressBar = container.querySelector(`.${dataKey.replace('_', '-')}-progress-bar`);
                if (progressBar) {
                    progressBar.style.width = `${normalizedScore}%`;
                }
                
                // Update score text
                const scoreElement = container.querySelector(`.${dataKey.replace('_', '-')}-similarity-score`);
                if (scoreElement) {
                    const sigFigScore = normalizedScore.toPrecision(3);
                    scoreElement.textContent = `${sigFigScore}%`;
                }
            });
        }

        // ============================================================================
        // PAPER CARD CREATION FUNCTIONS
        // ============================================================================
        function createPaperCard(paper, paperNumber) {
            const cardId = `paper-${paperNumber}`;
            
            return `
                <article class="bg-neutral-200" role="article" aria-labelledby="${cardId}">
                    <!-- Title Section -->
                    <div class="p-md">
                        <h2 id="${cardId}" class="text-neutral-70 font-heading font-bold text-2xl">
                            <span class="mr-sm">${paperNumber}.</span><a href="${paper.pdf_url}" 
                               class="paper-title-link" 
                               target="_blank" 
                               rel="noopener noreferrer"
                               aria-label="View paper PDF">${paper.title}</a>
                        </h2>
                    </div>
                    
                    <!-- Paper Info Section -->
                    <div class="grid grid-cols-1 gap-lg pb-xl px-xl">
                        <!-- Row 1: Metadata Module -->
                        <div class="flex flex-col gap-xs">
                            <!-- First row: arXiv ID and Publication Date -->
                            <div class="flex gap-xs">
                                <span class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y">
                                    arXiv ID: <a href="${paper.arxiv_url}" target="_blank" rel="noopener noreferrer" class="text-neutral-10 underline hover:no-underline">${paper.id}</a>
                                </span>
                                <span class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y">
                                    Published: ${formatPublicationDate(paper.published_date)}
                                </span>
                            </div>
                            
                            <!-- Second row: Authors -->
                            <div>
                                <span class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y metadata-tag">
                                    Authors: ${paper.h_index_status === 'completed' && paper.author_h_indexes && paper.author_h_indexes.length > 0 
                                        ? paper.author_h_indexes.map(author => 
                                            author.profile_url && author.profile_url !== null && author.profile_url !== '' 
                                                ? `<a href="${author.profile_url}" target="_blank" rel="noopener noreferrer" class="text-neutral-10 underline hover:no-underline">${author.name}</a>`
                                                : author.name
                                        ).join(', ')
                                        : paper.authors.join(', ')
                                    }
                                </span>
                            </div>
                            
                            <!-- Third row: Categories -->
                            <div>
                                <span class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y metadata-tag">
                                    Categories: ${paper.categories.join(', ')}
                                </span>
                            </div>
                        </div>
                        
                        <!-- Row 2: AI Generated Summary Module -->
                        ${paper.summary && paper.summary.trim() ? `
                        <div class="bg-neutral-300 p-lg">
                            <div class="flex flex-col gap-xs">
                                <h3 class="text-neutral-70 font-heading font-bold text-lg">AI-generated summary</h3>
                                <p class="text-neutral-70 font-body text-md">${paper.summary}</p>
                            </div>
                        </div>
                        ` : ''}
                        
                        <!-- Row 3: Abstract Module -->
                        <div class="bg-neutral-300 p-lg">
                            <div class="flex flex-col gap-xs">
                                <h3 class="text-neutral-70 font-heading font-bold text-lg">Abstract</h3>
                                <div class="abstract-container" data-paper-id="${paper.id}">
                                    <p class="abstract-text text-neutral-70 font-body text-md" 
                                       style="line-height: calc(1.5em);">${paper.abstract}</p>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Row 4: Score Row Section -->
                        ${paper.llm_score_status !== 'not_relevant_enough' ? `
                        <div class="flex flex-col tablet:flex-row gap-lg items-start">
                            <!-- Recommendation Score Module -->
                            <div class="bg-neutral-300 p-lg flex-1 w-full">
                                <div class="flex flex-col gap-xs">
                                    <!-- Score Section -->
                                    <div class="flex">
                                        <span class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y text-center">
                                            Recommendation:
                                        </span>
                                        <span class="text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y text-center ${getScoreColor('recommendation', paper.recommendation_score)}">
                                            ${paper.recommendation_score}
                                        </span>
                                    </div>
                                    
                                    <!-- Justification Section -->
                                    <div class="w-full recommendation-justification-section" data-paper-id="${paper.id}">
                                        <button class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y w-full text-left cursor-pointer border-none transition-opacity duration-200" 
                                                onclick="toggleRecommendationJustification('${paper.id}')">
                                            Show Justification <span class="text-xs">▲</span>
                                        </button>
                                        <div class="justification-text hidden text-neutral-20 font-body text-md px-tag-x py-tag-y bg-neutral-500 transition-all duration-300 ease-in-out">
                                            ${paper.recommendation_justification}
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Novelty Score Module -->
                            <div class="bg-neutral-300 p-lg flex-1 w-full">
                                <div class="flex flex-col gap-xs">
                                    <!-- Score Section -->
                                    <div class="flex">
                                        <span class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y text-center">
                                            Novelty:
                                        </span>
                                        <span class="text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y text-center ${getScoreColor('novelty', paper.novelty_score)}">
                                            ${paper.novelty_score}
                                        </span>
                                    </div>
                                    
                                    <!-- Justification Section -->
                                    <div class="w-full novelty-justification-section" data-paper-id="${paper.id}">
                                        <button class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y w-full text-left cursor-pointer border-none transition-opacity duration-200" 
                                                onclick="toggleNoveltyJustification('${paper.id}')">
                                            Show Justification <span class="text-xs">▲</span>
                                        </button>
                                        <div class="justification-text hidden text-neutral-20 font-body text-md px-tag-x py-tag-y bg-neutral-500 transition-all duration-300 ease-in-out">
                                            ${paper.novelty_justification}
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Potential Impact Score Module -->
                            <div class="bg-neutral-300 p-lg flex-1 w-full">
                                <div class="flex flex-col gap-xs">
                                    <!-- Score Section -->
                                    <div class="flex">
                                        <span class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y text-center">
                                            Potential Impact:
                                        </span>
                                        <span class="text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y text-center ${getScoreColor('impact', paper.impact_score)}">
                                            ${paper.impact_score}
                                        </span>
                                    </div>
                                    
                                    <!-- Justification Section -->
                                    <div class="w-full impact-justification-section" data-paper-id="${paper.id}">
                                        <button class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y w-full text-left cursor-pointer border-none transition-opacity duration-200" 
                                                onclick="toggleImpactJustification('${paper.id}')">
                                            Show Justification <span class="text-xs">▲</span>
                                        </button>
                                        <div class="justification-text hidden text-neutral-20 font-body text-md px-tag-x py-tag-y bg-neutral-500 transition-all duration-300 ease-in-out">
                                            ${paper.impact_justification}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        ` : ''}
                        
                        <!-- Row 5: Similarity, Relevance, H-index Section -->
                        <div class="flex flex-col tablet:flex-row gap-lg items-start">
                            <!-- Similarity Scores Module -->
                            <div class="bg-neutral-300 p-lg flex-1 w-full" data-paper-id="${paper.id}" data-normalized="false" data-show-hidden-topics="false">
                                <div class="flex flex-col gap-xs">
                                    <!-- Title Section -->
                                    <div class="text-center py-tag-y">
                                        <h3 class="text-neutral-70 font-heading font-bold text-xl">Similarity Scores</h3>
                                    </div>
                                    
                                    <!-- Scores Section -->
                                    <div class="flex flex-col gap-xs similarity-scores-container">
                                        ${generateSimilarityTopicRows(paper)}
                                    </div>
                                    
                                    <!-- Show Other Topics Button (conditionally shown) -->
                                    <div class="show-other-topics-container" ${getHiddenTopicsCount() > 0 ? '' : 'style="display: none;"'}>
                                        <button class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md py-tag-y mt-md w-full text-center hover:bg-neutral-600" onclick="toggleSimilarityHiddenTopics('${paper.id}')">
                                            Show Other Topics <span class="text-xs">▼</span>
                                        </button>
                                    </div>
                                    
                                    <!-- Hidden Topics Container (appears after button when toggled) -->
                                    <div class="hidden-topics-container" style="display: none;"></div>
                                    
                                    <!-- Button Section -->
                                    <div>
                                        <button class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md py-tag-y mt-md w-full text-center" onclick="toggleSimilarityScores(this)">
                                            Show Normalized Scores ⇄
                                        </button>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Relevance Module -->
                            <div class="bg-neutral-300 p-lg flex-1 w-full" data-paper-id="${paper.id}" data-show-hidden-topics="false">
                                <div class="flex flex-col gap-xs">
                                    <!-- Title Section -->
                                    <div class="text-center py-tag-y">
                                        <h3 class="text-neutral-70 font-heading font-bold text-xl">Topic Relevance</h3>
                                    </div>
                                    
                                    <!-- Scores Section -->
                                    <div class="flex flex-col gap-xs relevance-scores-container">
                                        ${generateRelevanceTopicRows(paper)}
                                    </div>
                                    
                                    <!-- Show Other Topics Button (conditionally shown) -->
                                    <div class="show-other-topics-container" ${getHiddenTopicsCount() > 0 ? '' : 'style="display: none;"'}>
                                        <button class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md py-tag-y mt-md w-full text-center hover:bg-neutral-600" onclick="toggleRelevanceHiddenTopics('${paper.id}')">
                                            Show Other Topics <span class="text-xs">▼</span>
                                        </button>
                                    </div>
                                    
                                    <!-- Hidden Topics Container (appears after button when toggled) -->
                                    <div class="hidden-topics-container" style="display: none;"></div>
                                    
                                    <!-- Justification Section -->
                                    <div class="w-full relevance-justification-section" data-paper-id="${paper.id}">
                                        <button class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y mt-md w-full text-center cursor-pointer border-none transition-opacity duration-200" 
                                                onclick="toggleRelevanceJustification('${paper.id}')">
                                            Show Justification <span class="text-xs">▲</span>
                                        </button>
                                        <div class="justification-text hidden text-neutral-20 font-mono text-md px-tag-x py-tag-y bg-neutral-500 transition-all duration-300 ease-in-out flex flex-col gap-sm">
                                            ${generateRelevanceJustificationContent(paper)}
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Author H-Index Module -->
                            <div class="bg-neutral-300 p-lg flex-1 w-full">
                                <div class="flex flex-col gap-md">
                                    <!-- Title Section -->
                                    <div class="text-center py-tag-y">
                                        <h3 class="text-neutral-70 font-heading font-bold text-xl">Author H-Index</h3>
                                    </div>
                                    
                                    ${paper.h_index_status === 'not_fetched' || paper.h_index_status === 'failed' ? `
                                        <!-- No Data Available Section -->
                                        <div class="text-center pt-lg pb-sm">
                                            <p class="text-neutral-60 font-heading font-bold text-lg">No H-Index data available</p>
                                        </div>
                                    ` : `
                                        <!-- H-Index Info Section -->
                                        <div class="flex flex-col gap-sm">
                                            <!-- Authors Found Row -->
                                            <div class="flex justify-between items-center">
                                                <span class="text-neutral-60 font-heading font-bold text-xl px-tag-x py-tag-y">Authors found:</span>
                                                <span class="text-neutral-60 font-heading font-bold text-xl px-tag-x py-tag-y">${paper.authors_found}/${paper.total_authors}</span>
                                            </div>
                                            
                                            <!-- Highest H-Index Row -->
                                            <div class="flex justify-between items-center">
                                                <span class="text-neutral-60 font-heading font-bold text-xl px-tag-x py-tag-y">Highest H-Index:</span>
                                                <span class="text-neutral-60 font-heading font-bold text-xl px-tag-x py-tag-y">${paper.highest_h_index || 'N/A'}</span>
                                            </div>
                                            
                                            <!-- Average H-Index Row -->
                                            <div class="flex justify-between items-center">
                                                <span class="text-neutral-60 font-heading font-bold text-xl px-tag-x py-tag-y">Average H-Index:</span>
                                                <span class="text-neutral-60 font-heading font-bold text-xl px-tag-x py-tag-y">${paper.average_h_index ? paper.average_h_index.toFixed(1) : 'N/A'}</span>
                                            </div>
                                            
                                            <!-- Notable Authors Row -->
                                            <div class="flex justify-between items-center">
                                                <span class="text-neutral-60 font-heading font-bold text-xl px-tag-x py-tag-y">Notable (H>5):</span>
                                                <span class="text-neutral-60 font-heading font-bold text-xl px-tag-x py-tag-y">${paper.notable_authors_count || 0}</span>
                                            </div>
                                        </div>
                                        
                                        <!-- Semantic Scholar Button -->
                                        <div>
                                            <button class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md py-tag-y mt-md w-full text-center" 
                                                    onclick="window.open('${paper.semantic_scholar_url}', '_blank')">
                                                Verify source on Semantic Scholar
                                            </button>
                                        </div>
                                        
                                        <!-- Individual H-Indices Section -->
                                        <div class="w-full author-h-index-section" data-paper-id="${paper.id}">
                                            <button class="bg-neutral-500 text-neutral-10 font-heading font-bold text-md px-tag-x py-tag-y w-full text-center cursor-pointer border-none transition-opacity duration-200" 
                                                    onclick="toggleAuthorHIndices('${paper.id}')">
                                                Show Individual H-Indices <span class="text-xs">▼</span>
                                            </button>
                                            <div class="individual-authors-text hidden text-neutral-20 font-mono text-md px-xl py-tag-y bg-neutral-500 transition-all duration-300 ease-in-out">
                                                ${paper.author_h_indexes && paper.author_h_indexes.length > 0 ? 
                                                    paper.author_h_indexes.map(author => `
                                                        <div class="flex justify-between items-center py-xs">
                                                            ${author.profile_url && author.profile_url !== null && author.profile_url !== '' 
                                                                ? `<a href="${author.profile_url}" target="_blank" rel="noopener noreferrer" class="text-neutral-20 font-mono text-md underline hover:no-underline">${author.name}:</a>`
                                                                : `<span class="text-neutral-20 font-mono text-md">${author.name}:</span>`
                                                            }
                                                            <span class="text-neutral-20 font-mono text-md">${author.h_index !== null && author.h_index !== undefined ? author.h_index : 'N/A'}</span>
                                                        </div>
                                                    `).join('') 
                                                    : '<div class="text-center text-neutral-20">No individual author data available</div>'
                                                }
                                            </div>
                                        </div>
                                    `}
                                </div>
                            </div>
                        </div>
                    </div>
                </article>
            `;
        }

        // ============================================================================
        // QUICK FILTER FUNCTIONS
        // ============================================================================


        function applyQuickFilter(filterType) {
            // Build URL parameters based on filter type
            const url = new URL(window.location.href);
            
            // Clear all existing parameters
            url.search = '';
            
            // Set sort to recommendation best first for all filters
            url.searchParams.set('sort', 'recommend_best');
            
            switch(filterType) {
                case 'must-read':
                    // Recommendation: Only Must Read + Scoring: Only Has Scoring
                    url.searchParams.set('recommendation_must', 'true');
                    url.searchParams.set('recommendation_should', 'false');
                    url.searchParams.set('recommendation_skip', 'false');
                    url.searchParams.set('recommendation_ignore', 'false');
                    url.searchParams.set('scoring_has', 'true');
                    url.searchParams.set('scoring_no', 'false');
                    break;
                    
                case 'should-read':
                    // Recommendation: Only Should Read + Scoring: Only Has Scoring
                    url.searchParams.set('recommendation_must', 'false');
                    url.searchParams.set('recommendation_should', 'true');
                    url.searchParams.set('recommendation_skip', 'false');
                    url.searchParams.set('recommendation_ignore', 'false');
                    url.searchParams.set('scoring_has', 'true');
                    url.searchParams.set('scoring_no', 'false');
                    break;
                    
                case 'rlhf':
                    // Topic: Only RLHF + Relevance: Exclude Not Relevant
                    url.searchParams.set('topic_rlhf', 'true');
                    url.searchParams.set('topic_weak_supervision', 'false');
                    url.searchParams.set('topic_diffusion_reasoning', 'false');
                    url.searchParams.set('topic_distributed_training', 'false');
                    url.searchParams.set('topic_datasets', 'false');
                    url.searchParams.set('relevance_highly', 'true');
                    url.searchParams.set('relevance_moderately', 'true');
                    url.searchParams.set('relevance_tangentially', 'true');
                    url.searchParams.set('relevance_not', 'false');
                    break;
                    
                case 'weak-supervision':
                    url.searchParams.set('topic_rlhf', 'false');
                    url.searchParams.set('topic_weak_supervision', 'true');
                    url.searchParams.set('topic_diffusion_reasoning', 'false');
                    url.searchParams.set('topic_distributed_training', 'false');
                    url.searchParams.set('topic_datasets', 'false');
                    url.searchParams.set('relevance_highly', 'true');
                    url.searchParams.set('relevance_moderately', 'true');
                    url.searchParams.set('relevance_tangentially', 'true');
                    url.searchParams.set('relevance_not', 'false');
                    break;
                    
                case 'diffusion-reasoning':
                    url.searchParams.set('topic_rlhf', 'false');
                    url.searchParams.set('topic_weak_supervision', 'false');
                    url.searchParams.set('topic_diffusion_reasoning', 'true');
                    url.searchParams.set('topic_distributed_training', 'false');
                    url.searchParams.set('topic_datasets', 'false');
                    url.searchParams.set('relevance_highly', 'true');
                    url.searchParams.set('relevance_moderately', 'true');
                    url.searchParams.set('relevance_tangentially', 'true');
                    url.searchParams.set('relevance_not', 'false');
                    break;
                    
                case 'distributed-training':
                    url.searchParams.set('topic_rlhf', 'false');
                    url.searchParams.set('topic_weak_supervision', 'false');
                    url.searchParams.set('topic_diffusion_reasoning', 'false');
                    url.searchParams.set('topic_distributed_training', 'true');
                    url.searchParams.set('topic_datasets', 'false');
                    url.searchParams.set('relevance_highly', 'true');
                    url.searchParams.set('relevance_moderately', 'true');
                    url.searchParams.set('relevance_tangentially', 'true');
                    url.searchParams.set('relevance_not', 'false');
                    break;
                    
                case 'datasets':
                    url.searchParams.set('topic_rlhf', 'false');
                    url.searchParams.set('topic_weak_supervision', 'false');
                    url.searchParams.set('topic_diffusion_reasoning', 'false');
                    url.searchParams.set('topic_distributed_training', 'false');
                    url.searchParams.set('topic_datasets', 'true');
                    url.searchParams.set('relevance_highly', 'true');
                    url.searchParams.set('relevance_moderately', 'true');
                    url.searchParams.set('relevance_tangentially', 'true');
                    url.searchParams.set('relevance_not', 'false');
                    break;
                    
                case 'reset':
                    // Clear all parameters, which will reset everything to defaults
                    break;
                    
                default:
                    console.warn('Unknown quick filter type:', filterType);
                    return;
            }
            
            // Navigate to new URL, which will trigger existing URL parsing logic
            window.location.href = url.toString();
        }



        // ============================================================================
        // PAGE INITIALIZATION
        // ============================================================================

        function initializePage() {

            // Get sort parameter from URL, default to 'recommend_best'
            currentSort = getUrlParameter('sort') || 'recommend_best';
            
            // Load H-Index filters from URL
            updateHIndexFiltersFromURL();
            
            // Load Scoring filters from URL
            updateScoringFiltersFromURL();
            
            // Load Recommendation filters from URL
            updateRecommendationFiltersFromURL();
            
            // Load Novelty filters from URL
            updateNoveltyFiltersFromURL();
            
            // Load Impact filters from URL
            updateImpactFiltersFromURL();
            
            // Load Topic filters from URL
            updateTopicFiltersFromURL();
            
            // Load Relevance filters from URL
            loadRelevanceFiltersFromURL();
            
            // Update disabled state for advanced filters after loading scoring filters
            updateAdvancedFiltersDisabledState();
            
            // Update page title and headers based on embedded date
            updatePageTitles(PAGE_DATE);
            
            // Update sort dropdown UI
            updateSortDropdownUI();
            
            // Setup H-Index input validation
            setupHIndexValidation();
            
            // Sync H-Index UI with loaded filters
            syncHIndexUI();
            
            // Apply initial sorting and filtering
            applyFiltersAndSort();
            
            // Display first page
            displayCurrentPage();
            
        }

        // ============================================================================
        // ABSTRACT TRUNCATION LOGIC
        // ============================================================================
        
        let resizeTimer;

        function resetAbstractToOriginal(container) {
            const abstractText = container.querySelector('.abstract-text');
            const originalText = abstractText.getAttribute('data-original-text');
            
            if (originalText) {
                // Reset to clean original text
                abstractText.innerHTML = originalText;
                abstractText.setAttribute('data-expanded', 'false');
                // Clear any existing truncated text to force recalculation
                abstractText.removeAttribute('data-truncated-text');
            }
        }

        function calculateAverageCharWidth(fontStyle, fontSize, fontFamily) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            ctx.font = `${fontStyle} ${fontSize} ${fontFamily}`;
            
            const characterSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 ';
            const totalWidth = ctx.measureText(characterSet).width;
            
            return totalWidth / characterSet.length;
        }

        function getTextContentWidth(element) {
            const computedStyle = getComputedStyle(element);
            return element.clientWidth - 
                parseFloat(computedStyle.paddingLeft) - 
                parseFloat(computedStyle.paddingRight);
        }

        function calculateThreeLineCharLimit(element) {
            const computedStyle = getComputedStyle(element);
            const fontSize = computedStyle.fontSize;
            const fontFamily = computedStyle.fontFamily;
            const fontWeight = computedStyle.fontWeight;
            
            // Get average character width
            const avgCharWidth = calculateAverageCharWidth(fontWeight, fontSize, fontFamily);
            
            // Get content width
            const contentWidth = getTextContentWidth(element);
            
            // Calculate characters per line
            const charsPerLine = Math.floor(contentWidth / avgCharWidth);
            
            // Total characters for 3 lines
            const totalChars = charsPerLine * 3;
            
            // Reserve space for "... [Expand]"
            const expandButtonChars = 30;
            
            return Math.max(0, totalChars - expandButtonChars);
        }

        function toggleAbstract(paperId) {
            const containers = document.querySelectorAll(`.abstract-container[data-paper-id="${paperId}"]`);
            
            containers.forEach(container => {
                const abstractText = container.querySelector('.abstract-text');
                if (!abstractText) return; // Safety check
                
                const isExpanded = abstractText.getAttribute('data-expanded') === 'true';
                
                if (isExpanded) {
                    // Collapse - restore truncated text
                    const truncatedText = abstractText.getAttribute('data-truncated-text');
                    abstractText.innerHTML = truncatedText;
                    abstractText.setAttribute('data-expanded', 'false');
                } else {
                    // Expand - show full text
                    const originalText = abstractText.getAttribute('data-original-text');
                    abstractText.innerHTML = `${originalText} <button class="text-neutral-60 font-body font-bold text-md cursor-pointer bg-transparent border-none p-0 hover:opacity-70 transition-opacity duration-200" onclick="toggleAbstract('${paperId}')">[Collapse]</button>`;
                    abstractText.setAttribute('data-expanded', 'true');
                }
                
                // Re-render KaTeX after content change
                setTimeout(() => renderKatexInElement(abstractText), 50);
            });
        }

        // Function to setup abstract truncation using font metrics and binary search
        function setupAbstractTruncation() {
            document.querySelectorAll('.abstract-container').forEach(container => {
                const abstractText = container.querySelector('.abstract-text');
                const paperId = container.getAttribute('data-paper-id');
                
                // Get original text - only set it if not already stored to prevent corruption
                let originalText = abstractText.getAttribute('data-original-text');
                if (!originalText) {
                    // First time setup - get clean text content
                    originalText = abstractText.textContent;
                    abstractText.setAttribute('data-original-text', originalText);
                } else {
                    // Subsequent calls - reset to clean state first
                    resetAbstractToOriginal(container);
                }
                
                // Always reset to collapsed state
                abstractText.setAttribute('data-expanded', 'false');
                
                // Calculate the rough character limit for 3 lines as starting point
                const roughCharLimit = calculateThreeLineCharLimit(abstractText);
                
                // Check if text needs truncation
                if (originalText.length > roughCharLimit) {
                    // Create expand button template
                    const expandButton = '... <button class="text-neutral-60 font-body font-bold text-md cursor-pointer bg-transparent border-none p-0 hover:opacity-70 transition-opacity duration-200" onclick="toggleAbstract(\'' + paperId + '\')">[Expand]</button>';
                    
                    // Calculate 3-line height for comparison
                    const computedStyle = getComputedStyle(abstractText);
                    const lineHeight = parseFloat(computedStyle.lineHeight);
                    const maxHeight = lineHeight * 3;
                    
                    // Binary search for perfect truncation point
                    let left = 0;
                    let right = Math.min(originalText.length, roughCharLimit + 100); // Use rough estimate + buffer
                    let bestFit = '';
                    let bestLength = 0;
                    
                    // Create temporary element for height testing
                    const testElement = abstractText.cloneNode(true);
                    testElement.style.position = 'absolute';
                    testElement.style.visibility = 'hidden';
                    testElement.style.width = abstractText.offsetWidth + 'px';
                    testElement.style.height = 'auto';
                    testElement.style.maxHeight = 'none';
                    document.body.appendChild(testElement);
                    
                    while (left <= right) {
                        const mid = Math.floor((left + right) / 2);
                        const testText = originalText.substring(0, mid) + expandButton;
                        
                        testElement.innerHTML = testText;
                        
                        if (testElement.offsetHeight <= maxHeight) {
                            // Text fits, try longer
                            bestFit = testText;
                            bestLength = mid;
                            left = mid + 1;
                        } else {
                            // Text too long, trying shorter
                            right = mid - 1;
                        }
                    }
                    
                    // Clean up temporary element
                    document.body.removeChild(testElement);
                    
                    // Apply the best fit result
                    if (bestFit) {
                        abstractText.setAttribute('data-truncated-text', bestFit);
                        abstractText.innerHTML = bestFit;
                    } else {
                        // Fallback to rough estimate if binary search fails
                        const fallbackText = originalText.substring(0, Math.max(0, roughCharLimit - 50)) + expandButton;
                        abstractText.setAttribute('data-truncated-text', fallbackText);
                        abstractText.innerHTML = fallbackText;
                    }
                } else {
                    // Text fits without truncation
                    abstractText.innerHTML = originalText;
                }
            });
        }

        // Function to toggle recommendation justification
        function toggleRecommendationJustification(paperId) {
            const containers = document.querySelectorAll(`.recommendation-justification-section[data-paper-id="${paperId}"]`);
            
            containers.forEach(container => {
                const button = container.querySelector('button');
                const textDiv = container.querySelector('.justification-text');
                const isHidden = textDiv.classList.contains('hidden');
                
                if (isHidden) {
                    // Show justification
                    textDiv.classList.remove('hidden');
                    button.innerHTML = 'Hide Justification <span class="text-xs">▼</span>';
                    button.classList.remove('bg-neutral-500');
                    button.classList.add('bg-neutral-600');
                } else {
                    // Hide justification
                    textDiv.classList.add('hidden');
                    button.innerHTML = 'Show Justification <span class="text-xs">▲</span>';
                    button.classList.remove('bg-neutral-600');
                    button.classList.add('bg-neutral-500');
                }
            });
        }

        // Function to toggle novelty justification
        function toggleNoveltyJustification(paperId) {
            const containers = document.querySelectorAll(`.novelty-justification-section[data-paper-id="${paperId}"]`);
            
            containers.forEach(container => {
                const button = container.querySelector('button');
                const textDiv = container.querySelector('.justification-text');
                const isHidden = textDiv.classList.contains('hidden');
                
                if (isHidden) {
                    // Show justification
                    textDiv.classList.remove('hidden');
                    button.innerHTML = 'Hide Justification <span class="text-xs">▼</span>';
                    button.classList.remove('bg-neutral-500');
                    button.classList.add('bg-neutral-600');
                } else {
                    // Hide justification
                    textDiv.classList.add('hidden');
                    button.innerHTML = 'Show Justification <span class="text-xs">▲</span>';
                    button.classList.remove('bg-neutral-600');
                    button.classList.add('bg-neutral-500');
                }
            });
        }

        // Function to toggle impact justification
        function toggleImpactJustification(paperId) {
            const containers = document.querySelectorAll(`.impact-justification-section[data-paper-id="${paperId}"]`);
            
            containers.forEach(container => {
                const button = container.querySelector('button');
                const textDiv = container.querySelector('.justification-text');
                const isHidden = textDiv.classList.contains('hidden');
                
                if (isHidden) {
                    // Show justification
                    textDiv.classList.remove('hidden');
                    button.innerHTML = 'Hide Justification <span class="text-xs">▼</span>';
                    button.classList.remove('bg-neutral-500');
                    button.classList.add('bg-neutral-600');
                } else {
                    // Hide justification
                    textDiv.classList.add('hidden');
                    button.innerHTML = 'Show Justification <span class="text-xs">▲</span>';
                    button.classList.remove('bg-neutral-600');
                    button.classList.add('bg-neutral-500');
                }
            });
        }

        // Function to toggle relevance justification
        function toggleRelevanceJustification(paperId) {
            const containers = document.querySelectorAll(`.relevance-justification-section[data-paper-id="${paperId}"]`);
            
            containers.forEach(container => {
                const button = container.querySelector('button');
                const textDiv = container.querySelector('.justification-text');
                const isHidden = textDiv.classList.contains('hidden');
                
                if (isHidden) {
                    // Show justification
                    textDiv.classList.remove('hidden');
                    button.innerHTML = 'Hide Justification <span class="text-xs">▼</span>';
                    button.classList.remove('bg-neutral-500');
                    button.classList.add('bg-neutral-600');
                } else {
                    // Hide justification
                    textDiv.classList.add('hidden');
                    button.innerHTML = 'Show Justification <span class="text-xs">▲</span>';
                    button.classList.remove('bg-neutral-600');
                    button.classList.add('bg-neutral-500');
                }
            });
        }

        // Function to toggle author H-indices
        function toggleAuthorHIndices(paperId) {
            const containers = document.querySelectorAll(`.author-h-index-section[data-paper-id="${paperId}"]`);
            
            containers.forEach(container => {
                const button = container.querySelector('button');
                const textDiv = container.querySelector('.individual-authors-text');
                const isHidden = textDiv.classList.contains('hidden');
                
                if (isHidden) {
                    // Show individual H-indices
                    textDiv.classList.remove('hidden');
                    button.innerHTML = 'Hide Individual H-Indices <span class="text-xs">▲</span>';
                    button.classList.remove('bg-neutral-500');
                    button.classList.add('bg-neutral-600');
                } else {
                    // Hide individual H-indices
                    textDiv.classList.add('hidden');
                    button.innerHTML = 'Show Individual H-Indices <span class="text-xs">▼</span>';
                    button.classList.remove('bg-neutral-600');
                    button.classList.add('bg-neutral-500');
                }
            });
        }

        // Function to setup initial similarity progress bars (raw scores only)
        function setupInitialProgressBars() {
            currentPagePapers.forEach(paper => {
                setupProgressBarsForPaper(paper);
            });
        }

        // Function to toggle similarity scores between raw and normalized
        function toggleSimilarityScores(buttonElement) {
            // Find the parent container with data-paper-id
            const container = buttonElement.closest('[data-paper-id]');
            if (!container) return;
            
            const paperId = container.getAttribute('data-paper-id');
            const isNormalized = container.getAttribute('data-normalized') === 'true';
            
            // Find the paper data from current page papers
            const paper = currentPagePapers.find(p => p.id === paperId);
            if (!paper) return;
            
            // Toggle state
            container.setAttribute('data-normalized', (!isNormalized).toString());
            
            // Update button text
            buttonElement.textContent = isNormalized ? 'Show Normalized Scores ⇄' : 'Show Raw Scores ⇄';
            
            if (!isNormalized) {
                // Switch to normalized mode
                updateNormalizedScores(paperId);
                
                // Change all progress bars to normalized color
                const progressBars = container.querySelectorAll('.similarity-progress-bar');
                progressBars.forEach(bar => {
                    bar.classList.remove('bg-bar-raw');
                    bar.classList.add('bg-bar-normalized');
                });
            } else {
                // Switch to raw mode
                const isShowingHidden = container.getAttribute('data-show-hidden-topics') === 'true';
                const topicsToShow = isShowingHidden ? 
                    ['rlhf', 'weakSupervision', 'diffusionReasoning', 'distributedTraining', 'datasets'] :
                    getVisibleTopics();
                    
                const topicMapping = getTopicKeyMapping();
                
                topicsToShow.forEach(topic => {
                    const dataKey = topicMapping[topic];
                    const rawScore = paper[`${dataKey}_score`];
                    
                    // Update progress bar
                    const progressBar = container.querySelector(`.${dataKey.replace('_', '-')}-progress-bar`);
                    if (progressBar) {
                        progressBar.style.width = `${(rawScore * 100)}%`;
                        // Change to raw bar color
                        progressBar.classList.remove('bg-bar-normalized');
                        progressBar.classList.add('bg-bar-raw');
                    }
                    
                    // Update score text
                    const scoreElement = container.querySelector(`.${dataKey.replace('_', '-')}-similarity-score`);
                    if (scoreElement) {
                        scoreElement.textContent = rawScore.toFixed(3);
                    }
                });
            }
        }

        // Pagination functions
        function calculatePaginationWindow(currentPage, totalPages) {
            const windowSize = 5;
            const halfWindow = Math.floor(windowSize / 2);
            
            let start = Math.max(1, currentPage - halfWindow);
            let end = Math.min(totalPages, start + windowSize - 1);
            
            // Adjust start if we can't show a full window at the end
            if (end - start + 1 < windowSize) {
                start = Math.max(1, end - windowSize + 1);
            }
            
            return { start, end };
        }

        function updatePaginationUI() {
            const { start, end } = calculatePaginationWindow(currentPage, totalPages);
            
            // Update mobile pagination
            updatePaginationButtons('mobile', start, end);
            
            // Update desktop pagination
            updatePaginationButtons('desktop', start, end);
            
            // Update footer pagination
            updateFooterPaginationButtons('mobile', start, end);
            updateFooterPaginationButtons('desktop', start, end);
        }

        function updatePaginationButtons(layout, start, end) {
            const container = layout === 'mobile' 
                ? document.getElementById('mobile-pagination-numbers')
                : document.getElementById('desktop-pagination-numbers');
            
            if (!container) return;
            
            // Clear existing buttons
            container.innerHTML = '';
            
            // Create pagination buttons
            for (let i = start; i <= end; i++) {
                const isActive = i === currentPage;
                const buttonClass = isActive 
                    ? 'bg-neutral-900 text-neutral-10' 
                    : 'bg-neutral-300 text-neutral-70 hover:bg-neutral-400 cursor-pointer';
                
                const sizeClasses = layout === 'mobile' 
                    ? 'w-8 h-8' 
                    : 'clamp(1.5rem, 3vw, 1.875rem)';
                
                const button = document.createElement('div');
                button.className = `pagination-square ${buttonClass} flex items-center justify-center`;
                
                if (layout === 'desktop') {
                    button.style.width = sizeClasses;
                    button.style.height = sizeClasses;
                } else {
                    button.className += ` ${sizeClasses}`;
                }
                
                button.innerHTML = `<span class="font-heading font-bold text-${layout === 'mobile' ? 'sm' : 'md'}">${i}</span>`;
                
                if (!isActive) {
                    button.onclick = () => goToPage(i);
                    button.style.cursor = 'pointer';
                }
                
                container.appendChild(button);
            }
            
            // Update arrow button states
            updateArrowButtons(layout);
        }

        function updateFooterPaginationButtons(layout, start, end) {
            const container = layout === 'mobile' 
                ? document.getElementById('mobile-footer-pagination-numbers')
                : document.getElementById('desktop-footer-pagination-numbers');
            
            if (!container) return;
            
            // Clear existing buttons
            container.innerHTML = '';
            
            // Create pagination buttons
            for (let i = start; i <= end; i++) {
                const isActive = i === currentPage;
                const buttonClass = isActive 
                    ? 'bg-neutral-900 text-neutral-10' 
                    : 'bg-neutral-300 text-neutral-70 hover:bg-neutral-400 cursor-pointer';
                
                const sizeClasses = layout === 'mobile' 
                    ? 'w-8 h-8' 
                    : 'clamp(1.5rem, 3vw, 1.875rem)';
                
                const button = document.createElement('div');
                button.className = `pagination-square ${buttonClass} flex items-center justify-center`;
                
                if (layout === 'desktop') {
                    button.style.width = sizeClasses;
                    button.style.height = sizeClasses;
                } else {
                    button.className += ` ${sizeClasses}`;
                }
                
                button.innerHTML = `<span class="font-heading font-bold text-${layout === 'mobile' ? 'sm' : 'md'}">${i}</span>`;
                
                if (!isActive) {
                    button.onclick = () => goToPage(i);
                    button.style.cursor = 'pointer';
                }
                
                container.appendChild(button);
            }
            
            // Update footer arrow button states
            updateFooterArrowButtons(layout);
        }

        function updateArrowButtons(layout) {
            const prevBtn = document.getElementById(`${layout}-prev-btn`);
            const nextBtn = document.getElementById(`${layout}-next-btn`);
            
            // Update previous button
            if (prevBtn) {
                if (currentPage <= 1) {
                    // Show disabled state instead of hiding
                    prevBtn.classList.add('disabled');
                    prevBtn.onclick = null;
                } else {
                    // Show enabled state
                    prevBtn.classList.remove('disabled');
                    prevBtn.onclick = () => goToPage(currentPage - 1);
                }
            }
            
            // Update next button
            if (nextBtn) {
                if (currentPage >= totalPages) {
                    // Show disabled state instead of hiding
                    nextBtn.classList.add('disabled');
                    nextBtn.onclick = null;
                } else {
                    // Show enabled state
                    nextBtn.classList.remove('disabled');
                    nextBtn.onclick = () => goToPage(currentPage + 1);
                }
            }
        }

        function updateFooterArrowButtons(layout) {
            const prevBtn = document.getElementById(`${layout}-footer-prev-btn`);
            const nextBtn = document.getElementById(`${layout}-footer-next-btn`);
            
            // Update previous button
            if (prevBtn) {
                if (currentPage <= 1) {
                    // Show disabled state instead of hiding
                    prevBtn.classList.add('disabled');
                    prevBtn.onclick = null;
                } else {
                    // Show enabled state
                    prevBtn.classList.remove('disabled');
                    prevBtn.onclick = () => goToPage(currentPage - 1);
                }
            }
            
            // Update next button
            if (nextBtn) {
                if (currentPage >= totalPages) {
                    // Show disabled state instead of hiding
                    nextBtn.classList.add('disabled');
                    nextBtn.onclick = null;
                } else {
                    // Show enabled state
                    nextBtn.classList.remove('disabled');
                    nextBtn.onclick = () => goToPage(currentPage + 1);
                }
            }
        }

        function goToPage(page) {
            // Prevent navigation if page is out of bounds or is current page
            if (page === currentPage || page < 1 || page > totalPages) {
                return;
            }
            
            console.log(`Navigating to page ${page}`);
            currentPage = page;
            updatePaginationUI();
            displayCurrentPage();
            
            // Re-run truncation after new content is displayed
            setTimeout(() => {
                setupAbstractTruncation();
                setupInitialProgressBars();
            }, 50);
            
            // Scroll to top after loading new page
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // ============================================================================
        // SCROLL LOCK FUNCTIONS
        // ============================================================================
        
        function lockBodyScroll() {
            // Get the width of the scrollbar
            const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
            document.body.style.paddingRight = `${scrollbarWidth}px`;
            
            // Add the class to prevent scrolling
            document.body.classList.add('no-scroll');
        }

        function unlockBodyScroll() {
            // Remove the inline padding
            document.body.style.paddingRight = '';

            // Remove the class to re-enable scrolling
            document.body.classList.remove('no-scroll');
        }

        // ============================================================================
        // SIDEBAR FUNCTIONS
        // ============================================================================

        function toggleMobileMenu() {
            if (isMobileSidebarOpen) {
                closeMobileMenu();
            } else {
                openMobileMenu();
            }
        }

        function openMobileMenu() {
            const sidebar = document.getElementById('mobile-sidebar');
            const mainContainer = document.getElementById('mobile-main-container');
            
            // Move sidebar into view (full screen width)
            sidebar.style.transform = 'translateX(0)';
            
            // Lock body scrolling with padding compensation
            lockBodyScroll();
            
            isMobileSidebarOpen = true;
        }

        function closeMobileMenu() {
            const sidebar = document.getElementById('mobile-sidebar');
            const mainContainer = document.getElementById('mobile-main-container');
            
            // Move sidebar out of view
            sidebar.style.transform = 'translateX(-100%)';
            
            // Unlock body scrolling
            unlockBodyScroll();
            
            isMobileSidebarOpen = false;
        }

        function toggleDesktopMenu() {
            if (isDesktopSidebarOpen) {
                closeDesktopMenu();
            } else {
                openDesktopMenu();
            }
        }

        function openDesktopMenu() {
            const sidebar = document.getElementById('desktop-sidebar');
            const overlay = document.getElementById('desktop-sidebar-overlay');
            
            // Show sidebar
            sidebar.style.transform = 'translateX(0)';
            
            // Show overlay
            overlay.style.opacity = '1';
            overlay.style.pointerEvents = 'auto';
            
            // Lock body scrolling with padding compensation
            lockBodyScroll();
            
            isDesktopSidebarOpen = true;
        }

        function closeDesktopMenu() {
            const sidebar = document.getElementById('desktop-sidebar');
            const overlay = document.getElementById('desktop-sidebar-overlay');
            
            // Hide sidebar
            sidebar.style.transform = 'translateX(-100%)';
            
            // Hide overlay
            overlay.style.opacity = '0';
            overlay.style.pointerEvents = 'none';
            
            // Unlock body scrolling
            unlockBodyScroll();
            
            isDesktopSidebarOpen = false;
        }

        // Handle window resize to close mobile menu if switching to desktop
        window.addEventListener('resize', function() {
            if (window.innerWidth >= 768 && isMobileSidebarOpen) {
                closeMobileMenu();
            }
            if (window.innerWidth < 768 && isDesktopSidebarOpen) {
                closeDesktopMenu();
            }
        });

        // ============================================================================
        // CLICK OUTSIDE TO CLOSE DROPDOWNS
        // ============================================================================
        
        // Add click outside listener to close dropdowns
        document.addEventListener('click', function(event) {
            // List of all dropdown containers
            const dropdowns = [
                { dropdown: document.getElementById('mobile-sort-dropdown'), button: document.getElementById('mobile-sort-btn') },
                { dropdown: document.getElementById('desktop-sort-dropdown'), button: document.getElementById('desktop-sort-btn') },
                { dropdown: document.getElementById('mobile-hindex-dropdown'), button: document.getElementById('mobile-hindex-btn') },
                { dropdown: document.getElementById('desktop-hindex-dropdown'), button: document.getElementById('desktop-hindex-btn') },
                { dropdown: document.getElementById('mobile-scoring-dropdown'), button: document.getElementById('mobile-scoring-btn') },
                { dropdown: document.getElementById('desktop-scoring-dropdown'), button: document.getElementById('desktop-scoring-btn') },
                { dropdown: document.getElementById('mobile-recommendation-dropdown'), button: document.getElementById('mobile-recommendation-btn') },
                { dropdown: document.getElementById('desktop-recommendation-dropdown'), button: document.getElementById('desktop-recommendation-btn') },
                { dropdown: document.getElementById('mobile-novelty-dropdown'), button: document.getElementById('mobile-novelty-btn') },
                { dropdown: document.getElementById('desktop-novelty-dropdown'), button: document.getElementById('desktop-novelty-btn') },
                { dropdown: document.getElementById('mobile-impact-dropdown'), button: document.getElementById('mobile-impact-btn') },
                { dropdown: document.getElementById('desktop-impact-dropdown'), button: document.getElementById('desktop-impact-btn') },
                { dropdown: document.getElementById('mobile-relevance-dropdown'), button: document.getElementById('mobile-relevance-btn') },
                { dropdown: document.getElementById('desktop-relevance-dropdown'), button: document.getElementById('desktop-relevance-btn') },
                { dropdown: document.getElementById('mobile-topic-dropdown'), button: document.getElementById('mobile-topic-btn') },
                { dropdown: document.getElementById('desktop-topic-dropdown'), button: document.getElementById('desktop-topic-btn') }
            ];
            
            dropdowns.forEach(({ dropdown, button }) => {
                if (!dropdown || !button) return;
                
                // Check if dropdown is open and click is outside
                if (!dropdown.classList.contains('hidden')) {
                    const dropdownContainer = dropdown.parentElement; // The relative container
                    
                    // Check if click is outside the dropdown container
                    if (!dropdownContainer.contains(event.target)) {
                        dropdown.classList.add('hidden');
                        button.classList.remove('bg-neutral-600');
                        button.classList.add('bg-neutral-500');
                        
                        // Reset pending filters for specific dropdown types
                        if (dropdown.id.includes('hindex')) {
                            resetPendingHIndexFilters();
                        } else if (dropdown.id.includes('novelty')) {
                            resetPendingNoveltyFilters();
                        } else if (dropdown.id.includes('impact')) {
                            resetPendingImpactFilters();
                        } else if (dropdown.id.includes('relevance')) {
                            resetPendingRelevanceFilters();
                        } else if (dropdown.id.includes('topic')) {
                            resetPendingTopicFilters();
                        } else if (dropdown.id.includes('recommendation')) {
                            resetPendingRecommendationFilters();
                        } else if (dropdown.id.includes('scoring')) {
                            resetPendingScoringFilters();
                        }
                    }
                }
            });
        });

        // Initialize page on load
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Papers Dashboard loaded successfully');
            initializePage();
        });

        // Setup abstract truncation when everything is fully loaded
        window.addEventListener('load', function() {
            setupAbstractTruncation();
            setupInitialProgressBars();
        });

        // Setup debounced resize handler for truncation
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                setupAbstractTruncation();
            }, 250); // Delay to wait for resize to settle
        });
    </script>

    <!-- KaTeX JavaScript -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js" integrity="sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
    
    <!-- KaTeX Auto-render Configuration -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            // Configure KaTeX auto-render after page content is loaded
            setTimeout(function() {
                renderMathInElement(document.body, {
                    // KaTeX rendering options
                    delimiters: [
                        {left: '$$', right: '$$', display: true},       // Block math
                        {left: '$', right: '$', display: false},        // Inline math
                        {left: '\\(', right: '\\)', display: false},    // Inline math alternative
                        {left: '\\[', right: '\\]', display: true},     // Block math alternative
                        {left: '\\begin{equation}', right: '\\end{equation}', display: true},
                        {left: '\\begin{align}', right: '\\end{align}', display: true},
                        {left: '\\begin{alignat}', right: '\\end{alignat}', display: true},
                        {left: '\\begin{gather}', right: '\\end{gather}', display: true},
                        {left: '\\begin{CD}', right: '\\end{CD}', display: true},
                    ],
                    // Throw errors on unknown commands/symbols
                    throwOnError: false,
                    // Allow HTML in math expressions
                    trust: true,
                    // Ignore certain classes/elements
                    ignoredClasses: [
                        "nokatex", 
                        "katex-ignore"
                    ],
                    // Skip script and style tags
                    ignoredTags: [
                        "script", 
                        "noscript", 
                        "style", 
                        "textarea", 
                        "pre", 
                        "code"
                    ]
                });
            }, 500); // Delay to ensure all content is loaded
        });
    </script>
</body>
</html>
